; ModuleID = '../../SPEC_CPU2006v1.1/benchspec/CPU2006/435.gromacs/src/gmxfio.c'
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.10.0"

%struct._RuneLocale = type { [8 x i8], [32 x i8], i32 (i8*, i64, i8**)*, i32 (i32, i8*, i64, i8**)*, i32, [256 x i32], [256 x i32], [256 x i32], %struct._RuneRange, %struct._RuneRange, %struct._RuneRange, i8*, i32, i32, %struct._RuneCharClass* }
%struct._RuneRange = type { i32, %struct._RuneEntry* }
%struct._RuneEntry = type { i32, i32, i32, i32* }
%struct._RuneCharClass = type { [14 x i8], i32 }
%struct.t_fileio = type { i32, i32, i32, i32, i32, i32, i8*, %struct.__sFILE*, %struct.XDR* }
%struct.__sFILE = type { i8*, i32, i32, i16, i16, %struct.__sbuf, i32, i8*, i32 (i8*)*, i32 (i8*, i8*, i32)*, i64 (i8*, i64, i32)*, i32 (i8*, i8*, i32)*, %struct.__sbuf, %struct.__sFILEX*, i32, [3 x i8], [1 x i8], %struct.__sbuf, i32, i64 }
%struct.__sFILEX = type opaque
%struct.__sbuf = type { i8*, i32 }
%struct.XDR = type { i32, %struct.xdr_ops*, i8*, i8*, i8*, i32 }
%struct.xdr_ops = type { i32 (%struct.XDR*, i64*)*, i32 (%struct.XDR*, i64*)*, i32 (%struct.XDR*, i8*, i32)*, i32 (%struct.XDR*, i8*, i32)*, i32 (%struct.XDR*)*, i32 (%struct.XDR*, i32)*, i32* (%struct.XDR*, i32)*, void (%struct.XDR*)*, i32 (%struct.XDR*, i32*)*, i32 (%struct.XDR*, i32*)* }

@_DefaultRuneLocale = external global %struct._RuneLocale
@do_read = global i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, align 8
@do_write = global i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, align 8
@.str = private unnamed_addr constant [9 x i8] c"[header]\00", align 1
@.str1 = private unnamed_addr constant [11 x i8] c"[inputrec]\00", align 1
@.str2 = private unnamed_addr constant [6 x i8] c"[box]\00", align 1
@.str3 = private unnamed_addr constant [11 x i8] c"[topology]\00", align 1
@.str4 = private unnamed_addr constant [14 x i8] c"[coordinates]\00", align 1
@.str5 = private unnamed_addr constant [13 x i8] c"[velocities]\00", align 1
@.str6 = private unnamed_addr constant [9 x i8] c"[forces]\00", align 1
@itemstr = global [7 x i8*] [i8* getelementptr inbounds ([9 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str1, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str2, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str3, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8]* @.str4, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str5, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str6, i32 0, i32 0)], align 16
@.str7 = private unnamed_addr constant [359 x i8] c"; The header holds information on the number of atoms etc. and on whether\0A; certain items are present in the file or not.\0A; \0A;                             WARNING\0A;                   DO NOT EDIT THIS FILE BY HAND\0A; The GROMACS preprocessor performs a lot of checks on your input that\0A; you ignore when editing this. Your simulation may crash because of this\0A\00", align 1
@.str8 = private unnamed_addr constant [106 x i8] c"; The inputrec holds the parameters for MD such as the number of steps,\0A; the timestep and the cut-offs.\0A\00", align 1
@.str9 = private unnamed_addr constant [29 x i8] c"; The simulation box in nm.\0A\00", align 1
@.str10 = private unnamed_addr constant [150 x i8] c"; The topology section describes the topology of the molcecules\0A; i.e. bonds, angles and dihedrals etc. and also holds the force field\0A; parameters.\0A\00", align 1
@.str11 = private unnamed_addr constant [32 x i8] c"; The atomic coordinates in nm\0A\00", align 1
@.str12 = private unnamed_addr constant [34 x i8] c"; The atomic velocities in nm/ps\0A\00", align 1
@.str13 = private unnamed_addr constant [38 x i8] c"; The forces on the atoms in nm/ps^2\0A\00", align 1
@comment_str = global [7 x i8*] [i8* getelementptr inbounds ([359 x i8]* @.str7, i32 0, i32 0), i8* getelementptr inbounds ([106 x i8]* @.str8, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8]* @.str9, i32 0, i32 0), i8* getelementptr inbounds ([150 x i8]* @.str10, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8]* @.str11, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str12, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8]* @.str13, i32 0, i32 0)], align 16
@add_comment = internal unnamed_addr global i8* null, align 8
@.str14 = private unnamed_addr constant [12 x i8] c"add_comment\00", align 1
@.str15 = private unnamed_addr constant [66 x i8] c"../../SPEC_CPU2006v1.1/benchspec/CPU2006/435.gromacs/src/gmxfio.c\00", align 1
@.str16 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str17 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str19 = private unnamed_addr constant [43 x i8] c"DEATH HORROR in gmx_fio_open, mode is '%s'\00", align 1
@.str20 = private unnamed_addr constant [6 x i8] c"ASCII\00", align 1
@.str21 = private unnamed_addr constant [2 x i8] c"b\00", align 1
@nFIO = internal unnamed_addr global i32 0, align 4
@FIO = internal unnamed_addr global %struct.t_fileio* null, align 8
@.str22 = private unnamed_addr constant [4 x i8] c"FIO\00", align 1
@ftpXDR = internal global [4 x i32] [i32 26, i32 4, i32 9, i32 6], align 16
@.str23 = private unnamed_addr constant [18 x i8] c"File %s not found\00", align 1
@.str24 = private unnamed_addr constant [9 x i8] c"fio->xdr\00", align 1
@.str25 = private unnamed_addr constant [18 x i8] c"Could not open %s\00", align 1
@__stdinp = external global %struct.__sFILE*
@__stdoutp = external global %struct.__sFILE*
@.str26 = private unnamed_addr constant [6 x i8] c"STDIO\00", align 1
@.str27 = private unnamed_addr constant [13 x i8] c"FIO[fio].xdr\00", align 1
@.str28 = private unnamed_addr constant [12 x i8] c"FIO[fio].fn\00", align 1
@ftpASC = internal global [3 x i32] [i32 27, i32 13, i32 15], align 4
@ftpBIN = internal global [4 x i32] [i32 28, i32 5, i32 39, i32 10], align 16
@.str29 = private unnamed_addr constant [46 x i8] c"Can not read/write topologies to file type %s\00", align 1
@curfio = internal unnamed_addr global %struct.t_fileio* null, align 8
@.str30 = private unnamed_addr constant [24 x i8] c"Can not seek on file %s\00", align 1
@.str31 = private unnamed_addr constant [27 x i8] c"gmx_fio_select not called!\00", align 1
@.str32 = private unnamed_addr constant [50 x i8] c"Trying to access non-open file %d, in %s, line %d\00", align 1
@.str33 = private unnamed_addr constant [58 x i8] c"wrong string length %d for string %s (source %s, line %d)\00", align 1
@.str34 = private unnamed_addr constant [5 x i8] c"cptr\00", align 1
@__stderrp = external global %struct.__sFILE*
@.str35 = private unnamed_addr constant [56 x i8] c"Error in xdr I/O %s %s to file %s (source %s, line %d)\0A\00", align 1
@eioNames = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([5 x i8]* @.str41, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str42, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str43, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str44, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str45, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str46, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str47, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str48, i32 0, i32 0)], align 16
@.str36 = private unnamed_addr constant [67 x i8] c"nitem (%d) may differ from 1 only for %s or %s, not for %s(%s, %d)\00", align 1
@.str37 = private unnamed_addr constant [46 x i8] c"Trying to %s %s type %d (%s), src %s, line %d\00", align 1
@.str38 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str39 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str40 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str41 = private unnamed_addr constant [5 x i8] c"REAL\00", align 1
@.str42 = private unnamed_addr constant [4 x i8] c"INT\00", align 1
@.str43 = private unnamed_addr constant [7 x i8] c"NUCHAR\00", align 1
@.str44 = private unnamed_addr constant [7 x i8] c"USHORT\00", align 1
@.str45 = private unnamed_addr constant [5 x i8] c"RVEC\00", align 1
@.str46 = private unnamed_addr constant [6 x i8] c"NRVEC\00", align 1
@.str47 = private unnamed_addr constant [5 x i8] c"IVEC\00", align 1
@.str48 = private unnamed_addr constant [7 x i8] c"STRING\00", align 1
@.str49 = private unnamed_addr constant [4 x i8] c"%lf\00", align 1
@.str50 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str51 = private unnamed_addr constant [5 x i8] c"%lf\0A\00", align 1
@.str52 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str53 = private unnamed_addr constant [55 x i8] c"Error reading %s %s from file %s (source %s, line %d)\0A\00", align 1
@next_item.buf = internal global [4096 x i8] zeroinitializer, align 16
@next_item.bufindex = internal unnamed_addr global [20 x i32] zeroinitializer, align 16
@nbuf = internal unnamed_addr global i32 0, align 4
@.str54 = private unnamed_addr constant [12 x i8] c"End of file\00", align 1
@.str55 = private unnamed_addr constant [31 x i8] c"String '%s' truncated to '%s'\0A\00", align 1
@.str56 = private unnamed_addr constant [11 x i8] c"%18.10e%s\0A\00", align 1
@.str57 = private unnamed_addr constant [8 x i8] c"%18d%s\0A\00", align 1
@.str58 = private unnamed_addr constant [4 x i8] c"%4d\00", align 1
@.str59 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str60 = private unnamed_addr constant [25 x i8] c"%18.10e%18.10e%18.10e%s\0A\00", align 1
@.str61 = private unnamed_addr constant [16 x i8] c"%18d%18d%18d%s\0A\00", align 1
@.str62 = private unnamed_addr constant [9 x i8] c"%-18s%s\0A\00", align 1
@.str63 = private unnamed_addr constant [53 x i8] c"Error writing %s %s to file %s (source %s, line %d)\0A\00", align 1
@.str64 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@dbgstr.buf = internal global [4096 x i8] zeroinitializer, align 16
@.str65 = private unnamed_addr constant [10 x i8] c"  ; %s %s\00", align 1
@.str66 = private unnamed_addr constant [45 x i8] c"written size %u bytes, source size %u bytes\0A\00", align 1

; Function Attrs: nounwind optsize readnone ssp uwtable
define i32 @isascii(i32 %_c) #0 {
  %1 = icmp ult i32 %_c, 128
  %2 = zext i1 %1 to i32
  ret i32 %2
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @__istype(i32 %_c, i64 %_f) #1 {
  %isascii = icmp ult i32 %_c, 128
  br i1 %isascii, label %1, label %8

; <label>:1                                       ; preds = %0
  %2 = sext i32 %_c to i64
  %3 = getelementptr inbounds %struct._RuneLocale* @_DefaultRuneLocale, i64 0, i32 5, i64 %2
  %4 = load i32* %3, align 4, !tbaa !2
  %5 = zext i32 %4 to i64
  %6 = and i64 %5, %_f
  %7 = icmp ne i64 %6, 0
  br label %11

; <label>:8                                       ; preds = %0
  %9 = tail call i32 @__maskrune(i32 %_c, i64 %_f) #9
  %10 = icmp ne i32 %9, 0
  br label %11

; <label>:11                                      ; preds = %8, %1
  %.sink = phi i1 [ %7, %1 ], [ %10, %8 ]
  %12 = zext i1 %.sink to i32
  ret i32 %12
}

; Function Attrs: optsize
declare i32 @__maskrune(i32, i64) #2

; Function Attrs: nounwind optsize readonly ssp uwtable
define i32 @__isctype(i32 %_c, i64 %_f) #3 {
  %1 = icmp ugt i32 %_c, 255
  br i1 %1, label %10, label %2

; <label>:2                                       ; preds = %0
  %3 = sext i32 %_c to i64
  %4 = getelementptr inbounds %struct._RuneLocale* @_DefaultRuneLocale, i64 0, i32 5, i64 %3
  %5 = load i32* %4, align 4, !tbaa !2
  %6 = zext i32 %5 to i64
  %7 = and i64 %6, %_f
  %8 = icmp ne i64 %7, 0
  %9 = zext i1 %8 to i32
  br label %10

; <label>:10                                      ; preds = %0, %2
  %11 = phi i32 [ %9, %2 ], [ 0, %0 ]
  ret i32 %11
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @__wcwidth(i32 %_c) #1 {
  %1 = icmp eq i32 %_c, 0
  br i1 %1, label %11, label %2

; <label>:2                                       ; preds = %0
  %3 = tail call i32 @__maskrune(i32 %_c, i64 3758358528) #9
  %4 = icmp ult i32 %3, 536870912
  br i1 %4, label %7, label %5

; <label>:5                                       ; preds = %2
  %6 = lshr i32 %3, 30
  br label %11

; <label>:7                                       ; preds = %2
  %8 = lshr i32 %3, 17
  %9 = and i32 %8, 2
  %10 = add nsw i32 %9, -1
  br label %11

; <label>:11                                      ; preds = %0, %7, %5
  %.0 = phi i32 [ %6, %5 ], [ %10, %7 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isalnum(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 1280) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isalpha(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 256) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isblank(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 131072) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @iscntrl(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 512) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize readonly ssp uwtable
define i32 @isdigit(i32 %_c) #3 {
  %1 = icmp ugt i32 %_c, 255
  br i1 %1, label %__isctype.exit, label %2

; <label>:2                                       ; preds = %0
  %3 = sext i32 %_c to i64
  %4 = getelementptr inbounds %struct._RuneLocale* @_DefaultRuneLocale, i64 0, i32 5, i64 %3
  %5 = load i32* %4, align 4, !tbaa !2
  %6 = lshr i32 %5, 10
  %.lobit = and i32 %6, 1
  br label %__isctype.exit

__isctype.exit:                                   ; preds = %0, %2
  %7 = phi i32 [ %.lobit, %2 ], [ 0, %0 ]
  ret i32 %7
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isgraph(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 2048) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @islower(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 4096) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isprint(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 262144) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @ispunct(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 8192) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isspace(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 16384) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isupper(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 32768) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize readonly ssp uwtable
define i32 @isxdigit(i32 %_c) #3 {
  %1 = icmp ugt i32 %_c, 255
  br i1 %1, label %__isctype.exit, label %2

; <label>:2                                       ; preds = %0
  %3 = sext i32 %_c to i64
  %4 = getelementptr inbounds %struct._RuneLocale* @_DefaultRuneLocale, i64 0, i32 5, i64 %3
  %5 = load i32* %4, align 4, !tbaa !2
  %6 = lshr i32 %5, 16
  %.lobit = and i32 %6, 1
  br label %__isctype.exit

__isctype.exit:                                   ; preds = %0, %2
  %7 = phi i32 [ %.lobit, %2 ], [ 0, %0 ]
  ret i32 %7
}

; Function Attrs: nounwind optsize readnone ssp uwtable
define i32 @toascii(i32 %_c) #0 {
  %1 = and i32 %_c, 127
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @tolower(i32 %_c) #1 {
  %1 = tail call i32 @__tolower(i32 %_c) #9
  ret i32 %1
}

; Function Attrs: optsize
declare i32 @__tolower(i32) #2

; Function Attrs: nounwind optsize ssp uwtable
define i32 @toupper(i32 %_c) #1 {
  %1 = tail call i32 @__toupper(i32 %_c) #9
  ret i32 %1
}

; Function Attrs: optsize
declare i32 @__toupper(i32) #2

; Function Attrs: nounwind optsize ssp uwtable
define i32 @digittoint(i32 %_c) #1 {
  %1 = tail call i32 @__maskrune(i32 %_c, i64 15) #9
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @ishexnumber(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 65536) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isideogram(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 524288) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isnumber(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 1024) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isphonogram(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 2097152) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isrune(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 4294967280) #10
  ret i32 %1
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @isspecial(i32 %_c) #1 {
  %1 = tail call i32 @__istype(i32 %_c, i64 1048576) #10
  ret i32 %1
}

; Function Attrs: alwaysinline nounwind optsize ssp uwtable
define i32 @__sputc(i32 %_c, %struct.__sFILE* %_p) #4 {
  %1 = getelementptr inbounds %struct.__sFILE* %_p, i64 0, i32 2
  %2 = load i32* %1, align 4, !tbaa !6
  %3 = add nsw i32 %2, -1
  store i32 %3, i32* %1, align 4, !tbaa !6
  %4 = icmp sgt i32 %2, 0
  br i1 %4, label %._crit_edge, label %5

._crit_edge:                                      ; preds = %0
  %.pre = and i32 %_c, 255
  br label %10

; <label>:5                                       ; preds = %0
  %6 = getelementptr inbounds %struct.__sFILE* %_p, i64 0, i32 6
  %7 = load i32* %6, align 4, !tbaa !12
  %8 = icmp sle i32 %2, %7
  %sext.mask = and i32 %_c, 255
  %9 = icmp eq i32 %sext.mask, 10
  %or.cond = or i1 %9, %8
  br i1 %or.cond, label %15, label %10

; <label>:10                                      ; preds = %._crit_edge, %5
  %.pre-phi = phi i32 [ %.pre, %._crit_edge ], [ %sext.mask, %5 ]
  %11 = trunc i32 %_c to i8
  %12 = getelementptr inbounds %struct.__sFILE* %_p, i64 0, i32 0
  %13 = load i8** %12, align 8, !tbaa !13
  %14 = getelementptr inbounds i8* %13, i64 1
  store i8* %14, i8** %12, align 8, !tbaa !13
  store i8 %11, i8* %13, align 1, !tbaa !14
  br label %17

; <label>:15                                      ; preds = %5
  %16 = tail call i32 @__swbuf(i32 %_c, %struct.__sFILE* %_p) #9
  br label %17

; <label>:17                                      ; preds = %15, %10
  %.0 = phi i32 [ %.pre-phi, %10 ], [ %16, %15 ]
  ret i32 %.0
}

; Function Attrs: optsize
declare i32 @__swbuf(i32, %struct.__sFILE*) #2

; Function Attrs: alwaysinline nounwind optsize readnone ssp uwtable
define i32 @__sigbits(i32 %__signo) #5 {
  %1 = icmp sgt i32 %__signo, 32
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = add nsw i32 %__signo, -1
  %4 = shl i32 1, %3
  br label %5

; <label>:5                                       ; preds = %0, %2
  %6 = phi i32 [ %4, %2 ], [ 0, %0 ]
  ret i32 %6
}

; Function Attrs: nounwind optsize readonly ssp uwtable
define i32 @in_ftpset(i32 %ftp, i32 %nset, i32* nocapture readonly %set) #3 {
  %1 = icmp sgt i32 %nset, 0
  br i1 %1, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %2 = add i32 %nset, -1
  br label %3

; <label>:3                                       ; preds = %3, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %3 ]
  %bResult.02 = phi i32 [ 0, %.lr.ph ], [ %.bResult.0, %3 ]
  %4 = getelementptr inbounds i32* %set, i64 %indvars.iv
  %5 = load i32* %4, align 4, !tbaa !2
  %6 = icmp eq i32 %5, %ftp
  %.bResult.0 = select i1 %6, i32 1, i32 %bResult.02
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %2
  br i1 %exitcond, label %._crit_edge, label %3

._crit_edge:                                      ; preds = %3, %0
  %bResult.0.lcssa = phi i32 [ 0, %0 ], [ %.bResult.0, %3 ]
  ret i32 %bResult.0.lcssa
}

; Function Attrs: nounwind optsize ssp uwtable
define internal i32 @do_dummy(i8* nocapture readnone %item, i32 %nitem, i32 %eio, i8* nocapture readnone %desc, i8* nocapture readnone %srcfile, i32 %line) #1 {
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([27 x i8]* @.str31, i64 0, i64 0)) #9
  ret i32 0
}

; Function Attrs: nounwind optsize ssp uwtable
define void @set_comment(i8* readonly %comment) #1 {
  %1 = icmp eq i8* %comment, null
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = tail call i8* @strdup(i8* %comment) #9
  store i8* %3, i8** @add_comment, align 8, !tbaa !15
  br label %4

; <label>:4                                       ; preds = %0, %2
  ret void
}

; Function Attrs: nounwind optsize
declare noalias i8* @strdup(i8* nocapture readonly) #6

; Function Attrs: nounwind optsize ssp uwtable
define void @unset_comment() #1 {
  %1 = load i8** @add_comment, align 8, !tbaa !15
  %2 = icmp eq i8* %1, null
  br i1 %2, label %4, label %3

; <label>:3                                       ; preds = %0
  tail call void @save_free(i8* getelementptr inbounds ([12 x i8]* @.str14, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 147, i8* %1) #9
  br label %4

; <label>:4                                       ; preds = %0, %3
  store i8* null, i8** @add_comment, align 8, !tbaa !15
  ret void
}

; Function Attrs: optsize
declare void @save_free(i8*, i8*, i32, i8*) #2

; Function Attrs: nounwind optsize ssp uwtable
define i32 @gmx_fio_open(i8* %fn, i8* %mode) #1 {
  %newmode = alloca [5 x i8], align 2
  %1 = tail call i32 @fn2ftp(i8* %fn) #9
  %2 = icmp eq i32 %1, 27
  br i1 %2, label %3, label %6

; <label>:3                                       ; preds = %0
  %4 = getelementptr inbounds [5 x i8]* %newmode, i64 0, i64 0
  %5 = call i8* @__strcpy_chk(i8* %4, i8* %mode, i64 5) #9
  br label %15

; <label>:6                                       ; preds = %0
  %7 = load i8* %mode, align 1, !tbaa !14
  switch i8 %7, label %14 [
    i8 114, label %8
    i8 119, label %10
    i8 97, label %12
  ]

; <label>:8                                       ; preds = %6
  %9 = bitcast [5 x i8]* %newmode to i16*
  store i16 114, i16* %9, align 2
  br label %15

; <label>:10                                      ; preds = %6
  %11 = bitcast [5 x i8]* %newmode to i16*
  store i16 119, i16* %11, align 2
  br label %15

; <label>:12                                      ; preds = %6
  %13 = bitcast [5 x i8]* %newmode to i16*
  store i16 97, i16* %13, align 2
  br label %15

; <label>:14                                      ; preds = %6
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([43 x i8]* @.str19, i64 0, i64 0), i8* %mode) #9
  br label %15

; <label>:15                                      ; preds = %8, %12, %14, %10, %3
  %16 = call i32 @fn2ftp(i8* %fn) #9
  %17 = call i8* @ftp2ftype(i32 %16) #9
  %18 = call i32 @strncmp(i8* %17, i8* getelementptr inbounds ([6 x i8]* @.str20, i64 0, i64 0), i64 5) #9
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %.preheader, label %20

; <label>:20                                      ; preds = %15
  %21 = getelementptr inbounds [5 x i8]* %newmode, i64 0, i64 0
  %22 = call i8* @strchr(i8* %21, i32 98) #9
  %23 = icmp eq i8* %22, null
  br i1 %23, label %24, label %.preheader

; <label>:24                                      ; preds = %20
  %25 = call i8* @strchr(i8* %21, i32 66) #9
  %26 = icmp eq i8* %25, null
  br i1 %26, label %27, label %.preheader

; <label>:27                                      ; preds = %24
  %28 = call i8* @__strcat_chk(i8* %21, i8* getelementptr inbounds ([2 x i8]* @.str21, i64 0, i64 0), i64 5) #9
  br label %.preheader

.preheader:                                       ; preds = %15, %20, %24, %27
  %29 = load i32* @nFIO, align 4, !tbaa !2
  %30 = icmp sgt i32 %29, 0
  br i1 %30, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %.preheader
  %31 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %32 = sext i32 %29 to i64
  br label %33

; <label>:33                                      ; preds = %.lr.ph, %40
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %40 ]
  %34 = getelementptr inbounds %struct.t_fileio* %31, i64 %indvars.iv, i32 1
  %35 = load i32* %34, align 4, !tbaa !16
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %37, label %40

; <label>:37                                      ; preds = %33
  %38 = trunc i64 %indvars.iv to i32
  %39 = getelementptr inbounds %struct.t_fileio* %31, i64 %indvars.iv
  br label %.loopexit

; <label>:40                                      ; preds = %33
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %41 = icmp slt i64 %indvars.iv.next, %32
  br i1 %41, label %33, label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %40
  %42 = trunc i64 %indvars.iv.next to i32
  br label %.loopexit

.loopexit:                                        ; preds = %.preheader, %..loopexit_crit_edge, %37
  %i.02 = phi i32 [ %38, %37 ], [ %42, %..loopexit_crit_edge ], [ 0, %.preheader ]
  %nfio.0 = phi i32 [ %38, %37 ], [ 0, %..loopexit_crit_edge ], [ 0, %.preheader ]
  %fio.0 = phi %struct.t_fileio* [ %39, %37 ], [ null, %..loopexit_crit_edge ], [ null, %.preheader ]
  %43 = icmp eq i32 %i.02, %29
  br i1 %43, label %44, label %54

; <label>:44                                      ; preds = %.loopexit
  %45 = add nsw i32 %29, 1
  store i32 %45, i32* @nFIO, align 4, !tbaa !2
  %46 = load i8** bitcast (%struct.t_fileio** @FIO to i8**), align 8, !tbaa !15
  %47 = mul i32 %45, 48
  %48 = call i8* @save_realloc(i8* getelementptr inbounds ([4 x i8]* @.str22, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 676, i8* %46, i32 %47) #9
  %49 = bitcast i8* %48 to %struct.t_fileio*
  store i8* %48, i8** bitcast (%struct.t_fileio** @FIO to i8**), align 8, !tbaa !15
  %50 = load i32* @nFIO, align 4, !tbaa !2
  %51 = add nsw i32 %50, -1
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds %struct.t_fileio* %49, i64 %52
  br label %54

; <label>:54                                      ; preds = %44, %.loopexit
  %nfio.1 = phi i32 [ %51, %44 ], [ %nfio.0, %.loopexit ]
  %fio.1 = phi %struct.t_fileio* [ %53, %44 ], [ %fio.0, %.loopexit ]
  %55 = getelementptr inbounds [5 x i8]* %newmode, i64 0, i64 0
  %56 = load i8* %55, align 2, !tbaa !14
  %57 = icmp eq i8 %56, 114
  %58 = zext i1 %57 to i32
  %59 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 7
  %60 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 8
  %61 = icmp eq i8* %fn, null
  %62 = bitcast %struct.__sFILE** %59 to i8*
  call void @llvm.memset.p0i8.i64(i8* %62, i8 0, i64 16, i32 8, i1 false)
  br i1 %61, label %91, label %63

; <label>:63                                      ; preds = %54
  %64 = call i32 @fn2ftp(i8* %fn) #9
  %65 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 0
  store i32 %64, i32* %65, align 4, !tbaa !18
  %66 = call i8* @strdup(i8* %fn) #9
  %67 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 6
  store i8* %66, i8** %67, align 8, !tbaa !19
  %68 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 5
  store i32 0, i32* %68, align 4, !tbaa !20
  %69 = load i32* %65, align 4, !tbaa !18
  br label %70

; <label>:70                                      ; preds = %70, %63
  %indvars.iv.i = phi i64 [ 0, %63 ], [ %indvars.iv.next.i, %70 ]
  %bResult.02.i = phi i32 [ 0, %63 ], [ %.bResult.0.i, %70 ]
  %71 = getelementptr inbounds [4 x i32]* @ftpXDR, i64 0, i64 %indvars.iv.i
  %72 = load i32* %71, align 4, !tbaa !2
  %73 = icmp eq i32 %72, %69
  %.bResult.0.i = select i1 %73, i32 1, i32 %bResult.02.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i, 4
  br i1 %exitcond, label %in_ftpset.exit, label %70

in_ftpset.exit:                                   ; preds = %70
  %74 = icmp eq i32 %.bResult.0.i, 0
  br i1 %74, label %89, label %75

; <label>:75                                      ; preds = %in_ftpset.exit
  %76 = load i8* %55, align 2, !tbaa !14
  %77 = icmp eq i8 %76, 119
  br i1 %77, label %82, label %78

; <label>:78                                      ; preds = %75
  %79 = call i32 @fexist(i8* %fn) #9
  %80 = icmp eq i32 %79, 0
  br i1 %80, label %81, label %82

; <label>:81                                      ; preds = %78
  call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([18 x i8]* @.str23, i64 0, i64 0), i8* %fn) #9
  br label %82

; <label>:82                                      ; preds = %78, %81, %75
  %83 = call i8* @save_calloc(i8* getelementptr inbounds ([9 x i8]* @.str24, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 711, i32 1, i32 48) #9
  %84 = bitcast i8* %83 to %struct.XDR*
  %85 = bitcast %struct.XDR** %60 to i8**
  store i8* %83, i8** %85, align 8, !tbaa !21
  %86 = call i32 @xdropen(%struct.XDR* %84, i8* %fn, i8* %55) #9
  %87 = icmp eq i32 %86, 0
  br i1 %87, label %88, label %99

; <label>:88                                      ; preds = %82
  call void (i32, i8*, ...)* @fatal_error(i32 -1, i8* getelementptr inbounds ([18 x i8]* @.str25, i64 0, i64 0), i8* %fn) #9
  br label %99

; <label>:89                                      ; preds = %in_ftpset.exit
  %90 = call %struct.__sFILE* @ffopen(i8* %fn, i8* %55) #9
  store %struct.__sFILE* %90, %struct.__sFILE** %59, align 8, !tbaa !22
  br label %99

; <label>:91                                      ; preds = %54
  %92 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 0
  store i32 27, i32* %92, align 4, !tbaa !18
  %93 = load %struct.__sFILE** @__stdinp, align 8, !tbaa !15
  %94 = load %struct.__sFILE** @__stdoutp, align 8, !tbaa !15
  %95 = select i1 %57, %struct.__sFILE* %93, %struct.__sFILE* %94
  store %struct.__sFILE* %95, %struct.__sFILE** %59, align 8, !tbaa !22
  %96 = call i8* @strdup(i8* getelementptr inbounds ([6 x i8]* @.str26, i64 0, i64 0)) #9
  %97 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 6
  store i8* %96, i8** %97, align 8, !tbaa !19
  %98 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 5
  store i32 1, i32* %98, align 4, !tbaa !20
  br label %99

; <label>:99                                      ; preds = %82, %89, %88, %91
  %100 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 2
  store i32 %58, i32* %100, align 4, !tbaa !23
  %101 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 3
  store i32 0, i32* %101, align 4, !tbaa !24
  %102 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 4
  store i32 0, i32* %102, align 4, !tbaa !25
  %103 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 1
  store i32 1, i32* %103, align 4, !tbaa !16
  ret i32 %nfio.1
}

; Function Attrs: optsize
declare i32 @fn2ftp(i8*) #2

; Function Attrs: nounwind optsize
declare i8* @__strcpy_chk(i8*, i8*, i64) #6

; Function Attrs: optsize
declare void @fatal_error(i32, i8*, ...) #2

; Function Attrs: nounwind optsize readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) #7

; Function Attrs: optsize
declare i8* @ftp2ftype(i32) #2

; Function Attrs: nounwind optsize readonly
declare i8* @strchr(i8*, i32) #7

; Function Attrs: nounwind optsize
declare i8* @__strcat_chk(i8*, i8*, i64) #6

; Function Attrs: optsize
declare i8* @save_realloc(i8*, i8*, i32, i8*, i32) #2

; Function Attrs: optsize
declare i32 @fexist(i8*) #2

; Function Attrs: optsize
declare i8* @save_calloc(i8*, i8*, i32, i32, i32) #2

; Function Attrs: optsize
declare i32 @xdropen(%struct.XDR*, i8*, i8*) #2

; Function Attrs: optsize
declare %struct.__sFILE* @ffopen(i8*, i8*) #2

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_close(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 737) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 0
  %8 = load i32* %7, align 4, !tbaa !18
  br label %9

; <label>:9                                       ; preds = %9, %_gmx_fio_check.exit
  %indvars.iv.i = phi i64 [ 0, %_gmx_fio_check.exit ], [ %indvars.iv.next.i, %9 ]
  %bResult.02.i = phi i32 [ 0, %_gmx_fio_check.exit ], [ %.bResult.0.i, %9 ]
  %10 = getelementptr inbounds [4 x i32]* @ftpXDR, i64 0, i64 %indvars.iv.i
  %11 = load i32* %10, align 4, !tbaa !2
  %12 = icmp eq i32 %11, %8
  %.bResult.0.i = select i1 %12, i32 1, i32 %bResult.02.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i, 4
  br i1 %exitcond, label %in_ftpset.exit, label %9

in_ftpset.exit:                                   ; preds = %9
  %13 = icmp eq i32 %.bResult.0.i, 0
  br i1 %13, label %22, label %14

; <label>:14                                      ; preds = %in_ftpset.exit
  %15 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 8
  %16 = load %struct.XDR** %15, align 8, !tbaa !21
  %17 = tail call i32 @xdrclose(%struct.XDR* %16) #9
  %18 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %19 = getelementptr inbounds %struct.t_fileio* %18, i64 %5, i32 8
  %20 = bitcast %struct.XDR** %19 to i8**
  %21 = load i8** %20, align 8, !tbaa !21
  tail call void @save_free(i8* getelementptr inbounds ([13 x i8]* @.str27, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 741, i8* %21) #9
  br label %29

; <label>:22                                      ; preds = %in_ftpset.exit
  %23 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 5
  %24 = load i32* %23, align 4, !tbaa !20
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %29

; <label>:26                                      ; preds = %22
  %27 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 7
  %28 = load %struct.__sFILE** %27, align 8, !tbaa !22
  tail call void @ffclose(%struct.__sFILE* %28) #9
  br label %29

; <label>:29                                      ; preds = %22, %26, %14
  %30 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %31 = getelementptr inbounds %struct.t_fileio* %30, i64 %5, i32 6
  %32 = load i8** %31, align 8, !tbaa !19
  tail call void @save_free(i8* getelementptr inbounds ([12 x i8]* @.str28, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 749, i8* %32) #9
  %33 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %34 = getelementptr inbounds %struct.t_fileio* %33, i64 %5, i32 1
  store i32 0, i32* %34, align 4, !tbaa !16
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !15
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !15
  ret void
}

; Function Attrs: optsize
declare i32 @xdrclose(%struct.XDR*) #2

; Function Attrs: optsize
declare void @ffclose(%struct.__sFILE*) #2

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_select(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 757) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 0
  %8 = load i32* %7, align 4, !tbaa !18
  br label %9

; <label>:9                                       ; preds = %9, %_gmx_fio_check.exit
  %indvars.iv.i = phi i64 [ 0, %_gmx_fio_check.exit ], [ %indvars.iv.next.i, %9 ]
  %bResult.02.i = phi i32 [ 0, %_gmx_fio_check.exit ], [ %.bResult.0.i, %9 ]
  %10 = getelementptr inbounds [4 x i32]* @ftpXDR, i64 0, i64 %indvars.iv.i
  %11 = load i32* %10, align 4, !tbaa !2
  %12 = icmp eq i32 %11, %8
  %.bResult.0.i = select i1 %12, i32 1, i32 %bResult.02.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond16 = icmp eq i64 %indvars.iv.next.i, 4
  br i1 %exitcond16, label %in_ftpset.exit, label %9

in_ftpset.exit:                                   ; preds = %9
  %13 = icmp eq i32 %.bResult.0.i, 0
  br i1 %13, label %.preheader17, label %14

; <label>:14                                      ; preds = %in_ftpset.exit
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_xdr, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !15
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_xdr, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !15
  br label %30

.preheader17:                                     ; preds = %in_ftpset.exit, %.preheader17
  %indvars.iv.i8 = phi i64 [ %indvars.iv.next.i11, %.preheader17 ], [ 0, %in_ftpset.exit ]
  %bResult.02.i9 = phi i32 [ %.bResult.0.i10, %.preheader17 ], [ 0, %in_ftpset.exit ]
  %15 = getelementptr inbounds [3 x i32]* @ftpASC, i64 0, i64 %indvars.iv.i8
  %16 = load i32* %15, align 4, !tbaa !2
  %17 = icmp eq i32 %16, %8
  %.bResult.0.i10 = select i1 %17, i32 1, i32 %bResult.02.i9
  %indvars.iv.next.i11 = add nuw nsw i64 %indvars.iv.i8, 1
  %exitcond15 = icmp eq i64 %indvars.iv.next.i11, 3
  br i1 %exitcond15, label %in_ftpset.exit14, label %.preheader17

in_ftpset.exit14:                                 ; preds = %.preheader17
  %18 = icmp eq i32 %.bResult.0.i10, 0
  br i1 %18, label %.preheader, label %19

; <label>:19                                      ; preds = %in_ftpset.exit14
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_ascread, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !15
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_ascwrite, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !15
  br label %30

.preheader:                                       ; preds = %in_ftpset.exit14, %.preheader
  %indvars.iv.i1 = phi i64 [ %indvars.iv.next.i4, %.preheader ], [ 0, %in_ftpset.exit14 ]
  %bResult.02.i2 = phi i32 [ %.bResult.0.i3, %.preheader ], [ 0, %in_ftpset.exit14 ]
  %20 = getelementptr inbounds [4 x i32]* @ftpBIN, i64 0, i64 %indvars.iv.i1
  %21 = load i32* %20, align 4, !tbaa !2
  %22 = icmp eq i32 %21, %8
  %.bResult.0.i3 = select i1 %22, i32 1, i32 %bResult.02.i2
  %indvars.iv.next.i4 = add nuw nsw i64 %indvars.iv.i1, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i4, 4
  br i1 %exitcond, label %in_ftpset.exit7, label %.preheader

in_ftpset.exit7:                                  ; preds = %.preheader
  %23 = icmp eq i32 %.bResult.0.i3, 0
  br i1 %23, label %25, label %24

; <label>:24                                      ; preds = %in_ftpset.exit7
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_binread, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !15
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_binwrite, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !15
  br label %30

; <label>:25                                      ; preds = %in_ftpset.exit7
  %26 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %27 = getelementptr inbounds %struct.t_fileio* %26, i64 0, i32 0
  %28 = load i32* %27, align 4, !tbaa !18
  %29 = tail call i8* @ftp2ext(i32 %28) #9
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([46 x i8]* @.str29, i64 0, i64 0), i8* %29) #9
  %.pre = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  br label %30

; <label>:30                                      ; preds = %19, %25, %24, %14
  %31 = phi %struct.t_fileio* [ %6, %19 ], [ %.pre, %25 ], [ %6, %24 ], [ %6, %14 ]
  %32 = getelementptr inbounds %struct.t_fileio* %31, i64 %5
  store %struct.t_fileio* %32, %struct.t_fileio** @curfio, align 8, !tbaa !15
  ret void
}

; Function Attrs: nounwind optsize ssp uwtable
define internal i32 @do_xdr(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
  %fvec = alloca [3 x float], align 4
  %1 = bitcast [3 x float]* %fvec to i8*
  %dvec = alloca [3 x double], align 16
  %idum = alloca i32, align 4
  %us = alloca i16, align 2
  %d = alloca double, align 8
  %f = alloca float, align 4
  %cptr = alloca i8*, align 8
  %slen = alloca i32, align 4
  store double 0.000000e+00, double* %d, align 8, !tbaa !26
  store float 0.000000e+00, float* %f, align 4, !tbaa !28
  tail call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 516) #10
  switch i32 %eio, label %.critedge.thread [
    i32 0, label %8
    i32 1, label %54
    i32 2, label %.preheader
    i32 3, label %82
    i32 4, label %102
    i32 5, label %.preheader20
    i32 6, label %158
    i32 7, label %184
  ]

.preheader20:                                     ; preds = %0
  %2 = icmp sgt i32 %nitem, 0
  br i1 %2, label %.lr.ph30, label %.critedge.thread60

.lr.ph30:                                         ; preds = %.preheader20
  %3 = icmp eq i8* %item, null
  %4 = bitcast i8* %item to [3 x float]*
  %5 = sext i32 %nitem to i64
  br label %150

.preheader:                                       ; preds = %0
  %6 = icmp sgt i32 %nitem, 0
  br i1 %6, label %.lr.ph, label %.critedge.thread60

.lr.ph:                                           ; preds = %.preheader
  %7 = sext i32 %nitem to i64
  br label %74

; <label>:8                                       ; preds = %0
  %9 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %10 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 3
  %11 = load i32* %10, align 4, !tbaa !24
  %12 = icmp eq i32 %11, 0
  %13 = icmp ne i8* %item, null
  br i1 %12, label %34, label %14

; <label>:14                                      ; preds = %8
  br i1 %13, label %15, label %23

; <label>:15                                      ; preds = %14
  %16 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 2
  %17 = load i32* %16, align 4, !tbaa !23
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %27

; <label>:19                                      ; preds = %15
  %20 = bitcast i8* %item to float*
  %21 = load float* %20, align 4, !tbaa !28
  %22 = fpext float %21 to double
  store double %22, double* %d, align 8, !tbaa !26
  br label %27

; <label>:23                                      ; preds = %14
  %24 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 8
  %25 = load %struct.XDR** %24, align 8, !tbaa !21
  %26 = call i32 @xdr_double(%struct.XDR* %25, double* %d) #9
  br label %.critedge

; <label>:27                                      ; preds = %15, %19
  %28 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 8
  %29 = load %struct.XDR** %28, align 8, !tbaa !21
  %30 = call i32 @xdr_double(%struct.XDR* %29, double* %d) #9
  %31 = load double* %d, align 8, !tbaa !26
  %32 = fptrunc double %31 to float
  %33 = bitcast i8* %item to float*
  store float %32, float* %33, align 4, !tbaa !28
  br label %.critedge

; <label>:34                                      ; preds = %8
  br i1 %13, label %35, label %43

; <label>:35                                      ; preds = %34
  %36 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 2
  %37 = load i32* %36, align 4, !tbaa !23
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %39, label %47

; <label>:39                                      ; preds = %35
  %40 = bitcast i8* %item to i32*
  %41 = load i32* %40, align 4, !tbaa !28
  %42 = bitcast float* %f to i32*
  store i32 %41, i32* %42, align 4, !tbaa !28
  br label %47

; <label>:43                                      ; preds = %34
  %44 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 8
  %45 = load %struct.XDR** %44, align 8, !tbaa !21
  %46 = call i32 @xdr_float(%struct.XDR* %45, float* %f) #9
  br label %.critedge

; <label>:47                                      ; preds = %35, %39
  %48 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 8
  %49 = load %struct.XDR** %48, align 8, !tbaa !21
  %50 = call i32 @xdr_float(%struct.XDR* %49, float* %f) #9
  %51 = bitcast float* %f to i32*
  %52 = load i32* %51, align 4, !tbaa !28
  %53 = bitcast i8* %item to i32*
  store i32 %52, i32* %53, align 4, !tbaa !28
  br label %.critedge

; <label>:54                                      ; preds = %0
  %55 = icmp eq i8* %item, null
  %56 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  br i1 %55, label %64, label %57

; <label>:57                                      ; preds = %54
  %58 = getelementptr inbounds %struct.t_fileio* %56, i64 0, i32 2
  %59 = load i32* %58, align 4, !tbaa !23
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %61, label %68

; <label>:61                                      ; preds = %57
  %62 = bitcast i8* %item to i32*
  %63 = load i32* %62, align 4, !tbaa !2
  store i32 %63, i32* %idum, align 4, !tbaa !2
  br label %68

; <label>:64                                      ; preds = %54
  %65 = getelementptr inbounds %struct.t_fileio* %56, i64 0, i32 8
  %66 = load %struct.XDR** %65, align 8, !tbaa !21
  %67 = call i32 @xdr_int(%struct.XDR* %66, i32* %idum) #9
  br label %.critedge

; <label>:68                                      ; preds = %57, %61
  %69 = getelementptr inbounds %struct.t_fileio* %56, i64 0, i32 8
  %70 = load %struct.XDR** %69, align 8, !tbaa !21
  %71 = call i32 @xdr_int(%struct.XDR* %70, i32* %idum) #9
  %72 = load i32* %idum, align 4, !tbaa !2
  %73 = bitcast i8* %item to i32*
  store i32 %72, i32* %73, align 4, !tbaa !2
  br label %.critedge

; <label>:74                                      ; preds = %.lr.ph, %74
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %74 ]
  %75 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %76 = getelementptr inbounds %struct.t_fileio* %75, i64 0, i32 8
  %77 = load %struct.XDR** %76, align 8, !tbaa !21
  %78 = getelementptr inbounds i8* %item, i64 %indvars.iv
  %79 = tail call i32 @xdr_u_char(%struct.XDR* %77, i8* %78) #9
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %80 = icmp slt i64 %indvars.iv.next, %7
  %81 = icmp ne i32 %79, 0
  %or.cond = and i1 %80, %81
  br i1 %or.cond, label %74, label %.critedge

; <label>:82                                      ; preds = %0
  %83 = icmp eq i8* %item, null
  %84 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  br i1 %83, label %92, label %85

; <label>:85                                      ; preds = %82
  %86 = getelementptr inbounds %struct.t_fileio* %84, i64 0, i32 2
  %87 = load i32* %86, align 4, !tbaa !23
  %88 = icmp eq i32 %87, 0
  br i1 %88, label %89, label %96

; <label>:89                                      ; preds = %85
  %90 = bitcast i8* %item to i16*
  %91 = load i16* %90, align 2, !tbaa !30
  store i16 %91, i16* %us, align 2, !tbaa !30
  br label %96

; <label>:92                                      ; preds = %82
  %93 = getelementptr inbounds %struct.t_fileio* %84, i64 0, i32 8
  %94 = load %struct.XDR** %93, align 8, !tbaa !21
  %95 = call i32 @xdr_u_short(%struct.XDR* %94, i16* %us) #9
  br label %.critedge

; <label>:96                                      ; preds = %85, %89
  %97 = getelementptr inbounds %struct.t_fileio* %84, i64 0, i32 8
  %98 = load %struct.XDR** %97, align 8, !tbaa !21
  %99 = call i32 @xdr_u_short(%struct.XDR* %98, i16* %us) #9
  %100 = load i16* %us, align 2, !tbaa !30
  %101 = bitcast i8* %item to i16*
  store i16 %100, i16* %101, align 2, !tbaa !30
  br label %.critedge

; <label>:102                                     ; preds = %0
  %103 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %104 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 3
  %105 = load i32* %104, align 4, !tbaa !24
  %106 = icmp eq i32 %105, 0
  %107 = icmp ne i8* %item, null
  br i1 %106, label %138, label %108

; <label>:108                                     ; preds = %102
  br i1 %107, label %113, label %.loopexit19.thread57

.loopexit19.thread57:                             ; preds = %108
  %109 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 8
  %110 = load %struct.XDR** %109, align 8, !tbaa !21
  %111 = bitcast [3 x double]* %dvec to i8*
  %112 = call i32 @xdr_vector(%struct.XDR* %110, i8* %111, i32 3, i32 8, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, double*)* @xdr_double to i32 (%struct.XDR*, i8*, ...)*)) #9
  br label %.critedge

; <label>:113                                     ; preds = %108
  %114 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 2
  %115 = load i32* %114, align 4, !tbaa !23
  %116 = icmp eq i32 %115, 0
  br i1 %116, label %.preheader18, label %.loopexit19.thread

.loopexit19.thread:                               ; preds = %113
  %117 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 8
  %118 = load %struct.XDR** %117, align 8, !tbaa !21
  %119 = bitcast [3 x double]* %dvec to i8*
  %120 = call i32 @xdr_vector(%struct.XDR* %118, i8* %119, i32 3, i32 8, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, double*)* @xdr_double to i32 (%struct.XDR*, i8*, ...)*)) #9
  br label %.preheader16

.preheader18:                                     ; preds = %113
  %121 = bitcast i8* %item to float*
  br label %122

; <label>:122                                     ; preds = %122, %.preheader18
  %indvars.iv41 = phi i64 [ 0, %.preheader18 ], [ %indvars.iv.next42, %122 ]
  %123 = getelementptr inbounds float* %121, i64 %indvars.iv41
  %124 = load float* %123, align 4, !tbaa !28
  %125 = fpext float %124 to double
  %126 = getelementptr inbounds [3 x double]* %dvec, i64 0, i64 %indvars.iv41
  store double %125, double* %126, align 8, !tbaa !26
  %indvars.iv.next42 = add nuw nsw i64 %indvars.iv41, 1
  %exitcond43 = icmp eq i64 %indvars.iv.next42, 3
  br i1 %exitcond43, label %.loopexit19, label %122

.loopexit19:                                      ; preds = %122
  %127 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 8
  %128 = load %struct.XDR** %127, align 8, !tbaa !21
  %129 = bitcast [3 x double]* %dvec to i8*
  %130 = call i32 @xdr_vector(%struct.XDR* %128, i8* %129, i32 3, i32 8, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, double*)* @xdr_double to i32 (%struct.XDR*, i8*, ...)*)) #9
  br label %.preheader16

.preheader16:                                     ; preds = %.loopexit19, %.loopexit19.thread
  %131 = phi i32 [ %120, %.loopexit19.thread ], [ %130, %.loopexit19 ]
  %132 = bitcast i8* %item to float*
  br label %133

; <label>:133                                     ; preds = %133, %.preheader16
  %indvars.iv39 = phi i64 [ 0, %.preheader16 ], [ %indvars.iv.next40, %133 ]
  %134 = getelementptr inbounds [3 x double]* %dvec, i64 0, i64 %indvars.iv39
  %135 = load double* %134, align 8, !tbaa !26
  %136 = fptrunc double %135 to float
  %137 = getelementptr inbounds float* %132, i64 %indvars.iv39
  store float %136, float* %137, align 4, !tbaa !28
  %indvars.iv.next40 = add nuw nsw i64 %indvars.iv39, 1
  %exitcond = icmp eq i64 %indvars.iv.next40, 3
  br i1 %exitcond, label %.critedge, label %133

; <label>:138                                     ; preds = %102
  br i1 %107, label %139, label %143

; <label>:139                                     ; preds = %138
  %140 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 2
  %141 = load i32* %140, align 4, !tbaa !23
  %142 = icmp eq i32 %141, 0
  br i1 %142, label %.preheader15, label %.preheader13

.preheader15:                                     ; preds = %139
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %item, i64 12, i32 4, i1 false)
  br label %.preheader13

; <label>:143                                     ; preds = %138
  %144 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 8
  %145 = load %struct.XDR** %144, align 8, !tbaa !21
  %146 = call i32 @xdr_vector(%struct.XDR* %145, i8* %1, i32 3, i32 4, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, float*)* @xdr_float to i32 (%struct.XDR*, i8*, ...)*)) #9
  br label %.critedge

.preheader13:                                     ; preds = %.preheader15, %139
  %147 = getelementptr inbounds %struct.t_fileio* %103, i64 0, i32 8
  %148 = load %struct.XDR** %147, align 8, !tbaa !21
  %149 = call i32 @xdr_vector(%struct.XDR* %148, i8* %1, i32 3, i32 4, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, float*)* @xdr_float to i32 (%struct.XDR*, i8*, ...)*)) #9
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %item, i8* %1, i64 12, i32 4, i1 false)
  br label %.critedge

; <label>:150                                     ; preds = %.lr.ph30, %153
  %indvars.iv44 = phi i64 [ 0, %.lr.ph30 ], [ %indvars.iv.next45, %153 ]
  %ptr.029 = phi float* [ null, %.lr.ph30 ], [ %ptr.1, %153 ]
  br i1 %3, label %153, label %151

; <label>:151                                     ; preds = %150
  %152 = getelementptr inbounds [3 x float]* %4, i64 %indvars.iv44, i64 0
  br label %153

; <label>:153                                     ; preds = %150, %151
  %ptr.1 = phi float* [ %152, %151 ], [ %ptr.029, %150 ]
  %154 = bitcast float* %ptr.1 to i8*
  %155 = tail call i32 @do_xdr(i8* %154, i32 1, i32 4, i8* %desc, i8* %srcfile, i32 %line) #10
  %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1
  %156 = icmp slt i64 %indvars.iv.next45, %5
  %157 = icmp ne i32 %155, 0
  %or.cond5 = and i1 %156, %157
  br i1 %or.cond5, label %150, label %.critedge

; <label>:158                                     ; preds = %0
  %159 = bitcast i8* %item to i32*
  %160 = icmp eq i8* %item, null
  br label %161

; <label>:161                                     ; preds = %158, %180
  %indvars.iv46 = phi i64 [ 0, %158 ], [ %indvars.iv.next47, %180 ]
  %162 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  br i1 %160, label %170, label %163

; <label>:163                                     ; preds = %161
  %164 = getelementptr inbounds %struct.t_fileio* %162, i64 0, i32 2
  %165 = load i32* %164, align 4, !tbaa !23
  %166 = icmp eq i32 %165, 0
  br i1 %166, label %167, label %174

; <label>:167                                     ; preds = %163
  %168 = getelementptr inbounds i32* %159, i64 %indvars.iv46
  %169 = load i32* %168, align 4, !tbaa !2
  store i32 %169, i32* %idum, align 4, !tbaa !2
  br label %174

; <label>:170                                     ; preds = %161
  %171 = getelementptr inbounds %struct.t_fileio* %162, i64 0, i32 8
  %172 = load %struct.XDR** %171, align 8, !tbaa !21
  %173 = call i32 @xdr_int(%struct.XDR* %172, i32* %idum) #9
  br label %180

; <label>:174                                     ; preds = %163, %167
  %175 = getelementptr inbounds %struct.t_fileio* %162, i64 0, i32 8
  %176 = load %struct.XDR** %175, align 8, !tbaa !21
  %177 = call i32 @xdr_int(%struct.XDR* %176, i32* %idum) #9
  %178 = load i32* %idum, align 4, !tbaa !2
  %179 = getelementptr inbounds i32* %159, i64 %indvars.iv46
  store i32 %178, i32* %179, align 4, !tbaa !2
  br label %180

; <label>:180                                     ; preds = %170, %174
  %181 = phi i32 [ %173, %170 ], [ %177, %174 ]
  %indvars.iv.next47 = add nuw nsw i64 %indvars.iv46, 1
  %182 = icmp slt i64 %indvars.iv.next47, 3
  %183 = icmp ne i32 %181, 0
  %or.cond7 = and i1 %182, %183
  br i1 %or.cond7, label %161, label %.critedge

; <label>:184                                     ; preds = %0
  %185 = icmp ne i8* %item, null
  br i1 %185, label %186, label %196

; <label>:186                                     ; preds = %184
  %187 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %188 = getelementptr inbounds %struct.t_fileio* %187, i64 0, i32 2
  %189 = load i32* %188, align 4, !tbaa !23
  %190 = icmp eq i32 %189, 0
  br i1 %190, label %191, label %195

; <label>:191                                     ; preds = %186
  %192 = tail call i64 @strlen(i8* %item) #9
  %193 = add i64 %192, 1
  %194 = trunc i64 %193 to i32
  store i32 %194, i32* %slen, align 4, !tbaa !2
  br label %197

; <label>:195                                     ; preds = %186
  store i32 0, i32* %slen, align 4, !tbaa !2
  br label %197

; <label>:196                                     ; preds = %184
  store i32 0, i32* %slen, align 4, !tbaa !2
  %.pre = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  br label %197

; <label>:197                                     ; preds = %191, %195, %196
  %198 = phi %struct.t_fileio* [ %187, %191 ], [ %187, %195 ], [ %.pre, %196 ]
  %199 = getelementptr inbounds %struct.t_fileio* %198, i64 0, i32 8
  %200 = load %struct.XDR** %199, align 8, !tbaa !21
  %201 = call i32 @xdr_int(%struct.XDR* %200, i32* %slen) #9
  %202 = icmp slt i32 %201, 1
  br i1 %202, label %203, label %205

; <label>:203                                     ; preds = %197
  %204 = load i32* %slen, align 4, !tbaa !2
  call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([58 x i8]* @.str33, i64 0, i64 0), i32 %204, i8* %desc, i8* %srcfile, i32 %line) #9
  br label %205

; <label>:205                                     ; preds = %203, %197
  br i1 %185, label %.thread8, label %206

.thread8:                                         ; preds = %205
  store i8* %item, i8** %cptr, align 8, !tbaa !15
  br label %215

; <label>:206                                     ; preds = %205
  %207 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %208 = getelementptr inbounds %struct.t_fileio* %207, i64 0, i32 2
  %209 = load i32* %208, align 4, !tbaa !23
  %210 = icmp eq i32 %209, 0
  br i1 %210, label %.thread, label %211

.thread:                                          ; preds = %206
  store i8* null, i8** %cptr, align 8, !tbaa !15
  br label %.thread9

; <label>:211                                     ; preds = %206
  %212 = load i32* %slen, align 4, !tbaa !2
  %213 = call i8* @save_calloc(i8* getelementptr inbounds ([5 x i8]* @.str34, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 605, i32 %212, i32 1) #9
  store i8* %213, i8** %cptr, align 8, !tbaa !15
  %214 = icmp eq i8* %213, null
  br i1 %214, label %.thread9, label %215

; <label>:215                                     ; preds = %211, %.thread8
  %216 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %217 = getelementptr inbounds %struct.t_fileio* %216, i64 0, i32 8
  %218 = load %struct.XDR** %217, align 8, !tbaa !21
  %219 = load i32* %slen, align 4, !tbaa !2
  %220 = call i32 @xdr_string(%struct.XDR* %218, i8** %cptr, i32 %219) #9
  br i1 %185, label %.critedge, label %.thread9

.thread9:                                         ; preds = %211, %.thread, %215
  %res.310 = phi i32 [ %220, %215 ], [ 1, %.thread ], [ 1, %211 ]
  %221 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %222 = getelementptr inbounds %struct.t_fileio* %221, i64 0, i32 2
  %223 = load i32* %222, align 4, !tbaa !23
  %224 = icmp eq i32 %223, 0
  br i1 %224, label %.critedge, label %225

; <label>:225                                     ; preds = %.thread9
  %226 = load i8** %cptr, align 8, !tbaa !15
  call void @save_free(i8* getelementptr inbounds ([5 x i8]* @.str34, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 613, i8* %226) #9
  br label %.critedge

.critedge.thread:                                 ; preds = %0
  tail call fastcc void @fe(i32 %eio, i8* %desc, i32 617) #10
  br label %228

.critedge:                                        ; preds = %180, %153, %133, %74, %143, %.loopexit19.thread57, %92, %64, %43, %23, %.preheader13, %.thread9, %215, %225, %96, %68, %27, %47
  %res.4 = phi i32 [ %220, %215 ], [ %res.310, %225 ], [ %res.310, %.thread9 ], [ %146, %143 ], [ %99, %96 ], [ %95, %92 ], [ %71, %68 ], [ %67, %64 ], [ %30, %27 ], [ %26, %23 ], [ %50, %47 ], [ %46, %43 ], [ %149, %.preheader13 ], [ %112, %.loopexit19.thread57 ], [ %79, %74 ], [ %131, %133 ], [ %155, %153 ], [ %181, %180 ]
  %227 = icmp eq i32 %res.4, 0
  br i1 %227, label %228, label %.critedge.thread60

; <label>:228                                     ; preds = %.critedge.thread, %.critedge
  %229 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %230 = getelementptr inbounds %struct.t_fileio* %229, i64 0, i32 4
  %231 = load i32* %230, align 4, !tbaa !25
  %232 = icmp eq i32 %231, 0
  br i1 %232, label %.critedge.thread60, label %233

; <label>:233                                     ; preds = %228
  %234 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %235 = sext i32 %eio to i64
  %236 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %235
  %237 = load i8** %236, align 8, !tbaa !15
  %238 = getelementptr inbounds %struct.t_fileio* %229, i64 0, i32 6
  %239 = load i8** %238, align 8, !tbaa !19
  %240 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %234, i8* getelementptr inbounds ([56 x i8]* @.str35, i64 0, i64 0), i8* %237, i8* %desc, i8* %239, i8* %srcfile, i32 %line) #9
  br label %.critedge.thread60

.critedge.thread60:                               ; preds = %.preheader20, %.preheader, %228, %233, %.critedge
  %res.411 = phi i32 [ 0, %228 ], [ 0, %233 ], [ %res.4, %.critedge ], [ 1, %.preheader ], [ 1, %.preheader20 ]
  %241 = icmp ne i32 %res.411, 0
  %242 = zext i1 %241 to i32
  ret i32 %242
}

; Function Attrs: nounwind optsize ssp uwtable
define internal i32 @do_ascread(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
  %i = alloca i32, align 4
  %ix = alloca i32, align 4
  %d = alloca double, align 8
  %x = alloca double, align 8
  %1 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %2 = getelementptr inbounds %struct.t_fileio* %1, i64 0, i32 7
  %3 = load %struct.__sFILE** %2, align 8, !tbaa !22
  tail call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 335) #10
  switch i32 %eio, label %103 [
    i32 0, label %9
    i32 1, label %17
    i32 2, label %.preheader
    i32 3, label %37
    i32 4, label %45
    i32 5, label %.preheader7
    i32 6, label %67
    i32 7, label %77
  ]

.preheader7:                                      ; preds = %0
  store i32 0, i32* %i, align 4, !tbaa !2
  %4 = icmp sgt i32 %nitem, 0
  br i1 %4, label %.lr.ph13, label %decode_string.exit.thread

.lr.ph13:                                         ; preds = %.preheader7
  %5 = bitcast i8* %item to [3 x float]*
  %6 = icmp eq i8* %item, null
  br label %53

.preheader:                                       ; preds = %0
  store i32 0, i32* %i, align 4, !tbaa !2
  %7 = icmp sgt i32 %nitem, 0
  br i1 %7, label %.lr.ph, label %decode_string.exit.thread

.lr.ph:                                           ; preds = %.preheader
  %8 = icmp eq i8* %item, null
  br label %24

; <label>:9                                       ; preds = %0
  %10 = tail call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %11 = call i32 (i8*, i8*, ...)* @sscanf(i8* %10, i8* getelementptr inbounds ([4 x i8]* @.str49, i64 0, i64 0), double* %d) #9
  %12 = icmp eq i8* %item, null
  br i1 %12, label %decode_string.exit, label %13

; <label>:13                                      ; preds = %9
  %14 = load double* %d, align 8, !tbaa !26
  %15 = fptrunc double %14 to float
  %16 = bitcast i8* %item to float*
  store float %15, float* %16, align 4, !tbaa !28
  br label %decode_string.exit

; <label>:17                                      ; preds = %0
  %18 = tail call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %19 = call i32 (i8*, i8*, ...)* @sscanf(i8* %18, i8* getelementptr inbounds ([3 x i8]* @.str50, i64 0, i64 0), i32* %i) #9
  %20 = icmp eq i8* %item, null
  br i1 %20, label %decode_string.exit, label %21

; <label>:21                                      ; preds = %17
  %22 = load i32* %i, align 4, !tbaa !2
  %23 = bitcast i8* %item to i32*
  store i32 %22, i32* %23, align 4, !tbaa !2
  br label %decode_string.exit

; <label>:24                                      ; preds = %.lr.ph, %33
  %25 = call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %26 = call i32 (i8*, i8*, ...)* @sscanf(i8* %25, i8* getelementptr inbounds ([3 x i8]* @.str50, i64 0, i64 0), i32* %ix) #9
  br i1 %8, label %._crit_edge, label %27

._crit_edge:                                      ; preds = %24
  %.pre = load i32* %i, align 4, !tbaa !2
  br label %33

; <label>:27                                      ; preds = %24
  %28 = load i32* %ix, align 4, !tbaa !2
  %29 = trunc i32 %28 to i8
  %30 = load i32* %i, align 4, !tbaa !2
  %31 = sext i32 %30 to i64
  %32 = getelementptr inbounds i8* %item, i64 %31
  store i8 %29, i8* %32, align 1, !tbaa !14
  br label %33

; <label>:33                                      ; preds = %._crit_edge, %27
  %34 = phi i32 [ %.pre, %._crit_edge ], [ %30, %27 ]
  %35 = add nsw i32 %34, 1
  store i32 %35, i32* %i, align 4, !tbaa !2
  %36 = icmp slt i32 %35, %nitem
  br i1 %36, label %24, label %decode_string.exit

; <label>:37                                      ; preds = %0
  %38 = tail call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %39 = call i32 (i8*, i8*, ...)* @sscanf(i8* %38, i8* getelementptr inbounds ([3 x i8]* @.str50, i64 0, i64 0), i32* %i) #9
  %40 = icmp eq i8* %item, null
  br i1 %40, label %decode_string.exit, label %41

; <label>:41                                      ; preds = %37
  %42 = load i32* %i, align 4, !tbaa !2
  %43 = trunc i32 %42 to i16
  %44 = bitcast i8* %item to i16*
  store i16 %43, i16* %44, align 2, !tbaa !30
  br label %decode_string.exit

; <label>:45                                      ; preds = %0
  %46 = bitcast i8* %item to float*
  br label %47

; <label>:47                                      ; preds = %47, %45
  %indvars.iv = phi i64 [ 0, %45 ], [ %indvars.iv.next, %47 ]
  %48 = call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %49 = call i32 (i8*, i8*, ...)* @sscanf(i8* %48, i8* getelementptr inbounds ([5 x i8]* @.str51, i64 0, i64 0), double* %x) #9
  %50 = load double* %x, align 8, !tbaa !26
  %51 = fptrunc double %50 to float
  %52 = getelementptr inbounds float* %46, i64 %indvars.iv
  store float %51, float* %52, align 4, !tbaa !28
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 3
  br i1 %exitcond, label %decode_string.exit, label %47

; <label>:53                                      ; preds = %.lr.ph13, %63
  %storemerge12 = phi i32 [ 0, %.lr.ph13 ], [ %65, %63 ]
  %54 = sext i32 %storemerge12 to i64
  br label %55

; <label>:55                                      ; preds = %62, %53
  %indvars.iv19 = phi i64 [ 0, %53 ], [ %indvars.iv.next20, %62 ]
  %56 = call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %57 = call i32 (i8*, i8*, ...)* @sscanf(i8* %56, i8* getelementptr inbounds ([5 x i8]* @.str51, i64 0, i64 0), double* %x) #9
  br i1 %6, label %62, label %58

; <label>:58                                      ; preds = %55
  %59 = load double* %x, align 8, !tbaa !26
  %60 = fptrunc double %59 to float
  %61 = getelementptr inbounds [3 x float]* %5, i64 %54, i64 %indvars.iv19
  store float %60, float* %61, align 4, !tbaa !28
  br label %62

; <label>:62                                      ; preds = %55, %58
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %exitcond21 = icmp eq i64 %indvars.iv.next20, 3
  br i1 %exitcond21, label %63, label %55

; <label>:63                                      ; preds = %62
  %64 = load i32* %i, align 4, !tbaa !2
  %65 = add nsw i32 %64, 1
  store i32 %65, i32* %i, align 4, !tbaa !2
  %66 = icmp slt i32 %65, %nitem
  br i1 %66, label %53, label %decode_string.exit

; <label>:67                                      ; preds = %0
  %68 = bitcast i8* %item to i32*
  %69 = icmp eq i8* %item, null
  br label %70

; <label>:70                                      ; preds = %76, %67
  %indvars.iv22 = phi i64 [ 0, %67 ], [ %indvars.iv.next23, %76 ]
  %71 = call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %72 = call i32 (i8*, i8*, ...)* @sscanf(i8* %71, i8* getelementptr inbounds ([4 x i8]* @.str52, i64 0, i64 0), i32* %ix) #9
  br i1 %69, label %76, label %73

; <label>:73                                      ; preds = %70
  %74 = load i32* %ix, align 4, !tbaa !2
  %75 = getelementptr inbounds i32* %68, i64 %indvars.iv22
  store i32 %74, i32* %75, align 4, !tbaa !2
  br label %76

; <label>:76                                      ; preds = %70, %73
  %indvars.iv.next23 = add nuw nsw i64 %indvars.iv22, 1
  %exitcond24 = icmp eq i64 %indvars.iv.next23, 3
  br i1 %exitcond24, label %decode_string.exit, label %70

; <label>:77                                      ; preds = %0
  %78 = tail call fastcc i8* @next_item(%struct.__sFILE* %3) #10
  %79 = icmp eq i8* %item, null
  br i1 %79, label %decode_string.exit.thread, label %80

; <label>:80                                      ; preds = %77
  %81 = tail call i64 @strlen(i8* %78) #9
  %82 = add i64 %81, 1
  %83 = trunc i64 %82 to i32
  %84 = load i8* %78, align 1, !tbaa !14
  %85 = icmp ne i8 %84, 0
  %86 = icmp sgt i32 %83, 1
  %or.cond2.i = and i1 %85, %86
  br i1 %or.cond2.i, label %.lr.ph.i, label %.critedge.i

.lr.ph.i:                                         ; preds = %80
  %87 = shl i64 %82, 32
  %sext = add i64 %87, -4294967296
  %88 = ashr exact i64 %sext, 32
  br label %89

; <label>:89                                      ; preds = %89, %.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i, %89 ]
  %90 = phi i8 [ %84, %.lr.ph.i ], [ %94, %89 ]
  %91 = icmp eq i8 %90, 95
  %92 = getelementptr inbounds i8* %item, i64 %indvars.iv.i
  %..i = select i1 %91, i8 32, i8 %90
  store i8 %..i, i8* %92, align 1, !tbaa !14
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %93 = getelementptr inbounds i8* %78, i64 %indvars.iv.next.i
  %94 = load i8* %93, align 1, !tbaa !14
  %95 = icmp ne i8 %94, 0
  %96 = icmp slt i64 %indvars.iv.next.i, %88
  %or.cond.i = and i1 %96, %95
  br i1 %or.cond.i, label %89, label %..critedge_crit_edge.i

..critedge_crit_edge.i:                           ; preds = %89
  %97 = trunc i64 %indvars.iv.next.i to i32
  br label %.critedge.i

.critedge.i:                                      ; preds = %..critedge_crit_edge.i, %80
  %.lcssa.i = phi i64 [ %indvars.iv.next.i, %..critedge_crit_edge.i ], [ 0, %80 ]
  %i.0.lcssa.i = phi i32 [ %97, %..critedge_crit_edge.i ], [ 0, %80 ]
  %98 = getelementptr inbounds i8* %item, i64 %.lcssa.i
  store i8 0, i8* %98, align 1, !tbaa !14
  %99 = icmp eq i32 %i.0.lcssa.i, %83
  br i1 %99, label %100, label %decode_string.exit.thread5

; <label>:100                                     ; preds = %.critedge.i
  %101 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %102 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %101, i8* getelementptr inbounds ([31 x i8]* @.str55, i64 0, i64 0), i8* %78, i8* %item) #9
  br label %decode_string.exit.thread5

; <label>:103                                     ; preds = %0
  tail call fastcc void @fe(i32 %eio, i8* %desc, i32 388) #10
  br label %decode_string.exit.thread

decode_string.exit:                               ; preds = %76, %63, %47, %33, %9, %17, %37, %41, %21, %13
  %res.5 = phi i32 [ %39, %41 ], [ %39, %37 ], [ %19, %21 ], [ %19, %17 ], [ %11, %13 ], [ %11, %9 ], [ %26, %33 ], [ %49, %47 ], [ %57, %63 ], [ %72, %76 ]
  %104 = icmp slt i32 %res.5, 1
  br i1 %104, label %decode_string.exit.thread, label %decode_string.exit.thread5

decode_string.exit.thread:                        ; preds = %.preheader7, %.preheader, %77, %103, %decode_string.exit
  %res.53 = phi i32 [ %res.5, %decode_string.exit ], [ 0, %103 ], [ 0, %77 ], [ 0, %.preheader ], [ 0, %.preheader7 ]
  %105 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %106 = getelementptr inbounds %struct.t_fileio* %105, i64 0, i32 4
  %107 = load i32* %106, align 4, !tbaa !25
  %108 = icmp eq i32 %107, 0
  br i1 %108, label %decode_string.exit.thread5, label %109

; <label>:109                                     ; preds = %decode_string.exit.thread
  %110 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %111 = sext i32 %eio to i64
  %112 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %111
  %113 = load i8** %112, align 8, !tbaa !15
  %114 = getelementptr inbounds %struct.t_fileio* %105, i64 0, i32 6
  %115 = load i8** %114, align 8, !tbaa !19
  %116 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %110, i8* getelementptr inbounds ([55 x i8]* @.str53, i64 0, i64 0), i8* %113, i8* %desc, i8* %115, i8* %srcfile, i32 %line) #9
  br label %decode_string.exit.thread5

decode_string.exit.thread5:                       ; preds = %100, %.critedge.i, %decode_string.exit.thread, %109, %decode_string.exit
  %res.52 = phi i32 [ %res.53, %decode_string.exit.thread ], [ %res.53, %109 ], [ %res.5, %decode_string.exit ], [ 1, %.critedge.i ], [ 1, %100 ]
  %117 = icmp sgt i32 %res.52, 0
  %118 = zext i1 %117 to i32
  ret i32 %118
}

; Function Attrs: nounwind optsize ssp uwtable
define internal i32 @do_ascwrite(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
  %strbuf = alloca [256 x i8], align 16
  %1 = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %1) #8
  tail call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 213) #10
  switch i32 %eio, label %.thread [
    i32 0, label %10
    i32 1, label %19
    i32 2, label %.preheader
    i32 3, label %38
    i32 4, label %47
    i32 5, label %.preheader3
    i32 6, label %79
    i32 7, label %93
  ]

.preheader3:                                      ; preds = %0
  %2 = icmp sgt i32 %nitem, 0
  br i1 %2, label %.lr.ph7, label %.loopexit.thread

.lr.ph7:                                          ; preds = %.preheader3
  %3 = bitcast i8* %item to [3 x float]*
  %4 = add i32 %nitem, -1
  br label %64

.preheader:                                       ; preds = %0
  %5 = icmp sgt i32 %nitem, 0
  %6 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 0, i32 7
  %8 = load %struct.__sFILE** %7, align 8, !tbaa !22
  br i1 %5, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %9 = add i32 %nitem, -1
  br label %27

; <label>:10                                      ; preds = %0
  %11 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %12 = getelementptr inbounds %struct.t_fileio* %11, i64 0, i32 7
  %13 = load %struct.__sFILE** %12, align 8, !tbaa !22
  %14 = bitcast i8* %item to float*
  %15 = load float* %14, align 4, !tbaa !28
  %16 = fpext float %15 to double
  %17 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %18 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %13, i8* getelementptr inbounds ([11 x i8]* @.str56, i64 0, i64 0), double %16, i8* %17) #9
  br label %.loopexit

; <label>:19                                      ; preds = %0
  %20 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %21 = getelementptr inbounds %struct.t_fileio* %20, i64 0, i32 7
  %22 = load %struct.__sFILE** %21, align 8, !tbaa !22
  %23 = bitcast i8* %item to i32*
  %24 = load i32* %23, align 4, !tbaa !2
  %25 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %26 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %22, i8* getelementptr inbounds ([8 x i8]* @.str57, i64 0, i64 0), i32 %24, i8* %25) #9
  br label %.loopexit

; <label>:27                                      ; preds = %27, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %27 ]
  %28 = phi %struct.__sFILE* [ %8, %.lr.ph ], [ %35, %27 ]
  %29 = getelementptr inbounds i8* %item, i64 %indvars.iv
  %30 = load i8* %29, align 1, !tbaa !14
  %31 = zext i8 %30 to i32
  %32 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %28, i8* getelementptr inbounds ([4 x i8]* @.str58, i64 0, i64 0), i32 %31) #9
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %33 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %34 = getelementptr inbounds %struct.t_fileio* %33, i64 0, i32 7
  %35 = load %struct.__sFILE** %34, align 8, !tbaa !22
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %9
  br i1 %exitcond, label %._crit_edge, label %27

._crit_edge:                                      ; preds = %27, %.preheader
  %.lcssa = phi %struct.__sFILE* [ %8, %.preheader ], [ %35, %27 ]
  %res.0.lcssa = phi i32 [ 0, %.preheader ], [ %32, %27 ]
  %36 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %37 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %.lcssa, i8* getelementptr inbounds ([4 x i8]* @.str59, i64 0, i64 0), i8* %36) #9
  br label %.loopexit

; <label>:38                                      ; preds = %0
  %39 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %40 = getelementptr inbounds %struct.t_fileio* %39, i64 0, i32 7
  %41 = load %struct.__sFILE** %40, align 8, !tbaa !22
  %42 = bitcast i8* %item to i16*
  %43 = load i16* %42, align 2, !tbaa !30
  %44 = zext i16 %43 to i32
  %45 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %46 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %41, i8* getelementptr inbounds ([8 x i8]* @.str57, i64 0, i64 0), i32 %44, i8* %45) #9
  br label %.loopexit

; <label>:47                                      ; preds = %0
  %48 = bitcast i8* %item to float*
  %49 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %50 = getelementptr inbounds %struct.t_fileio* %49, i64 0, i32 7
  %51 = load %struct.__sFILE** %50, align 8, !tbaa !22
  %52 = load float* %48, align 4, !tbaa !28
  %53 = fpext float %52 to double
  %54 = getelementptr inbounds i8* %item, i64 4
  %55 = bitcast i8* %54 to float*
  %56 = load float* %55, align 4, !tbaa !28
  %57 = fpext float %56 to double
  %58 = getelementptr inbounds i8* %item, i64 8
  %59 = bitcast i8* %58 to float*
  %60 = load float* %59, align 4, !tbaa !28
  %61 = fpext float %60 to double
  %62 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %63 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %51, i8* getelementptr inbounds ([25 x i8]* @.str60, i64 0, i64 0), double %53, double %57, double %61, i8* %62) #9
  br label %.loopexit

; <label>:64                                      ; preds = %64, %.lr.ph7
  %indvars.iv12 = phi i64 [ 0, %.lr.ph7 ], [ %indvars.iv.next13, %64 ]
  %65 = getelementptr inbounds [3 x float]* %3, i64 %indvars.iv12, i64 0
  %66 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %67 = getelementptr inbounds %struct.t_fileio* %66, i64 0, i32 7
  %68 = load %struct.__sFILE** %67, align 8, !tbaa !22
  %69 = load float* %65, align 4, !tbaa !28
  %70 = fpext float %69 to double
  %71 = getelementptr inbounds [3 x float]* %3, i64 %indvars.iv12, i64 1
  %72 = load float* %71, align 4, !tbaa !28
  %73 = fpext float %72 to double
  %74 = getelementptr inbounds [3 x float]* %3, i64 %indvars.iv12, i64 2
  %75 = load float* %74, align 4, !tbaa !28
  %76 = fpext float %75 to double
  %77 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %78 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %68, i8* getelementptr inbounds ([25 x i8]* @.str60, i64 0, i64 0), double %70, double %73, double %76, i8* %77) #9
  %indvars.iv.next13 = add nuw nsw i64 %indvars.iv12, 1
  %lftr.wideiv14 = trunc i64 %indvars.iv12 to i32
  %exitcond15 = icmp eq i32 %lftr.wideiv14, %4
  br i1 %exitcond15, label %.loopexit, label %64

; <label>:79                                      ; preds = %0
  %80 = bitcast i8* %item to i32*
  %81 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %82 = getelementptr inbounds %struct.t_fileio* %81, i64 0, i32 7
  %83 = load %struct.__sFILE** %82, align 8, !tbaa !22
  %84 = load i32* %80, align 4, !tbaa !2
  %85 = getelementptr inbounds i8* %item, i64 4
  %86 = bitcast i8* %85 to i32*
  %87 = load i32* %86, align 4, !tbaa !2
  %88 = getelementptr inbounds i8* %item, i64 8
  %89 = bitcast i8* %88 to i32*
  %90 = load i32* %89, align 4, !tbaa !2
  %91 = tail call fastcc i8* @dbgstr(i8* %desc) #10
  %92 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %83, i8* getelementptr inbounds ([16 x i8]* @.str61, i64 0, i64 0), i32 %84, i32 %87, i32 %90, i8* %91) #9
  br label %.loopexit

; <label>:93                                      ; preds = %0
  %94 = load i8* %item, align 1, !tbaa !14
  %not.1.i = icmp eq i8 %94, 0
  br i1 %not.1.i, label %.thread.i, label %.lr.ph.i

.thread.i:                                        ; preds = %93
  store i8 0, i8* %1, align 16, !tbaa !14
  br label %encode_string.exit

.lr.ph.i:                                         ; preds = %93, %100
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %100 ], [ 0, %93 ]
  %95 = phi i8 [ %102, %100 ], [ %94, %93 ]
  switch i8 %95, label %98 [
    i8 32, label %96
    i8 9, label %96
  ]

; <label>:96                                      ; preds = %.lr.ph.i, %.lr.ph.i
  %97 = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 %indvars.iv.i
  store i8 95, i8* %97, align 1, !tbaa !14
  br label %100

; <label>:98                                      ; preds = %.lr.ph.i
  %99 = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 %indvars.iv.i
  store i8 %95, i8* %99, align 1, !tbaa !14
  br label %100

; <label>:100                                     ; preds = %98, %96
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %101 = getelementptr inbounds i8* %item, i64 %indvars.iv.next.i
  %102 = load i8* %101, align 1, !tbaa !14
  %103 = icmp slt i64 %indvars.iv.next.i, 255
  %not..i = icmp ne i8 %102, 0
  %..i = and i1 %103, %not..i
  br i1 %..i, label %.lr.ph.i, label %104

; <label>:104                                     ; preds = %100
  %105 = trunc i64 %indvars.iv.next.i to i32
  %phitmp.i = icmp eq i32 %105, 256
  %106 = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 %indvars.iv.next.i
  store i8 0, i8* %106, align 1, !tbaa !14
  br i1 %phitmp.i, label %107, label %encode_string.exit

; <label>:107                                     ; preds = %104
  %108 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %109 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %108, i8* getelementptr inbounds ([31 x i8]* @.str55, i64 0, i64 0), i8* %item, i8* %1) #9
  br label %encode_string.exit

encode_string.exit:                               ; preds = %.thread.i, %104, %107
  %110 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %111 = getelementptr inbounds %struct.t_fileio* %110, i64 0, i32 7
  %112 = load %struct.__sFILE** %111, align 8, !tbaa !22
  %113 = call fastcc i8* @dbgstr(i8* %desc) #10
  %114 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %112, i8* getelementptr inbounds ([9 x i8]* @.str62, i64 0, i64 0), i8* %1, i8* %113) #9
  br label %.loopexit

.thread:                                          ; preds = %0
  tail call fastcc void @fe(i32 %eio, i8* %desc, i32 253) #10
  br label %.loopexit.thread

.loopexit:                                        ; preds = %64, %encode_string.exit, %79, %47, %38, %._crit_edge, %19, %10
  %res.2 = phi i32 [ %114, %encode_string.exit ], [ %92, %79 ], [ %63, %47 ], [ %46, %38 ], [ %res.0.lcssa, %._crit_edge ], [ %26, %19 ], [ %18, %10 ], [ %78, %64 ]
  %115 = icmp slt i32 %res.2, 1
  br i1 %115, label %.loopexit.thread, label %128

.loopexit.thread:                                 ; preds = %.preheader3, %.thread, %.loopexit
  %res.22 = phi i32 [ 0, %.thread ], [ %res.2, %.loopexit ], [ 0, %.preheader3 ]
  %116 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %117 = getelementptr inbounds %struct.t_fileio* %116, i64 0, i32 4
  %118 = load i32* %117, align 4, !tbaa !25
  %119 = icmp eq i32 %118, 0
  br i1 %119, label %128, label %120

; <label>:120                                     ; preds = %.loopexit.thread
  %121 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %122 = sext i32 %eio to i64
  %123 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %122
  %124 = load i8** %123, align 8, !tbaa !15
  %125 = getelementptr inbounds %struct.t_fileio* %116, i64 0, i32 6
  %126 = load i8** %125, align 8, !tbaa !19
  %127 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %121, i8* getelementptr inbounds ([53 x i8]* @.str63, i64 0, i64 0), i8* %124, i8* %desc, i8* %126, i8* %srcfile, i32 %line) #9
  br label %128

; <label>:128                                     ; preds = %.loopexit.thread, %120, %.loopexit
  %res.21 = phi i32 [ %res.22, %.loopexit.thread ], [ %res.22, %120 ], [ %res.2, %.loopexit ]
  %129 = icmp sgt i32 %res.21, 0
  %130 = zext i1 %129 to i32
  call void @llvm.lifetime.end(i64 256, i8* %1) #8
  ret i32 %130
}

; Function Attrs: nounwind optsize ssp uwtable
define internal i32 @do_binread(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
  %ssize = alloca i32, align 4
  tail call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 450) #10
  switch i32 %eio, label %19 [
    i32 0, label %1
    i32 1, label %20
    i32 2, label %6
    i32 3, label %7
    i32 4, label %8
    i32 5, label %8
    i32 6, label %13
    i32 7, label %14
  ]

; <label>:1                                       ; preds = %0
  %2 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %3 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 3
  %4 = load i32* %3, align 4, !tbaa !24
  %5 = icmp eq i32 %4, 0
  %. = select i1 %5, i64 4, i64 8
  br label %20

; <label>:6                                       ; preds = %0
  br label %20

; <label>:7                                       ; preds = %0
  br label %20

; <label>:8                                       ; preds = %0, %0
  %9 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %10 = getelementptr inbounds %struct.t_fileio* %9, i64 0, i32 3
  %11 = load i32* %10, align 4, !tbaa !24
  %12 = icmp eq i32 %11, 0
  %.1 = select i1 %12, i64 12, i64 24
  br label %20

; <label>:13                                      ; preds = %0
  br label %20

; <label>:14                                      ; preds = %0
  %15 = bitcast i32* %ssize to i8*
  %16 = call i32 @do_binread(i8* %15, i32 1, i32 1, i8* %desc, i8* %srcfile, i32 %line) #10
  %17 = load i32* %ssize, align 4, !tbaa !2
  %18 = sext i32 %17 to i64
  br label %20

; <label>:19                                      ; preds = %0
  tail call fastcc void @fe(i32 %eio, i8* %desc, i32 482) #10
  br label %20

; <label>:20                                      ; preds = %8, %0, %1, %19, %14, %13, %7, %6
  %size.0 = phi i64 [ 0, %19 ], [ %18, %14 ], [ 12, %13 ], [ 2, %7 ], [ 1, %6 ], [ %., %1 ], [ 4, %0 ], [ %.1, %8 ]
  %21 = icmp eq i8* %item, null
  br i1 %21, label %.thread, label %28

.thread:                                          ; preds = %20
  %22 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %23 = getelementptr inbounds %struct.t_fileio* %22, i64 0, i32 7
  %24 = load %struct.__sFILE** %23, align 8, !tbaa !22
  %25 = sext i32 %nitem to i64
  %26 = mul i64 %size.0, %25
  %27 = call i32 @fseek(%struct.__sFILE* %24, i64 %26, i32 1) #9
  br label %48

; <label>:28                                      ; preds = %20
  %29 = sext i32 %nitem to i64
  %30 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %31 = getelementptr inbounds %struct.t_fileio* %30, i64 0, i32 7
  %32 = load %struct.__sFILE** %31, align 8, !tbaa !22
  %33 = call i64 @fread(i8* %item, i64 %size.0, i64 %29, %struct.__sFILE* %32) #9
  %34 = icmp eq i64 %33, %29
  br i1 %34, label %48, label %35

; <label>:35                                      ; preds = %28
  %36 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %37 = getelementptr inbounds %struct.t_fileio* %36, i64 0, i32 4
  %38 = load i32* %37, align 4, !tbaa !25
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %48, label %40

; <label>:40                                      ; preds = %35
  %41 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %42 = sext i32 %eio to i64
  %43 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %42
  %44 = load i8** %43, align 8, !tbaa !15
  %45 = getelementptr inbounds %struct.t_fileio* %36, i64 0, i32 6
  %46 = load i8** %45, align 8, !tbaa !19
  %47 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %41, i8* getelementptr inbounds ([55 x i8]* @.str53, i64 0, i64 0), i8* %44, i8* %desc, i8* %46, i8* %srcfile, i32 %line) #9
  br label %48

; <label>:48                                      ; preds = %.thread, %35, %28, %40
  %49 = phi i32 [ 1, %.thread ], [ 0, %35 ], [ 1, %28 ], [ 0, %40 ]
  ret i32 %49
}

; Function Attrs: nounwind optsize ssp uwtable
define internal i32 @do_binwrite(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
  %ssize = alloca i32, align 4
  tail call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 403) #10
  switch i32 %eio, label %13 [
    i32 0, label %14
    i32 1, label %14
    i32 2, label %1
    i32 3, label %2
    i32 4, label %3
    i32 5, label %4
    i32 6, label %5
    i32 7, label %6
  ]

; <label>:1                                       ; preds = %0
  br label %14

; <label>:2                                       ; preds = %0
  br label %14

; <label>:3                                       ; preds = %0
  br label %14

; <label>:4                                       ; preds = %0
  br label %14

; <label>:5                                       ; preds = %0
  br label %14

; <label>:6                                       ; preds = %0
  %7 = tail call i64 @strlen(i8* %item) #9
  %8 = add i64 %7, 1
  %9 = trunc i64 %8 to i32
  store i32 %9, i32* %ssize, align 4, !tbaa !2
  %sext = shl i64 %8, 32
  %10 = ashr exact i64 %sext, 32
  %11 = bitcast i32* %ssize to i8*
  %12 = call i32 @do_binwrite(i8* %11, i32 1, i32 1, i8* %desc, i8* %srcfile, i32 %line) #10
  br label %14

; <label>:13                                      ; preds = %0
  tail call fastcc void @fe(i32 %eio, i8* %desc, i32 431) #10
  br label %14

; <label>:14                                      ; preds = %0, %0, %13, %6, %5, %4, %3, %2, %1
  %size.0 = phi i64 [ 0, %13 ], [ %10, %6 ], [ 12, %5 ], [ 12, %4 ], [ 12, %3 ], [ 2, %2 ], [ 1, %1 ], [ 4, %0 ], [ 4, %0 ]
  %15 = sext i32 %nitem to i64
  %16 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %17 = getelementptr inbounds %struct.t_fileio* %16, i64 0, i32 7
  %18 = load %struct.__sFILE** %17, align 8, !tbaa !22
  %19 = call i64 @"\01_fwrite"(i8* %item, i64 %size.0, i64 %15, %struct.__sFILE* %18) #9
  %20 = icmp eq i64 %19, %15
  br i1 %20, label %38, label %21

; <label>:21                                      ; preds = %14
  %22 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %23 = getelementptr inbounds %struct.t_fileio* %22, i64 0, i32 4
  %24 = load i32* %23, align 4, !tbaa !25
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %38, label %26

; <label>:26                                      ; preds = %21
  %27 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %28 = sext i32 %eio to i64
  %29 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %28
  %30 = load i8** %29, align 8, !tbaa !15
  %31 = getelementptr inbounds %struct.t_fileio* %22, i64 0, i32 6
  %32 = load i8** %31, align 8, !tbaa !19
  %33 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %27, i8* getelementptr inbounds ([53 x i8]* @.str63, i64 0, i64 0), i8* %30, i8* %desc, i8* %32, i8* %srcfile, i32 %line) #9
  %34 = load %struct.__sFILE** @__stderrp, align 8, !tbaa !15
  %35 = trunc i64 %19 to i32
  %36 = trunc i64 %size.0 to i32
  %37 = call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %34, i8* getelementptr inbounds ([45 x i8]* @.str66, i64 0, i64 0), i32 %35, i32 %36) #9
  br label %38

; <label>:38                                      ; preds = %21, %14, %26
  %39 = zext i1 %20 to i32
  ret i32 %39
}

; Function Attrs: optsize
declare i8* @ftp2ext(i32) #2

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_setprecision(i32 %fio, i32 %bDouble) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 788) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 3
  store i32 %bDouble, i32* %7, align 4, !tbaa !24
  ret void
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @gmx_fio_getdebug(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 794) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 4
  %8 = load i32* %7, align 4, !tbaa !25
  ret i32 %8
}

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_setdebug(i32 %fio, i32 %bDebug) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 800) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 4
  store i32 %bDebug, i32* %7, align 4, !tbaa !25
  ret void
}

; Function Attrs: nounwind optsize ssp uwtable
define i8* @gmx_fio_getname(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 806) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %6 = getelementptr inbounds %struct.t_fileio* %5, i64 0, i32 6
  %7 = load i8** %6, align 8, !tbaa !19
  ret i8* %7
}

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_setftp(i32 %fio, i32 %ftp) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 812) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 0
  store i32 %ftp, i32* %7, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @gmx_fio_getftp(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 818) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 0
  %8 = load i32* %7, align 4, !tbaa !18
  ret i32 %8
}

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_rewind(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 824) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 8
  %8 = load %struct.XDR** %7, align 8, !tbaa !21
  %9 = icmp eq %struct.XDR* %8, null
  br i1 %9, label %22, label %10

; <label>:10                                      ; preds = %_gmx_fio_check.exit
  %11 = tail call i32 @xdrclose(%struct.XDR* %8) #9
  %12 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %13 = getelementptr inbounds %struct.t_fileio* %12, i64 %5, i32 8
  %14 = load %struct.XDR** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.t_fileio* %12, i64 %5, i32 6
  %16 = load i8** %15, align 8, !tbaa !19
  %17 = getelementptr inbounds %struct.t_fileio* %12, i64 %5, i32 2
  %18 = load i32* %17, align 4, !tbaa !23
  %19 = icmp ne i32 %18, 0
  %20 = select i1 %19, i8* getelementptr inbounds ([2 x i8]* @.str16, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8]* @.str17, i64 0, i64 0)
  %21 = tail call i32 @xdropen(%struct.XDR* %14, i8* %16, i8* %20) #9
  br label %25

; <label>:22                                      ; preds = %_gmx_fio_check.exit
  %23 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 7
  %24 = load %struct.__sFILE** %23, align 8, !tbaa !22
  tail call void @frewind(%struct.__sFILE* %24) #9
  br label %25

; <label>:25                                      ; preds = %22, %10
  ret void
}

; Function Attrs: optsize
declare void @frewind(%struct.__sFILE*) #2

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_flush(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 836) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 7
  %8 = load %struct.__sFILE** %7, align 8, !tbaa !22
  %9 = icmp eq %struct.__sFILE* %8, null
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %_gmx_fio_check.exit
  %11 = tail call i32 @fflush(%struct.__sFILE* %8) #9
  br label %12

; <label>:12                                      ; preds = %_gmx_fio_check.exit, %10
  ret void
}

; Function Attrs: nounwind optsize
declare i32 @fflush(%struct.__sFILE* nocapture) #6

; Function Attrs: nounwind optsize ssp uwtable
define i64 @gmx_fio_ftell(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 843) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 7
  %8 = load %struct.__sFILE** %7, align 8, !tbaa !22
  %9 = icmp eq %struct.__sFILE* %8, null
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %_gmx_fio_check.exit
  %11 = tail call i64 @ftell(%struct.__sFILE* %8) #9
  br label %12

; <label>:12                                      ; preds = %_gmx_fio_check.exit, %10
  %.0 = phi i64 [ %11, %10 ], [ 0, %_gmx_fio_check.exit ]
  ret i64 %.0
}

; Function Attrs: nounwind optsize
declare i64 @ftell(%struct.__sFILE* nocapture) #6

; Function Attrs: nounwind optsize ssp uwtable
define void @gmx_fio_seek(i32 %fio, i64 %fpos) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 852) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 7
  %8 = load %struct.__sFILE** %7, align 8, !tbaa !22
  %9 = icmp eq %struct.__sFILE* %8, null
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %_gmx_fio_check.exit
  %11 = tail call i32 @fseek(%struct.__sFILE* %8, i64 %fpos, i32 0) #9
  br label %15

; <label>:12                                      ; preds = %_gmx_fio_check.exit
  %13 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 6
  %14 = load i8** %13, align 8, !tbaa !19
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([24 x i8]* @.str30, i64 0, i64 0), i8* %14) #9
  br label %15

; <label>:15                                      ; preds = %12, %10
  ret void
}

; Function Attrs: nounwind optsize
declare i32 @fseek(%struct.__sFILE* nocapture, i64, i32) #6

; Function Attrs: nounwind optsize ssp uwtable
define %struct.__sFILE* @gmx_fio_getfp(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 865) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 7
  %8 = load %struct.__sFILE** %7, align 8, !tbaa !22
  ret %struct.__sFILE* %8
}

; Function Attrs: nounwind optsize ssp uwtable
define %struct.XDR* @gmx_fio_getxdr(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 874) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 8
  %8 = load %struct.XDR** %7, align 8, !tbaa !21
  ret %struct.XDR* %8
}

; Function Attrs: nounwind optsize ssp uwtable
define i32 @gmx_fio_getread(i32 %fio) #1 {
  %1 = icmp sgt i32 %fio, -1
  %2 = load i32* @nFIO, align 4
  %3 = icmp sgt i32 %2, %fio
  %or.cond.i = and i1 %1, %3
  br i1 %or.cond.i, label %_gmx_fio_check.exit, label %4

; <label>:4                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str32, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 883) #9
  br label %_gmx_fio_check.exit

_gmx_fio_check.exit:                              ; preds = %0, %4
  %5 = sext i32 %fio to i64
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !15
  %7 = getelementptr inbounds %struct.t_fileio* %6, i64 %5, i32 2
  %8 = load i32* %7, align 4, !tbaa !23
  ret i32 %8
}

; Function Attrs: nounwind optsize ssp uwtable
define internal fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 %line) #1 {
  %1 = icmp eq i32 %nitem, 1
  br i1 %1, label %6, label %switch.early.test

switch.early.test:                                ; preds = %0
  switch i32 %eio, label %2 [
    i32 5, label %6
    i32 2, label %6
  ]

; <label>:2                                       ; preds = %switch.early.test
  %3 = sext i32 %eio to i64
  %4 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %3
  %5 = load i8** %4, align 8, !tbaa !15
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([67 x i8]* @.str36, i64 0, i64 0), i32 %nitem, i8* getelementptr inbounds ([7 x i8]* @.str43, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8]* @.str46, i64 0, i64 0), i8* %5, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 %line) #9
  br label %6

; <label>:6                                       ; preds = %switch.early.test, %switch.early.test, %0, %2
  ret void
}

; Function Attrs: optsize
declare i32 @xdr_double(%struct.XDR*, double*) #2

; Function Attrs: optsize
declare i32 @xdr_float(%struct.XDR*, float*) #2

; Function Attrs: optsize
declare i32 @xdr_int(%struct.XDR*, i32*) #2

; Function Attrs: optsize
declare i32 @xdr_u_char(%struct.XDR*, i8*) #2

; Function Attrs: optsize
declare i32 @xdr_u_short(%struct.XDR*, i16*) #2

; Function Attrs: optsize
declare i32 @xdr_vector(%struct.XDR*, i8*, i32, i32, i32 (%struct.XDR*, i8*, ...)*) #2

; Function Attrs: nounwind optsize readonly
declare i64 @strlen(i8* nocapture) #7

; Function Attrs: optsize
declare i32 @xdr_string(%struct.XDR*, i8**, i32) #2

; Function Attrs: nounwind optsize ssp uwtable
define internal fastcc void @fe(i32 %eio, i8* %desc, i32 %line) #1 {
  %1 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %2 = getelementptr inbounds %struct.t_fileio* %1, i64 0, i32 2
  %3 = load i32* %2, align 4, !tbaa !23
  %4 = icmp ne i32 %3, 0
  %5 = select i1 %4, i8* getelementptr inbounds ([5 x i8]* @.str38, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8]* @.str39, i64 0, i64 0)
  %6 = icmp ult i32 %eio, 8
  br i1 %6, label %7, label %11

; <label>:7                                       ; preds = %0
  %8 = sext i32 %eio to i64
  %9 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %8
  %10 = load i8** %9, align 8, !tbaa !15
  br label %11

; <label>:11                                      ; preds = %0, %7
  %12 = phi i8* [ %10, %7 ], [ getelementptr inbounds ([8 x i8]* @.str40, i64 0, i64 0), %0 ]
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([46 x i8]* @.str37, i64 0, i64 0), i8* %5, i8* %desc, i32 %eio, i8* %12, i8* getelementptr inbounds ([66 x i8]* @.str15, i64 0, i64 0), i32 %line) #9
  ret void
}

; Function Attrs: nounwind optsize
declare i32 @fprintf(%struct.__sFILE* nocapture, i8* nocapture readonly, ...) #6

; Function Attrs: nounwind optsize
declare i32 @sscanf(i8* nocapture readonly, i8* nocapture readonly, ...) #6

; Function Attrs: nounwind optsize ssp uwtable
define internal fastcc i8* @next_item(%struct.__sFILE* %fp) #1 {
  %1 = load i32* @nbuf, align 4, !tbaa !2
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %.lr.ph11, label %tailrecurse._crit_edge

tailrecurse.loopexit:                             ; preds = %45, %45
  %3 = load i32* @nbuf, align 4, !tbaa !2
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %.lr.ph11, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse.loopexit, %0
  %5 = phi i32 [ %1, %0 ], [ %3, %tailrecurse.loopexit ]
  %6 = load i64* bitcast ([20 x i32]* @next_item.bufindex to i64*), align 16
  %7 = icmp sgt i32 %5, 1
  br i1 %7, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %tailrecurse._crit_edge
  %8 = lshr i64 %6, 32
  %9 = trunc i64 %8 to i32
  %10 = sext i32 %5 to i64
  store i32 %9, i32* getelementptr inbounds ([20 x i32]* @next_item.bufindex, i64 0, i64 0), align 16, !tbaa !2
  %11 = icmp sgt i32 %5, 2
  br i1 %11, label %._crit_edge20, label %._crit_edge

._crit_edge20:                                    ; preds = %.lr.ph, %._crit_edge20
  %indvars.iv.next27 = phi i64 [ %indvars.iv.next, %._crit_edge20 ], [ 2, %.lr.ph ]
  %.phi.trans.insert = getelementptr inbounds [20 x i32]* @next_item.bufindex, i64 0, i64 %indvars.iv.next27
  %.pre = load i32* %.phi.trans.insert, align 4, !tbaa !2
  %12 = add nsw i64 %indvars.iv.next27, -1
  %13 = getelementptr inbounds [20 x i32]* @next_item.bufindex, i64 0, i64 %12
  store i32 %.pre, i32* %13, align 4, !tbaa !2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv.next27, 1
  %14 = icmp slt i64 %indvars.iv.next, %10
  br i1 %14, label %._crit_edge20, label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph, %._crit_edge20, %tailrecurse._crit_edge
  %15 = add nsw i32 %5, -1
  store i32 %15, i32* @nbuf, align 4, !tbaa !2
  %sext = shl i64 %6, 32
  %16 = ashr exact i64 %sext, 32
  %17 = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %16
  ret i8* %17

.lr.ph11:                                         ; preds = %0, %tailrecurse.loopexit
  %18 = tail call i8* @fgets2(i8* getelementptr inbounds ([4096 x i8]* @next_item.buf, i64 0, i64 0), i32 4095, %struct.__sFILE* %fp) #9
  %19 = icmp eq i8* %18, null
  br i1 %19, label %20, label %.preheader

; <label>:20                                      ; preds = %.lr.ph11
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([12 x i8]* @.str54, i64 0, i64 0)) #9
  br label %.preheader

.preheader:                                       ; preds = %45, %28, %.lr.ph11, %20
  %i.1 = phi i32 [ 0, %20 ], [ 0, %.lr.ph11 ], [ %29, %28 ], [ %i.3, %45 ]
  %21 = sext i32 %i.1 to i64
  %22 = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %21
  %23 = load i8* %22, align 1, !tbaa !14
  switch i8 %23, label %24 [
    i8 0, label %.critedge1
    i8 59, label %.critedge1
  ]

; <label>:24                                      ; preds = %.preheader
  %25 = sext i8 %23 to i32
  %26 = tail call i32 @__istype(i32 %25, i64 16384) #9
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %.critedge1, label %28

; <label>:28                                      ; preds = %24
  %29 = add nsw i32 %i.1, 1
  br label %.preheader

.critedge1:                                       ; preds = %24, %.preheader, %.preheader, %33
  %indvars.iv18 = phi i64 [ %indvars.iv.next19, %33 ], [ %21, %.preheader ], [ %21, %.preheader ], [ %21, %24 ]
  %30 = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %indvars.iv18
  %31 = load i8* %30, align 1, !tbaa !14
  %32 = trunc i64 %indvars.iv18 to i32
  switch i8 %31, label %33 [
    i8 0, label %.critedge2
    i8 59, label %.critedge2
  ]

; <label>:33                                      ; preds = %.critedge1
  %34 = sext i8 %31 to i32
  %35 = tail call i32 @__istype(i32 %34, i64 16384) #9
  %36 = icmp eq i32 %35, 0
  %indvars.iv.next19 = add i64 %indvars.iv18, 1
  br i1 %36, label %.critedge1, label %.critedge2thread-pre-split

.critedge2thread-pre-split:                       ; preds = %33
  %.pr = load i8* %30, align 1, !tbaa !14
  br label %.critedge2

.critedge2:                                       ; preds = %.critedge1, %.critedge1, %.critedge2thread-pre-split
  %37 = phi i8 [ %.pr, %.critedge2thread-pre-split ], [ %31, %.critedge1 ], [ %31, %.critedge1 ]
  %38 = icmp sgt i32 %32, %i.1
  br i1 %38, label %39, label %45

; <label>:39                                      ; preds = %.critedge2
  store i8 0, i8* %30, align 1, !tbaa !14
  %40 = load i32* @nbuf, align 4, !tbaa !2
  %41 = add nsw i32 %40, 1
  store i32 %41, i32* @nbuf, align 4, !tbaa !2
  %42 = sext i32 %40 to i64
  %43 = getelementptr inbounds [20 x i32]* @next_item.bufindex, i64 0, i64 %42
  store i32 %i.1, i32* %43, align 4, !tbaa !2
  %44 = add nsw i32 %32, 1
  br label %45

; <label>:45                                      ; preds = %.critedge2, %39
  %i.3 = phi i32 [ %44, %39 ], [ %32, %.critedge2 ]
  switch i8 %37, label %.preheader [
    i8 0, label %tailrecurse.loopexit
    i8 59, label %tailrecurse.loopexit
  ]
}

; Function Attrs: optsize
declare i8* @fgets2(i8*, i32, %struct.__sFILE*) #2

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #8

; Function Attrs: nounwind optsize ssp uwtable
define internal fastcc i8* @dbgstr(i8* %desc) #1 {
  %1 = load %struct.t_fileio** @curfio, align 8, !tbaa !15
  %2 = getelementptr inbounds %struct.t_fileio* %1, i64 0, i32 4
  %3 = load i32* %2, align 4, !tbaa !25
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %10, label %5

; <label>:5                                       ; preds = %0
  %6 = load i8** @add_comment, align 8, !tbaa !15
  %7 = icmp ne i8* %6, null
  %8 = select i1 %7, i8* %6, i8* getelementptr inbounds ([1 x i8]* @.str64, i64 0, i64 0)
  %9 = tail call i32 (i8*, i32, i64, i8*, ...)* @__sprintf_chk(i8* getelementptr inbounds ([4096 x i8]* @dbgstr.buf, i64 0, i64 0), i32 0, i64 4096, i8* getelementptr inbounds ([10 x i8]* @.str65, i64 0, i64 0), i8* %8, i8* %desc) #9
  br label %10

; <label>:10                                      ; preds = %0, %5
  %.0 = phi i8* [ getelementptr inbounds ([4096 x i8]* @dbgstr.buf, i64 0, i64 0), %5 ], [ getelementptr inbounds ([1 x i8]* @.str64, i64 0, i64 0), %0 ]
  ret i8* %.0
}

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #8

; Function Attrs: optsize
declare i32 @__sprintf_chk(i8*, i32, i64, i8*, ...) #2

; Function Attrs: nounwind optsize
declare i64 @fread(i8* nocapture, i64, i64, %struct.__sFILE* nocapture) #6

; Function Attrs: optsize
declare i64 @"\01_fwrite"(i8*, i64, i64, %struct.__sFILE*) #2

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #8

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #8

attributes #0 = { nounwind optsize readnone ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind optsize ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { optsize "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind optsize readonly ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { alwaysinline nounwind optsize ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { alwaysinline nounwind optsize readnone ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind optsize "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind optsize readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "target-features"="+ssse3,+cx16,+sse,+sse2,+sse3" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind }
attributes #9 = { nounwind optsize }
attributes #10 = { optsize }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"PIC Level", i32 2}
!1 = !{!"Apple LLVM version 7.0.0 (clang-700.1.76)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !3, i64 12}
!7 = !{!"__sFILE", !8, i64 0, !3, i64 8, !3, i64 12, !9, i64 16, !9, i64 18, !10, i64 24, !3, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !8, i64 72, !8, i64 80, !10, i64 88, !8, i64 104, !3, i64 112, !4, i64 116, !4, i64 119, !10, i64 120, !3, i64 136, !11, i64 144}
!8 = !{!"any pointer", !4, i64 0}
!9 = !{!"short", !4, i64 0}
!10 = !{!"__sbuf", !8, i64 0, !3, i64 8}
!11 = !{!"long long", !4, i64 0}
!12 = !{!7, !3, i64 40}
!13 = !{!7, !8, i64 0}
!14 = !{!4, !4, i64 0}
!15 = !{!8, !8, i64 0}
!16 = !{!17, !3, i64 4}
!17 = !{!"", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !8, i64 24, !8, i64 32, !8, i64 40}
!18 = !{!17, !3, i64 0}
!19 = !{!17, !8, i64 24}
!20 = !{!17, !3, i64 20}
!21 = !{!17, !8, i64 40}
!22 = !{!17, !8, i64 32}
!23 = !{!17, !3, i64 8}
!24 = !{!17, !3, i64 12}
!25 = !{!17, !3, i64 16}
!26 = !{!27, !27, i64 0}
!27 = !{!"double", !4, i64 0}
!28 = !{!29, !29, i64 0}
!29 = !{!"float", !4, i64 0}
!30 = !{!9, !9, i64 0}
