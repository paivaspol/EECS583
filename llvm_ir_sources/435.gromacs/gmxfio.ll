; ModuleID = '../../SPEC/benchspec/CPU2006/435.gromacs/src/gmxfio.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.t_fileio = type { i32, i32, i32, i32, i32, i32, i8*, %struct._IO_FILE*, %struct.XDR* }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.XDR = type { i32, %struct.xdr_ops*, i8*, i8*, i8*, i32 }
%struct.xdr_ops = type { i32 (%struct.XDR*, i64*)*, i32 (%struct.XDR*, i64*)*, i32 (%struct.XDR*, i8*, i32)*, i32 (%struct.XDR*, i8*, i32)*, i32 (%struct.XDR*)*, i32 (%struct.XDR*, i32)*, i32* (%struct.XDR*, i32)*, void (%struct.XDR*)*, i32 (%struct.XDR*, i32*)*, i32 (%struct.XDR*, i32*)* }

@do_read = global i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, align 8
@do_write = global i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, align 8
@.str = private unnamed_addr constant [9 x i8] c"[header]\00", align 1
@.str1 = private unnamed_addr constant [11 x i8] c"[inputrec]\00", align 1
@.str2 = private unnamed_addr constant [6 x i8] c"[box]\00", align 1
@.str3 = private unnamed_addr constant [11 x i8] c"[topology]\00", align 1
@.str4 = private unnamed_addr constant [14 x i8] c"[coordinates]\00", align 1
@.str5 = private unnamed_addr constant [13 x i8] c"[velocities]\00", align 1
@.str6 = private unnamed_addr constant [9 x i8] c"[forces]\00", align 1
@itemstr = global [7 x i8*] [i8* getelementptr inbounds ([9 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str1, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str2, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8]* @.str3, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8]* @.str4, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8]* @.str5, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @.str6, i32 0, i32 0)], align 16
@.str7 = private unnamed_addr constant [359 x i8] c"; The header holds information on the number of atoms etc. and on whether\0A; certain items are present in the file or not.\0A; \0A;                             WARNING\0A;                   DO NOT EDIT THIS FILE BY HAND\0A; The GROMACS preprocessor performs a lot of checks on your input that\0A; you ignore when editing this. Your simulation may crash because of this\0A\00", align 1
@.str8 = private unnamed_addr constant [106 x i8] c"; The inputrec holds the parameters for MD such as the number of steps,\0A; the timestep and the cut-offs.\0A\00", align 1
@.str9 = private unnamed_addr constant [29 x i8] c"; The simulation box in nm.\0A\00", align 1
@.str10 = private unnamed_addr constant [150 x i8] c"; The topology section describes the topology of the molcecules\0A; i.e. bonds, angles and dihedrals etc. and also holds the force field\0A; parameters.\0A\00", align 1
@.str11 = private unnamed_addr constant [32 x i8] c"; The atomic coordinates in nm\0A\00", align 1
@.str12 = private unnamed_addr constant [34 x i8] c"; The atomic velocities in nm/ps\0A\00", align 1
@.str13 = private unnamed_addr constant [38 x i8] c"; The forces on the atoms in nm/ps^2\0A\00", align 1
@comment_str = global [7 x i8*] [i8* getelementptr inbounds ([359 x i8]* @.str7, i32 0, i32 0), i8* getelementptr inbounds ([106 x i8]* @.str8, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8]* @.str9, i32 0, i32 0), i8* getelementptr inbounds ([150 x i8]* @.str10, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8]* @.str11, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8]* @.str12, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8]* @.str13, i32 0, i32 0)], align 16
@add_comment = internal unnamed_addr global i8* null, align 8
@.str14 = private unnamed_addr constant [12 x i8] c"add_comment\00", align 1
@.str15 = private unnamed_addr constant [54 x i8] c"../../SPEC/benchspec/CPU2006/435.gromacs/src/gmxfio.c\00", align 1
@.str16 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str17 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str19 = private unnamed_addr constant [43 x i8] c"DEATH HORROR in gmx_fio_open, mode is '%s'\00", align 1
@.str20 = private unnamed_addr constant [6 x i8] c"ASCII\00", align 1
@nFIO = internal unnamed_addr global i32 0, align 4
@FIO = internal unnamed_addr global %struct.t_fileio* null, align 8
@.str22 = private unnamed_addr constant [4 x i8] c"FIO\00", align 1
@ftpXDR = internal global [4 x i32] [i32 26, i32 4, i32 9, i32 6], align 16
@.str23 = private unnamed_addr constant [18 x i8] c"File %s not found\00", align 1
@.str24 = private unnamed_addr constant [9 x i8] c"fio->xdr\00", align 1
@.str25 = private unnamed_addr constant [18 x i8] c"Could not open %s\00", align 1
@stdin = external global %struct._IO_FILE*
@stdout = external global %struct._IO_FILE*
@.str26 = private unnamed_addr constant [6 x i8] c"STDIO\00", align 1
@.str27 = private unnamed_addr constant [13 x i8] c"FIO[fio].xdr\00", align 1
@.str28 = private unnamed_addr constant [12 x i8] c"FIO[fio].fn\00", align 1
@ftpASC = internal global [3 x i32] [i32 27, i32 13, i32 15], align 4
@ftpBIN = internal global [4 x i32] [i32 28, i32 5, i32 39, i32 10], align 16
@.str29 = private unnamed_addr constant [46 x i8] c"Can not read/write topologies to file type %s\00", align 1
@curfio = internal unnamed_addr global %struct.t_fileio* null, align 8
@.str30 = private unnamed_addr constant [24 x i8] c"Can not seek on file %s\00", align 1
@stderr = external global %struct._IO_FILE*
@.str31 = private unnamed_addr constant [53 x i8] c"Error writing %s %s to file %s (source %s, line %d)\0A\00", align 1
@eioNames = internal unnamed_addr constant [8 x i8*] [i8* getelementptr inbounds ([5 x i8]* @.str33, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str34, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str36, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str37, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8]* @.str38, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str39, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str40, i32 0, i32 0)], align 16
@.str32 = private unnamed_addr constant [45 x i8] c"written size %u bytes, source size %u bytes\0A\00", align 1
@.str33 = private unnamed_addr constant [5 x i8] c"REAL\00", align 1
@.str34 = private unnamed_addr constant [4 x i8] c"INT\00", align 1
@.str35 = private unnamed_addr constant [7 x i8] c"NUCHAR\00", align 1
@.str36 = private unnamed_addr constant [7 x i8] c"USHORT\00", align 1
@.str37 = private unnamed_addr constant [5 x i8] c"RVEC\00", align 1
@.str38 = private unnamed_addr constant [6 x i8] c"NRVEC\00", align 1
@.str39 = private unnamed_addr constant [5 x i8] c"IVEC\00", align 1
@.str40 = private unnamed_addr constant [7 x i8] c"STRING\00", align 1
@.str41 = private unnamed_addr constant [46 x i8] c"Trying to %s %s type %d (%s), src %s, line %d\00", align 1
@.str42 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str43 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str44 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str45 = private unnamed_addr constant [67 x i8] c"nitem (%d) may differ from 1 only for %s or %s, not for %s(%s, %d)\00", align 1
@.str46 = private unnamed_addr constant [55 x i8] c"Error reading %s %s from file %s (source %s, line %d)\0A\00", align 1
@.str47 = private unnamed_addr constant [11 x i8] c"%18.10e%s\0A\00", align 1
@.str48 = private unnamed_addr constant [8 x i8] c"%18d%s\0A\00", align 1
@.str49 = private unnamed_addr constant [4 x i8] c"%4d\00", align 1
@.str50 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str51 = private unnamed_addr constant [25 x i8] c"%18.10e%18.10e%18.10e%s\0A\00", align 1
@.str52 = private unnamed_addr constant [16 x i8] c"%18d%18d%18d%s\0A\00", align 1
@.str53 = private unnamed_addr constant [9 x i8] c"%-18s%s\0A\00", align 1
@.str54 = private unnamed_addr constant [31 x i8] c"String '%s' truncated to '%s'\0A\00", align 1
@.str55 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@dbgstr.buf = internal global [4096 x i8] zeroinitializer, align 16
@.str56 = private unnamed_addr constant [10 x i8] c"  ; %s %s\00", align 1
@.str57 = private unnamed_addr constant [4 x i8] c"%lf\00", align 1
@.str58 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str59 = private unnamed_addr constant [5 x i8] c"%lf\0A\00", align 1
@.str60 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@next_item.buf = internal global [4096 x i8] zeroinitializer, align 16
@next_item.bufindex = internal unnamed_addr global [20 x i32] zeroinitializer, align 16
@nbuf = internal unnamed_addr global i32 0, align 4
@.str61 = private unnamed_addr constant [12 x i8] c"End of file\00", align 1
@.str62 = private unnamed_addr constant [58 x i8] c"wrong string length %d for string %s (source %s, line %d)\00", align 1
@.str63 = private unnamed_addr constant [5 x i8] c"cptr\00", align 1
@.str64 = private unnamed_addr constant [56 x i8] c"Error in xdr I/O %s %s to file %s (source %s, line %d)\0A\00", align 1
@.str65 = private unnamed_addr constant [50 x i8] c"Trying to access non-open file %d, in %s, line %d\00", align 1
@.str66 = private unnamed_addr constant [27 x i8] c"gmx_fio_select not called!\00", align 1

; Function Attrs: nounwind optsize readonly uwtable
define i32 @in_ftpset(i32 %ftp, i32 %nset, i32* nocapture %set) #0 {
entry:
  %cmp4 = icmp sgt i32 %nset, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %bResult.06 = phi i32 [ %.bResult.0, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i32* %set, i64 %indvars.iv
  %0 = load i32* %arrayidx, align 4, !tbaa !0
  %cmp1 = icmp eq i32 %0, %ftp
  %.bResult.0 = select i1 %cmp1, i32 1, i32 %bResult.06
  %indvars.iv.next = add i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %nset
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %bResult.0.lcssa = phi i32 [ 0, %entry ], [ %.bResult.0, %for.body ]
  ret i32 %bResult.0.lcssa
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @do_dummy(i8* nocapture %item, i32 %nitem, i32 %eio, i8* nocapture %desc, i8* nocapture %srcfile, i32 %line) #1 {
entry:
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([27 x i8]* @.str66, i64 0, i64 0)) #7
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define void @set_comment(i8* %comment) #1 {
entry:
  %tobool = icmp eq i8* %comment, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i8* @gmx_strdup(i8* %comment) #7
  store i8* %call, i8** @add_comment, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: optsize
declare i8* @gmx_strdup(i8*) #2

; Function Attrs: nounwind optsize uwtable
define void @unset_comment() #1 {
entry:
  %0 = load i8** @add_comment, align 8, !tbaa !3
  %tobool = icmp eq i8* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @save_free(i8* getelementptr inbounds ([12 x i8]* @.str14, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 147, i8* %0) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  store i8* null, i8** @add_comment, align 8, !tbaa !3
  ret void
}

; Function Attrs: optsize
declare void @save_free(i8*, i8*, i32, i8*) #2

; Function Attrs: nounwind optsize uwtable
define i32 @gmx_fio_open(i8* %fn, i8* %mode) #1 {
entry:
  %newmode = alloca [5 x i8], align 2
  %call = call i32 @fn2ftp(i8* %fn) #7
  %cmp = icmp eq i32 %call, 27
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [5 x i8]* %newmode, i64 0, i64 0
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* %mode) #7
  br label %if.end26

if.else:                                          ; preds = %entry
  %0 = load i8* %mode, align 1, !tbaa !1
  switch i8 %0, label %if.else23 [
    i8 114, label %if.then4
    i8 119, label %if.then12
    i8 97, label %if.then20
  ]

if.then4:                                         ; preds = %if.else
  %1 = bitcast [5 x i8]* %newmode to i16*
  store i16 114, i16* %1, align 2
  br label %if.end26

if.then12:                                        ; preds = %if.else
  %2 = bitcast [5 x i8]* %newmode to i16*
  store i16 119, i16* %2, align 2
  br label %if.end26

if.then20:                                        ; preds = %if.else
  %3 = bitcast [5 x i8]* %newmode to i16*
  store i16 97, i16* %3, align 2
  br label %if.end26

if.else23:                                        ; preds = %if.else
  call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([43 x i8]* @.str19, i64 0, i64 0), i8* %mode) #7
  br label %if.end26

if.end26:                                         ; preds = %if.then4, %if.then20, %if.else23, %if.then12, %if.then
  %call27 = call i32 @fn2ftp(i8* %fn) #7
  %call28 = call i8* @ftp2ftype(i32 %call27) #7
  %call29 = call i32 @strncmp(i8* %call28, i8* getelementptr inbounds ([6 x i8]* @.str20, i64 0, i64 0), i64 5) #8
  %tobool = icmp eq i32 %call29, 0
  br i1 %tobool, label %for.cond.preheader, label %if.then30

if.then30:                                        ; preds = %if.end26
  %arraydecay31 = getelementptr inbounds [5 x i8]* %newmode, i64 0, i64 0
  %call32 = call i8* @strchr(i8* %arraydecay31, i32 98) #8
  %cmp33 = icmp eq i8* %call32, null
  br i1 %cmp33, label %land.lhs.true, label %for.cond.preheader

land.lhs.true:                                    ; preds = %if.then30
  %call36 = call i8* @strchr(i8* %arraydecay31, i32 66) #8
  %cmp37 = icmp eq i8* %call36, null
  br i1 %cmp37, label %if.then39, label %for.cond.preheader

if.then39:                                        ; preds = %land.lhs.true
  %strlen = call i64 @strlen(i8* %arraydecay31)
  %endptr = getelementptr [5 x i8]* %newmode, i64 0, i64 %strlen
  %4 = bitcast i8* %endptr to i16*
  store i16 98, i16* %4, align 1
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end26, %if.then30, %land.lhs.true, %if.then39
  %5 = load i32* @nFIO, align 4, !tbaa !0
  %cmp44146 = icmp sgt i32 %5, 0
  br i1 %cmp44146, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %6 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  br label %for.body

for.cond:                                         ; preds = %for.body
  %7 = trunc i64 %indvars.iv.next to i32
  %cmp44 = icmp slt i32 %7, %5
  br i1 %cmp44, label %for.body, label %for.end

for.body:                                         ; preds = %for.body.lr.ph, %for.cond
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.cond ]
  %i.0147 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.cond ]
  %bOpen = getelementptr inbounds %struct.t_fileio* %6, i64 %indvars.iv, i32 1
  %8 = load i32* %bOpen, align 4, !tbaa !0
  %tobool47 = icmp eq i32 %8, 0
  %indvars.iv.next = add i64 %indvars.iv, 1
  %inc = add nsw i32 %i.0147, 1
  br i1 %tobool47, label %if.then48, label %for.cond

if.then48:                                        ; preds = %for.body
  %arrayidx46 = getelementptr inbounds %struct.t_fileio* %6, i64 %indvars.iv
  br label %for.end

for.end:                                          ; preds = %for.cond.preheader, %for.cond, %if.then48
  %i.0145 = phi i32 [ %i.0147, %if.then48 ], [ 0, %for.cond.preheader ], [ %inc, %for.cond ]
  %nfio.0 = phi i32 [ %i.0147, %if.then48 ], [ 0, %for.cond.preheader ], [ 0, %for.cond ]
  %fio.0 = phi %struct.t_fileio* [ %arrayidx46, %if.then48 ], [ null, %for.cond.preheader ], [ null, %for.cond ]
  %cmp52 = icmp eq i32 %i.0145, %5
  br i1 %cmp52, label %if.then54, label %if.end62

if.then54:                                        ; preds = %for.end
  %inc55 = add nsw i32 %5, 1
  store i32 %inc55, i32* @nFIO, align 4, !tbaa !0
  %9 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %10 = bitcast %struct.t_fileio* %9 to i8*
  %mul = mul i32 %inc55, 48
  %call58 = call i8* @save_realloc(i8* getelementptr inbounds ([4 x i8]* @.str22, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 676, i8* %10, i32 %mul) #7
  %11 = bitcast i8* %call58 to %struct.t_fileio*
  store %struct.t_fileio* %11, %struct.t_fileio** @FIO, align 8, !tbaa !3
  %12 = load i32* @nFIO, align 4, !tbaa !0
  %sub = add nsw i32 %12, -1
  %idxprom59 = sext i32 %sub to i64
  %arrayidx60 = getelementptr inbounds %struct.t_fileio* %11, i64 %idxprom59
  br label %if.end62

if.end62:                                         ; preds = %if.then54, %for.end
  %nfio.1 = phi i32 [ %sub, %if.then54 ], [ %nfio.0, %for.end ]
  %fio.1 = phi %struct.t_fileio* [ %arrayidx60, %if.then54 ], [ %fio.0, %for.end ]
  %arrayidx63 = getelementptr inbounds [5 x i8]* %newmode, i64 0, i64 0
  %13 = load i8* %arrayidx63, align 2, !tbaa !1
  %cmp65 = icmp eq i8 %13, 114
  %conv66 = zext i1 %cmp65 to i32
  %fp = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 7
  %xdr = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 8
  %tobool67 = icmp eq i8* %fn, null
  %14 = bitcast %struct._IO_FILE** %fp to i8*
  call void @llvm.memset.p0i8.i64(i8* %14, i8 0, i64 16, i32 8, i1 false)
  br i1 %tobool67, label %if.else100, label %if.then68

if.then68:                                        ; preds = %if.end62
  %call69 = call i32 @fn2ftp(i8* %fn) #7
  %iFTP = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 0
  store i32 %call69, i32* %iFTP, align 4, !tbaa !0
  %call70 = call i8* @gmx_strdup(i8* %fn) #7
  %fn71 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 6
  store i8* %call70, i8** %fn71, align 8, !tbaa !3
  %bStdio = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 5
  store i32 0, i32* %bStdio, align 4, !tbaa !0
  %15 = load i32* %iFTP, align 4, !tbaa !0
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.then68
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %if.then68 ]
  %bResult.06.i = phi i32 [ %.bResult.0.i, %for.body.i ], [ 0, %if.then68 ]
  %arrayidx.i = getelementptr inbounds [4 x i32]* @ftpXDR, i64 0, i64 %indvars.iv.i
  %16 = load i32* %arrayidx.i, align 4, !tbaa !0
  %cmp1.i = icmp eq i32 %16, %15
  %.bResult.0.i = select i1 %cmp1.i, i32 1, i32 %bResult.06.i
  %indvars.iv.next.i = add i64 %indvars.iv.i, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next.i to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 4
  br i1 %exitcond, label %in_ftpset.exit, label %for.body.i

in_ftpset.exit:                                   ; preds = %for.body.i
  %tobool74 = icmp eq i32 %.bResult.0.i, 0
  br i1 %tobool74, label %if.else95, label %if.then75

if.then75:                                        ; preds = %in_ftpset.exit
  %17 = load i8* %arrayidx63, align 2, !tbaa !1
  %cmp78 = icmp eq i8 %17, 119
  br i1 %cmp78, label %if.end86, label %if.else81

if.else81:                                        ; preds = %if.then75
  %call82 = call i32 @fexist(i8* %fn) #7
  %tobool83 = icmp eq i32 %call82, 0
  br i1 %tobool83, label %if.then84, label %if.end86

if.then84:                                        ; preds = %if.else81
  call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([18 x i8]* @.str23, i64 0, i64 0), i8* %fn) #7
  br label %if.end86

if.end86:                                         ; preds = %if.else81, %if.then84, %if.then75
  %call87 = call i8* @save_calloc(i8* getelementptr inbounds ([9 x i8]* @.str24, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 711, i32 1, i32 48) #7
  %18 = bitcast i8* %call87 to %struct.XDR*
  store %struct.XDR* %18, %struct.XDR** %xdr, align 8, !tbaa !3
  %call91 = call i32 @xdropen(%struct.XDR* %18, i8* %fn, i8* %arrayidx63) #7
  %tobool92 = icmp eq i32 %call91, 0
  br i1 %tobool92, label %if.then93, label %if.end107

if.then93:                                        ; preds = %if.end86
  call void (i32, i8*, ...)* @fatal_error(i32 -1, i8* getelementptr inbounds ([18 x i8]* @.str25, i64 0, i64 0), i8* %fn) #7
  br label %if.end107

if.else95:                                        ; preds = %in_ftpset.exit
  %call97 = call %struct._IO_FILE* @ffopen(i8* %fn, i8* %arrayidx63) #7
  store %struct._IO_FILE* %call97, %struct._IO_FILE** %fp, align 8, !tbaa !3
  br label %if.end107

if.else100:                                       ; preds = %if.end62
  %iFTP101 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 0
  store i32 27, i32* %iFTP101, align 4, !tbaa !0
  %19 = load %struct._IO_FILE** @stdin, align 8, !tbaa !3
  %20 = load %struct._IO_FILE** @stdout, align 8, !tbaa !3
  %cond = select i1 %cmp65, %struct._IO_FILE* %19, %struct._IO_FILE* %20
  store %struct._IO_FILE* %cond, %struct._IO_FILE** %fp, align 8, !tbaa !3
  %call104 = call i8* @gmx_strdup(i8* getelementptr inbounds ([6 x i8]* @.str26, i64 0, i64 0)) #7
  %fn105 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 6
  store i8* %call104, i8** %fn105, align 8, !tbaa !3
  %bStdio106 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 5
  store i32 1, i32* %bStdio106, align 4, !tbaa !0
  br label %if.end107

if.end107:                                        ; preds = %if.end86, %if.else95, %if.then93, %if.else100
  %bRead108 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 2
  store i32 %conv66, i32* %bRead108, align 4, !tbaa !0
  %bDouble = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 3
  store i32 0, i32* %bDouble, align 4, !tbaa !0
  %bDebug = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 4
  store i32 0, i32* %bDebug, align 4, !tbaa !0
  %bOpen109 = getelementptr inbounds %struct.t_fileio* %fio.1, i64 0, i32 1
  store i32 1, i32* %bOpen109, align 4, !tbaa !0
  ret i32 %nfio.1
}

; Function Attrs: optsize
declare i32 @fn2ftp(i8*) #2

; Function Attrs: nounwind optsize
declare i8* @strcpy(i8*, i8* nocapture) #3

; Function Attrs: optsize
declare void @fatal_error(i32, i8*, ...) #2

; Function Attrs: nounwind optsize readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) #4

; Function Attrs: optsize
declare i8* @ftp2ftype(i32) #2

; Function Attrs: nounwind optsize readonly
declare i8* @strchr(i8*, i32) #4

; Function Attrs: optsize
declare i8* @save_realloc(i8*, i8*, i32, i8*, i32) #2

; Function Attrs: optsize
declare i32 @fexist(i8*) #2

; Function Attrs: optsize
declare i8* @save_calloc(i8*, i8*, i32, i32, i32) #2

; Function Attrs: optsize
declare i32 @xdropen(%struct.XDR*, i8*, i8*) #2

; Function Attrs: optsize
declare %struct._IO_FILE* @ffopen(i8*, i8*) #2

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_close(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 737) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %iFTP = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 0
  %1 = load i32* %iFTP, align 4, !tbaa !0
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %entry
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %entry ]
  %bResult.06.i = phi i32 [ %.bResult.0.i, %for.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds [4 x i32]* @ftpXDR, i64 0, i64 %indvars.iv.i
  %2 = load i32* %arrayidx.i, align 4, !tbaa !0
  %cmp1.i = icmp eq i32 %2, %1
  %.bResult.0.i = select i1 %cmp1.i, i32 1, i32 %bResult.06.i
  %indvars.iv.next.i = add i64 %indvars.iv.i, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next.i to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 4
  br i1 %exitcond, label %in_ftpset.exit, label %for.body.i

in_ftpset.exit:                                   ; preds = %for.body.i
  %tobool = icmp eq i32 %.bResult.0.i, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %in_ftpset.exit
  %xdr = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 8
  %3 = load %struct.XDR** %xdr, align 8, !tbaa !3
  %call3 = tail call i32 @xdrclose(%struct.XDR* %3) #7
  %4 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %xdr6 = getelementptr inbounds %struct.t_fileio* %4, i64 %idxprom, i32 8
  %5 = load %struct.XDR** %xdr6, align 8, !tbaa !3
  %6 = bitcast %struct.XDR* %5 to i8*
  tail call void @save_free(i8* getelementptr inbounds ([13 x i8]* @.str27, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 741, i8* %6) #7
  br label %if.end13

if.else:                                          ; preds = %in_ftpset.exit
  %bStdio = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 5
  %7 = load i32* %bStdio, align 4, !tbaa !0
  %tobool9 = icmp eq i32 %7, 0
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.else
  %fp = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 7
  %8 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  tail call void @ffclose(%struct._IO_FILE* %8) #7
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then10, %if.then
  %9 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %9, i64 %idxprom, i32 6
  %10 = load i8** %fn, align 8, !tbaa !3
  tail call void @save_free(i8* getelementptr inbounds ([12 x i8]* @.str28, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 749, i8* %10) #7
  %11 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %bOpen = getelementptr inbounds %struct.t_fileio* %11, i64 %idxprom, i32 1
  store i32 0, i32* %bOpen, align 4, !tbaa !0
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !3
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_dummy, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @_gmx_fio_check(i32 %fio, i32 %line) #1 {
entry:
  %cmp = icmp sgt i32 %fio, -1
  %0 = load i32* @nFIO, align 4, !tbaa !0
  %cmp1 = icmp sgt i32 %0, %fio
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([50 x i8]* @.str65, i64 0, i64 0), i32 %fio, i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 %line) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: optsize
declare i32 @xdrclose(%struct.XDR*) #2

; Function Attrs: optsize
declare void @ffclose(%struct._IO_FILE*) #2

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_select(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 757) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %iFTP = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 0
  %1 = load i32* %iFTP, align 4, !tbaa !0
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %entry
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %entry ]
  %bResult.06.i = phi i32 [ %.bResult.0.i, %for.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds [4 x i32]* @ftpXDR, i64 0, i64 %indvars.iv.i
  %2 = load i32* %arrayidx.i, align 4, !tbaa !0
  %cmp1.i = icmp eq i32 %2, %1
  %.bResult.0.i = select i1 %cmp1.i, i32 1, i32 %bResult.06.i
  %indvars.iv.next.i = add i64 %indvars.iv.i, 1
  %lftr.wideiv47 = trunc i64 %indvars.iv.next.i to i32
  %exitcond48 = icmp eq i32 %lftr.wideiv47, 4
  br i1 %exitcond48, label %in_ftpset.exit, label %for.body.i

in_ftpset.exit:                                   ; preds = %for.body.i
  %tobool = icmp eq i32 %.bResult.0.i, 0
  br i1 %tobool, label %for.body.i43, label %if.then

if.then:                                          ; preds = %in_ftpset.exit
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_xdr, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !3
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_xdr, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !3
  br label %if.end18

for.body.i43:                                     ; preds = %in_ftpset.exit, %for.body.i43
  %indvars.iv.i35 = phi i64 [ %indvars.iv.next.i40, %for.body.i43 ], [ 0, %in_ftpset.exit ]
  %bResult.06.i36 = phi i32 [ %.bResult.0.i39, %for.body.i43 ], [ 0, %in_ftpset.exit ]
  %arrayidx.i37 = getelementptr inbounds [3 x i32]* @ftpASC, i64 0, i64 %indvars.iv.i35
  %3 = load i32* %arrayidx.i37, align 4, !tbaa !0
  %cmp1.i38 = icmp eq i32 %3, %1
  %.bResult.0.i39 = select i1 %cmp1.i38, i32 1, i32 %bResult.06.i36
  %indvars.iv.next.i40 = add i64 %indvars.iv.i35, 1
  %lftr.wideiv45 = trunc i64 %indvars.iv.next.i40 to i32
  %exitcond46 = icmp eq i32 %lftr.wideiv45, 3
  br i1 %exitcond46, label %in_ftpset.exit44, label %for.body.i43

in_ftpset.exit44:                                 ; preds = %for.body.i43
  %tobool5 = icmp eq i32 %.bResult.0.i39, 0
  br i1 %tobool5, label %for.body.i33, label %if.then6

if.then6:                                         ; preds = %in_ftpset.exit44
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_ascread, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !3
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_ascwrite, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !3
  br label %if.end18

for.body.i33:                                     ; preds = %in_ftpset.exit44, %for.body.i33
  %indvars.iv.i25 = phi i64 [ %indvars.iv.next.i30, %for.body.i33 ], [ 0, %in_ftpset.exit44 ]
  %bResult.06.i26 = phi i32 [ %.bResult.0.i29, %for.body.i33 ], [ 0, %in_ftpset.exit44 ]
  %arrayidx.i27 = getelementptr inbounds [4 x i32]* @ftpBIN, i64 0, i64 %indvars.iv.i25
  %4 = load i32* %arrayidx.i27, align 4, !tbaa !0
  %cmp1.i28 = icmp eq i32 %4, %1
  %.bResult.0.i29 = select i1 %cmp1.i28, i32 1, i32 %bResult.06.i26
  %indvars.iv.next.i30 = add i64 %indvars.iv.i25, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next.i30 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 4
  br i1 %exitcond, label %in_ftpset.exit34, label %for.body.i33

in_ftpset.exit34:                                 ; preds = %for.body.i33
  %tobool12 = icmp eq i32 %.bResult.0.i29, 0
  br i1 %tobool12, label %if.else14, label %if.then13

if.then13:                                        ; preds = %in_ftpset.exit34
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_binread, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_read, align 8, !tbaa !3
  store i32 (i8*, i32, i32, i8*, i8*, i32)* @do_binwrite, i32 (i8*, i32, i32, i8*, i8*, i32)** @do_write, align 8, !tbaa !3
  br label %if.end18

if.else14:                                        ; preds = %in_ftpset.exit34
  %5 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %iFTP15 = getelementptr inbounds %struct.t_fileio* %5, i64 0, i32 0
  %6 = load i32* %iFTP15, align 4, !tbaa !0
  %call16 = tail call i8* @ftp2ext(i32 %6) #7
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([46 x i8]* @.str29, i64 0, i64 0), i8* %call16) #7
  %.pre = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  br label %if.end18

if.end18:                                         ; preds = %if.then6, %if.else14, %if.then13, %if.then
  %7 = phi %struct.t_fileio* [ %0, %if.then6 ], [ %.pre, %if.else14 ], [ %0, %if.then13 ], [ %0, %if.then ]
  %arrayidx20 = getelementptr inbounds %struct.t_fileio* %7, i64 %idxprom
  store %struct.t_fileio* %arrayidx20, %struct.t_fileio** @curfio, align 8, !tbaa !3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @do_xdr(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
entry:
  %fvec = alloca [3 x float], align 4
  %0 = bitcast [3 x float]* %fvec to i8*
  %dvec = alloca [3 x double], align 16
  %idum = alloca i32, align 4
  %us = alloca i16, align 2
  %d = alloca double, align 8
  %f = alloca float, align 4
  %cptr = alloca i8*, align 8
  %slen = alloca i32, align 4
  store double 0.000000e+00, double* %d, align 8, !tbaa !4
  store float 0.000000e+00, float* %f, align 4, !tbaa !5
  call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 516) #9
  switch i32 %eio, label %sw.epilog.thread [
    i32 0, label %sw.bb
    i32 1, label %sw.bb20
    i32 2, label %for.cond.preheader
    i32 3, label %sw.bb37
    i32 4, label %sw.bb49
    i32 5, label %for.cond125.preheader
    i32 6, label %sw.bb142
    i32 7, label %sw.bb168
  ]

for.cond125.preheader:                            ; preds = %entry
  %cmp126308 = icmp slt i32 %nitem, 1
  br i1 %cmp126308, label %if.end214, label %for.body131.lr.ph

for.body131.lr.ph:                                ; preds = %for.cond125.preheader
  %tobool132 = icmp eq i8* %item, null
  %1 = bitcast i8* %item to [3 x float]*
  br label %for.body131

for.cond.preheader:                               ; preds = %entry
  %cmp299 = icmp slt i32 %nitem, 1
  br i1 %cmp299, label %if.end214, label %for.body

sw.bb:                                            ; preds = %entry
  %2 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDouble = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 3
  %3 = load i32* %bDouble, align 4, !tbaa !0
  %tobool = icmp eq i32 %3, 0
  %tobool1 = icmp ne i8* %item, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %sw.bb
  br i1 %tobool1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %bRead = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 2
  %4 = load i32* %bRead, align 4, !tbaa !0
  %tobool2 = icmp eq i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.then5

if.then3:                                         ; preds = %land.lhs.true
  %5 = bitcast i8* %item to float*
  %6 = load float* %5, align 4, !tbaa !5
  %conv = fpext float %6 to double
  store double %conv, double* %d, align 8, !tbaa !4
  br label %if.then5

if.end:                                           ; preds = %if.then
  %xdr = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 8
  %7 = load %struct.XDR** %xdr, align 8, !tbaa !3
  %call = call i32 @xdr_double(%struct.XDR* %7, double* %d) #7
  br label %sw.epilog

if.then5:                                         ; preds = %land.lhs.true, %if.then3
  %xdr331 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 8
  %8 = load %struct.XDR** %xdr331, align 8, !tbaa !3
  %call332 = call i32 @xdr_double(%struct.XDR* %8, double* %d) #7
  %9 = load double* %d, align 8, !tbaa !4
  %conv6 = fptrunc double %9 to float
  %10 = bitcast i8* %item to float*
  store float %conv6, float* %10, align 4, !tbaa !5
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  br i1 %tobool1, label %land.lhs.true9, label %if.end13

land.lhs.true9:                                   ; preds = %if.else
  %bRead10 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 2
  %11 = load i32* %bRead10, align 4, !tbaa !0
  %tobool11 = icmp eq i32 %11, 0
  br i1 %tobool11, label %if.then12, label %if.then17

if.then12:                                        ; preds = %land.lhs.true9
  %12 = bitcast i8* %item to float*
  %13 = load float* %12, align 4, !tbaa !5
  store float %13, float* %f, align 4, !tbaa !5
  br label %if.then17

if.end13:                                         ; preds = %if.else
  %xdr14 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 8
  %14 = load %struct.XDR** %xdr14, align 8, !tbaa !3
  %call15 = call i32 @xdr_float(%struct.XDR* %14, float* %f) #7
  br label %sw.epilog

if.then17:                                        ; preds = %land.lhs.true9, %if.then12
  %xdr14334 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 8
  %15 = load %struct.XDR** %xdr14334, align 8, !tbaa !3
  %call15335 = call i32 @xdr_float(%struct.XDR* %15, float* %f) #7
  %16 = load float* %f, align 4, !tbaa !5
  %17 = bitcast i8* %item to float*
  store float %16, float* %17, align 4, !tbaa !5
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %tobool21 = icmp eq i8* %item, null
  %18 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  br i1 %tobool21, label %if.end26, label %land.lhs.true22

land.lhs.true22:                                  ; preds = %sw.bb20
  %bRead23 = getelementptr inbounds %struct.t_fileio* %18, i64 0, i32 2
  %19 = load i32* %bRead23, align 4, !tbaa !0
  %tobool24 = icmp eq i32 %19, 0
  br i1 %tobool24, label %if.then25, label %if.then30

if.then25:                                        ; preds = %land.lhs.true22
  %20 = bitcast i8* %item to i32*
  %21 = load i32* %20, align 4, !tbaa !0
  store i32 %21, i32* %idum, align 4, !tbaa !0
  br label %if.then30

if.end26:                                         ; preds = %sw.bb20
  %xdr27 = getelementptr inbounds %struct.t_fileio* %18, i64 0, i32 8
  %22 = load %struct.XDR** %xdr27, align 8, !tbaa !3
  %call28 = call i32 @xdr_int(%struct.XDR* %22, i32* %idum) #7
  br label %sw.epilog

if.then30:                                        ; preds = %land.lhs.true22, %if.then25
  %xdr27337 = getelementptr inbounds %struct.t_fileio* %18, i64 0, i32 8
  %23 = load %struct.XDR** %xdr27337, align 8, !tbaa !3
  %call28338 = call i32 @xdr_int(%struct.XDR* %23, i32* %idum) #7
  %24 = load i32* %idum, align 4, !tbaa !0
  %25 = bitcast i8* %item to i32*
  store i32 %24, i32* %25, align 4, !tbaa !0
  br label %sw.epilog

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.cond.preheader ]
  %26 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %xdr35 = getelementptr inbounds %struct.t_fileio* %26, i64 0, i32 8
  %27 = load %struct.XDR** %xdr35, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %item, i64 %indvars.iv
  %call36 = call i32 @xdr_u_char(%struct.XDR* %27, i8* %arrayidx) #7
  %indvars.iv.next = add i64 %indvars.iv, 1
  %28 = trunc i64 %indvars.iv.next to i32
  %cmp = icmp sge i32 %28, %nitem
  %tobool34 = icmp eq i32 %call36, 0
  %or.cond = or i1 %cmp, %tobool34
  br i1 %or.cond, label %sw.epilog, label %for.body

sw.bb37:                                          ; preds = %entry
  %tobool38 = icmp eq i8* %item, null
  %29 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  br i1 %tobool38, label %if.end43, label %land.lhs.true39

land.lhs.true39:                                  ; preds = %sw.bb37
  %bRead40 = getelementptr inbounds %struct.t_fileio* %29, i64 0, i32 2
  %30 = load i32* %bRead40, align 4, !tbaa !0
  %tobool41 = icmp eq i32 %30, 0
  br i1 %tobool41, label %if.then42, label %if.then47

if.then42:                                        ; preds = %land.lhs.true39
  %31 = bitcast i8* %item to i16*
  %32 = load i16* %31, align 2, !tbaa !6
  store i16 %32, i16* %us, align 2, !tbaa !6
  br label %if.then47

if.end43:                                         ; preds = %sw.bb37
  %xdr44 = getelementptr inbounds %struct.t_fileio* %29, i64 0, i32 8
  %33 = load %struct.XDR** %xdr44, align 8, !tbaa !3
  %call45 = call i32 @xdr_u_short(%struct.XDR* %33, i16* %us) #7
  br label %sw.epilog

if.then47:                                        ; preds = %land.lhs.true39, %if.then42
  %xdr44340 = getelementptr inbounds %struct.t_fileio* %29, i64 0, i32 8
  %34 = load %struct.XDR** %xdr44340, align 8, !tbaa !3
  %call45341 = call i32 @xdr_u_short(%struct.XDR* %34, i16* %us) #7
  %35 = load i16* %us, align 2, !tbaa !6
  %36 = bitcast i8* %item to i16*
  store i16 %35, i16* %36, align 2, !tbaa !6
  br label %sw.epilog

sw.bb49:                                          ; preds = %entry
  %37 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDouble50 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 3
  %38 = load i32* %bDouble50, align 4, !tbaa !0
  %tobool51 = icmp eq i32 %38, 0
  %tobool53 = icmp ne i8* %item, null
  br i1 %tobool51, label %if.else88, label %if.then52

if.then52:                                        ; preds = %sw.bb49
  br i1 %tobool53, label %land.lhs.true54, label %if.end70.thread346

if.end70.thread346:                               ; preds = %if.then52
  %xdr71347 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 8
  %39 = load %struct.XDR** %xdr71347, align 8, !tbaa !3
  %40 = bitcast [3 x double]* %dvec to i8*
  %call72348 = call i32 @xdr_vector(%struct.XDR* %39, i8* %40, i32 3, i32 8, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, double*)* @xdr_double to i32 (%struct.XDR*, i8*, ...)*)) #7
  br label %sw.epilog

land.lhs.true54:                                  ; preds = %if.then52
  %bRead55 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 2
  %41 = load i32* %bRead55, align 4, !tbaa !0
  %tobool56 = icmp eq i32 %41, 0
  br i1 %tobool56, label %for.cond58.preheader, label %if.end70.thread

if.end70.thread:                                  ; preds = %land.lhs.true54
  %xdr71343 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 8
  %42 = load %struct.XDR** %xdr71343, align 8, !tbaa !3
  %43 = bitcast [3 x double]* %dvec to i8*
  %call72344 = call i32 @xdr_vector(%struct.XDR* %42, i8* %43, i32 3, i32 8, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, double*)* @xdr_double to i32 (%struct.XDR*, i8*, ...)*)) #7
  br label %for.cond75.preheader

for.cond58.preheader:                             ; preds = %land.lhs.true54
  %44 = bitcast i8* %item to float*
  br label %for.body61

for.body61:                                       ; preds = %for.body61, %for.cond58.preheader
  %indvars.iv320 = phi i64 [ 0, %for.cond58.preheader ], [ %indvars.iv.next321, %for.body61 ]
  %arrayidx63 = getelementptr inbounds float* %44, i64 %indvars.iv320
  %45 = load float* %arrayidx63, align 4, !tbaa !5
  %conv64 = fpext float %45 to double
  %arrayidx66 = getelementptr inbounds [3 x double]* %dvec, i64 0, i64 %indvars.iv320
  store double %conv64, double* %arrayidx66, align 8, !tbaa !4
  %indvars.iv.next321 = add i64 %indvars.iv320, 1
  %lftr.wideiv322 = trunc i64 %indvars.iv.next321 to i32
  %exitcond323 = icmp eq i32 %lftr.wideiv322, 3
  br i1 %exitcond323, label %if.end70, label %for.body61

if.end70:                                         ; preds = %for.body61
  %xdr71 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 8
  %46 = load %struct.XDR** %xdr71, align 8, !tbaa !3
  %47 = bitcast [3 x double]* %dvec to i8*
  %call72 = call i32 @xdr_vector(%struct.XDR* %46, i8* %47, i32 3, i32 8, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, double*)* @xdr_double to i32 (%struct.XDR*, i8*, ...)*)) #7
  br label %for.cond75.preheader

for.cond75.preheader:                             ; preds = %if.end70, %if.end70.thread
  %call72345 = phi i32 [ %call72344, %if.end70.thread ], [ %call72, %if.end70 ]
  %48 = bitcast i8* %item to float*
  br label %for.body78

for.body78:                                       ; preds = %for.body78, %for.cond75.preheader
  %indvars.iv318 = phi i64 [ 0, %for.cond75.preheader ], [ %indvars.iv.next319, %for.body78 ]
  %arrayidx80 = getelementptr inbounds [3 x double]* %dvec, i64 0, i64 %indvars.iv318
  %49 = load double* %arrayidx80, align 8, !tbaa !4
  %conv81 = fptrunc double %49 to float
  %arrayidx83 = getelementptr inbounds float* %48, i64 %indvars.iv318
  store float %conv81, float* %arrayidx83, align 4, !tbaa !5
  %indvars.iv.next319 = add i64 %indvars.iv318, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next319 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 3
  br i1 %exitcond, label %sw.epilog, label %for.body78

if.else88:                                        ; preds = %sw.bb49
  br i1 %tobool53, label %land.lhs.true90, label %if.end105.thread352

if.end105.thread352:                              ; preds = %if.else88
  %xdr106353 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 8
  %50 = load %struct.XDR** %xdr106353, align 8, !tbaa !3
  %call108354 = call i32 @xdr_vector(%struct.XDR* %50, i8* %0, i32 3, i32 4, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, float*)* @xdr_float to i32 (%struct.XDR*, i8*, ...)*)) #7
  br label %sw.epilog

land.lhs.true90:                                  ; preds = %if.else88
  %bRead91 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 2
  %51 = load i32* %bRead91, align 4, !tbaa !0
  %tobool92 = icmp eq i32 %51, 0
  br i1 %tobool92, label %if.end105, label %if.end105.thread

if.end105.thread:                                 ; preds = %land.lhs.true90
  %xdr106349 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 8
  %52 = load %struct.XDR** %xdr106349, align 8, !tbaa !3
  %call108350 = call i32 @xdr_vector(%struct.XDR* %52, i8* %0, i32 3, i32 4, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, float*)* @xdr_float to i32 (%struct.XDR*, i8*, ...)*)) #7
  br label %for.cond111.preheader

if.end105:                                        ; preds = %land.lhs.true90
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %item, i64 12, i32 4, i1 false)
  %xdr106 = getelementptr inbounds %struct.t_fileio* %37, i64 0, i32 8
  %53 = load %struct.XDR** %xdr106, align 8, !tbaa !3
  %call108 = call i32 @xdr_vector(%struct.XDR* %53, i8* %0, i32 3, i32 4, i32 (%struct.XDR*, i8*, ...)* bitcast (i32 (%struct.XDR*, float*)* @xdr_float to i32 (%struct.XDR*, i8*, ...)*)) #7
  br label %for.cond111.preheader

for.cond111.preheader:                            ; preds = %if.end105, %if.end105.thread
  %call108351 = phi i32 [ %call108350, %if.end105.thread ], [ %call108, %if.end105 ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %item, i8* %0, i64 12, i32 4, i1 false)
  br label %sw.epilog

for.body131:                                      ; preds = %for.body131.lr.ph, %if.end137
  %indvars.iv324 = phi i64 [ 0, %for.body131.lr.ph ], [ %indvars.iv.next325, %if.end137 ]
  %ptr.0310 = phi float* [ null, %for.body131.lr.ph ], [ %ptr.1, %if.end137 ]
  br i1 %tobool132, label %if.end137, label %if.then133

if.then133:                                       ; preds = %for.body131
  %arraydecay136 = getelementptr inbounds [3 x float]* %1, i64 %indvars.iv324, i64 0
  br label %if.end137

if.end137:                                        ; preds = %for.body131, %if.then133
  %ptr.1 = phi float* [ %arraydecay136, %if.then133 ], [ %ptr.0310, %for.body131 ]
  %54 = bitcast float* %ptr.1 to i8*
  %call138 = call i32 @do_xdr(i8* %54, i32 1, i32 4, i8* %desc, i8* %srcfile, i32 %line) #9
  %indvars.iv.next325 = add i64 %indvars.iv324, 1
  %55 = trunc i64 %indvars.iv.next325 to i32
  %cmp126 = icmp sge i32 %55, %nitem
  %tobool129 = icmp eq i32 %call138, 0
  %or.cond290 = or i1 %cmp126, %tobool129
  br i1 %or.cond290, label %sw.epilog, label %for.body131

sw.bb142:                                         ; preds = %entry
  %56 = bitcast i8* %item to i32*
  %tobool150 = icmp eq i8* %item, null
  br label %for.body149

for.body149:                                      ; preds = %sw.bb142, %for.inc165
  %indvars.iv326 = phi i64 [ 0, %sw.bb142 ], [ %indvars.iv.next327, %for.inc165 ]
  %57 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  br i1 %tobool150, label %if.end157, label %land.lhs.true151

land.lhs.true151:                                 ; preds = %for.body149
  %bRead152 = getelementptr inbounds %struct.t_fileio* %57, i64 0, i32 2
  %58 = load i32* %bRead152, align 4, !tbaa !0
  %tobool153 = icmp eq i32 %58, 0
  br i1 %tobool153, label %if.then154, label %if.then161

if.then154:                                       ; preds = %land.lhs.true151
  %arrayidx156 = getelementptr inbounds i32* %56, i64 %indvars.iv326
  %59 = load i32* %arrayidx156, align 4, !tbaa !0
  store i32 %59, i32* %idum, align 4, !tbaa !0
  br label %if.then161

if.end157:                                        ; preds = %for.body149
  %xdr158 = getelementptr inbounds %struct.t_fileio* %57, i64 0, i32 8
  %60 = load %struct.XDR** %xdr158, align 8, !tbaa !3
  %call159 = call i32 @xdr_int(%struct.XDR* %60, i32* %idum) #7
  br label %for.inc165

if.then161:                                       ; preds = %land.lhs.true151, %if.then154
  %xdr158355 = getelementptr inbounds %struct.t_fileio* %57, i64 0, i32 8
  %61 = load %struct.XDR** %xdr158355, align 8, !tbaa !3
  %call159356 = call i32 @xdr_int(%struct.XDR* %61, i32* %idum) #7
  %62 = load i32* %idum, align 4, !tbaa !0
  %arrayidx163 = getelementptr inbounds i32* %56, i64 %indvars.iv326
  store i32 %62, i32* %arrayidx163, align 4, !tbaa !0
  br label %for.inc165

for.inc165:                                       ; preds = %if.end157, %if.then161
  %call159357 = phi i32 [ %call159, %if.end157 ], [ %call159356, %if.then161 ]
  %indvars.iv.next327 = add i64 %indvars.iv326, 1
  %63 = trunc i64 %indvars.iv326 to i32
  %cmp144 = icmp sgt i32 %63, 1
  %tobool147 = icmp eq i32 %call159357, 0
  %or.cond291 = or i1 %cmp144, %tobool147
  br i1 %or.cond291, label %sw.epilog, label %for.body149

sw.bb168:                                         ; preds = %entry
  %tobool169 = icmp ne i8* %item, null
  br i1 %tobool169, label %if.then170, label %if.else178

if.then170:                                       ; preds = %sw.bb168
  %64 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bRead171 = getelementptr inbounds %struct.t_fileio* %64, i64 0, i32 2
  %65 = load i32* %bRead171, align 4, !tbaa !0
  %tobool172 = icmp eq i32 %65, 0
  br i1 %tobool172, label %if.then173, label %if.else176

if.then173:                                       ; preds = %if.then170
  %call174 = call i64 @strlen(i8* %item) #8
  %add = add i64 %call174, 1
  %conv175 = trunc i64 %add to i32
  store i32 %conv175, i32* %slen, align 4, !tbaa !0
  br label %if.end179

if.else176:                                       ; preds = %if.then170
  store i32 0, i32* %slen, align 4, !tbaa !0
  br label %if.end179

if.else178:                                       ; preds = %sw.bb168
  store i32 0, i32* %slen, align 4, !tbaa !0
  %.pre = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  br label %if.end179

if.end179:                                        ; preds = %if.then173, %if.else176, %if.else178
  %66 = phi %struct.t_fileio* [ %64, %if.then173 ], [ %64, %if.else176 ], [ %.pre, %if.else178 ]
  %xdr180 = getelementptr inbounds %struct.t_fileio* %66, i64 0, i32 8
  %67 = load %struct.XDR** %xdr180, align 8, !tbaa !3
  %call181 = call i32 @xdr_int(%struct.XDR* %67, i32* %slen) #7
  %cmp182 = icmp slt i32 %call181, 1
  br i1 %cmp182, label %if.then184, label %if.end185

if.then184:                                       ; preds = %if.end179
  %68 = load i32* %slen, align 4, !tbaa !0
  call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([58 x i8]* @.str62, i64 0, i64 0), i32 %68, i8* %desc, i8* %srcfile, i32 %line) #7
  br label %if.end185

if.end185:                                        ; preds = %if.then184, %if.end179
  br i1 %tobool169, label %if.end193.thread293, label %land.lhs.true187

if.end193.thread293:                              ; preds = %if.end185
  store i8* %item, i8** %cptr, align 8, !tbaa !3
  br label %if.then195

land.lhs.true187:                                 ; preds = %if.end185
  %69 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bRead188 = getelementptr inbounds %struct.t_fileio* %69, i64 0, i32 2
  %70 = load i32* %bRead188, align 4, !tbaa !0
  %tobool189 = icmp eq i32 %70, 0
  br i1 %tobool189, label %if.end193.thread, label %if.end193

if.end193.thread:                                 ; preds = %land.lhs.true187
  store i8* null, i8** %cptr, align 8, !tbaa !3
  br label %if.end199

if.end193:                                        ; preds = %land.lhs.true187
  %71 = load i32* %slen, align 4, !tbaa !0
  %call191 = call i8* @save_calloc(i8* getelementptr inbounds ([5 x i8]* @.str63, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 605, i32 %71, i32 1) #7
  store i8* %call191, i8** %cptr, align 8, !tbaa !3
  %tobool194 = icmp eq i8* %call191, null
  br i1 %tobool194, label %land.lhs.true201, label %if.then195

if.then195:                                       ; preds = %if.end193.thread293, %if.end193
  %72 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %xdr196 = getelementptr inbounds %struct.t_fileio* %72, i64 0, i32 8
  %73 = load %struct.XDR** %xdr196, align 8, !tbaa !3
  %74 = load i32* %slen, align 4, !tbaa !0
  %call197 = call i32 @xdr_string(%struct.XDR* %73, i8** %cptr, i32 %74) #7
  br label %if.end199

if.end199:                                        ; preds = %if.end193.thread, %if.then195
  %res.3 = phi i32 [ %call197, %if.then195 ], [ 1, %if.end193.thread ]
  br i1 %tobool169, label %sw.epilog, label %land.lhs.true201

land.lhs.true201:                                 ; preds = %if.end199, %if.end193
  %res.3295 = phi i32 [ 1, %if.end193 ], [ %res.3, %if.end199 ]
  %75 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bRead202 = getelementptr inbounds %struct.t_fileio* %75, i64 0, i32 2
  %76 = load i32* %bRead202, align 4, !tbaa !0
  %tobool203 = icmp eq i32 %76, 0
  br i1 %tobool203, label %sw.epilog, label %if.then204

if.then204:                                       ; preds = %land.lhs.true201
  %77 = load i8** %cptr, align 8, !tbaa !3
  call void @save_free(i8* getelementptr inbounds ([5 x i8]* @.str63, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 613, i8* %77) #7
  br label %sw.epilog

sw.epilog.thread:                                 ; preds = %entry
  call fastcc void @fe(i32 %eio, i8* %desc, i32 617) #9
  br label %land.lhs.true208

sw.epilog:                                        ; preds = %for.inc165, %if.end137, %for.body78, %for.body, %if.end105.thread352, %if.end70.thread346, %if.end43, %if.end26, %if.end13, %if.end, %for.cond111.preheader, %land.lhs.true201, %if.end199, %if.then204, %if.then47, %if.then30, %if.then5, %if.then17
  %res.4 = phi i32 [ %res.3, %if.end199 ], [ %res.3295, %if.then204 ], [ %res.3295, %land.lhs.true201 ], [ %call45341, %if.then47 ], [ %call45, %if.end43 ], [ %call28338, %if.then30 ], [ %call28, %if.end26 ], [ %call332, %if.then5 ], [ %call, %if.end ], [ %call15335, %if.then17 ], [ %call15, %if.end13 ], [ %call108351, %for.cond111.preheader ], [ %call72348, %if.end70.thread346 ], [ %call108354, %if.end105.thread352 ], [ %call36, %for.body ], [ %call72345, %for.body78 ], [ %call138, %if.end137 ], [ %call159357, %for.inc165 ]
  %cmp206 = icmp eq i32 %res.4, 0
  br i1 %cmp206, label %land.lhs.true208, label %if.end214

land.lhs.true208:                                 ; preds = %sw.epilog, %sw.epilog.thread
  %78 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %78, i64 0, i32 4
  %79 = load i32* %bDebug, align 4, !tbaa !0
  %tobool209 = icmp eq i32 %79, 0
  br i1 %tobool209, label %if.end214, label %if.then210

if.then210:                                       ; preds = %land.lhs.true208
  %80 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %idxprom211 = sext i32 %eio to i64
  %arrayidx212 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom211
  %81 = load i8** %arrayidx212, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %78, i64 0, i32 6
  %82 = load i8** %fn, align 8, !tbaa !3
  %call213 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %80, i8* getelementptr inbounds ([56 x i8]* @.str64, i64 0, i64 0), i8* %81, i8* %desc, i8* %82, i8* %srcfile, i32 %line) #7
  br label %if.end214

if.end214:                                        ; preds = %for.cond125.preheader, %for.cond.preheader, %land.lhs.true208, %if.then210, %sw.epilog
  %res.4297 = phi i32 [ 0, %land.lhs.true208 ], [ 0, %if.then210 ], [ %res.4, %sw.epilog ], [ 1, %for.cond.preheader ], [ 1, %for.cond125.preheader ]
  %cmp215 = icmp ne i32 %res.4297, 0
  %conv216 = zext i1 %cmp215 to i32
  ret i32 %conv216
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @do_ascread(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
entry:
  %i = alloca i32, align 4
  %ix = alloca i32, align 4
  %d = alloca double, align 8
  %x = alloca double, align 8
  %0 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp1 = getelementptr inbounds %struct.t_fileio* %0, i64 0, i32 7
  %1 = load %struct._IO_FILE** %fp1, align 8, !tbaa !3
  call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 335) #9
  switch i32 %eio, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %for.cond.preheader
    i32 3, label %sw.bb17
    i32 4, label %sw.bb24
    i32 5, label %for.cond38.preheader
    i32 6, label %sw.bb62
    i32 7, label %sw.bb77
  ]

for.cond38.preheader:                             ; preds = %entry
  store i32 0, i32* %i, align 4, !tbaa !0
  %cmp39144 = icmp sgt i32 %nitem, 0
  br i1 %cmp39144, label %for.body41.lr.ph, label %land.lhs.true

for.body41.lr.ph:                                 ; preds = %for.cond38.preheader
  %2 = bitcast i8* %item to [3 x float]*
  %tobool50 = icmp eq i8* %item, null
  br label %for.body41

for.cond.preheader:                               ; preds = %entry
  store i32 0, i32* %i, align 4, !tbaa !0
  %cmp139 = icmp sgt i32 %nitem, 0
  br i1 %cmp139, label %for.body.lr.ph, label %land.lhs.true

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %tobool13 = icmp eq i8* %item, null
  br label %for.body

sw.bb:                                            ; preds = %entry
  %call = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call2 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call, i8* getelementptr inbounds ([4 x i8]* @.str57, i64 0, i64 0), double* %d) #7
  %tobool = icmp eq i8* %item, null
  br i1 %tobool, label %sw.epilog, label %if.then

if.then:                                          ; preds = %sw.bb
  %3 = load double* %d, align 8, !tbaa !4
  %conv = fptrunc double %3 to float
  %4 = bitcast i8* %item to float*
  store float %conv, float* %4, align 4, !tbaa !5
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %call4 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call5 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call4, i8* getelementptr inbounds ([3 x i8]* @.str58, i64 0, i64 0), i32* %i) #7
  %tobool6 = icmp eq i8* %item, null
  br i1 %tobool6, label %sw.epilog, label %if.then7

if.then7:                                         ; preds = %sw.bb3
  %5 = load i32* %i, align 4, !tbaa !0
  %6 = bitcast i8* %item to i32*
  store i32 %5, i32* %6, align 4, !tbaa !0
  br label %sw.epilog

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %call11 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call12 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call11, i8* getelementptr inbounds ([3 x i8]* @.str58, i64 0, i64 0), i32* %ix) #7
  br i1 %tobool13, label %for.body.for.inc_crit_edge, label %if.then14

for.body.for.inc_crit_edge:                       ; preds = %for.body
  %.pre = load i32* %i, align 4, !tbaa !0
  br label %for.inc

if.then14:                                        ; preds = %for.body
  %7 = load i32* %ix, align 4, !tbaa !0
  %conv15 = trunc i32 %7 to i8
  %8 = load i32* %i, align 4, !tbaa !0
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds i8* %item, i64 %idxprom
  store i8 %conv15, i8* %arrayidx, align 1, !tbaa !1
  br label %for.inc

for.inc:                                          ; preds = %for.body.for.inc_crit_edge, %if.then14
  %9 = phi i32 [ %.pre, %for.body.for.inc_crit_edge ], [ %8, %if.then14 ]
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4, !tbaa !0
  %cmp = icmp slt i32 %inc, %nitem
  br i1 %cmp, label %for.body, label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %call18 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call19 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call18, i8* getelementptr inbounds ([3 x i8]* @.str58, i64 0, i64 0), i32* %i) #7
  %tobool20 = icmp eq i8* %item, null
  br i1 %tobool20, label %sw.epilog, label %if.then21

if.then21:                                        ; preds = %sw.bb17
  %10 = load i32* %i, align 4, !tbaa !0
  %conv22 = trunc i32 %10 to i16
  %11 = bitcast i8* %item to i16*
  store i16 %conv22, i16* %11, align 2, !tbaa !6
  br label %sw.epilog

sw.bb24:                                          ; preds = %entry
  %12 = bitcast i8* %item to float*
  br label %for.body28

for.body28:                                       ; preds = %for.body28, %sw.bb24
  %indvars.iv = phi i64 [ 0, %sw.bb24 ], [ %indvars.iv.next, %for.body28 ]
  %call29 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call30 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call29, i8* getelementptr inbounds ([5 x i8]* @.str59, i64 0, i64 0), double* %x) #7
  %13 = load double* %x, align 8, !tbaa !4
  %conv31 = fptrunc double %13 to float
  %arrayidx33 = getelementptr inbounds float* %12, i64 %indvars.iv
  store float %conv31, float* %arrayidx33, align 4, !tbaa !5
  %indvars.iv.next = add i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 3
  br i1 %exitcond, label %sw.epilog, label %for.body28

for.body41:                                       ; preds = %for.body41.lr.ph, %for.inc59
  %storemerge145 = phi i32 [ 0, %for.body41.lr.ph ], [ %inc60, %for.inc59 ]
  %idxprom42 = sext i32 %storemerge145 to i64
  br label %for.body47

for.body47:                                       ; preds = %for.inc56, %for.body41
  %indvars.iv149 = phi i64 [ 0, %for.body41 ], [ %indvars.iv.next150, %for.inc56 ]
  %call48 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call49 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call48, i8* getelementptr inbounds ([5 x i8]* @.str59, i64 0, i64 0), double* %x) #7
  br i1 %tobool50, label %for.inc56, label %if.then51

if.then51:                                        ; preds = %for.body47
  %14 = load double* %x, align 8, !tbaa !4
  %conv52 = fptrunc double %14 to float
  %arrayidx54 = getelementptr inbounds [3 x float]* %2, i64 %idxprom42, i64 %indvars.iv149
  store float %conv52, float* %arrayidx54, align 4, !tbaa !5
  br label %for.inc56

for.inc56:                                        ; preds = %for.body47, %if.then51
  %indvars.iv.next150 = add i64 %indvars.iv149, 1
  %lftr.wideiv151 = trunc i64 %indvars.iv.next150 to i32
  %exitcond152 = icmp eq i32 %lftr.wideiv151, 3
  br i1 %exitcond152, label %for.inc59, label %for.body47

for.inc59:                                        ; preds = %for.inc56
  %15 = load i32* %i, align 4, !tbaa !0
  %inc60 = add nsw i32 %15, 1
  store i32 %inc60, i32* %i, align 4, !tbaa !0
  %cmp39 = icmp slt i32 %inc60, %nitem
  br i1 %cmp39, label %for.body41, label %sw.epilog

sw.bb62:                                          ; preds = %entry
  %16 = bitcast i8* %item to i32*
  %tobool69 = icmp eq i8* %item, null
  br label %for.body66

for.body66:                                       ; preds = %for.inc74, %sw.bb62
  %indvars.iv153 = phi i64 [ 0, %sw.bb62 ], [ %indvars.iv.next154, %for.inc74 ]
  %call67 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %call68 = call i32 (i8*, i8*, ...)* @__isoc99_sscanf(i8* %call67, i8* getelementptr inbounds ([4 x i8]* @.str60, i64 0, i64 0), i32* %ix) #7
  br i1 %tobool69, label %for.inc74, label %if.then70

if.then70:                                        ; preds = %for.body66
  %17 = load i32* %ix, align 4, !tbaa !0
  %arrayidx72 = getelementptr inbounds i32* %16, i64 %indvars.iv153
  store i32 %17, i32* %arrayidx72, align 4, !tbaa !0
  br label %for.inc74

for.inc74:                                        ; preds = %for.body66, %if.then70
  %indvars.iv.next154 = add i64 %indvars.iv153, 1
  %lftr.wideiv155 = trunc i64 %indvars.iv.next154 to i32
  %exitcond156 = icmp eq i32 %lftr.wideiv155, 3
  br i1 %exitcond156, label %sw.epilog, label %for.body66

sw.bb77:                                          ; preds = %entry
  %call78 = call fastcc i8* @next_item(%struct._IO_FILE* %1) #9
  %tobool79 = icmp eq i8* %item, null
  br i1 %tobool79, label %land.lhs.true, label %if.then80

if.then80:                                        ; preds = %sw.bb77
  %call81 = call i64 @strlen(i8* %call78) #8
  %add = add i64 %call81, 1
  %conv82 = trunc i64 %add to i32
  %sub.i = add nsw i32 %conv82, -1
  %18 = load i8* %call78, align 1, !tbaa !1
  %cmp34.i = icmp ne i8 %18, 0
  %cmp235.i = icmp sgt i32 %sub.i, 0
  %or.cond36.i = and i1 %cmp34.i, %cmp235.i
  br i1 %or.cond36.i, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %if.then80, %for.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %if.then80 ]
  %19 = phi i8 [ %20, %for.body.i ], [ %18, %if.then80 ]
  %i.037.i = phi i32 [ %inc.i, %for.body.i ], [ 0, %if.then80 ]
  %cmp7.i = icmp eq i8 %19, 95
  %arrayidx10.i = getelementptr inbounds i8* %item, i64 %indvars.iv.i
  %..i = select i1 %cmp7.i, i8 32, i8 %19
  store i8 %..i, i8* %arrayidx10.i, align 1, !tbaa !1
  %indvars.iv.next.i = add i64 %indvars.iv.i, 1
  %inc.i = add nsw i32 %i.037.i, 1
  %arrayidx.i = getelementptr inbounds i8* %call78, i64 %indvars.iv.next.i
  %20 = load i8* %arrayidx.i, align 1, !tbaa !1
  %cmp.i = icmp ne i8 %20, 0
  %21 = trunc i64 %indvars.iv.next.i to i32
  %cmp2.i = icmp slt i32 %21, %sub.i
  %or.cond.i = and i1 %cmp.i, %cmp2.i
  br i1 %or.cond.i, label %for.body.i, label %for.end.i

for.end.i:                                        ; preds = %for.body.i, %if.then80
  %idxprom.lcssa.i = phi i64 [ 0, %if.then80 ], [ %indvars.iv.next.i, %for.body.i ]
  %i.0.lcssa.i = phi i32 [ 0, %if.then80 ], [ %inc.i, %for.body.i ]
  %arrayidx16.i = getelementptr inbounds i8* %item, i64 %idxprom.lcssa.i
  store i8 0, i8* %arrayidx16.i, align 1, !tbaa !1
  %cmp17.i = icmp eq i32 %i.0.lcssa.i, %conv82
  br i1 %cmp17.i, label %if.then19.i, label %if.end91

if.then19.i:                                      ; preds = %for.end.i
  %22 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %call.i = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %22, i8* getelementptr inbounds ([31 x i8]* @.str54, i64 0, i64 0), i8* %call78, i8* %item) #7
  br label %if.end91

sw.default:                                       ; preds = %entry
  call fastcc void @fe(i32 %eio, i8* %desc, i32 388) #9
  br label %land.lhs.true

sw.epilog:                                        ; preds = %for.inc74, %for.inc59, %for.body28, %for.inc, %sw.bb, %sw.bb3, %sw.bb17, %if.then21, %if.then7, %if.then
  %res.5 = phi i32 [ %call19, %if.then21 ], [ %call19, %sw.bb17 ], [ %call5, %if.then7 ], [ %call5, %sw.bb3 ], [ %call2, %if.then ], [ %call2, %sw.bb ], [ %call12, %for.inc ], [ %call30, %for.body28 ], [ %call49, %for.inc59 ], [ %call68, %for.inc74 ]
  %cmp84 = icmp slt i32 %res.5, 1
  br i1 %cmp84, label %land.lhs.true, label %if.end91

land.lhs.true:                                    ; preds = %for.cond38.preheader, %for.cond.preheader, %sw.bb77, %sw.default, %sw.epilog
  %res.5135 = phi i32 [ %res.5, %sw.epilog ], [ 0, %sw.default ], [ 0, %sw.bb77 ], [ 0, %for.cond.preheader ], [ 0, %for.cond38.preheader ]
  %23 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %23, i64 0, i32 4
  %24 = load i32* %bDebug, align 4, !tbaa !0
  %tobool86 = icmp eq i32 %24, 0
  br i1 %tobool86, label %if.end91, label %if.then87

if.then87:                                        ; preds = %land.lhs.true
  %25 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %idxprom88 = sext i32 %eio to i64
  %arrayidx89 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom88
  %26 = load i8** %arrayidx89, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %23, i64 0, i32 6
  %27 = load i8** %fn, align 8, !tbaa !3
  %call90 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %25, i8* getelementptr inbounds ([55 x i8]* @.str46, i64 0, i64 0), i8* %26, i8* %desc, i8* %27, i8* %srcfile, i32 %line) #7
  br label %if.end91

if.end91:                                         ; preds = %if.then19.i, %for.end.i, %land.lhs.true, %if.then87, %sw.epilog
  %res.5134 = phi i32 [ %res.5135, %land.lhs.true ], [ %res.5135, %if.then87 ], [ %res.5, %sw.epilog ], [ 1, %for.end.i ], [ 1, %if.then19.i ]
  %cmp92 = icmp sgt i32 %res.5134, 0
  %conv93 = zext i1 %cmp92 to i32
  ret i32 %conv93
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @do_ascwrite(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
entry:
  %strbuf = alloca [256 x i8], align 16
  %0 = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 0
  call void @llvm.lifetime.start(i64 256, i8* %0) #5
  call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 213) #9
  switch i32 %eio, label %sw.epilog.thread [
    i32 0, label %sw.bb
    i32 1, label %sw.bb2
    i32 2, label %for.cond.preheader
    i32 3, label %sw.bb14
    i32 4, label %sw.bb19
    i32 5, label %for.cond30.preheader
    i32 6, label %sw.bb48
    i32 7, label %sw.bb55
  ]

for.cond30.preheader:                             ; preds = %entry
  %cmp31109 = icmp sgt i32 %nitem, 0
  br i1 %cmp31109, label %for.body33.lr.ph, label %land.lhs.true

for.body33.lr.ph:                                 ; preds = %for.cond30.preheader
  %1 = bitcast i8* %item to [3 x float]*
  br label %for.body33

for.cond.preheader:                               ; preds = %entry
  %cmp105 = icmp sgt i32 %nitem, 0
  %2 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp8106 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 7
  %3 = load %struct._IO_FILE** %fp8106, align 8, !tbaa !3
  br i1 %cmp105, label %for.body, label %for.end

sw.bb:                                            ; preds = %entry
  %4 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %4, i64 0, i32 7
  %5 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  %6 = bitcast i8* %item to float*
  %7 = load float* %6, align 4, !tbaa !5
  %conv = fpext float %7 to double
  %call = call fastcc i8* @dbgstr(i8* %desc) #9
  %call1 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([11 x i8]* @.str47, i64 0, i64 0), double %conv, i8* %call) #7
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %8 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp3 = getelementptr inbounds %struct.t_fileio* %8, i64 0, i32 7
  %9 = load %struct._IO_FILE** %fp3, align 8, !tbaa !3
  %10 = bitcast i8* %item to i32*
  %11 = load i32* %10, align 4, !tbaa !0
  %call4 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call5 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %9, i8* getelementptr inbounds ([8 x i8]* @.str48, i64 0, i64 0), i32 %11, i8* %call4) #7
  br label %sw.epilog

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.cond.preheader ]
  %12 = phi %struct._IO_FILE* [ %15, %for.body ], [ %3, %for.cond.preheader ]
  %arrayidx = getelementptr inbounds i8* %item, i64 %indvars.iv
  %13 = load i8* %arrayidx, align 1, !tbaa !1
  %conv9 = zext i8 %13 to i32
  %call10 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %12, i8* getelementptr inbounds ([4 x i8]* @.str49, i64 0, i64 0), i32 %conv9) #7
  %indvars.iv.next = add i64 %indvars.iv, 1
  %14 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp8 = getelementptr inbounds %struct.t_fileio* %14, i64 0, i32 7
  %15 = load %struct._IO_FILE** %fp8, align 8, !tbaa !3
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %nitem
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %.lcssa = phi %struct._IO_FILE* [ %3, %for.cond.preheader ], [ %15, %for.body ]
  %res.0.lcssa = phi i32 [ 0, %for.cond.preheader ], [ %call10, %for.body ]
  %call12 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call13 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %.lcssa, i8* getelementptr inbounds ([4 x i8]* @.str50, i64 0, i64 0), i8* %call12) #7
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry
  %16 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp15 = getelementptr inbounds %struct.t_fileio* %16, i64 0, i32 7
  %17 = load %struct._IO_FILE** %fp15, align 8, !tbaa !3
  %18 = bitcast i8* %item to i16*
  %19 = load i16* %18, align 2, !tbaa !6
  %conv16 = zext i16 %19 to i32
  %call17 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call18 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %17, i8* getelementptr inbounds ([8 x i8]* @.str48, i64 0, i64 0), i32 %conv16, i8* %call17) #7
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry
  %20 = bitcast i8* %item to float*
  %21 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp20 = getelementptr inbounds %struct.t_fileio* %21, i64 0, i32 7
  %22 = load %struct._IO_FILE** %fp20, align 8, !tbaa !3
  %23 = load float* %20, align 4, !tbaa !5
  %conv22 = fpext float %23 to double
  %arrayidx23 = getelementptr inbounds i8* %item, i64 4
  %24 = bitcast i8* %arrayidx23 to float*
  %25 = load float* %24, align 4, !tbaa !5
  %conv24 = fpext float %25 to double
  %arrayidx25 = getelementptr inbounds i8* %item, i64 8
  %26 = bitcast i8* %arrayidx25 to float*
  %27 = load float* %26, align 4, !tbaa !5
  %conv26 = fpext float %27 to double
  %call27 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call28 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %22, i8* getelementptr inbounds ([25 x i8]* @.str51, i64 0, i64 0), double %conv22, double %conv24, double %conv26, i8* %call27) #7
  br label %sw.epilog

for.body33:                                       ; preds = %for.body33, %for.body33.lr.ph
  %indvars.iv113 = phi i64 [ 0, %for.body33.lr.ph ], [ %indvars.iv.next114, %for.body33 ]
  %arraydecay = getelementptr inbounds [3 x float]* %1, i64 %indvars.iv113, i64 0
  %28 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp36 = getelementptr inbounds %struct.t_fileio* %28, i64 0, i32 7
  %29 = load %struct._IO_FILE** %fp36, align 8, !tbaa !3
  %30 = load float* %arraydecay, align 4, !tbaa !5
  %conv38 = fpext float %30 to double
  %arrayidx39 = getelementptr inbounds [3 x float]* %1, i64 %indvars.iv113, i64 1
  %31 = load float* %arrayidx39, align 4, !tbaa !5
  %conv40 = fpext float %31 to double
  %arrayidx41 = getelementptr inbounds [3 x float]* %1, i64 %indvars.iv113, i64 2
  %32 = load float* %arrayidx41, align 4, !tbaa !5
  %conv42 = fpext float %32 to double
  %call43 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call44 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %29, i8* getelementptr inbounds ([25 x i8]* @.str51, i64 0, i64 0), double %conv38, double %conv40, double %conv42, i8* %call43) #7
  %indvars.iv.next114 = add i64 %indvars.iv113, 1
  %lftr.wideiv115 = trunc i64 %indvars.iv.next114 to i32
  %exitcond116 = icmp eq i32 %lftr.wideiv115, %nitem
  br i1 %exitcond116, label %sw.epilog, label %for.body33

sw.bb48:                                          ; preds = %entry
  %33 = bitcast i8* %item to i32*
  %34 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp49 = getelementptr inbounds %struct.t_fileio* %34, i64 0, i32 7
  %35 = load %struct._IO_FILE** %fp49, align 8, !tbaa !3
  %36 = load i32* %33, align 4, !tbaa !0
  %arrayidx51 = getelementptr inbounds i8* %item, i64 4
  %37 = bitcast i8* %arrayidx51 to i32*
  %38 = load i32* %37, align 4, !tbaa !0
  %arrayidx52 = getelementptr inbounds i8* %item, i64 8
  %39 = bitcast i8* %arrayidx52 to i32*
  %40 = load i32* %39, align 4, !tbaa !0
  %call53 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call54 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %35, i8* getelementptr inbounds ([16 x i8]* @.str52, i64 0, i64 0), i32 %36, i32 %38, i32 %40, i8* %call53) #7
  br label %sw.epilog

sw.bb55:                                          ; preds = %entry
  %41 = load i8* %item, align 1, !tbaa !1
  %not.cmp1.i = icmp eq i8 %41, 0
  br i1 %not.cmp1.i, label %for.end.thread.i, label %for.body.i

for.end.thread.i:                                 ; preds = %sw.bb55
  store i8 0, i8* %0, align 16, !tbaa !1
  br label %encode_string.exit

for.body.i:                                       ; preds = %sw.bb55, %for.inc.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc.i ], [ 0, %sw.bb55 ]
  %42 = phi i8 [ %43, %for.inc.i ], [ %41, %sw.bb55 ]
  %i.02.i = phi i32 [ %inc.i, %for.inc.i ], [ 0, %sw.bb55 ]
  switch i8 %42, label %if.else.i [
    i8 32, label %if.then.i
    i8 9, label %if.then.i
  ]

if.then.i:                                        ; preds = %for.body.i, %for.body.i
  %arrayidx15.i = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 %indvars.iv.i
  store i8 95, i8* %arrayidx15.i, align 1, !tbaa !1
  br label %for.inc.i

if.else.i:                                        ; preds = %for.body.i
  %arrayidx19.i = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 %indvars.iv.i
  store i8 %42, i8* %arrayidx19.i, align 1, !tbaa !1
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.else.i, %if.then.i
  %indvars.iv.next.i = add i64 %indvars.iv.i, 1
  %inc.i = add nsw i32 %i.02.i, 1
  %arrayidx.i = getelementptr inbounds i8* %item, i64 %indvars.iv.next.i
  %43 = load i8* %arrayidx.i, align 1, !tbaa !1
  %44 = trunc i64 %indvars.iv.next.i to i32
  %cmp2.i = icmp slt i32 %44, 255
  %not.cmp.i = icmp ne i8 %43, 0
  %.cmp2.i = and i1 %cmp2.i, %not.cmp.i
  br i1 %.cmp2.i, label %for.body.i, label %for.end.i

for.end.i:                                        ; preds = %for.inc.i
  %phitmp.i = icmp eq i32 %inc.i, 256
  %arrayidx21.i = getelementptr inbounds [256 x i8]* %strbuf, i64 0, i64 %indvars.iv.next.i
  store i8 0, i8* %arrayidx21.i, align 1, !tbaa !1
  br i1 %phitmp.i, label %if.then24.i, label %encode_string.exit

if.then24.i:                                      ; preds = %for.end.i
  %45 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %call.i = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %45, i8* getelementptr inbounds ([31 x i8]* @.str54, i64 0, i64 0), i8* %item, i8* %0) #7
  br label %encode_string.exit

encode_string.exit:                               ; preds = %for.end.thread.i, %for.end.i, %if.then24.i
  %46 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp57 = getelementptr inbounds %struct.t_fileio* %46, i64 0, i32 7
  %47 = load %struct._IO_FILE** %fp57, align 8, !tbaa !3
  %call59 = call fastcc i8* @dbgstr(i8* %desc) #9
  %call60 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %47, i8* getelementptr inbounds ([9 x i8]* @.str53, i64 0, i64 0), i8* %0, i8* %call59) #7
  br label %sw.epilog

sw.epilog.thread:                                 ; preds = %entry
  call fastcc void @fe(i32 %eio, i8* %desc, i32 253) #9
  br label %land.lhs.true

sw.epilog:                                        ; preds = %for.body33, %encode_string.exit, %sw.bb48, %sw.bb19, %sw.bb14, %for.end, %sw.bb2, %sw.bb
  %res.2 = phi i32 [ %call60, %encode_string.exit ], [ %call54, %sw.bb48 ], [ %call28, %sw.bb19 ], [ %call18, %sw.bb14 ], [ %res.0.lcssa, %for.end ], [ %call5, %sw.bb2 ], [ %call1, %sw.bb ], [ %call44, %for.body33 ]
  %cmp61 = icmp slt i32 %res.2, 1
  br i1 %cmp61, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.cond30.preheader, %sw.epilog.thread, %sw.epilog
  %res.2104 = phi i32 [ 0, %sw.epilog.thread ], [ %res.2, %sw.epilog ], [ 0, %for.cond30.preheader ]
  %48 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %48, i64 0, i32 4
  %49 = load i32* %bDebug, align 4, !tbaa !0
  %tobool = icmp eq i32 %49, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %50 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %idxprom63 = sext i32 %eio to i64
  %arrayidx64 = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom63
  %51 = load i8** %arrayidx64, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %48, i64 0, i32 6
  %52 = load i8** %fn, align 8, !tbaa !3
  %call65 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %50, i8* getelementptr inbounds ([53 x i8]* @.str31, i64 0, i64 0), i8* %51, i8* %desc, i8* %52, i8* %srcfile, i32 %line) #7
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %if.then, %sw.epilog
  %res.2103 = phi i32 [ %res.2104, %land.lhs.true ], [ %res.2104, %if.then ], [ %res.2, %sw.epilog ]
  %cmp66 = icmp sgt i32 %res.2103, 0
  %conv67 = zext i1 %cmp66 to i32
  call void @llvm.lifetime.end(i64 256, i8* %0) #5
  ret i32 %conv67
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @do_binread(i8* %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
entry:
  %ssize = alloca i32, align 4
  call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 450) #9
  switch i32 %eio, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.epilog
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
    i32 4, label %sw.bb4
    i32 5, label %sw.bb4
    i32 6, label %sw.bb10
    i32 7, label %sw.bb11
  ]

sw.bb:                                            ; preds = %entry
  %0 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDouble = getelementptr inbounds %struct.t_fileio* %0, i64 0, i32 3
  %1 = load i32* %bDouble, align 4, !tbaa !0
  %tobool = icmp eq i32 %1, 0
  %. = select i1 %tobool, i64 4, i64 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry
  %2 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDouble5 = getelementptr inbounds %struct.t_fileio* %2, i64 0, i32 3
  %3 = load i32* %bDouble5, align 4, !tbaa !0
  %tobool6 = icmp eq i32 %3, 0
  %.46 = select i1 %tobool6, i64 12, i64 24
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry
  %4 = bitcast i32* %ssize to i8*
  %call = call i32 @do_binread(i8* %4, i32 1, i32 1, i8* %desc, i8* %srcfile, i32 %line) #9
  %5 = load i32* %ssize, align 4, !tbaa !0
  %conv = sext i32 %5 to i64
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call fastcc void @fe(i32 %eio, i8* %desc, i32 482) #9
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb4, %entry, %sw.bb, %sw.default, %sw.bb11, %sw.bb10, %sw.bb3, %sw.bb2
  %size.0 = phi i64 [ 0, %sw.default ], [ %conv, %sw.bb11 ], [ 12, %sw.bb10 ], [ 2, %sw.bb3 ], [ 1, %sw.bb2 ], [ %., %sw.bb ], [ 4, %entry ], [ %.46, %sw.bb4 ]
  %tobool12 = icmp eq i8* %item, null
  br i1 %tobool12, label %if.end21.thread, label %if.end21

if.end21.thread:                                  ; preds = %sw.epilog
  %6 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp17 = getelementptr inbounds %struct.t_fileio* %6, i64 0, i32 7
  %7 = load %struct._IO_FILE** %fp17, align 8, !tbaa !3
  %conv18 = sext i32 %nitem to i64
  %mul = mul i64 %size.0, %conv18
  %call19 = call i32 @fseek(%struct._IO_FILE* %7, i64 %mul, i32 1) #7
  br label %if.end27

if.end21:                                         ; preds = %sw.epilog
  %conv14 = sext i32 %nitem to i64
  %8 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %8, i64 0, i32 7
  %9 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  %call15 = call i64 @fread(i8* %item, i64 %size.0, i64 %conv14, %struct._IO_FILE* %9) #7
  %cmp = icmp eq i64 %call15, %conv14
  br i1 %cmp, label %if.end27, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end21
  %10 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %10, i64 0, i32 4
  %11 = load i32* %bDebug, align 4, !tbaa !0
  %tobool24 = icmp eq i32 %11, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %land.lhs.true
  %12 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %idxprom = sext i32 %eio to i64
  %arrayidx = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom
  %13 = load i8** %arrayidx, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %10, i64 0, i32 6
  %14 = load i8** %fn, align 8, !tbaa !3
  %call26 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %12, i8* getelementptr inbounds ([55 x i8]* @.str46, i64 0, i64 0), i8* %13, i8* %desc, i8* %14, i8* %srcfile, i32 %line) #7
  br label %if.end27

if.end27:                                         ; preds = %if.end21.thread, %land.lhs.true, %if.end21, %if.then25
  %cmp49 = phi i32 [ 1, %if.end21.thread ], [ 0, %land.lhs.true ], [ 1, %if.end21 ], [ 0, %if.then25 ]
  ret i32 %cmp49
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @do_binwrite(i8* nocapture %item, i32 %nitem, i32 %eio, i8* %desc, i8* %srcfile, i32 %line) #1 {
entry:
  %ssize = alloca i32, align 4
  call fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 403) #9
  switch i32 %eio, label %sw.default [
    i32 0, label %sw.epilog
    i32 1, label %sw.epilog
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
    i32 4, label %sw.bb4
    i32 5, label %sw.bb5
    i32 6, label %sw.bb6
    i32 7, label %sw.bb7
  ]

sw.bb2:                                           ; preds = %entry
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %call = call i64 @strlen(i8* %item) #8
  %add = add i64 %call, 1
  %conv = trunc i64 %add to i32
  store i32 %conv, i32* %ssize, align 4, !tbaa !0
  %sext = shl i64 %add, 32
  %conv8 = ashr exact i64 %sext, 32
  %0 = bitcast i32* %ssize to i8*
  %call9 = call i32 @do_binwrite(i8* %0, i32 1, i32 1, i8* %desc, i8* %srcfile, i32 %line) #9
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call fastcc void @fe(i32 %eio, i8* %desc, i32 431) #9
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %entry, %sw.default, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2
  %size.0 = phi i64 [ 0, %sw.default ], [ %conv8, %sw.bb7 ], [ 12, %sw.bb6 ], [ 12, %sw.bb5 ], [ 12, %sw.bb4 ], [ 2, %sw.bb3 ], [ 1, %sw.bb2 ], [ 4, %entry ], [ 4, %entry ]
  %conv10 = sext i32 %nitem to i64
  %1 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %1, i64 0, i32 7
  %2 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  %call11 = call i64 @fwrite(i8* %item, i64 %size.0, i64 %conv10, %struct._IO_FILE* %2) #7
  %cmp = icmp eq i64 %call11, %conv10
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.epilog
  %3 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %3, i64 0, i32 4
  %4 = load i32* %bDebug, align 4, !tbaa !0
  %tobool = icmp eq i32 %4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %idxprom = sext i32 %eio to i64
  %arrayidx = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom
  %6 = load i8** %arrayidx, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %3, i64 0, i32 6
  %7 = load i8** %fn, align 8, !tbaa !3
  %call14 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([53 x i8]* @.str31, i64 0, i64 0), i8* %6, i8* %desc, i8* %7, i8* %srcfile, i32 %line) #7
  %8 = load %struct._IO_FILE** @stderr, align 8, !tbaa !3
  %conv15 = trunc i64 %call11 to i32
  %conv16 = trunc i64 %size.0 to i32
  %call17 = call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %8, i8* getelementptr inbounds ([45 x i8]* @.str32, i64 0, i64 0), i32 %conv15, i32 %conv16) #7
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %sw.epilog, %if.then
  %conv20 = zext i1 %cmp to i32
  ret i32 %conv20
}

; Function Attrs: optsize
declare i8* @ftp2ext(i32) #2

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_setprecision(i32 %fio, i32 %bDouble) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 788) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %bDouble1 = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 3
  store i32 %bDouble, i32* %bDouble1, align 4, !tbaa !0
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @gmx_fio_getdebug(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 794) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 4
  %1 = load i32* %bDebug, align 4, !tbaa !0
  ret i32 %1
}

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_setdebug(i32 %fio, i32 %bDebug) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 800) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %bDebug1 = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 4
  store i32 %bDebug, i32* %bDebug1, align 4, !tbaa !0
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i8* @gmx_fio_getname(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 806) #9
  %0 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %0, i64 0, i32 6
  %1 = load i8** %fn, align 8, !tbaa !3
  ret i8* %1
}

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_setftp(i32 %fio, i32 %ftp) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 812) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %iFTP = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 0
  store i32 %ftp, i32* %iFTP, align 4, !tbaa !0
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @gmx_fio_getftp(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 818) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %iFTP = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 0
  %1 = load i32* %iFTP, align 4, !tbaa !0
  ret i32 %1
}

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_rewind(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 824) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %xdr = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 8
  %1 = load %struct.XDR** %xdr, align 8, !tbaa !3
  %tobool = icmp eq %struct.XDR* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @xdrclose(%struct.XDR* %1) #7
  %2 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %xdr6 = getelementptr inbounds %struct.t_fileio* %2, i64 %idxprom, i32 8
  %3 = load %struct.XDR** %xdr6, align 8, !tbaa !3
  %fn = getelementptr inbounds %struct.t_fileio* %2, i64 %idxprom, i32 6
  %4 = load i8** %fn, align 8, !tbaa !3
  %bRead = getelementptr inbounds %struct.t_fileio* %2, i64 %idxprom, i32 2
  %5 = load i32* %bRead, align 4, !tbaa !0
  %tobool11 = icmp ne i32 %5, 0
  %cond = select i1 %tobool11, i8* getelementptr inbounds ([2 x i8]* @.str16, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8]* @.str17, i64 0, i64 0)
  %call12 = tail call i32 @xdropen(%struct.XDR* %3, i8* %4, i8* %cond) #7
  br label %if.end

if.else:                                          ; preds = %entry
  %fp = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 7
  %6 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  tail call void @frewind(%struct._IO_FILE* %6) #7
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: optsize
declare void @frewind(%struct._IO_FILE*) #2

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_flush(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 836) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 7
  %1 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  %tobool = icmp eq %struct._IO_FILE* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @fflush(%struct._IO_FILE* %1) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Function Attrs: nounwind optsize
declare i32 @fflush(%struct._IO_FILE* nocapture) #3

; Function Attrs: nounwind optsize uwtable
define i64 @gmx_fio_ftell(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 843) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 7
  %1 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  %tobool = icmp eq %struct._IO_FILE* %1, null
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i64 @ftell(%struct._IO_FILE* %1) #7
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i64 [ %call, %if.then ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind optsize
declare i64 @ftell(%struct._IO_FILE* nocapture) #3

; Function Attrs: nounwind optsize uwtable
define void @gmx_fio_seek(i32 %fio, i64 %fpos) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 852) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 7
  %1 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  %tobool = icmp eq %struct._IO_FILE* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @fseek(%struct._IO_FILE* %1, i64 %fpos, i32 0) #7
  br label %if.end

if.else:                                          ; preds = %entry
  %fn = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 6
  %2 = load i8** %fn, align 8, !tbaa !3
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([24 x i8]* @.str30, i64 0, i64 0), i8* %2) #7
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind optsize
declare i32 @fseek(%struct._IO_FILE* nocapture, i64, i32) #3

; Function Attrs: nounwind optsize uwtable
define %struct._IO_FILE* @gmx_fio_getfp(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 865) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %fp = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 7
  %1 = load %struct._IO_FILE** %fp, align 8, !tbaa !3
  ret %struct._IO_FILE* %1
}

; Function Attrs: nounwind optsize uwtable
define %struct.XDR* @gmx_fio_getxdr(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 874) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %xdr = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 8
  %1 = load %struct.XDR** %xdr, align 8, !tbaa !3
  ret %struct.XDR* %1
}

; Function Attrs: nounwind optsize uwtable
define i32 @gmx_fio_getread(i32 %fio) #1 {
entry:
  tail call fastcc void @_gmx_fio_check(i32 %fio, i32 883) #9
  %idxprom = sext i32 %fio to i64
  %0 = load %struct.t_fileio** @FIO, align 8, !tbaa !3
  %bRead = getelementptr inbounds %struct.t_fileio* %0, i64 %idxprom, i32 2
  %1 = load i32* %bRead, align 4, !tbaa !0
  ret i32 %1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @_check_nitem(i32 %eio, i32 %nitem, i32 %line) #1 {
entry:
  %cmp = icmp eq i32 %nitem, 1
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  switch i32 %eio, label %if.then [
    i32 5, label %if.end
    i32 2, label %if.end
  ]

if.then:                                          ; preds = %land.lhs.true
  %idxprom = sext i32 %eio to i64
  %arrayidx = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom
  %0 = load i8** %arrayidx, align 8, !tbaa !3
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([67 x i8]* @.str45, i64 0, i64 0), i32 %nitem, i8* getelementptr inbounds ([7 x i8]* @.str35, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8]* @.str38, i64 0, i64 0), i8* %0, i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 %line) #7
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %land.lhs.true, %entry, %if.then
  ret void
}

; Function Attrs: nounwind optsize readonly
declare i64 @strlen(i8* nocapture) #4

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fe(i32 %eio, i8* %desc, i32 %line) #1 {
entry:
  %0 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bRead = getelementptr inbounds %struct.t_fileio* %0, i64 0, i32 2
  %1 = load i32* %bRead, align 4, !tbaa !0
  %tobool = icmp ne i32 %1, 0
  %cond = select i1 %tobool, i8* getelementptr inbounds ([5 x i8]* @.str42, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8]* @.str43, i64 0, i64 0)
  %2 = icmp ult i32 %eio, 8
  br i1 %2, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %idxprom = sext i32 %eio to i64
  %arrayidx = getelementptr inbounds [8 x i8*]* @eioNames, i64 0, i64 %idxprom
  %3 = load i8** %arrayidx, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond2 = phi i8* [ %3, %cond.true ], [ getelementptr inbounds ([8 x i8]* @.str44, i64 0, i64 0), %entry ]
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([46 x i8]* @.str41, i64 0, i64 0), i8* %cond, i8* %desc, i32 %eio, i8* %cond2, i8* getelementptr inbounds ([54 x i8]* @.str15, i64 0, i64 0), i32 %line) #7
  ret void
}

; Function Attrs: nounwind optsize
declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) #3

; Function Attrs: nounwind optsize
declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture, ...) #3

; Function Attrs: nounwind optsize
declare i64 @fread(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) #3

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #5

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @dbgstr(i8* %desc) #1 {
entry:
  %0 = load %struct.t_fileio** @curfio, align 8, !tbaa !3
  %bDebug = getelementptr inbounds %struct.t_fileio* %0, i64 0, i32 4
  %1 = load i32* %bDebug, align 4, !tbaa !0
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %return, label %if.else

if.else:                                          ; preds = %entry
  %2 = load i8** @add_comment, align 8, !tbaa !3
  %tobool1 = icmp ne i8* %2, null
  %cond = select i1 %tobool1, i8* %2, i8* getelementptr inbounds ([1 x i8]* @.str55, i64 0, i64 0)
  %call = tail call i32 (i8*, i8*, ...)* @sprintf(i8* getelementptr inbounds ([4096 x i8]* @dbgstr.buf, i64 0, i64 0), i8* getelementptr inbounds ([10 x i8]* @.str56, i64 0, i64 0), i8* %cond, i8* %desc) #7
  br label %return

return:                                           ; preds = %entry, %if.else
  %retval.0 = phi i8* [ getelementptr inbounds ([4096 x i8]* @dbgstr.buf, i64 0, i64 0), %if.else ], [ getelementptr inbounds ([1 x i8]* @.str55, i64 0, i64 0), %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #5

; Function Attrs: nounwind optsize
declare i32 @sprintf(i8* nocapture, i8* nocapture, ...) #3

; Function Attrs: nounwind optsize
declare i32 @__isoc99_sscanf(i8* nocapture, i8* nocapture, ...) #3

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @next_item(%struct._IO_FILE* %fp) #1 {
entry:
  %0 = load i32* @nbuf, align 4, !tbaa !0
  %tobool96 = icmp eq i32 %0, 0
  br i1 %tobool96, label %if.else, label %if.then

tailrecurse.loopexit:                             ; preds = %do.cond, %do.cond
  %1 = load i32* @nbuf, align 4, !tbaa !0
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %tailrecurse.loopexit, %entry
  %2 = phi i32 [ %0, %entry ], [ %1, %tailrecurse.loopexit ]
  %3 = load i32* getelementptr inbounds ([20 x i32]* @next_item.bufindex, i64 0, i64 0), align 16, !tbaa !0
  %cmp88 = icmp sgt i32 %2, 1
  br i1 %cmp88, label %for.body, label %for.end

for.body:                                         ; preds = %if.then, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 1, %if.then ]
  %arrayidx = getelementptr inbounds [20 x i32]* @next_item.bufindex, i64 0, i64 %indvars.iv
  %4 = load i32* %arrayidx, align 4, !tbaa !0
  %5 = add nsw i64 %indvars.iv, -1
  %arrayidx2 = getelementptr inbounds [20 x i32]* @next_item.bufindex, i64 0, i64 %5
  store i32 %4, i32* %arrayidx2, align 4, !tbaa !0
  %indvars.iv.next = add i64 %indvars.iv, 1
  %6 = trunc i64 %indvars.iv.next to i32
  %cmp = icmp slt i32 %6, %2
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %if.then
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* @nbuf, align 4, !tbaa !0
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %idx.ext
  ret i8* %add.ptr

if.else:                                          ; preds = %entry, %tailrecurse.loopexit
  %call = tail call i8* @fgets2(i8* getelementptr inbounds ([4096 x i8]* @next_item.buf, i64 0, i64 0), i32 4095, %struct._IO_FILE* %fp) #7
  %cmp3 = icmp eq i8* %call, null
  br i1 %cmp3, label %if.then4, label %while.cond

if.then4:                                         ; preds = %if.else
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([12 x i8]* @.str61, i64 0, i64 0)) #7
  br label %while.cond

while.cond:                                       ; preds = %do.cond, %while.body, %if.else, %if.then4
  %i.1 = phi i32 [ 0, %if.then4 ], [ 0, %if.else ], [ %inc22, %while.body ], [ %i.3, %do.cond ]
  %idxprom5 = sext i32 %i.1 to i64
  %arrayidx6 = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %idxprom5
  %7 = load i8* %arrayidx6, align 1, !tbaa !1
  switch i8 %7, label %land.rhs [
    i8 0, label %while.cond23
    i8 59, label %while.cond23
  ]

land.rhs:                                         ; preds = %while.cond
  %idxprom17 = sext i8 %7 to i64
  %call18 = tail call i16** @__ctype_b_loc() #10
  %8 = load i16** %call18, align 8, !tbaa !3
  %arrayidx19 = getelementptr inbounds i16* %8, i64 %idxprom17
  %9 = load i16* %arrayidx19, align 2, !tbaa !6
  %and = and i16 %9, 8192
  %tobool21 = icmp eq i16 %and, 0
  br i1 %tobool21, label %while.cond23, label %while.body

while.body:                                       ; preds = %land.rhs
  %inc22 = add nsw i32 %i.1, 1
  br label %while.cond

while.cond23:                                     ; preds = %land.rhs, %while.cond, %while.cond, %land.rhs35.while.cond23_crit_edge
  %10 = phi i8 [ %.pre, %land.rhs35.while.cond23_crit_edge ], [ %7, %while.cond ], [ %7, %while.cond ], [ %7, %land.rhs ]
  %indvars.iv104 = phi i64 [ %indvars.iv.next105, %land.rhs35.while.cond23_crit_edge ], [ %idxprom5, %while.cond ], [ %idxprom5, %while.cond ], [ %idxprom5, %land.rhs ]
  %i.2 = phi i32 [ %inc47, %land.rhs35.while.cond23_crit_edge ], [ %i.1, %while.cond ], [ %i.1, %while.cond ], [ %i.1, %land.rhs ]
  %arrayidx25 = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %indvars.iv104
  switch i8 %10, label %land.rhs35 [
    i8 0, label %while.end48
    i8 59, label %while.end48
  ]

land.rhs35:                                       ; preds = %while.cond23
  %idxprom39 = sext i8 %10 to i64
  %call40 = tail call i16** @__ctype_b_loc() #10
  %11 = load i16** %call40, align 8, !tbaa !3
  %arrayidx41 = getelementptr inbounds i16* %11, i64 %idxprom39
  %12 = load i16* %arrayidx41, align 2, !tbaa !6
  %and43 = and i16 %12, 8192
  %lnot = icmp eq i16 %and43, 0
  %indvars.iv.next105 = add i64 %indvars.iv104, 1
  br i1 %lnot, label %land.rhs35.while.cond23_crit_edge, label %while.end48

land.rhs35.while.cond23_crit_edge:                ; preds = %land.rhs35
  %inc47 = add nsw i32 %i.2, 1
  %arrayidx25.phi.trans.insert = getelementptr inbounds [4096 x i8]* @next_item.buf, i64 0, i64 %indvars.iv.next105
  %.pre = load i8* %arrayidx25.phi.trans.insert, align 1, !tbaa !1
  br label %while.cond23

while.end48:                                      ; preds = %while.cond23, %while.cond23, %land.rhs35
  %cmp51 = icmp sgt i32 %i.2, %i.1
  br i1 %cmp51, label %if.then53, label %do.cond

if.then53:                                        ; preds = %while.end48
  store i8 0, i8* %arrayidx25, align 1, !tbaa !1
  %13 = load i32* @nbuf, align 4, !tbaa !0
  %inc56 = add nsw i32 %13, 1
  store i32 %inc56, i32* @nbuf, align 4, !tbaa !0
  %idxprom57 = sext i32 %13 to i64
  %arrayidx58 = getelementptr inbounds [20 x i32]* @next_item.bufindex, i64 0, i64 %idxprom57
  store i32 %i.1, i32* %arrayidx58, align 4, !tbaa !0
  %inc59 = add nsw i32 %i.2, 1
  br label %do.cond

do.cond:                                          ; preds = %while.end48, %if.then53
  %i.3 = phi i32 [ %inc59, %if.then53 ], [ %i.2, %while.end48 ]
  switch i8 %10, label %while.cond [
    i8 0, label %tailrecurse.loopexit
    i8 59, label %tailrecurse.loopexit
  ]
}

; Function Attrs: optsize
declare i8* @fgets2(i8*, i32, %struct._IO_FILE*) #2

; Function Attrs: nounwind optsize readnone
declare i16** @__ctype_b_loc() #6

; Function Attrs: nounwind optsize
declare i32 @xdr_double(%struct.XDR*, double*) #3

; Function Attrs: nounwind optsize
declare i32 @xdr_float(%struct.XDR*, float*) #3

; Function Attrs: nounwind optsize
declare i32 @xdr_int(%struct.XDR*, i32*) #3

; Function Attrs: nounwind optsize
declare i32 @xdr_u_char(%struct.XDR*, i8*) #3

; Function Attrs: nounwind optsize
declare i32 @xdr_u_short(%struct.XDR*, i16*) #3

; Function Attrs: nounwind optsize
declare i32 @xdr_vector(%struct.XDR*, i8*, i32, i32, i32 (%struct.XDR*, i8*, ...)*) #3

; Function Attrs: nounwind optsize
declare i32 @xdr_string(%struct.XDR*, i8**, i32) #3

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) #5

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #5

attributes #0 = { nounwind optsize readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind optsize uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { optsize "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind optsize "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind optsize readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { nounwind optsize readnone "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind optsize }
attributes #8 = { nounwind optsize readonly }
attributes #9 = { optsize }
attributes #10 = { nounwind optsize readnone }

!0 = metadata !{metadata !"int", metadata !1}
!1 = metadata !{metadata !"omnipotent char", metadata !2}
!2 = metadata !{metadata !"Simple C/C++ TBAA"}
!3 = metadata !{metadata !"any pointer", metadata !1}
!4 = metadata !{metadata !"double", metadata !1}
!5 = metadata !{metadata !"float", metadata !1}
!6 = metadata !{metadata !"short", metadata !1}
