; ModuleID = '../../SPEC/benchspec/CPU2006/400.perlbench/src/pp.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i32, i32 }
%struct.op = type { %struct.op*, %struct.op*, {}*, i64, i16, i16, i8, i8 }
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i32, i32, i32, %struct.sv*, %struct.sv* }
%struct.hv = type { %struct.xpvhv*, i32, i32 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i32, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i32 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i32, i32 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i32, i32, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i32, i32, i8, %struct.hv* }
%struct.regexp = type { i32*, i32*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i32*, i32, i32, i32, i32, i32, i32, i32, i32, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.gv = type { %struct.xpvgv*, i32, i32 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i32, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i32, i32, i32, i8* }
%struct.io = type { %struct.xpvio*, i32, i32 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i32, i32 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i32 }
%union.any = type { i8* }
%struct.xpv = type { i8*, i64, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i32, i32, i32, %struct.stackinfo*, %struct.stackinfo*, i32 }
%struct.context = type { i32, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i32, %struct.cop*, i32, i32, i32, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i32, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }

@PL_stack_sp = external global %struct.sv**
@PL_op = external global %struct.op*
@PL_stack_max = external global %struct.sv**
@PL_sv_undef = external global %struct.sv
@PL_curpad = external global %struct.sv**
@.str = private unnamed_addr constant [44 x i8] c"Can't return array to lvalue scalar context\00", align 1
@.str1 = private unnamed_addr constant [43 x i8] c"Can't return hash to lvalue scalar context\00", align 1
@.str2 = private unnamed_addr constant [17 x i8] c"NOT IMPL LINE %d\00", align 1
@PL_amagic_generation = external global i64
@.str3 = private unnamed_addr constant [50 x i8] c"Overloaded dereference did not return a reference\00", align 1
@.str4 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@PL_Sv = external global %struct.sv*
@.str5 = private unnamed_addr constant [21 x i8] c"Not a GLOB reference\00", align 1
@PL_no_modify = external constant [0 x i8]
@PL_curcop = external global %struct.cop*
@PL_no_usym = external constant [0 x i8]
@.str6 = private unnamed_addr constant [9 x i8] c"a symbol\00", align 1
@PL_dowarn = external global i8
@PL_no_symref = external constant [0 x i8]
@.str7 = private unnamed_addr constant [23 x i8] c"Not a SCALAR reference\00", align 1
@.str8 = private unnamed_addr constant [9 x i8] c"a SCALAR\00", align 1
@PL_no_localize_ref = external constant [0 x i8]
@.str9 = private unnamed_addr constant [40 x i8] c"Can't modify non-lvalue subroutine call\00", align 1
@.str10 = private unnamed_addr constant [7 x i8] c"CORE::\00", align 1
@PL_op_name = external global [0 x i8*]
@PL_op_desc = external global [0 x i8*]
@PL_opargs = external global [0 x i32]
@.str11 = private unnamed_addr constant [9 x i8] c"?$@@%&*$\00", align 1
@.str12 = private unnamed_addr constant [32 x i8] c"Can't find an opnumber for \22%s\22\00", align 1
@PL_stack_base = external global %struct.sv**
@PL_markstack_ptr = external global i32*
@PL_tmps_ix = external global i32
@PL_tmps_max = external global i32
@PL_sv_no = external global %struct.sv
@.str13 = private unnamed_addr constant [34 x i8] c"Attempt to bless into a reference\00", align 1
@.str14 = private unnamed_addr constant [48 x i8] c"Explicit blessing to '' (assuming package main)\00", align 1
@.str15 = private unnamed_addr constant [5 x i8] c"RRAY\00", align 1
@.str16 = private unnamed_addr constant [4 x i8] c"ODE\00", align 1
@.str17 = private unnamed_addr constant [10 x i8] c"ILEHANDLE\00", align 1
@.str18 = private unnamed_addr constant [18 x i8] c"*glob{FILEHANDLE}\00", align 1
@.str19 = private unnamed_addr constant [6 x i8] c"ORMAT\00", align 1
@.str20 = private unnamed_addr constant [4 x i8] c"LOB\00", align 1
@.str21 = private unnamed_addr constant [4 x i8] c"ASH\00", align 1
@.str22 = private unnamed_addr constant [4 x i8] c"AME\00", align 1
@.str23 = private unnamed_addr constant [7 x i8] c"ACKAGE\00", align 1
@.str24 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@.str25 = private unnamed_addr constant [6 x i8] c"CALAR\00", align 1
@PL_lastscream = external global %struct.sv*
@PL_sv_yes = external global %struct.sv
@PL_maxscream = external global i32
@PL_screamfirst = external global i32*
@PL_screamnext = external global i32*
@.str26 = private unnamed_addr constant [24 x i8] c"do_study: out of memory\00", align 1
@PL_defgv = external global %struct.gv*
@.str27 = private unnamed_addr constant [33 x i8] c"Constant subroutine %s undefined\00", align 1
@.str28 = private unnamed_addr constant [12 x i8] c"(anonymous)\00", align 1
@.str29 = private unnamed_addr constant [25 x i8] c"Illegal division by zero\00", align 1
@.str30 = private unnamed_addr constant [21 x i8] c"Illegal modulus zero\00", align 1
@Perl_pp_repeat.oom_list_extend = internal constant [33 x i8] c"Out of memory during list extend\00", align 16
@Perl_pp_repeat.oom_string_extend = internal constant [35 x i8] c"Out of memory during string extend\00", align 16
@.str31 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@PL_Xpv = external global %struct.xpv*
@PL_utf8skip = external constant [0 x i8]
@PL_ppaddr = external global [0 x %struct.op* ()*]
@PL_srand_called = external global i8
@.str32 = private unnamed_addr constant [21 x i8] c"Can't take log of %g\00", align 1
@.str33 = private unnamed_addr constant [22 x i8] c"Can't take sqrt of %g\00", align 1
@PL_tainting = external global i8
@.str34 = private unnamed_addr constant [25 x i8] c"substr outside of string\00", align 1
@.str35 = private unnamed_addr constant [45 x i8] c"Attempt to use reference as lvalue in substr\00", align 1
@PL_encoding = external global %struct.sv*
@PL_tainted = external global i8
@.str36 = private unnamed_addr constant [5 x i8] c"\EF\BF\BD\00\00", align 1
@.str37 = private unnamed_addr constant [65 x i8] c"The crypt() function is unimplemented due to excessive paranoia.\00", align 1
@PL_no_aelem = external constant [0 x i8]
@.str38 = private unnamed_addr constant [21 x i8] c"Not a HASH reference\00", align 1
@.str39 = private unnamed_addr constant [7 x i8] c"EXISTS\00", align 1
@.str40 = private unnamed_addr constant [7 x i8] c"DELETE\00", align 1
@.str41 = private unnamed_addr constant [35 x i8] c"Can't localize pseudo-hash element\00", align 1
@PL_no_helem = external constant [0 x i8]
@.str42 = private unnamed_addr constant [41 x i8] c"Odd number of elements in anonymous hash\00", align 1
@PL_markstack_max = external global i32*
@.str43 = private unnamed_addr constant [7 x i8] c"SPLICE\00", align 1
@.str44 = private unnamed_addr constant [34 x i8] c"splice() offset past end of array\00", align 1
@.str45 = private unnamed_addr constant [5 x i8] c"PUSH\00", align 1
@.str46 = private unnamed_addr constant [8 x i8] c"UNSHIFT\00", align 1
@PL_savestack_ix = external global i32
@.str47 = private unnamed_addr constant [16 x i8] c"panic: pp_split\00", align 1
@PL_reg_match_utf8 = external global i8
@PL_savestack_max = external global i32
@PL_curstack = external global %struct.av*
@PL_savestack = external global %union.any*
@PL_curstackinfo = external global %struct.stackinfo*
@PL_multiline = external global i32
@PL_regint_string = external global %struct.sv* (%struct.regexp*)*
@PL_regexecp = external global i32 (%struct.regexp*, i8*, i8*, i8*, i32, %struct.sv*, i8*, i32)*
@.str48 = private unnamed_addr constant [11 x i8] c"Split loop\00", align 1
@PL_lockhook = external global void (%struct.sv*)*
@.str49 = private unnamed_addr constant [53 x i8] c"tried to access per-thread data in non-threaded perl\00", align 1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_stub() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 3
  switch i32 %and, label %cond.false15 [
    i32 1, label %if.end26
    i32 2, label %if.then
    i32 3, label %if.end26
  ]

cond.false15:                                     ; preds = %entry
  %call = tail call i32 @Perl_block_gimme() #7
  %phitmp = icmp eq i32 %call, 0
  br i1 %phitmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry, %cond.false15
  %3 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp22 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp22, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then
  %call25 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then
  %sp.0 = phi %struct.sv** [ %call25, %if.then24 ], [ %0, %if.then ]
  %incdec.ptr = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %if.end26

if.end26:                                         ; preds = %cond.false15, %entry, %entry, %if.end
  %sp.1 = phi %struct.sv** [ %incdec.ptr, %if.end ], [ %0, %entry ], [ %0, %entry ], [ %0, %cond.false15 ]
  store %struct.sv** %sp.1, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %5
}

; Function Attrs: optsize
declare i32 @Perl_block_gimme() #1

; Function Attrs: optsize
declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

; Function Attrs: nounwind optsize readonly uwtable
define %struct.op* @Perl_pp_scalar() #2 {
entry:
  %0 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %0, i64 0, i32 0
  %1 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %1
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_padav() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %tobool = icmp slt i8 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @Perl_save_clearsv(%struct.sv** %arrayidx) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then4
  %sp.0 = phi %struct.sv** [ %call, %if.then4 ], [ %0, %if.end ]
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %7, i64 0, i32 6
  %8 = load i8* %op_flags, align 1, !tbaa !1
  %and7 = and i8 %8, 16
  %tobool8 = icmp eq i8 %and7, 0
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.end5
  %incdec.ptr = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %9 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %9, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %if.end5
  %op_private10 = getelementptr inbounds %struct.op* %7, i64 0, i32 7
  %10 = load i8* %op_private10, align 1, !tbaa !1
  %and12 = and i8 %10, 8
  %tobool13 = icmp eq i8 %and12, 0
  br i1 %tobool13, label %if.end35, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %call14 = tail call i32 @Perl_is_lvalue_sub() #7
  %tobool15 = icmp eq i32 %call14, 0
  %.pre = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags36.phi.trans.insert = getelementptr inbounds %struct.op* %.pre, i64 0, i32 6
  %.pre166 = load i8* %op_flags36.phi.trans.insert, align 1, !tbaa !1
  br i1 %tobool15, label %if.end35, label %if.then16

if.then16:                                        ; preds = %land.lhs.true
  %conv18 = zext i8 %.pre166 to i32
  %and19 = and i32 %conv18, 3
  %tobool20 = icmp eq i32 %and19, 0
  br i1 %tobool20, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then16
  %cmp24 = icmp eq i32 %and19, 3
  %cond = zext i1 %cmp24 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then16
  %call26 = tail call i32 @Perl_dowantarray() #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond27 = phi i32 [ %cond, %cond.true ], [ %call26, %cond.false ]
  %cmp28 = icmp eq i32 %cond27, 0
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %cond.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([44 x i8]* @.str, i64 0, i64 0)) #7
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %cond.end
  %incdec.ptr32 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr32, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr32, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next33 = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  br label %return

if.end35:                                         ; preds = %land.lhs.true, %if.else
  %12 = phi i8 [ %8, %if.else ], [ %.pre166, %land.lhs.true ]
  %conv37 = zext i8 %12 to i32
  %and38 = and i32 %conv37, 3
  switch i32 %and38, label %cond.end62 [
    i32 1, label %if.end127
    i32 2, label %if.then108
    i32 3, label %if.then66
  ]

cond.end62:                                       ; preds = %if.end35
  %call57 = tail call i32 @Perl_block_gimme() #7
  switch i32 %call57, label %if.end127 [
    i32 1, label %if.then66
    i32 0, label %if.then108
  ]

if.then66:                                        ; preds = %if.end35, %cond.end62
  %13 = bitcast %struct.sv* %4 to %struct.av*
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %14 = load i32* %sv_flags, align 4, !tbaa !4
  %and67 = and i32 %14, 32768
  %tobool68 = icmp eq i32 %and67, 0
  br i1 %tobool68, label %cond.false72, label %cond.true69

cond.true69:                                      ; preds = %if.then66
  %call70 = tail call i32 @Perl_mg_size(%struct.sv* %4) #7
  %conv71 = sext i32 %call70 to i64
  br label %cond.end73

cond.false72:                                     ; preds = %if.then66
  %sv_any = bitcast %struct.sv* %4 to %struct.xpvav**
  %15 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_fill = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 1
  %16 = load i64* %xav_fill, align 8, !tbaa !3
  br label %cond.end73

cond.end73:                                       ; preds = %cond.false72, %cond.true69
  %cond74 = phi i64 [ %conv71, %cond.true69 ], [ %16, %cond.false72 ]
  %add = add nsw i64 %cond74, 1
  %conv75 = trunc i64 %add to i32
  %17 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast76 = ptrtoint %struct.sv** %17 to i64
  %sub.ptr.rhs.cast77 = ptrtoint %struct.sv** %sp.0 to i64
  %sub.ptr.sub78 = sub i64 %sub.ptr.lhs.cast76, %sub.ptr.rhs.cast77
  %sub.ptr.div79 = ashr exact i64 %sub.ptr.sub78, 3
  %sext161 = shl i64 %add, 32
  %conv80 = ashr exact i64 %sext161, 32
  %cmp81 = icmp slt i64 %sub.ptr.div79, %conv80
  br i1 %cmp81, label %if.then83, label %if.end85

if.then83:                                        ; preds = %cond.end73
  %call84 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.0, %struct.sv** %sp.0, i32 %conv75) #7
  br label %if.end85

if.end85:                                         ; preds = %cond.end73, %if.then83
  %sp.1 = phi %struct.sv** [ %call84, %if.then83 ], [ %sp.0, %cond.end73 ]
  %18 = load i32* %sv_flags, align 4, !tbaa !4
  %and87 = and i32 %18, 57344
  %tobool88 = icmp eq i32 %and87, 0
  br i1 %tobool88, label %if.else100, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end85
  %cmp90164 = icmp eq i32 %conv75, 0
  br i1 %cmp90164, label %if.end103, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %19 = trunc i64 %cond74 to i32
  %20 = add i32 %19, 1
  br label %for.body

for.body:                                         ; preds = %cond.end96, %for.body.lr.ph
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %cond.end96 ]
  %21 = trunc i64 %indvars.iv to i32
  %call92 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %13, i32 %21, i32 0) #7
  %tobool93 = icmp eq %struct.sv** %call92, null
  br i1 %tobool93, label %cond.end96, label %cond.true94

cond.true94:                                      ; preds = %for.body
  %22 = load %struct.sv** %call92, align 8, !tbaa !0
  br label %cond.end96

cond.end96:                                       ; preds = %for.body, %cond.true94
  %cond97 = phi %struct.sv* [ %22, %cond.true94 ], [ @PL_sv_undef, %for.body ]
  %indvars.iv.next = add i64 %indvars.iv, 1
  %arrayidx99 = getelementptr inbounds %struct.sv** %sp.1, i64 %indvars.iv.next
  store %struct.sv* %cond97, %struct.sv** %arrayidx99, align 8, !tbaa !0
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %20
  br i1 %exitcond, label %if.end103, label %for.body

if.else100:                                       ; preds = %if.end85
  %add.ptr = getelementptr inbounds %struct.sv** %sp.1, i64 1
  %23 = bitcast %struct.sv** %add.ptr to i8*
  %sv_any101 = bitcast %struct.sv* %4 to %struct.xpvav**
  %24 = load %struct.xpvav** %sv_any101, align 8, !tbaa !0
  %xav_array = getelementptr inbounds %struct.xpvav* %24, i64 0, i32 0
  %25 = load i8** %xav_array, align 8, !tbaa !0
  %mul = ashr exact i64 %sext161, 29
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %25, i64 %mul, i32 1, i1 false)
  br label %if.end103

if.end103:                                        ; preds = %for.cond.preheader, %cond.end96, %if.else100
  %add.ptr104 = getelementptr inbounds %struct.sv** %sp.1, i64 %conv80
  br label %if.end127

if.then108:                                       ; preds = %if.end35, %cond.end62
  %call109 = tail call %struct.sv* @Perl_sv_newmortal() #7
  %sv_flags111 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %26 = load i32* %sv_flags111, align 4, !tbaa !4
  %and112 = and i32 %26, 32768
  %tobool113 = icmp eq i32 %and112, 0
  br i1 %tobool113, label %cond.false117, label %cond.true114

cond.true114:                                     ; preds = %if.then108
  %call115 = tail call i32 @Perl_mg_size(%struct.sv* %4) #7
  %conv116 = sext i32 %call115 to i64
  br label %cond.end120

cond.false117:                                    ; preds = %if.then108
  %sv_any118 = bitcast %struct.sv* %4 to %struct.xpvav**
  %27 = load %struct.xpvav** %sv_any118, align 8, !tbaa !0
  %xav_fill119 = getelementptr inbounds %struct.xpvav* %27, i64 0, i32 1
  %28 = load i64* %xav_fill119, align 8, !tbaa !3
  br label %cond.end120

cond.end120:                                      ; preds = %cond.false117, %cond.true114
  %cond121 = phi i64 [ %conv116, %cond.true114 ], [ %28, %cond.false117 ]
  %add122 = shl i64 %cond121, 32
  %sext = add i64 %add122, 4294967296
  %conv124 = ashr exact i64 %sext, 32
  tail call void @Perl_sv_setiv(%struct.sv* %call109, i64 %conv124) #7
  %incdec.ptr125 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call109, %struct.sv** %incdec.ptr125, align 8, !tbaa !0
  br label %if.end127

if.end127:                                        ; preds = %cond.end62, %if.end35, %cond.end120, %if.end103
  %sp.2 = phi %struct.sv** [ %add.ptr104, %if.end103 ], [ %incdec.ptr125, %cond.end120 ], [ %sp.0, %if.end35 ], [ %sp.0, %cond.end62 ]
  store %struct.sv** %sp.2, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %29 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next128 = getelementptr inbounds %struct.op* %29, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end127, %if.end31, %if.then9
  %retval.0.in = phi %struct.op** [ %op_next, %if.then9 ], [ %op_next33, %if.end31 ], [ %op_next128, %if.end127 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_save_clearsv(%struct.sv**) #1

; Function Attrs: optsize
declare i32 @Perl_is_lvalue_sub() #1

; Function Attrs: optsize
declare i32 @Perl_dowantarray() #1

; Function Attrs: optsize
declare void @Perl_croak(i8*, ...) #1

; Function Attrs: optsize
declare i32 @Perl_mg_size(%struct.sv*) #1

; Function Attrs: optsize
declare %struct.sv** @Perl_av_fetch(%struct.av*, i32, i32) #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) #3

; Function Attrs: optsize
declare %struct.sv* @Perl_sv_newmortal() #1

; Function Attrs: optsize
declare void @Perl_sv_setiv(%struct.sv*, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_padhv() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sp.0 = phi %struct.sv** [ %call, %if.then ], [ %0, %entry ]
  %incdec.ptr = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  %6 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !1
  %tobool = icmp slt i8 %7, 0
  br i1 %tobool, label %if.then1, label %if.end4

if.then1:                                         ; preds = %if.end
  %op_targ2 = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %8 = load i64* %op_targ2, align 8, !tbaa !3
  %9 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx3 = getelementptr inbounds %struct.sv** %9, i64 %8
  tail call void @Perl_save_clearsv(%struct.sv** %arrayidx3) #7
  %.pre = load %struct.op** @PL_op, align 8, !tbaa !0
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %if.end
  %10 = phi %struct.op* [ %.pre, %if.then1 ], [ %6, %if.end ]
  %op_flags = getelementptr inbounds %struct.op* %10, i64 0, i32 6
  %11 = load i8* %op_flags, align 1, !tbaa !1
  %and6 = and i8 %11, 16
  %tobool7 = icmp eq i8 %and6, 0
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %if.end4
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %10, i64 0, i32 0
  %12 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.else:                                          ; preds = %if.end4
  %op_private9 = getelementptr inbounds %struct.op* %10, i64 0, i32 7
  %13 = load i8* %op_private9, align 1, !tbaa !1
  %and11 = and i8 %13, 8
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %if.end33, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %call13 = tail call i32 @Perl_is_lvalue_sub() #7
  %tobool14 = icmp eq i32 %call13, 0
  %.pre86 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags34.phi.trans.insert = getelementptr inbounds %struct.op* %.pre86, i64 0, i32 6
  %.pre87 = load i8* %op_flags34.phi.trans.insert, align 1, !tbaa !1
  br i1 %tobool14, label %if.end33, label %if.then15

if.then15:                                        ; preds = %land.lhs.true
  %conv17 = zext i8 %.pre87 to i32
  %and18 = and i32 %conv17, 3
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then15
  %cmp23 = icmp eq i32 %and18, 3
  %cond = zext i1 %cmp23 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then15
  %call25 = tail call i32 @Perl_dowantarray() #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond26 = phi i32 [ %cond, %cond.true ], [ %call25, %cond.false ]
  %cmp27 = icmp eq i32 %cond26, 0
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %cond.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([43 x i8]* @.str1, i64 0, i64 0)) #7
  br label %if.end30

if.end30:                                         ; preds = %cond.end, %if.then29
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next31 = getelementptr inbounds %struct.op* %14, i64 0, i32 0
  %15 = load %struct.op** %op_next31, align 8, !tbaa !0
  br label %return

if.end33:                                         ; preds = %land.lhs.true, %if.else
  %16 = phi i8 [ %11, %if.else ], [ %.pre87, %land.lhs.true ]
  %conv35 = zext i8 %16 to i32
  %and36 = and i32 %conv35, 3
  switch i32 %and36, label %cond.end60 [
    i32 1, label %if.end72
    i32 2, label %if.then69
    i32 3, label %if.then64
  ]

cond.end60:                                       ; preds = %if.end33
  %call55 = tail call i32 @Perl_block_gimme() #7
  switch i32 %call55, label %if.end72 [
    i32 1, label %if.then64
    i32 0, label %if.then69
  ]

if.then64:                                        ; preds = %if.end33, %cond.end60
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %call65 = tail call %struct.op* @Perl_do_kv() #7
  br label %return

if.then69:                                        ; preds = %if.end33, %cond.end60
  %17 = bitcast %struct.sv* %4 to %struct.hv*
  %call70 = tail call %struct.sv* @Perl_hv_scalar(%struct.hv* %17) #7
  store %struct.sv* %call70, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %if.end72

if.end72:                                         ; preds = %cond.end60, %if.end33, %if.then69
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %18 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next73 = getelementptr inbounds %struct.op* %18, i64 0, i32 0
  %19 = load %struct.op** %op_next73, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end72, %if.then64, %if.end30, %if.then8
  %retval.0 = phi %struct.op* [ %12, %if.then8 ], [ %15, %if.end30 ], [ %call65, %if.then64 ], [ %19, %if.end72 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.op* @Perl_do_kv() #1

; Function Attrs: optsize
declare %struct.sv* @Perl_hv_scalar(%struct.hv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_padany() #0 {
entry:
  %call = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([17 x i8]* @.str2, i64 0, i64 0), i32 128) #7
  ret %struct.op* %call
}

; Function Attrs: optsize
declare %struct.op* @Perl_die(i8*, ...) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_rv2gv() #0 {
entry:
  %len = alloca i64, align 8
  %len70 = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 524288
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else37, label %wasref

wasref:                                           ; preds = %if.then45, %if.end121, %entry, %if.then128
  %3 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool1 = icmp eq i64 %3, 0
  br i1 %tobool1, label %if.end19, label %if.then2

if.then2:                                         ; preds = %wasref
  %4 = load %struct.sv** %0, align 8, !tbaa !0
  br label %am_again

am_again:                                         ; preds = %land.lhs.true12, %if.then2
  %arg.0 = phi %struct.sv* [ %4, %if.then2 ], [ %call, %land.lhs.true12 ]
  %sv.0 = phi %struct.sv* [ %1, %if.then2 ], [ %call, %land.lhs.true12 ]
  %sp.0 = phi %struct.sv** [ %0, %if.then2 ], [ %6, %land.lhs.true12 ]
  %sv_flags3 = getelementptr inbounds %struct.sv* %arg.0, i64 0, i32 2
  %5 = load i32* %sv_flags3, align 4, !tbaa !4
  %and4 = and i32 %5, 268435456
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.end19, label %land.lhs.true

land.lhs.true:                                    ; preds = %am_again
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %arg.0, %struct.sv* @PL_sv_undef, i32 61, i32 9) #7
  %tobool6 = icmp eq %struct.sv* %call, null
  br i1 %tobool6, label %if.end19, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %call, i64 0, i32 2
  %7 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %7, 524288
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then7
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([50 x i8]* @.str3, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then11
  %cmp = icmp eq %struct.sv* %call, %arg.0
  br i1 %cmp, label %if.end19, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %call, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %8 to %struct.sv**
  %9 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any13 = getelementptr inbounds %struct.sv* %arg.0, i64 0, i32 0
  %10 = load i8** %sv_any13, align 8, !tbaa !0
  %xrv_rv14 = bitcast i8* %10 to %struct.sv**
  %11 = load %struct.sv** %xrv_rv14, align 8, !tbaa !0
  %cmp15 = icmp eq %struct.sv* %9, %11
  br i1 %cmp15, label %if.end19, label %am_again

if.end19:                                         ; preds = %land.lhs.true12, %if.end, %land.lhs.true, %am_again, %wasref
  %sv.1 = phi %struct.sv* [ %1, %wasref ], [ %call, %land.lhs.true12 ], [ %arg.0, %if.end ], [ %sv.0, %land.lhs.true ], [ %sv.0, %am_again ]
  %sp.1 = phi %struct.sv** [ %0, %wasref ], [ %6, %land.lhs.true12 ], [ %6, %if.end ], [ %sp.0, %land.lhs.true ], [ %sp.0, %am_again ]
  %sv_any20 = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 0
  %12 = load i8** %sv_any20, align 8, !tbaa !0
  %xrv_rv21 = bitcast i8* %12 to %struct.sv**
  %13 = load %struct.sv** %xrv_rv21, align 8, !tbaa !0
  %sv_flags22 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags22, align 4, !tbaa !4
  %and23 = and i32 %14, 255
  switch i32 %and23, label %if.then33 [
    i32 15, label %if.then25
    i32 13, label %if.end216
  ]

if.then25:                                        ; preds = %if.end19
  %call26 = call %struct.sv* @Perl_sv_newmortal() #7
  %15 = bitcast %struct.sv* %call26 to %struct.gv*
  call void @Perl_gv_init(%struct.gv* %15, %struct.hv* null, i8* getelementptr inbounds ([1 x i8]* @.str4, i64 0, i64 0), i64 0, i32 0) #7
  %16 = bitcast %struct.sv* %13 to %struct.io*
  %sv_any27 = bitcast %struct.sv* %call26 to %struct.xpvgv**
  %17 = load %struct.xpvgv** %sv_any27, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %17, i64 0, i32 7
  %18 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_io = getelementptr inbounds %struct.gp* %18, i64 0, i32 2
  store %struct.io* %16, %struct.io** %gp_io, align 8, !tbaa !0
  store %struct.sv* %13, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool28 = icmp eq %struct.sv* %13, null
  br i1 %tobool28, label %if.end216, label %land.rhs

land.rhs:                                         ; preds = %if.then25
  %sv_refcnt = getelementptr inbounds %struct.sv* %13, i64 0, i32 1
  %19 = load i32* %sv_refcnt, align 4, !tbaa !4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !4
  br label %if.end216

if.then33:                                        ; preds = %if.end19
  %call34 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str5, i64 0, i64 0)) #7
  br label %return

if.else37:                                        ; preds = %entry
  %and39 = and i32 %2, 255
  %cmp40 = icmp eq i32 %and39, 13
  br i1 %cmp40, label %if.end216, label %if.then41

if.then41:                                        ; preds = %if.else37
  %and43 = and i32 %2, 8192
  %tobool44 = icmp eq i32 %and43, 0
  br i1 %tobool44, label %if.end52, label %if.then45

if.then45:                                        ; preds = %if.then41
  %call46 = call i32 @Perl_mg_get(%struct.sv* %1) #7
  %20 = load i32* %sv_flags, align 4, !tbaa !4
  %and48 = and i32 %20, 524288
  %tobool49 = icmp eq i32 %and48, 0
  br i1 %tobool49, label %if.end52, label %wasref

if.end52:                                         ; preds = %if.then45, %if.then41
  %21 = phi i32 [ %20, %if.then45 ], [ %2, %if.then41 ]
  %and54 = and i32 %21, 118423552
  %tobool55 = icmp ne i32 %and54, 0
  %cmp57 = icmp eq %struct.sv* %1, @PL_sv_undef
  %or.cond = or i1 %tobool55, %cmp57
  br i1 %or.cond, label %if.end170, label %if.then58

if.then58:                                        ; preds = %if.end52
  %and60 = and i32 %21, 8388608
  %tobool61 = icmp eq i32 %and60, 0
  br i1 %tobool61, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.then58
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #7
  br label %if.end63

if.end63:                                         ; preds = %if.then58, %if.then62
  %22 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %22, i64 0, i32 7
  %23 = load i8* %op_private, align 1, !tbaa !1
  %conv = zext i8 %23 to i32
  %and64 = and i32 %conv, 96
  %tobool65 = icmp eq i32 %and64, 0
  br i1 %tobool65, label %if.end131, label %if.then66

if.then66:                                        ; preds = %if.end63
  %24 = getelementptr inbounds %struct.op* %22, i64 0, i32 3
  %25 = load i64* %24, align 8, !tbaa !3
  %tobool68 = icmp eq i64 %25, 0
  br i1 %tobool68, label %if.else81, label %if.then69

if.then69:                                        ; preds = %if.then66
  %26 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx72 = getelementptr inbounds %struct.sv** %26, i64 %25
  %27 = load %struct.sv** %arrayidx72, align 8, !tbaa !0
  %sv_flags73 = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %28 = load i32* %sv_flags73, align 4, !tbaa !4
  %and74 = and i32 %28, 262144
  %cmp75 = icmp eq i32 %and74, 0
  br i1 %cmp75, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then69
  %sv_any77 = getelementptr inbounds %struct.sv* %27, i64 0, i32 0
  %29 = load i8** %sv_any77, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %29, i64 8
  %30 = bitcast i8* %xpv_cur to i64*
  %31 = load i64* %30, align 8, !tbaa !3
  store i64 %31, i64* %len70, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %29 to i8**
  %32 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.then69
  %call79 = call i8* @Perl_sv_2pv_flags(%struct.sv* %27, i64* %len70, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %32, %cond.true ], [ %call79, %cond.false ]
  %call80 = call %struct.sv* @Perl_newSV(i64 0) #7
  %33 = bitcast %struct.sv* %call80 to %struct.gv*
  %34 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_stash = getelementptr inbounds %struct.cop* %34, i64 0, i32 9
  %35 = load %struct.hv** %cop_stash, align 8, !tbaa !0
  %36 = load i64* %len70, align 8, !tbaa !3
  call void @Perl_gv_init(%struct.gv* %33, %struct.hv* %35, i8* %cond, i64 %36, i32 0) #7
  br label %if.end91

if.else81:                                        ; preds = %if.then66
  %37 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_stash82 = getelementptr inbounds %struct.cop* %37, i64 0, i32 9
  %38 = load %struct.hv** %cop_stash82, align 8, !tbaa !0
  %tobool83 = icmp eq %struct.hv* %38, null
  br i1 %tobool83, label %cond.end88, label %cond.true84

cond.true84:                                      ; preds = %if.else81
  %39 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_stash85 = getelementptr inbounds %struct.cop* %39, i64 0, i32 9
  %40 = load %struct.hv** %cop_stash85, align 8, !tbaa !0
  %sv_any86 = getelementptr inbounds %struct.hv* %40, i64 0, i32 0
  %41 = load %struct.xpvhv** %sv_any86, align 8, !tbaa !0
  %xhv_name = getelementptr inbounds %struct.xpvhv* %41, i64 0, i32 10
  %42 = load i8** %xhv_name, align 8, !tbaa !0
  br label %cond.end88

cond.end88:                                       ; preds = %if.else81, %cond.true84
  %cond89 = phi i8* [ %42, %cond.true84 ], [ null, %if.else81 ]
  %call90 = call %struct.gv* @Perl_newGVgen(i8* %cond89) #7
  br label %if.end91

if.end91:                                         ; preds = %cond.end88, %cond.end
  %gv67.0 = phi %struct.gv* [ %33, %cond.end ], [ %call90, %cond.end88 ]
  %43 = load i32* %sv_flags, align 4, !tbaa !4
  %and93 = and i32 %43, 255
  %cmp94 = icmp ult i32 %and93, 3
  br i1 %cmp94, label %if.then96, label %if.end98

if.then96:                                        ; preds = %if.end91
  %call97 = call signext i8 @Perl_sv_upgrade(%struct.sv* %1, i32 3) #7
  br label %if.end98

if.end98:                                         ; preds = %if.then96, %if.end91
  %sv_any99 = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %44 = load i8** %sv_any99, align 8, !tbaa !0
  %xpv_pv100 = bitcast i8* %44 to i8**
  %45 = load i8** %xpv_pv100, align 8, !tbaa !0
  %tobool101 = icmp eq i8* %45, null
  br i1 %tobool101, label %if.end121, label %if.then102

if.then102:                                       ; preds = %if.end98
  %46 = load i32* %sv_flags, align 4, !tbaa !4
  %and104 = and i32 %46, 2097152
  %tobool105 = icmp eq i32 %and104, 0
  br i1 %tobool105, label %land.end109, label %land.rhs106

land.rhs106:                                      ; preds = %if.then102
  %call107 = call i32 @Perl_sv_backoff(%struct.sv* %1) #7
  %.pre = load i8** %sv_any99, align 8, !tbaa !0
  br label %land.end109

land.end109:                                      ; preds = %if.then102, %land.rhs106
  %47 = phi i8* [ %44, %if.then102 ], [ %.pre, %land.rhs106 ]
  %xpv_len = getelementptr inbounds i8* %47, i64 16
  %48 = bitcast i8* %xpv_len to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  %tobool112 = icmp eq i64 %49, 0
  br i1 %tobool112, label %if.end116, label %if.then113

if.then113:                                       ; preds = %land.end109
  %xpv_pv115 = bitcast i8* %47 to i8**
  %50 = load i8** %xpv_pv115, align 8, !tbaa !0
  call void @Perl_safesysfree(i8* %50) #7
  %.pre284 = load i8** %sv_any99, align 8, !tbaa !0
  br label %if.end116

if.end116:                                        ; preds = %land.end109, %if.then113
  %51 = phi i8* [ %47, %land.end109 ], [ %.pre284, %if.then113 ]
  %xpv_cur118 = getelementptr inbounds i8* %51, i64 8
  call void @llvm.memset.p0i8.i64(i8* %xpv_cur118, i8 0, i64 16, i32 8, i1 false)
  br label %if.end121

if.end121:                                        ; preds = %if.end98, %if.end116
  %52 = phi i8* [ %51, %if.end116 ], [ %44, %if.end98 ]
  %53 = bitcast %struct.gv* %gv67.0 to %struct.sv*
  %xrv_rv123 = bitcast i8* %52 to %struct.sv**
  store %struct.sv* %53, %struct.sv** %xrv_rv123, align 8, !tbaa !0
  %54 = load i32* %sv_flags, align 4, !tbaa !4
  %or = or i32 %54, 524288
  store i32 %or, i32* %sv_flags, align 4, !tbaa !4
  %and126 = and i32 %54, 16384
  %tobool127 = icmp eq i32 %and126, 0
  br i1 %tobool127, label %wasref, label %if.then128

if.then128:                                       ; preds = %if.end121
  %call129 = call i32 @Perl_mg_set(%struct.sv* %1) #7
  br label %wasref

if.end131:                                        ; preds = %if.end63
  %op_flags = getelementptr inbounds %struct.op* %22, i64 0, i32 6
  %55 = load i8* %op_flags, align 1, !tbaa !1
  %and133 = and i8 %55, 16
  %tobool134 = icmp eq i8 %and133, 0
  br i1 %tobool134, label %lor.lhs.false, label %if.then139

lor.lhs.false:                                    ; preds = %if.end131
  %and137 = and i32 %conv, 2
  %tobool138 = icmp eq i32 %and137, 0
  br i1 %tobool138, label %if.end141, label %if.then139

if.then139:                                       ; preds = %lor.lhs.false, %if.end131
  %call140 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_usym, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8]* @.str6, i64 0, i64 0)) #7
  br label %return

if.end141:                                        ; preds = %lor.lhs.false
  %56 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %56, i64 0, i32 14
  %57 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp142 = icmp eq %struct.sv* %57, null
  br i1 %cmp142, label %lor.lhs.false160, label %land.lhs.true144

land.lhs.true144:                                 ; preds = %if.end141
  %58 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings145 = getelementptr inbounds %struct.cop* %58, i64 0, i32 14
  %59 = load %struct.sv** %cop_warnings145, align 8, !tbaa !0
  %cmp146 = icmp eq %struct.sv* %59, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp146, label %lor.lhs.false160, label %land.lhs.true148

land.lhs.true148:                                 ; preds = %land.lhs.true144
  %60 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings149 = getelementptr inbounds %struct.cop* %60, i64 0, i32 14
  %61 = load %struct.sv** %cop_warnings149, align 8, !tbaa !0
  %cmp150 = icmp eq %struct.sv* %61, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp150, label %if.then168, label %lor.lhs.false152

lor.lhs.false152:                                 ; preds = %land.lhs.true148
  %62 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings153 = getelementptr inbounds %struct.cop* %62, i64 0, i32 14
  %63 = load %struct.sv** %cop_warnings153, align 8, !tbaa !0
  %sv_any154 = getelementptr inbounds %struct.sv* %63, i64 0, i32 0
  %64 = load i8** %sv_any154, align 8, !tbaa !0
  %xpv_pv155 = bitcast i8* %64 to i8**
  %65 = load i8** %xpv_pv155, align 8, !tbaa !0
  %arrayidx156 = getelementptr inbounds i8* %65, i64 10
  %66 = load i8* %arrayidx156, align 1, !tbaa !1
  %and158 = and i8 %66, 4
  %tobool159 = icmp eq i8 %and158, 0
  br i1 %tobool159, label %lor.lhs.false160, label %if.then168

lor.lhs.false160:                                 ; preds = %lor.lhs.false152, %land.lhs.true144, %if.end141
  %67 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings161 = getelementptr inbounds %struct.cop* %67, i64 0, i32 14
  %68 = load %struct.sv** %cop_warnings161, align 8, !tbaa !0
  %cmp162 = icmp eq %struct.sv* %68, null
  br i1 %cmp162, label %land.lhs.true164, label %if.end169

land.lhs.true164:                                 ; preds = %lor.lhs.false160
  %69 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and166 = and i8 %69, 1
  %tobool167 = icmp eq i8 %and166, 0
  br i1 %tobool167, label %if.end169, label %if.then168

if.then168:                                       ; preds = %lor.lhs.false152, %land.lhs.true164, %land.lhs.true148
  call void @Perl_report_uninit() #7
  br label %if.end169

if.end169:                                        ; preds = %land.lhs.true164, %if.then168, %lor.lhs.false160
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %70 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %70, i64 0, i32 0
  %71 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end170:                                        ; preds = %if.end52
  %and172 = and i32 %21, 262144
  %cmp173 = icmp eq i32 %and172, 0
  br i1 %cmp173, label %cond.false180, label %cond.true175

cond.true175:                                     ; preds = %if.end170
  %sv_any176 = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %72 = load i8** %sv_any176, align 8, !tbaa !0
  %xpv_cur177 = getelementptr inbounds i8* %72, i64 8
  %73 = bitcast i8* %xpv_cur177 to i64*
  %74 = load i64* %73, align 8, !tbaa !3
  store i64 %74, i64* %len, align 8, !tbaa !3
  %xpv_pv179 = bitcast i8* %72 to i8**
  %75 = load i8** %xpv_pv179, align 8, !tbaa !0
  br label %cond.end182

cond.false180:                                    ; preds = %if.end170
  %call181 = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %len, i32 2) #7
  br label %cond.end182

cond.end182:                                      ; preds = %cond.false180, %cond.true175
  %cond183 = phi i8* [ %75, %cond.true175 ], [ %call181, %cond.false180 ]
  %76 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags184 = getelementptr inbounds %struct.op* %76, i64 0, i32 6
  %77 = load i8* %op_flags184, align 1, !tbaa !1
  %78 = and i8 %77, -96
  %79 = icmp eq i8 %78, -128
  br i1 %79, label %if.then193, label %if.else205

if.then193:                                       ; preds = %cond.end182
  %call194 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond183, i32 0, i32 13) #7
  %80 = bitcast %struct.gv* %call194 to %struct.sv*
  %tobool195 = icmp eq %struct.gv* %call194, null
  br i1 %tobool195, label %land.lhs.true196, label %if.end216

land.lhs.true196:                                 ; preds = %if.then193
  %81 = load i64* %len, align 8, !tbaa !3
  %call197 = call signext i8 @Perl_is_gv_magical(i8* %cond183, i64 %81, i32 0) #7
  %tobool198 = icmp eq i8 %call197, 0
  br i1 %tobool198, label %if.then202, label %lor.lhs.false199

lor.lhs.false199:                                 ; preds = %land.lhs.true196
  %call200 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond183, i32 1, i32 13) #7
  %82 = bitcast %struct.gv* %call200 to %struct.sv*
  %tobool201 = icmp eq %struct.gv* %call200, null
  br i1 %tobool201, label %if.then202, label %if.end216

if.then202:                                       ; preds = %lor.lhs.false199, %land.lhs.true196
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %83 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next203 = getelementptr inbounds %struct.op* %83, i64 0, i32 0
  %84 = load %struct.op** %op_next203, align 8, !tbaa !0
  br label %return

if.else205:                                       ; preds = %cond.end182
  %op_private206 = getelementptr inbounds %struct.op* %76, i64 0, i32 7
  %85 = load i8* %op_private206, align 1, !tbaa !1
  %and208 = and i8 %85, 2
  %tobool209 = icmp eq i8 %and208, 0
  br i1 %tobool209, label %if.end212, label %if.then210

if.then210:                                       ; preds = %if.else205
  %call211 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_symref, i64 0, i64 0), i8* %cond183, i8* getelementptr inbounds ([9 x i8]* @.str6, i64 0, i64 0)) #7
  br label %return

if.end212:                                        ; preds = %if.else205
  %call213 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond183, i32 1, i32 13) #7
  %86 = bitcast %struct.gv* %call213 to %struct.sv*
  br label %if.end216

if.end216:                                        ; preds = %if.end19, %land.rhs, %if.then25, %lor.lhs.false199, %if.then193, %if.else37, %if.end212
  %sv.2 = phi %struct.sv* [ %86, %if.end212 ], [ %80, %if.then193 ], [ %82, %lor.lhs.false199 ], [ %1, %if.else37 ], [ %call26, %if.then25 ], [ %call26, %land.rhs ], [ %13, %if.end19 ]
  %sp.2 = phi %struct.sv** [ %0, %if.end212 ], [ %0, %if.then193 ], [ %0, %lor.lhs.false199 ], [ %0, %if.else37 ], [ %sp.1, %if.then25 ], [ %sp.1, %land.rhs ], [ %sp.1, %if.end19 ]
  %87 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private217 = getelementptr inbounds %struct.op* %87, i64 0, i32 7
  %88 = load i8* %op_private217, align 1, !tbaa !1
  %tobool220 = icmp slt i8 %88, 0
  br i1 %tobool220, label %if.then221, label %if.end226

if.then221:                                       ; preds = %if.end216
  %89 = bitcast %struct.sv* %sv.2 to %struct.gv*
  %op_flags222 = getelementptr inbounds %struct.op* %87, i64 0, i32 6
  %90 = load i8* %op_flags222, align 1, !tbaa !1
  %.lobit = lshr i8 %90, 7
  %91 = zext i8 %.lobit to i32
  %.not = xor i32 %91, 1
  call void @Perl_save_gp(%struct.gv* %89, i32 %.not) #7
  br label %if.end226

if.end226:                                        ; preds = %if.then221, %if.end216
  store %struct.sv* %sv.2, %struct.sv** %sp.2, align 8, !tbaa !0
  store %struct.sv** %sp.2, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %92 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next227 = getelementptr inbounds %struct.op* %92, i64 0, i32 0
  %93 = load %struct.op** %op_next227, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end226, %if.then210, %if.then202, %if.end169, %if.then139, %if.then33
  %retval.0 = phi %struct.op* [ %93, %if.end226 ], [ %call34, %if.then33 ], [ %call211, %if.then210 ], [ %84, %if.then202 ], [ %call140, %if.then139 ], [ %71, %if.end169 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_amagic_call(%struct.sv*, %struct.sv*, i32, i32) #1

; Function Attrs: optsize
declare void @Perl_gv_init(%struct.gv*, %struct.hv*, i8*, i64, i32) #1

; Function Attrs: optsize
declare i32 @Perl_mg_get(%struct.sv*) #1

; Function Attrs: optsize
declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i32) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_newSV(i64) #1

; Function Attrs: optsize
declare %struct.gv* @Perl_newGVgen(i8*) #1

; Function Attrs: optsize
declare signext i8 @Perl_sv_upgrade(%struct.sv*, i32) #1

; Function Attrs: optsize
declare i32 @Perl_sv_backoff(%struct.sv*) #1

; Function Attrs: optsize
declare void @Perl_safesysfree(i8*) #1

; Function Attrs: optsize
declare i32 @Perl_mg_set(%struct.sv*) #1

; Function Attrs: optsize
declare void @Perl_report_uninit() #1

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_fetchpv(i8*, i32, i32) #1

; Function Attrs: optsize
declare signext i8 @Perl_is_gv_magical(i8*, i64, i32) #1

; Function Attrs: optsize
declare void @Perl_save_gp(%struct.gv*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_rv2sv() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 524288
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %wasref

wasref:                                           ; preds = %if.then32, %entry
  %gv.0 = phi %struct.gv* [ null, %entry ], [ %15, %if.then32 ]
  %3 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool1 = icmp eq i64 %3, 0
  br i1 %tobool1, label %if.end19, label %if.then2

if.then2:                                         ; preds = %wasref
  %4 = load %struct.sv** %0, align 8, !tbaa !0
  br label %am_again

am_again:                                         ; preds = %land.lhs.true12, %if.then2
  %sp.0 = phi %struct.sv** [ %0, %if.then2 ], [ %6, %land.lhs.true12 ]
  %sv.0 = phi %struct.sv* [ %1, %if.then2 ], [ %call, %land.lhs.true12 ]
  %arg.0 = phi %struct.sv* [ %4, %if.then2 ], [ %call, %land.lhs.true12 ]
  %sv_flags3 = getelementptr inbounds %struct.sv* %arg.0, i64 0, i32 2
  %5 = load i32* %sv_flags3, align 4, !tbaa !4
  %and4 = and i32 %5, 268435456
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.end19, label %land.lhs.true

land.lhs.true:                                    ; preds = %am_again
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %arg.0, %struct.sv* @PL_sv_undef, i32 58, i32 9) #7
  %tobool6 = icmp eq %struct.sv* %call, null
  br i1 %tobool6, label %if.end19, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %call, i64 0, i32 2
  %7 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %7, 524288
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then7
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([50 x i8]* @.str3, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then11
  %cmp = icmp eq %struct.sv* %call, %arg.0
  br i1 %cmp, label %if.end19, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %call, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %8 to %struct.sv**
  %9 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any13 = getelementptr inbounds %struct.sv* %arg.0, i64 0, i32 0
  %10 = load i8** %sv_any13, align 8, !tbaa !0
  %xrv_rv14 = bitcast i8* %10 to %struct.sv**
  %11 = load %struct.sv** %xrv_rv14, align 8, !tbaa !0
  %cmp15 = icmp eq %struct.sv* %9, %11
  br i1 %cmp15, label %if.end19, label %am_again

if.end19:                                         ; preds = %land.lhs.true12, %if.end, %land.lhs.true, %am_again, %wasref
  %sp.1 = phi %struct.sv** [ %0, %wasref ], [ %6, %land.lhs.true12 ], [ %6, %if.end ], [ %sp.0, %land.lhs.true ], [ %sp.0, %am_again ]
  %sv.1 = phi %struct.sv* [ %1, %wasref ], [ %call, %land.lhs.true12 ], [ %arg.0, %if.end ], [ %sv.0, %land.lhs.true ], [ %sv.0, %am_again ]
  %sv_any20 = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 0
  %12 = load i8** %sv_any20, align 8, !tbaa !0
  %xrv_rv21 = bitcast i8* %12 to %struct.sv**
  %13 = load %struct.sv** %xrv_rv21, align 8, !tbaa !0
  %sv_flags22 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags22, align 4, !tbaa !4
  %and23 = and i32 %14, 255
  %and23.off = add i32 %and23, -10
  %switch = icmp ult i32 %and23.off, 3
  br i1 %switch, label %sw.bb, label %if.end121

sw.bb:                                            ; preds = %if.end19
  %call24 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([23 x i8]* @.str7, i64 0, i64 0)) #7
  br label %return

if.else:                                          ; preds = %entry
  %15 = bitcast %struct.sv* %1 to %struct.gv*
  %and26 = and i32 %2, 255
  %cmp27 = icmp eq i32 %and26, 13
  br i1 %cmp27, label %if.end119, label %if.then28

if.then28:                                        ; preds = %if.else
  %and30 = and i32 %2, 8192
  %tobool31 = icmp eq i32 %and30, 0
  br i1 %tobool31, label %if.end39, label %if.then32

if.then32:                                        ; preds = %if.then28
  %call33 = call i32 @Perl_mg_get(%struct.sv* %1) #7
  %16 = load i32* %sv_flags, align 4, !tbaa !4
  %and35 = and i32 %16, 524288
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %if.end39, label %wasref

if.end39:                                         ; preds = %if.then32, %if.then28
  %17 = phi i32 [ %16, %if.then32 ], [ %2, %if.then28 ]
  %and41 = and i32 %17, 118423552
  %tobool42 = icmp eq i32 %and41, 0
  br i1 %tobool42, label %if.then43, label %if.end79

if.then43:                                        ; preds = %if.end39
  %18 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %18, i64 0, i32 6
  %19 = load i8* %op_flags, align 1, !tbaa !1
  %and44 = and i8 %19, 16
  %tobool45 = icmp eq i8 %and44, 0
  br i1 %tobool45, label %lor.lhs.false, label %if.then49

lor.lhs.false:                                    ; preds = %if.then43
  %op_private = getelementptr inbounds %struct.op* %18, i64 0, i32 7
  %20 = load i8* %op_private, align 1, !tbaa !1
  %and47 = and i8 %20, 2
  %tobool48 = icmp eq i8 %and47, 0
  br i1 %tobool48, label %if.end51, label %if.then49

if.then49:                                        ; preds = %lor.lhs.false, %if.then43
  %call50 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_usym, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8]* @.str8, i64 0, i64 0)) #7
  br label %return

if.end51:                                         ; preds = %lor.lhs.false
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp52 = icmp eq %struct.sv* %22, null
  br i1 %cmp52, label %lor.lhs.false69, label %land.lhs.true54

land.lhs.true54:                                  ; preds = %if.end51
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings55 = getelementptr inbounds %struct.cop* %23, i64 0, i32 14
  %24 = load %struct.sv** %cop_warnings55, align 8, !tbaa !0
  %cmp56 = icmp eq %struct.sv* %24, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp56, label %lor.lhs.false69, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %land.lhs.true54
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings59 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings59, align 8, !tbaa !0
  %cmp60 = icmp eq %struct.sv* %26, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp60, label %if.then77, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %land.lhs.true58
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings63 = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings63, align 8, !tbaa !0
  %sv_any64 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %29 = load i8** %sv_any64, align 8, !tbaa !0
  %xpv_pv = bitcast i8* %29 to i8**
  %30 = load i8** %xpv_pv, align 8, !tbaa !0
  %arrayidx65 = getelementptr inbounds i8* %30, i64 10
  %31 = load i8* %arrayidx65, align 1, !tbaa !1
  %and67 = and i8 %31, 4
  %tobool68 = icmp eq i8 %and67, 0
  br i1 %tobool68, label %lor.lhs.false69, label %if.then77

lor.lhs.false69:                                  ; preds = %lor.lhs.false62, %land.lhs.true54, %if.end51
  %32 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings70 = getelementptr inbounds %struct.cop* %32, i64 0, i32 14
  %33 = load %struct.sv** %cop_warnings70, align 8, !tbaa !0
  %cmp71 = icmp eq %struct.sv* %33, null
  br i1 %cmp71, label %land.lhs.true73, label %if.end78

land.lhs.true73:                                  ; preds = %lor.lhs.false69
  %34 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and75 = and i8 %34, 1
  %tobool76 = icmp eq i8 %and75, 0
  br i1 %tobool76, label %if.end78, label %if.then77

if.then77:                                        ; preds = %lor.lhs.false62, %land.lhs.true73, %land.lhs.true58
  call void @Perl_report_uninit() #7
  br label %if.end78

if.end78:                                         ; preds = %land.lhs.true73, %if.then77, %lor.lhs.false69
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %35 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %35, i64 0, i32 0
  %36 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end79:                                         ; preds = %if.end39
  %and81 = and i32 %17, 262144
  %cmp82 = icmp eq i32 %and81, 0
  br i1 %cmp82, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end79
  %sv_any84 = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %37 = load i8** %sv_any84, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %37, i64 8
  %38 = bitcast i8* %xpv_cur to i64*
  %39 = load i64* %38, align 8, !tbaa !3
  store i64 %39, i64* %len, align 8, !tbaa !3
  %xpv_pv86 = bitcast i8* %37 to i8**
  %40 = load i8** %xpv_pv86, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.end79
  %call87 = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %len, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %40, %cond.true ], [ %call87, %cond.false ]
  %41 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags88 = getelementptr inbounds %struct.op* %41, i64 0, i32 6
  %42 = load i8* %op_flags88, align 1, !tbaa !1
  %43 = and i8 %42, -96
  %44 = icmp eq i8 %43, -128
  br i1 %44, label %if.then97, label %if.else109

if.then97:                                        ; preds = %cond.end
  %call98 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 0, i32 4) #7
  %tobool99 = icmp eq %struct.gv* %call98, null
  br i1 %tobool99, label %land.lhs.true100, label %if.end119

land.lhs.true100:                                 ; preds = %if.then97
  %45 = load i64* %len, align 8, !tbaa !3
  %call101 = call signext i8 @Perl_is_gv_magical(i8* %cond, i64 %45, i32 0) #7
  %tobool102 = icmp eq i8 %call101, 0
  br i1 %tobool102, label %if.then106, label %lor.lhs.false103

lor.lhs.false103:                                 ; preds = %land.lhs.true100
  %call104 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 1, i32 4) #7
  %tobool105 = icmp eq %struct.gv* %call104, null
  br i1 %tobool105, label %if.then106, label %if.end119

if.then106:                                       ; preds = %lor.lhs.false103, %land.lhs.true100
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %46 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next107 = getelementptr inbounds %struct.op* %46, i64 0, i32 0
  %47 = load %struct.op** %op_next107, align 8, !tbaa !0
  br label %return

if.else109:                                       ; preds = %cond.end
  %op_private110 = getelementptr inbounds %struct.op* %41, i64 0, i32 7
  %48 = load i8* %op_private110, align 1, !tbaa !1
  %and112 = and i8 %48, 2
  %tobool113 = icmp eq i8 %and112, 0
  br i1 %tobool113, label %if.end116, label %if.then114

if.then114:                                       ; preds = %if.else109
  %call115 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_symref, i64 0, i64 0), i8* %cond, i8* getelementptr inbounds ([9 x i8]* @.str8, i64 0, i64 0)) #7
  br label %return

if.end116:                                        ; preds = %if.else109
  %call117 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 1, i32 4) #7
  br label %if.end119

if.end119:                                        ; preds = %lor.lhs.false103, %if.then97, %if.else, %if.end116
  %gv.1 = phi %struct.gv* [ %call117, %if.end116 ], [ %call98, %if.then97 ], [ %call104, %lor.lhs.false103 ], [ %15, %if.else ]
  %sv_any120 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 0
  %49 = load %struct.xpvgv** %sv_any120, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %49, i64 0, i32 7
  %50 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_sv = getelementptr inbounds %struct.gp* %50, i64 0, i32 0
  %51 = load %struct.sv** %gp_sv, align 8, !tbaa !0
  br label %if.end121

if.end121:                                        ; preds = %if.end19, %if.end119
  %sp.2 = phi %struct.sv** [ %sp.1, %if.end19 ], [ %0, %if.end119 ]
  %sv.2 = phi %struct.sv* [ %13, %if.end19 ], [ %51, %if.end119 ]
  %gv.2 = phi %struct.gv* [ %gv.0, %if.end19 ], [ %gv.1, %if.end119 ]
  %52 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags122 = getelementptr inbounds %struct.op* %52, i64 0, i32 6
  %53 = load i8* %op_flags122, align 1, !tbaa !1
  %and124 = and i8 %53, 32
  %tobool125 = icmp eq i8 %and124, 0
  br i1 %tobool125, label %if.end155, label %if.then126

if.then126:                                       ; preds = %if.end121
  %op_private127 = getelementptr inbounds %struct.op* %52, i64 0, i32 7
  %54 = load i8* %op_private127, align 1, !tbaa !1
  %conv128 = zext i8 %54 to i32
  %and129 = and i32 %conv128, 128
  %tobool130 = icmp eq i32 %and129, 0
  br i1 %tobool130, label %if.else144, label %if.then131

if.then131:                                       ; preds = %if.then126
  %55 = getelementptr inbounds %struct.op* %52, i64 1, i32 0
  %56 = load %struct.op** %55, align 8, !tbaa !0
  %op_type = getelementptr inbounds %struct.op* %56, i64 0, i32 4
  %57 = load i16* %op_type, align 2, !tbaa !5
  %cmp133 = icmp eq i16 %57, 0
  br i1 %cmp133, label %if.then135, label %if.else137

if.then135:                                       ; preds = %if.then131
  %58 = load %struct.sv** %sp.2, align 8, !tbaa !0
  %59 = bitcast %struct.sv* %58 to %struct.gv*
  %call136 = call %struct.sv* @Perl_save_scalar(%struct.gv* %59) #7
  br label %if.end155

if.else137:                                       ; preds = %if.then131
  %tobool138 = icmp eq %struct.gv* %gv.2, null
  br i1 %tobool138, label %if.else141, label %if.then139

if.then139:                                       ; preds = %if.else137
  %call140 = call %struct.sv* @Perl_save_scalar(%struct.gv* %gv.2) #7
  br label %if.end155

if.else141:                                       ; preds = %if.else137
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([0 x i8]* @PL_no_localize_ref, i64 0, i64 0)) #7
  br label %if.end155

if.else144:                                       ; preds = %if.then126
  %and147 = and i32 %conv128, 96
  %tobool148 = icmp eq i32 %and147, 0
  br i1 %tobool148, label %if.end155, label %if.then149

if.then149:                                       ; preds = %if.else144
  call void @Perl_vivify_ref(%struct.sv* %sv.2, i32 %and147) #7
  br label %if.end155

if.end155:                                        ; preds = %if.else144, %if.end121, %if.then139, %if.else141, %if.then135, %if.then149
  %sv.3 = phi %struct.sv* [ %call136, %if.then135 ], [ %call140, %if.then139 ], [ %sv.2, %if.else141 ], [ %sv.2, %if.then149 ], [ %sv.2, %if.else144 ], [ %sv.2, %if.end121 ]
  store %struct.sv* %sv.3, %struct.sv** %sp.2, align 8, !tbaa !0
  store %struct.sv** %sp.2, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %60 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next156 = getelementptr inbounds %struct.op* %60, i64 0, i32 0
  %61 = load %struct.op** %op_next156, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end155, %if.then114, %if.then106, %if.end78, %if.then49, %sw.bb
  %retval.0 = phi %struct.op* [ %call24, %sw.bb ], [ %61, %if.end155 ], [ %call115, %if.then114 ], [ %47, %if.then106 ], [ %call50, %if.then49 ], [ %36, %if.end78 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_save_scalar(%struct.gv*) #1

; Function Attrs: optsize
declare void @Perl_vivify_ref(%struct.sv*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_av2arylen() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_any = bitcast %struct.sv* %1 to %struct.xpvav**
  %2 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_arylen = getelementptr inbounds %struct.xpvav* %2, i64 0, i32 8
  %3 = load %struct.sv** %xav_arylen, align 8, !tbaa !0
  %tobool = icmp eq %struct.sv* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.sv* @Perl_newSV(i64 0) #7
  %4 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_arylen2 = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 8
  store %struct.sv* %call, %struct.sv** %xav_arylen2, align 8, !tbaa !0
  %call3 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call, i32 1) #7
  tail call void @Perl_sv_magic(%struct.sv* %call, %struct.sv* %1, i32 35, i8* null, i32 0) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %sv.0 = phi %struct.sv* [ %3, %entry ], [ %call, %if.then ]
  store %struct.sv* %sv.0, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %5 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %5, i64 0, i32 0
  %6 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %6
}

; Function Attrs: optsize
declare void @Perl_sv_magic(%struct.sv*, %struct.sv*, i32, i8*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_pos() #0 {
entry:
  %i = alloca i32, align 4
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %6, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !1
  %and2 = and i8 %7, 8
  %tobool3 = icmp eq i8 %and2, 0
  br i1 %tobool3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call = call i32 @Perl_is_lvalue_sub() #7
  %tobool4 = icmp eq i32 %call, 0
  br i1 %tobool4, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and5 = and i32 %8, 255
  %cmp = icmp ult i32 %and5, 9
  br i1 %cmp, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %call8 = call signext i8 @Perl_sv_upgrade(%struct.sv* %4, i32 9) #7
  call void @Perl_sv_magic(%struct.sv* %4, %struct.sv* null, i32 46, i8* null, i32 0) #7
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then
  %sv_any = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %10 = getelementptr inbounds i8* %9, i64 80
  store i8 46, i8* %10, align 1, !tbaa !1
  %11 = load i8** %sv_any, align 8, !tbaa !0
  %xlv_targ = getelementptr inbounds i8* %11, i64 72
  %12 = bitcast i8* %xlv_targ to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !0
  %cmp10 = icmp eq %struct.sv* %13, %5
  br i1 %cmp10, label %if.end24, label %if.then12

if.then12:                                        ; preds = %if.end
  %tobool15 = icmp eq %struct.sv* %13, null
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.then12
  call void @Perl_sv_free(%struct.sv* %13) #7
  br label %if.end19

if.end19:                                         ; preds = %if.then12, %if.then16
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool20 = icmp eq %struct.sv* %5, null
  br i1 %tobool20, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end19
  %sv_refcnt = getelementptr inbounds %struct.sv* %5, i64 0, i32 1
  %14 = load i32* %sv_refcnt, align 4, !tbaa !4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !4
  br label %land.end

land.end:                                         ; preds = %if.end19, %land.rhs
  %15 = load i8** %sv_any, align 8, !tbaa !0
  %xlv_targ23 = getelementptr inbounds i8* %15, i64 72
  %16 = bitcast i8* %xlv_targ23 to %struct.sv**
  store %struct.sv* %5, %struct.sv** %16, align 8, !tbaa !0
  br label %if.end24

if.end24:                                         ; preds = %if.end, %land.end
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %17 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %17, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %sv_flags26 = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %18 = load i32* %sv_flags26, align 4, !tbaa !4
  %and27 = and i32 %18, 255
  %cmp28 = icmp ugt i32 %and27, 6
  br i1 %cmp28, label %land.lhs.true30, label %if.end61

land.lhs.true30:                                  ; preds = %if.else
  %sv_any31 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %19 = load i8** %sv_any31, align 8, !tbaa !0
  %xmg_magic = getelementptr inbounds i8* %19, i64 40
  %20 = bitcast i8* %xmg_magic to %struct.magic**
  %21 = load %struct.magic** %20, align 8, !tbaa !0
  %tobool32 = icmp eq %struct.magic* %21, null
  br i1 %tobool32, label %if.end61, label %if.then33

if.then33:                                        ; preds = %land.lhs.true30
  %call34 = call %struct.magic* @Perl_mg_find(%struct.sv* %5, i32 103) #7
  %tobool35 = icmp eq %struct.magic* %call34, null
  br i1 %tobool35, label %if.end61, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %if.then33
  %mg_len = getelementptr inbounds %struct.magic* %call34, i64 0, i32 7
  %22 = load i32* %mg_len, align 4, !tbaa !4
  %cmp37 = icmp sgt i32 %22, -1
  br i1 %cmp37, label %if.then39, label %if.end61

if.then39:                                        ; preds = %land.lhs.true36
  store i32 %22, i32* %i, align 4, !tbaa !4
  %23 = load i32* %sv_flags26, align 4, !tbaa !4
  %and42 = and i32 %23, 536870912
  %tobool43 = icmp eq i32 %and42, 0
  br i1 %tobool43, label %if.end50, label %land.lhs.true44

land.lhs.true44:                                  ; preds = %if.then39
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private45 = getelementptr inbounds %struct.cop* %24, i64 0, i32 7
  %25 = load i8* %op_private45, align 1, !tbaa !1
  %and47 = and i8 %25, 8
  %tobool48 = icmp eq i8 %and47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true44
  call void @Perl_sv_pos_b2u(%struct.sv* %5, i32* %i) #7
  br label %if.end50

if.end50:                                         ; preds = %land.lhs.true44, %if.then39, %if.then49
  %26 = load i32* %i, align 4, !tbaa !4
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %27, i64 0, i32 12
  %28 = load i32* %cop_arybase, align 4, !tbaa !4
  %add = add nsw i32 %28, %26
  %conv51 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %conv51) #7
  %sv_flags52 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %29 = load i32* %sv_flags52, align 4, !tbaa !4
  %and53 = and i32 %29, 16384
  %tobool54 = icmp eq i32 %and53, 0
  br i1 %tobool54, label %if.end57, label %if.then55

if.then55:                                        ; preds = %if.end50
  %call56 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end57

if.end57:                                         ; preds = %if.end50, %if.then55
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %30 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next59 = getelementptr inbounds %struct.op* %30, i64 0, i32 0
  br label %return

if.end61:                                         ; preds = %if.then33, %land.lhs.true30, %land.lhs.true36, %if.else
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %31 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next63 = getelementptr inbounds %struct.op* %31, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end61, %if.end57, %if.end24
  %retval.0.in = phi %struct.op** [ %op_next, %if.end24 ], [ %op_next59, %if.end57 ], [ %op_next63, %if.end61 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_free(%struct.sv*) #1

; Function Attrs: optsize
declare %struct.magic* @Perl_mg_find(%struct.sv*, i32) #1

; Function Attrs: optsize
declare void @Perl_sv_pos_b2u(%struct.sv*, i32*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_rv2cv() #0 {
entry:
  %gv = alloca %struct.gv*, align 8
  %stash = alloca %struct.hv*, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %2 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %2, i64 0, i32 6
  %3 = load i8* %op_flags, align 1, !tbaa !1
  %.lobit = lshr i8 %3, 7
  %4 = zext i8 %.lobit to i32
  %.not = xor i32 %4, 1
  %call = call %struct.cv* @Perl_sv_2cv(%struct.sv* %1, %struct.hv** %stash, %struct.gv** %gv, i32 %.not) #7
  %tobool1 = icmp eq %struct.cv* %call, null
  br i1 %tobool1, label %if.end35, label %if.then

if.then:                                          ; preds = %entry
  %sv_any = getelementptr inbounds %struct.cv* %call, i64 0, i32 0
  %5 = load %struct.xpvcv** %sv_any, align 8, !tbaa !0
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %5, i64 0, i32 17
  %6 = load i16* %xcv_flags, align 2, !tbaa !5
  %and3 = and i16 %6, 1
  %tobool4 = icmp eq i16 %and3, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %call6 = call %struct.cv* @Perl_cv_clone(%struct.cv* %call) #7
  %7 = bitcast %struct.cv* %call6 to %struct.sv*
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %7) #7
  %8 = bitcast %struct.sv* %call7 to %struct.cv*
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then5
  %cv.0 = phi %struct.cv* [ %8, %if.then5 ], [ %call, %if.then ]
  %9 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %9, i64 0, i32 7
  %10 = load i8* %op_private, align 1, !tbaa !1
  %tobool10 = icmp slt i8 %10, 0
  br i1 %tobool10, label %if.then11, label %if.end35

if.then11:                                        ; preds = %if.end
  %11 = load %struct.gv** %gv, align 8, !tbaa !0
  %tobool12 = icmp eq %struct.gv* %11, null
  br i1 %tobool12, label %if.end25, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then11
  %sv_any13 = getelementptr inbounds %struct.gv* %11, i64 0, i32 0
  %12 = load %struct.xpvgv** %sv_any13, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 7
  %13 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_cv = getelementptr inbounds %struct.gp* %13, i64 0, i32 7
  %14 = load %struct.cv** %gp_cv, align 8, !tbaa !0
  %cmp = icmp eq %struct.cv* %14, %cv.0
  br i1 %cmp, label %land.lhs.true15, label %if.end25

land.lhs.true15:                                  ; preds = %land.lhs.true
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 10
  %15 = load %struct.hv** %xgv_stash, align 8, !tbaa !0
  %xgv_name = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 8
  %16 = load i8** %xgv_name, align 8, !tbaa !0
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %12, i64 0, i32 9
  %17 = load i64* %xgv_namelen, align 8, !tbaa !3
  %call19 = call %struct.gv* @Perl_gv_autoload4(%struct.hv* %15, i8* %16, i64 %17, i32 0) #7
  store %struct.gv* %call19, %struct.gv** %gv, align 8, !tbaa !0
  %tobool20 = icmp eq %struct.gv* %call19, null
  br i1 %tobool20, label %if.end25, label %if.then21

if.then21:                                        ; preds = %land.lhs.true15
  %sv_any22 = getelementptr inbounds %struct.gv* %call19, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any22, align 8, !tbaa !0
  %xgv_gp23 = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp23, align 8, !tbaa !0
  %gp_cv24 = getelementptr inbounds %struct.gp* %19, i64 0, i32 7
  %20 = load %struct.cv** %gp_cv24, align 8, !tbaa !0
  br label %if.end25

if.end25:                                         ; preds = %land.lhs.true15, %if.then11, %if.then21, %land.lhs.true
  %cv.1 = phi %struct.cv* [ %20, %if.then21 ], [ %cv.0, %land.lhs.true15 ], [ %cv.0, %land.lhs.true ], [ %cv.0, %if.then11 ]
  %sv_any26 = getelementptr inbounds %struct.cv* %cv.1, i64 0, i32 0
  %21 = load %struct.xpvcv** %sv_any26, align 8, !tbaa !0
  %xcv_flags27 = getelementptr inbounds %struct.xpvcv* %21, i64 0, i32 17
  %22 = load i16* %xcv_flags27, align 2, !tbaa !5
  %and29 = and i16 %22, 256
  %tobool30 = icmp eq i16 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.end35

if.then31:                                        ; preds = %if.end25
  %call32 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([40 x i8]* @.str9, i64 0, i64 0)) #7
  br label %return

if.end35:                                         ; preds = %entry, %if.end25, %if.end
  %cv.2 = phi %struct.cv* [ %cv.1, %if.end25 ], [ %cv.0, %if.end ], [ bitcast (%struct.sv* @PL_sv_undef to %struct.cv*), %entry ]
  %23 = bitcast %struct.cv* %cv.2 to %struct.sv*
  store %struct.sv* %23, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %24 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %24, i64 0, i32 0
  %25 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end35, %if.then31
  %retval.0 = phi %struct.op* [ %25, %if.end35 ], [ %call32, %if.then31 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.cv* @Perl_sv_2cv(%struct.sv*, %struct.hv**, %struct.gv**, i32) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

; Function Attrs: optsize
declare %struct.cv* @Perl_cv_clone(%struct.cv*) #1

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_autoload4(%struct.hv*, i8*, i64, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_prototype() #0 {
entry:
  %stash = alloca %struct.hv*, align 8
  %gv = alloca %struct.gv*, align 8
  %str = alloca [14 x i8], align 1
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 262144
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end91, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !3
  %cmp = icmp ugt i64 %5, 6
  br i1 %cmp, label %if.then, label %if.end91

if.then:                                          ; preds = %land.lhs.true
  %xpv_pv = bitcast i8* %3 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !0
  %call = call i32 @strncmp(i8* %6, i8* getelementptr inbounds ([7 x i8]* @.str10, i64 0, i64 0), i64 6) #7
  %tobool2 = icmp eq i32 %call, 0
  br i1 %tobool2, label %if.then3, label %if.end91

if.then3:                                         ; preds = %if.then
  %add.ptr = getelementptr inbounds i8* %6, i64 6
  %sub = add i64 %5, 4294967290
  %conv = trunc i64 %sub to i32
  %call6 = call i32 @Perl_keyword(i8* %add.ptr, i32 %conv) #7
  %cmp7 = icmp slt i32 %call6, 0
  br i1 %cmp7, label %if.then9, label %if.else83

if.then9:                                         ; preds = %if.then3
  %call6.off = add i32 %call6, 25
  %7 = icmp ult i32 %call6.off, 2
  br i1 %7, label %set, label %while.body

while.cond:                                       ; preds = %lor.lhs.false20
  %8 = trunc i64 %indvars.iv.next to i32
  %cmp15 = icmp slt i32 %8, 352
  br i1 %cmp15, label %while.body, label %nonesuch

while.body:                                       ; preds = %if.then9, %while.cond
  %indvars.iv = phi i64 [ %indvars.iv.next, %while.cond ], [ 0, %if.then9 ]
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_name, i64 0, i64 %indvars.iv
  %9 = load i8** %arrayidx, align 8, !tbaa !0
  %call18 = call i32 @strcmp(i8* %add.ptr, i8* %9) #7
  %tobool19 = icmp eq i32 %call18, 0
  br i1 %tobool19, label %found, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %while.body
  %arrayidx23 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %indvars.iv
  %10 = load i8** %arrayidx23, align 8, !tbaa !0
  %call24 = call i32 @strcmp(i8* %add.ptr, i8* %10) #7
  %tobool25 = icmp eq i32 %call24, 0
  %indvars.iv.next = add i64 %indvars.iv, 1
  br i1 %tobool25, label %found, label %while.cond

found:                                            ; preds = %lor.lhs.false20, %while.body
  %arrayidx29 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %indvars.iv
  %11 = load i32* %arrayidx29, align 4, !tbaa !4
  %shr = lshr i32 %11, 13
  %tobool31142 = icmp eq i32 %shr, 0
  %arraydecay.pre = getelementptr inbounds [14 x i8]* %str, i64 0, i64 0
  br i1 %tobool31142, label %while.end75, label %while.body32

while.body32:                                     ; preds = %found, %if.end67
  %oa.0145 = phi i32 [ %shr74, %if.end67 ], [ %shr, %found ]
  %seen_question.0144 = phi i32 [ %seen_question.1, %if.end67 ], [ 0, %found ]
  %n.0143 = phi i32 [ %inc71, %if.end67 ], [ 0, %found ]
  %and33 = and i32 %oa.0145, 8
  %tobool34 = icmp ne i32 %and33, 0
  %tobool36 = icmp eq i32 %seen_question.0144, 0
  %or.cond = and i1 %tobool34, %tobool36
  br i1 %or.cond, label %if.then37, label %if.else

if.then37:                                        ; preds = %while.body32
  %inc38 = add nsw i32 %n.0143, 1
  %idxprom39 = sext i32 %n.0143 to i64
  %arrayidx40 = getelementptr inbounds [14 x i8]* %str, i64 0, i64 %idxprom39
  store i8 59, i8* %arrayidx40, align 1, !tbaa !1
  br label %if.end51

if.else:                                          ; preds = %while.body32
  %tobool41 = icmp eq i32 %n.0143, 0
  br i1 %tobool41, label %if.end51, label %land.lhs.true42

land.lhs.true42:                                  ; preds = %if.else
  %12 = load i8* %arraydecay.pre, align 1, !tbaa !1
  %cmp45 = icmp ne i8 %12, 59
  %or.cond139 = or i1 %cmp45, %tobool36
  br i1 %or.cond139, label %if.end51, label %set

if.end51:                                         ; preds = %land.lhs.true42, %if.else, %if.then37
  %n.1 = phi i32 [ %n.0143, %land.lhs.true42 ], [ 0, %if.else ], [ %inc38, %if.then37 ]
  %seen_question.1 = phi i32 [ %seen_question.0144, %land.lhs.true42 ], [ %seen_question.0144, %if.else ], [ 1, %if.then37 ]
  %and52 = and i32 %oa.0145, 7
  switch i32 %and52, label %if.then63 [
    i32 6, label %if.end67
    i32 2, label %if.end67
    i32 1, label %if.end67
    i32 0, label %if.end67
  ]

if.then63:                                        ; preds = %if.end51
  %inc64 = add nsw i32 %n.1, 1
  %idxprom65 = sext i32 %n.1 to i64
  %arrayidx66 = getelementptr inbounds [14 x i8]* %str, i64 0, i64 %idxprom65
  store i8 92, i8* %arrayidx66, align 1, !tbaa !1
  br label %if.end67

if.end67:                                         ; preds = %if.end51, %if.end51, %if.end51, %if.end51, %if.then63
  %n.2 = phi i32 [ %inc64, %if.then63 ], [ %n.1, %if.end51 ], [ %n.1, %if.end51 ], [ %n.1, %if.end51 ], [ %n.1, %if.end51 ]
  %idxprom69138 = zext i32 %and52 to i64
  %arrayidx70 = getelementptr inbounds [9 x i8]* @.str11, i64 0, i64 %idxprom69138
  %13 = load i8* %arrayidx70, align 1, !tbaa !1
  %inc71 = add nsw i32 %n.2, 1
  %idxprom72 = sext i32 %n.2 to i64
  %arrayidx73 = getelementptr inbounds [14 x i8]* %str, i64 0, i64 %idxprom72
  store i8 %13, i8* %arrayidx73, align 1, !tbaa !1
  %shr74 = ashr i32 %oa.0145, 4
  %tobool31 = icmp eq i32 %shr74, 0
  br i1 %tobool31, label %while.cond30.while.end75_crit_edge, label %while.body32

while.cond30.while.end75_crit_edge:               ; preds = %if.end67
  %phitmp = sext i32 %inc71 to i64
  br label %while.end75

while.end75:                                      ; preds = %found, %while.cond30.while.end75_crit_edge
  %n.0.lcssa = phi i64 [ %phitmp, %while.cond30.while.end75_crit_edge ], [ 0, %found ]
  %arrayidx78 = getelementptr inbounds [14 x i8]* %str, i64 0, i64 %n.0.lcssa
  store i8 0, i8* %arrayidx78, align 1, !tbaa !1
  %call81 = call %struct.sv* @Perl_newSVpvn(i8* %arraydecay.pre, i64 %n.0.lcssa) #7
  %call82 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call81) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  br label %if.end91

if.else83:                                        ; preds = %if.then3
  %tobool84 = icmp eq i32 %call6, 0
  br i1 %tobool84, label %nonesuch, label %set

nonesuch:                                         ; preds = %while.cond, %if.else83
  %call88 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([32 x i8]* @.str12, i64 0, i64 0), i8* %add.ptr) #7
  br label %return

if.end91:                                         ; preds = %if.then, %entry, %while.end75, %land.lhs.true
  %14 = phi %struct.sv* [ %1, %if.then ], [ %.pre, %while.end75 ], [ %1, %land.lhs.true ], [ %1, %entry ]
  %ret.0 = phi %struct.sv* [ @PL_sv_undef, %if.then ], [ %call82, %while.end75 ], [ @PL_sv_undef, %land.lhs.true ], [ @PL_sv_undef, %entry ]
  %call92 = call %struct.cv* @Perl_sv_2cv(%struct.sv* %14, %struct.hv** %stash, %struct.gv** %gv, i32 0) #7
  %tobool93 = icmp eq %struct.cv* %call92, null
  br i1 %tobool93, label %set, label %land.lhs.true94

land.lhs.true94:                                  ; preds = %if.end91
  %sv_flags95 = getelementptr inbounds %struct.cv* %call92, i64 0, i32 2
  %15 = load i32* %sv_flags95, align 4, !tbaa !4
  %and96 = and i32 %15, 262144
  %tobool97 = icmp eq i32 %and96, 0
  br i1 %tobool97, label %set, label %if.then98

if.then98:                                        ; preds = %land.lhs.true94
  %sv_any99 = getelementptr inbounds %struct.cv* %call92, i64 0, i32 0
  %16 = load %struct.xpvcv** %sv_any99, align 8, !tbaa !0
  %xpv_pv100 = getelementptr inbounds %struct.xpvcv* %16, i64 0, i32 0
  %17 = load i8** %xpv_pv100, align 8, !tbaa !0
  %18 = getelementptr inbounds %struct.xpvcv* %16, i64 0, i32 1
  %19 = load i64* %18, align 8, !tbaa !3
  %call103 = call %struct.sv* @Perl_newSVpvn(i8* %17, i64 %19) #7
  %call104 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call103) #7
  br label %set

set:                                              ; preds = %land.lhs.true42, %if.else83, %land.lhs.true94, %if.end91, %if.then98, %if.then9
  %ret.1 = phi %struct.sv* [ %call104, %if.then98 ], [ %ret.0, %land.lhs.true94 ], [ %ret.0, %if.end91 ], [ @PL_sv_undef, %if.then9 ], [ @PL_sv_undef, %if.else83 ], [ @PL_sv_undef, %land.lhs.true42 ]
  store %struct.sv* %ret.1, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %20, i64 0, i32 0
  %21 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %set, %nonesuch
  %retval.0 = phi %struct.op* [ %21, %set ], [ %call88, %nonesuch ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) #4

; Function Attrs: optsize
declare i32 @Perl_keyword(i8*, i32) #1

; Function Attrs: nounwind optsize readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) #4

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVpvn(i8*, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_anoncode() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = bitcast %struct.sv* %4 to %struct.cv*
  %sv_any = bitcast %struct.sv* %4 to %struct.xpvcv**
  %6 = load %struct.xpvcv** %sv_any, align 8, !tbaa !0
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %6, i64 0, i32 17
  %7 = load i16* %xcv_flags, align 2, !tbaa !5
  %and = and i16 %7, 1
  %tobool = icmp eq i16 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.cv* @Perl_cv_clone(%struct.cv* %5) #7
  %8 = bitcast %struct.cv* %call to %struct.sv*
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %8) #7
  %9 = bitcast %struct.sv* %call1 to %struct.cv*
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %cv.0 = phi %struct.cv* [ %9, %if.then ], [ %5, %entry ]
  %10 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %sp.0 = phi %struct.sv** [ %call4, %if.then3 ], [ %0, %if.end ]
  %11 = bitcast %struct.cv* %cv.0 to %struct.sv*
  %incdec.ptr = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %11, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %12 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %12, i64 0, i32 0
  %13 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %13
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_srefgen() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %call = tail call fastcc %struct.sv* @S_refto(%struct.sv* %1) #8
  store %struct.sv* %call, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %2 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %2, i64 0, i32 0
  %3 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %3
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.sv* @S_refto(%struct.sv* %sv) #0 {
entry:
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %0 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %0, 255
  switch i32 %and, label %if.else38 [
    i32 9, label %land.lhs.true
    i32 10, label %if.then16
  ]

land.lhs.true:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %sv, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !0
  %2 = getelementptr inbounds i8* %1, i64 80
  %3 = load i8* %2, align 1, !tbaa !1
  %cmp1 = icmp eq i8 %3, 121
  br i1 %cmp1, label %if.then, label %if.else38

if.then:                                          ; preds = %land.lhs.true
  %xlv_targlen = getelementptr inbounds i8* %1, i64 64
  %4 = bitcast i8* %xlv_targlen to i64*
  %5 = load i64* %4, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  tail call void @Perl_vivify_defelem(%struct.sv* %sv) #7
  %.pre = load i8** %sv_any, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then4
  %6 = phi i8* [ %1, %if.then ], [ %.pre, %if.then4 ]
  %xlv_targ = getelementptr inbounds i8* %6, i64 72
  %7 = bitcast i8* %xlv_targ to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !0
  %tobool6 = icmp eq %struct.sv* %8, null
  br i1 %tobool6, label %if.end55, label %if.else

if.else:                                          ; preds = %if.end
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_refcnt = getelementptr inbounds %struct.sv* %8, i64 0, i32 1
  %9 = load i32* %sv_refcnt, align 4, !tbaa !4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !4
  br label %if.end55

if.then16:                                        ; preds = %entry
  %sv_any17 = bitcast %struct.sv* %sv to %struct.xpvav**
  %10 = load %struct.xpvav** %sv_any17, align 8, !tbaa !0
  %xav_flags = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 9
  %11 = load i8* %xav_flags, align 1, !tbaa !1
  %12 = and i8 %11, 3
  %13 = icmp eq i8 %12, 2
  br i1 %13, label %if.end28.thread, label %if.end28

if.end28.thread:                                  ; preds = %if.then16
  %14 = bitcast %struct.sv* %sv to %struct.av*
  tail call void @Perl_av_reify(%struct.av* %14) #7
  %.pre77 = load i32* %sv_flags, align 4, !tbaa !4
  %and3079 = and i32 %.pre77, -2049
  store i32 %and3079, i32* %sv_flags, align 4, !tbaa !4
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !0
  br label %land.rhs32

if.end28:                                         ; preds = %if.then16
  %and30 = and i32 %0, -2049
  store i32 %and30, i32* %sv_flags, align 4, !tbaa !4
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool31 = icmp eq %struct.sv* %sv, null
  br i1 %tobool31, label %if.end55, label %land.rhs32

land.rhs32:                                       ; preds = %if.end28.thread, %if.end28
  %sv_refcnt33 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %15 = load i32* %sv_refcnt33, align 4, !tbaa !4
  %inc34 = add i32 %15, 1
  store i32 %inc34, i32* %sv_refcnt33, align 4, !tbaa !4
  br label %if.end55

if.else38:                                        ; preds = %entry, %land.lhs.true
  %and40 = and i32 %0, 512
  %tobool41 = icmp eq i32 %and40, 0
  br i1 %tobool41, label %if.else43, label %if.then42

if.then42:                                        ; preds = %if.else38
  %call = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %sv) #7
  br label %if.end55

if.else43:                                        ; preds = %if.else38
  %and45 = and i32 %0, -2049
  store i32 %and45, i32* %sv_flags, align 4, !tbaa !4
  store %struct.sv* %sv, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool46 = icmp eq %struct.sv* %sv, null
  br i1 %tobool46, label %if.end55, label %land.rhs47

land.rhs47:                                       ; preds = %if.else43
  %sv_refcnt48 = getelementptr inbounds %struct.sv* %sv, i64 0, i32 1
  %16 = load i32* %sv_refcnt48, align 4, !tbaa !4
  %inc49 = add i32 %16, 1
  store i32 %inc49, i32* %sv_refcnt48, align 4, !tbaa !4
  br label %if.end55

if.end55:                                         ; preds = %if.end, %land.rhs47, %if.else43, %land.rhs32, %if.end28, %if.then42, %if.else
  %sv.addr.0 = phi %struct.sv* [ %8, %if.else ], [ %call, %if.then42 ], [ @PL_sv_undef, %if.end ], [ null, %if.end28 ], [ %sv, %land.rhs32 ], [ null, %if.else43 ], [ %sv, %land.rhs47 ]
  %call56 = tail call %struct.sv* @Perl_sv_newmortal() #7
  %call57 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call56, i32 3) #7
  %sv_any58 = getelementptr inbounds %struct.sv* %call56, i64 0, i32 0
  %17 = load i8** %sv_any58, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %17 to %struct.sv**
  store %struct.sv* %sv.addr.0, %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_flags59 = getelementptr inbounds %struct.sv* %call56, i64 0, i32 2
  %18 = load i32* %sv_flags59, align 4, !tbaa !4
  %or = or i32 %18, 524288
  store i32 %or, i32* %sv_flags59, align 4, !tbaa !4
  ret %struct.sv* %call56
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_refgen() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %cmp = icmp eq i32 %and, 3
  %cond = zext i1 %cmp to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call i32 @Perl_dowantarray() #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond5 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp6 = icmp eq i32 %cond5, 1
  br i1 %cmp6, label %if.end13, label %if.then

if.then:                                          ; preds = %cond.end
  %add.ptr.sum = add i64 %idx.ext, 1
  %incdec.ptr8 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %cmp9 = icmp ugt %struct.sv** %incdec.ptr8, %0
  br i1 %cmp9, label %if.end, label %if.then11

if.then11:                                        ; preds = %if.then
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then11
  %storemerge = phi %struct.sv* [ %6, %if.then11 ], [ @PL_sv_undef, %if.then ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr8, align 8, !tbaa !0
  %call12 = tail call fastcc %struct.sv* @S_refto(%struct.sv* %storemerge) #8
  store %struct.sv* %call12, %struct.sv** %incdec.ptr8, align 8, !tbaa !0
  br label %return

if.end13:                                         ; preds = %cond.end
  %7 = load i32* @PL_tmps_ix, align 4, !tbaa !4
  %conv14 = sext i32 %7 to i64
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 3
  %add = add nsw i64 %conv14, %sub.ptr.div
  %8 = load i32* @PL_tmps_max, align 4, !tbaa !4
  %conv15 = sext i32 %8 to i64
  %cmp16 = icmp slt i64 %add, %conv15
  br i1 %cmp16, label %while.cond.preheader, label %if.then18

if.then18:                                        ; preds = %if.end13
  %conv23 = trunc i64 %sub.ptr.div to i32
  tail call void @Perl_tmps_grow(i32 %conv23) #7
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then18, %if.end13
  %add.ptr.sum50 = add i64 %idx.ext, 1
  %incdec.ptr2547 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum50
  %cmp2648 = icmp ugt %struct.sv** %incdec.ptr2547, %0
  br i1 %cmp2648, label %return, label %while.body

while.body:                                       ; preds = %while.cond.preheader, %while.body
  %incdec.ptr2549 = phi %struct.sv** [ %incdec.ptr25, %while.body ], [ %incdec.ptr2547, %while.cond.preheader ]
  %9 = load %struct.sv** %incdec.ptr2549, align 8, !tbaa !0
  %call28 = tail call fastcc %struct.sv* @S_refto(%struct.sv* %9) #8
  store %struct.sv* %call28, %struct.sv** %incdec.ptr2549, align 8, !tbaa !0
  %incdec.ptr25 = getelementptr inbounds %struct.sv** %incdec.ptr2549, i64 1
  %cmp26 = icmp ugt %struct.sv** %incdec.ptr25, %0
  br i1 %cmp26, label %return, label %while.body

return:                                           ; preds = %while.cond.preheader, %while.body, %if.end
  %storemerge46 = phi %struct.sv** [ %incdec.ptr8, %if.end ], [ %0, %while.body ], [ %0, %while.cond.preheader ]
  store %struct.sv** %storemerge46, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_tmps_grow(i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_ref() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %tobool = icmp eq %struct.sv* %5, null
  br i1 %tobool, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 8192
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call = tail call i32 @Perl_mg_get(%struct.sv* %5) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then, %land.lhs.true
  %7 = phi i32 [ %.pre, %if.then ], [ %6, %land.lhs.true ]
  %and4 = and i32 %7, 524288
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %return, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %8 to %struct.sv**
  %9 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %call9 = tail call i8* @Perl_sv_reftype(%struct.sv* %9, i32 1) #7
  %call10 = tail call i64 @strlen(i8* %call9) #7
  tail call void @Perl_sv_setpvn(%struct.sv* %4, i8* %call9, i64 %call10) #7
  %sv_flags11 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %10 = load i32* %sv_flags11, align 4, !tbaa !4
  %and12 = and i32 %10, 16384
  %tobool13 = icmp eq i32 %and12, 0
  br i1 %tobool13, label %return, label %if.then14

if.then14:                                        ; preds = %if.end8
  %call15 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %return

return:                                           ; preds = %entry, %if.then14, %if.end8, %lor.lhs.false
  %storemerge = phi %struct.sv* [ @PL_sv_no, %entry ], [ @PL_sv_no, %lor.lhs.false ], [ %4, %if.end8 ], [ %4, %if.then14 ]
  store %struct.sv* %storemerge, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i8* @Perl_sv_reftype(%struct.sv*, i32) #1

; Function Attrs: optsize
declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #1

; Function Attrs: nounwind optsize readonly
declare i64 @strlen(i8* nocapture) #4

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_bless() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %2 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %2, 15
  %cmp = icmp eq i8 %and, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_stash = getelementptr inbounds %struct.cop* %3, i64 0, i32 9
  %4 = load %struct.hv** %cop_stash, align 8, !tbaa !0
  br label %if.end49

if.else:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %tobool = icmp eq %struct.sv* %5, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %7 = and i32 %6, 268967936
  %8 = icmp eq i32 %7, 524288
  br i1 %8, label %if.then12, label %if.end

if.then12:                                        ; preds = %land.lhs.true
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([34 x i8]* @.str13, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %if.else, %land.lhs.true, %if.then12
  %sv_flags13.pre-phi = phi i32* [ %sv_flags, %land.lhs.true ], [ %sv_flags, %if.then12 ], [ inttoptr (i64 12 to i32*), %if.else ]
  %9 = load i32* %sv_flags13.pre-phi, align 4, !tbaa !4
  %and14 = and i32 %9, 262144
  %cmp15 = icmp eq i32 %and14, 0
  br i1 %cmp15, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur to i64*
  %12 = load i64* %11, align 8, !tbaa !3
  store i64 %12, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %len, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %13, %cond.true ], [ %call, %cond.false ]
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp18 = icmp eq %struct.sv* %15, null
  br i1 %cmp18, label %lor.lhs.false34, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %cond.end
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings21 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings21, align 8, !tbaa !0
  %cmp22 = icmp eq %struct.sv* %17, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp22, label %lor.lhs.false34, label %land.lhs.true24

land.lhs.true24:                                  ; preds = %land.lhs.true20
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings25 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings25, align 8, !tbaa !0
  %cmp26 = icmp eq %struct.sv* %19, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp26, label %land.lhs.true42, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true24
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings28 = getelementptr inbounds %struct.cop* %20, i64 0, i32 14
  %21 = load %struct.sv** %cop_warnings28, align 8, !tbaa !0
  %sv_any29 = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %22 = load i8** %sv_any29, align 8, !tbaa !0
  %xpv_pv30 = bitcast i8* %22 to i8**
  %23 = load i8** %xpv_pv30, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds i8* %23, i64 3
  %24 = load i8* %arrayidx, align 1, !tbaa !1
  %and32 = and i8 %24, 1
  %tobool33 = icmp eq i8 %and32, 0
  br i1 %tobool33, label %lor.lhs.false34, label %land.lhs.true42

lor.lhs.false34:                                  ; preds = %lor.lhs.false, %land.lhs.true20, %cond.end
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings35 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings35, align 8, !tbaa !0
  %cmp36 = icmp eq %struct.sv* %26, null
  br i1 %cmp36, label %land.lhs.true38, label %if.end46

land.lhs.true38:                                  ; preds = %lor.lhs.false34
  %27 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and40 = and i8 %27, 1
  %tobool41 = icmp eq i8 %and40, 0
  br i1 %tobool41, label %if.end46, label %land.lhs.true42

land.lhs.true42:                                  ; preds = %lor.lhs.false, %land.lhs.true38, %land.lhs.true24
  %28 = load i64* %len, align 8, !tbaa !3
  %cmp43 = icmp eq i64 %28, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %land.lhs.true42
  call void (i32, i8*, ...)* @Perl_warner(i32 12, i8* getelementptr inbounds ([48 x i8]* @.str14, i64 0, i64 0)) #7
  br label %if.end46

if.end46:                                         ; preds = %land.lhs.true38, %lor.lhs.false34, %if.then45, %land.lhs.true42
  %29 = load i64* %len, align 8, !tbaa !3
  %conv47 = trunc i64 %29 to i32
  %call48 = call %struct.hv* @Perl_gv_stashpvn(i8* %cond, i32 %conv47, i32 1) #7
  br label %if.end49

if.end49:                                         ; preds = %if.end46, %if.then
  %stash.0 = phi %struct.hv* [ %4, %if.then ], [ %call48, %if.end46 ]
  %sp.0 = phi %struct.sv** [ %0, %if.then ], [ %incdec.ptr, %if.end46 ]
  %30 = load %struct.sv** %sp.0, align 8, !tbaa !0
  %call50 = call %struct.sv* @Perl_sv_bless(%struct.sv* %30, %struct.hv* %stash.0) #7
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %31 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %31, i64 0, i32 0
  %32 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %32
}

; Function Attrs: optsize
declare void @Perl_warner(i32, i8*, ...) #1

; Function Attrs: optsize
declare %struct.hv* @Perl_gv_stashpvn(i8*, i32, i32) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_sv_bless(%struct.sv*, %struct.hv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_gelem() #0 {
entry:
  %n_a = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !3
  store i64 %5, i64* %n_a, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %3 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %n_a, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %6, %cond.true ], [ %call, %cond.false ]
  %incdec.ptr2 = getelementptr inbounds %struct.sv** %0, i64 -2
  %7 = load %struct.sv** %incdec.ptr, align 8, !tbaa !0
  %tobool = icmp eq i8* %cond, null
  br i1 %tobool, label %if.end93, label %if.then

if.then:                                          ; preds = %cond.end
  %add.ptr = getelementptr inbounds i8* %cond, i64 1
  %8 = load i8* %cond, align 1, !tbaa !1
  %conv = sext i8 %8 to i32
  switch i32 %conv, label %if.end93 [
    i32 65, label %sw.bb
    i32 67, label %sw.bb7
    i32 70, label %sw.bb21
    i32 71, label %sw.bb34
    i32 72, label %sw.bb39
    i32 73, label %sw.bb46
    i32 78, label %sw.bb56
    i32 80, label %sw.bb64
    i32 83, label %sw.bb77
  ]

sw.bb:                                            ; preds = %if.then
  %call3 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([5 x i8]* @.str15, i64 0, i64 0)) #7
  %tobool4 = icmp eq i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end93

if.then5:                                         ; preds = %sw.bb
  %sv_any6 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %9 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %9, i64 0, i32 7
  %10 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_av = getelementptr inbounds %struct.gp* %10, i64 0, i32 4
  %11 = load %struct.av** %gp_av, align 8, !tbaa !0
  %12 = bitcast %struct.av* %11 to %struct.sv*
  br label %if.end84

sw.bb7:                                           ; preds = %if.then
  %call8 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str16, i64 0, i64 0)) #7
  %tobool9 = icmp eq i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end93

if.then10:                                        ; preds = %sw.bb7
  %sv_any11 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %13 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !0
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp12, align 8, !tbaa !0
  %gp_cvgen = getelementptr inbounds %struct.gp* %14, i64 0, i32 8
  %15 = load i32* %gp_cvgen, align 4, !tbaa !4
  %tobool13 = icmp eq i32 %15, 0
  br i1 %tobool13, label %cond.false15, label %if.end93

cond.false15:                                     ; preds = %if.then10
  %gp_cv = getelementptr inbounds %struct.gp* %14, i64 0, i32 7
  %16 = load %struct.cv** %gp_cv, align 8, !tbaa !0
  %phitmp = bitcast %struct.cv* %16 to %struct.sv*
  br label %if.end84

sw.bb21:                                          ; preds = %if.then
  %call22 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([10 x i8]* @.str17, i64 0, i64 0)) #7
  %tobool23 = icmp eq i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.else

if.then24:                                        ; preds = %sw.bb21
  call void @Perl_deprecate(i8* getelementptr inbounds ([18 x i8]* @.str18, i64 0, i64 0)) #7
  %sv_any25 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %17 = load %struct.xpvgv** %sv_any25, align 8, !tbaa !0
  %xgv_gp26 = getelementptr inbounds %struct.xpvgv* %17, i64 0, i32 7
  %18 = load %struct.gp** %xgv_gp26, align 8, !tbaa !0
  %gp_io = getelementptr inbounds %struct.gp* %18, i64 0, i32 2
  %19 = load %struct.io** %gp_io, align 8, !tbaa !0
  %20 = bitcast %struct.io* %19 to %struct.sv*
  br label %if.end84

if.else:                                          ; preds = %sw.bb21
  %call27 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([6 x i8]* @.str19, i64 0, i64 0)) #7
  %tobool28 = icmp eq i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.end93

if.then29:                                        ; preds = %if.else
  %sv_any30 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %21 = load %struct.xpvgv** %sv_any30, align 8, !tbaa !0
  %xgv_gp31 = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 7
  %22 = load %struct.gp** %xgv_gp31, align 8, !tbaa !0
  %gp_form = getelementptr inbounds %struct.gp* %22, i64 0, i32 3
  %23 = load %struct.cv** %gp_form, align 8, !tbaa !0
  %24 = bitcast %struct.cv* %23 to %struct.sv*
  br label %if.end84

sw.bb34:                                          ; preds = %if.then
  %call35 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str20, i64 0, i64 0)) #7
  %tobool36 = icmp eq i32 %call35, 0
  %. = select i1 %tobool36, %struct.sv* %7, %struct.sv* null
  br label %if.end84

sw.bb39:                                          ; preds = %if.then
  %call40 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str21, i64 0, i64 0)) #7
  %tobool41 = icmp eq i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.end93

if.then42:                                        ; preds = %sw.bb39
  %sv_any43 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %25 = load %struct.xpvgv** %sv_any43, align 8, !tbaa !0
  %xgv_gp44 = getelementptr inbounds %struct.xpvgv* %25, i64 0, i32 7
  %26 = load %struct.gp** %xgv_gp44, align 8, !tbaa !0
  %gp_hv = getelementptr inbounds %struct.gp* %26, i64 0, i32 5
  %27 = load %struct.hv** %gp_hv, align 8, !tbaa !0
  %28 = bitcast %struct.hv* %27 to %struct.sv*
  br label %if.end84

sw.bb46:                                          ; preds = %if.then
  %29 = load i8* %add.ptr, align 1, !tbaa !1
  %cmp48 = icmp eq i8 %29, 79
  br i1 %cmp48, label %land.lhs.true, label %if.end93

land.lhs.true:                                    ; preds = %sw.bb46
  %arrayidx = getelementptr inbounds i8* %cond, i64 2
  %30 = load i8* %arrayidx, align 1, !tbaa !1
  %tobool50 = icmp eq i8 %30, 0
  br i1 %tobool50, label %if.then51, label %if.end93

if.then51:                                        ; preds = %land.lhs.true
  %sv_any52 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %31 = load %struct.xpvgv** %sv_any52, align 8, !tbaa !0
  %xgv_gp53 = getelementptr inbounds %struct.xpvgv* %31, i64 0, i32 7
  %32 = load %struct.gp** %xgv_gp53, align 8, !tbaa !0
  %gp_io54 = getelementptr inbounds %struct.gp* %32, i64 0, i32 2
  %33 = load %struct.io** %gp_io54, align 8, !tbaa !0
  %34 = bitcast %struct.io* %33 to %struct.sv*
  br label %if.end84

sw.bb56:                                          ; preds = %if.then
  %call57 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8]* @.str22, i64 0, i64 0)) #7
  %tobool58 = icmp eq i32 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.end93

if.then59:                                        ; preds = %sw.bb56
  %sv_any60 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %35 = load %struct.xpvgv** %sv_any60, align 8, !tbaa !0
  %xgv_name = getelementptr inbounds %struct.xpvgv* %35, i64 0, i32 8
  %36 = load i8** %xgv_name, align 8, !tbaa !0
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %35, i64 0, i32 9
  %37 = load i64* %xgv_namelen, align 8, !tbaa !3
  %call62 = call %struct.sv* @Perl_newSVpvn(i8* %36, i64 %37) #7
  br label %if.end88

sw.bb64:                                          ; preds = %if.then
  %call65 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([7 x i8]* @.str23, i64 0, i64 0)) #7
  %tobool66 = icmp eq i32 %call65, 0
  br i1 %tobool66, label %if.then67, label %if.end93

if.then67:                                        ; preds = %sw.bb64
  %sv_any68 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %38 = load %struct.xpvgv** %sv_any68, align 8, !tbaa !0
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %38, i64 0, i32 10
  %39 = load %struct.hv** %xgv_stash, align 8, !tbaa !0
  %sv_any69 = getelementptr inbounds %struct.hv* %39, i64 0, i32 0
  %40 = load %struct.xpvhv** %sv_any69, align 8, !tbaa !0
  %xhv_name = getelementptr inbounds %struct.xpvhv* %40, i64 0, i32 10
  %41 = load i8** %xhv_name, align 8, !tbaa !0
  %tobool70 = icmp ne i8* %41, null
  %cond74 = select i1 %tobool70, i8* %41, i8* getelementptr inbounds ([9 x i8]* @.str24, i64 0, i64 0)
  %call75 = call %struct.sv* @Perl_newSVpv(i8* %cond74, i64 0) #7
  br label %if.end88

sw.bb77:                                          ; preds = %if.then
  %call78 = call i32 @strcmp(i8* %add.ptr, i8* getelementptr inbounds ([6 x i8]* @.str25, i64 0, i64 0)) #7
  %tobool79 = icmp eq i32 %call78, 0
  br i1 %tobool79, label %if.then80, label %if.end93

if.then80:                                        ; preds = %sw.bb77
  %sv_any81 = bitcast %struct.sv* %7 to %struct.xpvgv**
  %42 = load %struct.xpvgv** %sv_any81, align 8, !tbaa !0
  %xgv_gp82 = getelementptr inbounds %struct.xpvgv* %42, i64 0, i32 7
  %43 = load %struct.gp** %xgv_gp82, align 8, !tbaa !0
  %gp_sv = getelementptr inbounds %struct.gp* %43, i64 0, i32 0
  %44 = load %struct.sv** %gp_sv, align 8, !tbaa !0
  br label %if.end84

if.end84:                                         ; preds = %sw.bb34, %cond.false15, %if.then5, %if.then29, %if.then24, %if.then42, %if.then51, %if.then80
  %tmpRef.0 = phi %struct.sv* [ %44, %if.then80 ], [ %34, %if.then51 ], [ %28, %if.then42 ], [ %24, %if.then29 ], [ %20, %if.then24 ], [ %12, %if.then5 ], [ %phitmp, %cond.false15 ], [ %., %sw.bb34 ]
  %tobool85 = icmp eq %struct.sv* %tmpRef.0, null
  br i1 %tobool85, label %if.end93, label %if.then86

if.then86:                                        ; preds = %if.end84
  %call87 = call %struct.sv* @Perl_newRV(%struct.sv* %tmpRef.0) #7
  br label %if.end88

if.end88:                                         ; preds = %if.then59, %if.then67, %if.then86
  %sv.1 = phi %struct.sv* [ %call87, %if.then86 ], [ %call75, %if.then67 ], [ %call62, %if.then59 ]
  %tobool89 = icmp eq %struct.sv* %sv.1, null
  br i1 %tobool89, label %if.end93, label %if.then90

if.then90:                                        ; preds = %if.end88
  %call91 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %sv.1) #7
  br label %if.end93

if.end93:                                         ; preds = %if.then10, %cond.end, %sw.bb, %sw.bb7, %if.else, %sw.bb39, %sw.bb46, %land.lhs.true, %sw.bb56, %sw.bb64, %sw.bb77, %if.then, %if.end84, %if.end88, %if.then90
  %sv.2 = phi %struct.sv* [ %sv.1, %if.then90 ], [ @PL_sv_undef, %if.end88 ], [ @PL_sv_undef, %if.end84 ], [ @PL_sv_undef, %if.then ], [ @PL_sv_undef, %sw.bb77 ], [ @PL_sv_undef, %sw.bb64 ], [ @PL_sv_undef, %sw.bb56 ], [ @PL_sv_undef, %land.lhs.true ], [ @PL_sv_undef, %sw.bb46 ], [ @PL_sv_undef, %sw.bb39 ], [ @PL_sv_undef, %if.else ], [ @PL_sv_undef, %sw.bb7 ], [ @PL_sv_undef, %sw.bb ], [ @PL_sv_undef, %cond.end ], [ @PL_sv_undef, %if.then10 ]
  %45 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %45 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp94 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp94, label %if.then96, label %if.end98

if.then96:                                        ; preds = %if.end93
  %call97 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr2, %struct.sv** %incdec.ptr2, i32 1) #7
  br label %if.end98

if.end98:                                         ; preds = %if.then96, %if.end93
  %sp.0 = phi %struct.sv** [ %call97, %if.then96 ], [ %incdec.ptr2, %if.end93 ]
  %incdec.ptr99 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %sv.2, %struct.sv** %incdec.ptr99, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr99, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %46 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %46, i64 0, i32 0
  %47 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %47
}

; Function Attrs: optsize
declare void @Perl_deprecate(i8*) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVpv(i8*, i64) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_newRV(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_study() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %2 = load %struct.sv** @PL_lastscream, align 8, !tbaa !0
  %cmp = icmp eq %struct.sv* %1, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %3 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %3, 134217728
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end10, label %if.then1

if.then1:                                         ; preds = %if.then
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.else:                                          ; preds = %entry
  %tobool3 = icmp eq %struct.sv* %2, null
  br i1 %tobool3, label %if.end7, label %if.then4

if.then4:                                         ; preds = %if.else
  %sv_flags5 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %6 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %6, -134217729
  store i32 %and6, i32* %sv_flags5, align 4, !tbaa !4
  call void @Perl_sv_free(%struct.sv* %2) #7
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then4
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool8 = icmp eq %struct.sv* %1, null
  br i1 %tobool8, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end7
  %sv_refcnt = getelementptr inbounds %struct.sv* %1, i64 0, i32 1
  %7 = load i32* %sv_refcnt, align 4, !tbaa !4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !4
  br label %land.end

land.end:                                         ; preds = %if.end7, %land.rhs
  store %struct.sv* %1, %struct.sv** @PL_lastscream, align 8, !tbaa !0
  %sv_flags11.phi.trans.insert = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %.pre = load i32* %sv_flags11.phi.trans.insert, align 4, !tbaa !4
  br label %if.end10

if.end10:                                         ; preds = %if.then, %land.end
  %8 = phi i32 [ %3, %if.then ], [ %.pre, %land.end ]
  %sv_flags11 = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %and12 = and i32 %8, 262144
  %cmp13 = icmp eq i32 %and12, 0
  br i1 %cmp13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end10
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %9, i64 8
  %10 = bitcast i8* %xpv_cur to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  store i64 %11, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %9 to i8**
  %12 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.end10
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %len, i32 2) #7
  %.pre107 = load i64* %len, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %13 = phi i64 [ %11, %cond.true ], [ %.pre107, %cond.false ]
  %cond = phi i8* [ %12, %cond.true ], [ %call, %cond.false ]
  %conv = trunc i64 %13 to i32
  %cmp15 = icmp slt i32 %conv, 1
  br i1 %cmp15, label %if.then17, label %if.end20

if.then17:                                        ; preds = %cond.end
  store %struct.sv* @PL_sv_no, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next19 = getelementptr inbounds %struct.op* %14, i64 0, i32 0
  %15 = load %struct.op** %op_next19, align 8, !tbaa !0
  br label %return

if.end20:                                         ; preds = %cond.end
  %16 = load i32* @PL_maxscream, align 4, !tbaa !4
  %cmp21 = icmp sgt i32 %conv, %16
  br i1 %cmp21, label %if.then23, label %if.end20.if.end36_crit_edge

if.end20.if.end36_crit_edge:                      ; preds = %if.end20
  %.pre108 = load i32** @PL_screamnext, align 8, !tbaa !0
  br label %if.end36

if.then23:                                        ; preds = %if.end20
  %cmp24 = icmp slt i32 %16, 0
  br i1 %cmp24, label %if.then26, label %if.else30

if.then26:                                        ; preds = %if.then23
  %add = add nsw i32 %conv, 80
  store i32 %add, i32* @PL_maxscream, align 4, !tbaa !4
  %call27 = call i8* @Perl_safesysmalloc(i64 1024) #7
  %17 = bitcast i8* %call27 to i32*
  store i32* %17, i32** @PL_screamfirst, align 8, !tbaa !0
  %18 = load i32* @PL_maxscream, align 4, !tbaa !4
  %conv28 = sext i32 %18 to i64
  %mul = shl nsw i64 %conv28, 2
  %call29 = call i8* @Perl_safesysmalloc(i64 %mul) #7
  %19 = bitcast i8* %call29 to i32*
  store i32* %19, i32** @PL_screamnext, align 8, !tbaa !0
  br label %if.end36

if.else30:                                        ; preds = %if.then23
  %div = sdiv i32 %conv, 4
  %add31 = add nsw i32 %div, %conv
  store i32 %add31, i32* @PL_maxscream, align 4, !tbaa !4
  %20 = load i32** @PL_screamnext, align 8, !tbaa !0
  %21 = bitcast i32* %20 to i8*
  %conv32 = sext i32 %add31 to i64
  %mul33 = shl nsw i64 %conv32, 2
  %call34 = call i8* @Perl_safesysrealloc(i8* %21, i64 %mul33) #7
  %22 = bitcast i8* %call34 to i32*
  store i32* %22, i32** @PL_screamnext, align 8, !tbaa !0
  br label %if.end36

if.end36:                                         ; preds = %if.end20.if.end36_crit_edge, %if.then26, %if.else30
  %23 = phi i32* [ %.pre108, %if.end20.if.end36_crit_edge ], [ %19, %if.then26 ], [ %22, %if.else30 ]
  %24 = load i32** @PL_screamfirst, align 8, !tbaa !0
  %tobool37 = icmp eq i32* %24, null
  %tobool38 = icmp eq i32* %23, null
  %or.cond = or i1 %tobool37, %tobool38
  br i1 %or.cond, label %if.then39, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end36
  %25 = bitcast i32* %24 to i8*
  call void @llvm.memset.p0i8.i64(i8* %25, i8 -1, i64 1024, i32 4, i1 false)
  %cmp45102 = icmp sgt i32 %conv, 0
  br i1 %cmp45102, label %while.body.lr.ph, label %while.end

if.then39:                                        ; preds = %if.end36
  %call40 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([24 x i8]* @.str26, i64 0, i64 0)) #7
  br label %return

while.body.lr.ph:                                 ; preds = %for.cond.preheader
  %sext = shl i64 %13, 32
  %26 = ashr exact i64 %sext, 32
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end61
  %indvars.iv = phi i64 [ %26, %while.body.lr.ph ], [ %indvars.iv.next, %if.end61 ]
  %dec44104.in = phi i32 [ %conv, %while.body.lr.ph ], [ %dec44104, %if.end61 ]
  %indvars.iv.next = add i64 %indvars.iv, -1
  %dec44104 = add nsw i32 %dec44104.in, -1
  %arrayidx = getelementptr inbounds i8* %cond, i64 %indvars.iv.next
  %27 = load i8* %arrayidx, align 1, !tbaa !1
  %idxprom48 = zext i8 %27 to i64
  %add.ptr.sum100 = or i64 %idxprom48, -256
  %scevgep.sum = add i64 %add.ptr.sum100, 256
  %arrayidx49 = getelementptr inbounds i32* %24, i64 %scevgep.sum
  %28 = load i32* %arrayidx49, align 4, !tbaa !4
  %cmp50 = icmp sgt i32 %28, -1
  br i1 %cmp50, label %if.then52, label %if.else57

if.then52:                                        ; preds = %while.body
  %29 = trunc i64 %indvars.iv.next to i32
  %sub = sub nsw i32 %28, %29
  %arrayidx56 = getelementptr inbounds i32* %23, i64 %indvars.iv.next
  store i32 %sub, i32* %arrayidx56, align 4, !tbaa !4
  br label %if.end61

if.else57:                                        ; preds = %while.body
  %sub58 = sub i32 1, %dec44104.in
  %arrayidx60 = getelementptr inbounds i32* %23, i64 %indvars.iv.next
  store i32 %sub58, i32* %arrayidx60, align 4, !tbaa !4
  %.pre109 = trunc i64 %indvars.iv.next to i32
  br label %if.end61

if.end61:                                         ; preds = %if.else57, %if.then52
  %.pre-phi = phi i32 [ %.pre109, %if.else57 ], [ %29, %if.then52 ]
  store i32 %.pre-phi, i32* %arrayidx49, align 4, !tbaa !4
  %cmp45 = icmp sgt i32 %.pre-phi, 0
  br i1 %cmp45, label %while.body, label %while.end

while.end:                                        ; preds = %if.end61, %for.cond.preheader
  %30 = load i32* %sv_flags11, align 4, !tbaa !4
  %or = or i32 %30, 134217728
  store i32 %or, i32* %sv_flags11, align 4, !tbaa !4
  call void @Perl_sv_magic(%struct.sv* %1, %struct.sv* null, i32 103, i8* null, i32 0) #7
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %31 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next66 = getelementptr inbounds %struct.op* %31, i64 0, i32 0
  %32 = load %struct.op** %op_next66, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %while.end, %if.then39, %if.then17, %if.then1
  %retval.0 = phi %struct.op* [ %5, %if.then1 ], [ %15, %if.then17 ], [ %32, %while.end ], [ %call40, %if.then39 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i8* @Perl_safesysmalloc(i64) #1

; Function Attrs: optsize
declare i8* @Perl_safesysrealloc(i8*, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_trans() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %0, align 8, !tbaa !0
  br label %if.end3

if.else:                                          ; preds = %entry
  %4 = load %struct.gv** @PL_defgv, align 8, !tbaa !0
  %sv_any = getelementptr inbounds %struct.gv* %4, i64 0, i32 0
  %5 = load %struct.xpvgv** %sv_any, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_sv = getelementptr inbounds %struct.gp* %6, i64 0, i32 0
  %7 = load %struct.sv** %gp_sv, align 8, !tbaa !0
  %8 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.else
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.then2, %if.then
  %sp.0 = phi %struct.sv** [ %incdec.ptr, %if.then ], [ %call, %if.then2 ], [ %0, %if.else ]
  %sv.0 = phi %struct.sv* [ %3, %if.then ], [ %7, %if.then2 ], [ %7, %if.else ]
  %call4 = tail call %struct.sv* @Perl_sv_newmortal() #7
  %call5 = tail call i32 @Perl_do_trans(%struct.sv* %sv.0) #7
  %conv6 = sext i32 %call5 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %call4, i64 %conv6) #7
  %sv_flags = getelementptr inbounds %struct.sv* %call4, i64 0, i32 2
  %9 = load i32* %sv_flags, align 4, !tbaa !4
  %and7 = and i32 %9, 16384
  %tobool8 = icmp eq i32 %and7, 0
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end3
  %call10 = tail call i32 @Perl_mg_set(%struct.sv* %call4) #7
  br label %if.end11

if.end11:                                         ; preds = %if.end3, %if.then9
  %incdec.ptr12 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call4, %struct.sv** %incdec.ptr12, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr12, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %10 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %10, i64 0, i32 0
  %11 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %11
}

; Function Attrs: optsize
declare i32 @Perl_do_trans(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_schop() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  tail call void @Perl_do_chop(%struct.sv* %4, %struct.sv* %5) #7
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 16384
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  %8 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %8
}

; Function Attrs: optsize
declare void @Perl_do_chop(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_chop() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %5 = load i64* %op_targ, align 8, !tbaa !3
  %6 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %6, i64 %5
  %7 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %cmp14 = icmp ult %struct.sv** %add.ptr, %0
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %while.body
  %mark.015 = phi %struct.sv** [ %incdec.ptr2, %while.body ], [ %add.ptr, %entry ]
  %incdec.ptr2 = getelementptr inbounds %struct.sv** %mark.015, i64 1
  %8 = load %struct.sv** %incdec.ptr2, align 8, !tbaa !0
  tail call void @Perl_do_chop(%struct.sv* %7, %struct.sv* %8) #7
  %cmp = icmp ult %struct.sv** %incdec.ptr2, %0
  br i1 %cmp, label %while.body, label %while.cond.while.end_crit_edge

while.cond.while.end_crit_edge:                   ; preds = %while.body
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  br label %while.end

while.end:                                        ; preds = %while.cond.while.end_crit_edge, %entry
  %9 = phi %struct.sv** [ %.pre, %while.cond.while.end_crit_edge ], [ %1, %entry ]
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %10 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %10, 16384
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  %call = tail call i32 @Perl_mg_set(%struct.sv* %7) #7
  br label %if.end

if.end:                                           ; preds = %while.end, %if.then
  %add.ptr4.sum = add i64 %idx.ext, 1
  %incdec.ptr5 = getelementptr inbounds %struct.sv** %9, i64 %add.ptr4.sum
  store %struct.sv* %7, %struct.sv** %incdec.ptr5, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr5, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  %12 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %12
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_schomp() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %call = tail call i32 @Perl_do_chomp(%struct.sv* %5) #7
  %conv = sext i32 %call to i64
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %conv) #7
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 16384
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  %8 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %8
}

; Function Attrs: optsize
declare i32 @Perl_do_chomp(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_chomp() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %5 = load i64* %op_targ, align 8, !tbaa !3
  %6 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %6, i64 %5
  %7 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %cmp11 = icmp ugt %struct.sv** %0, %add.ptr
  br i1 %cmp11, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %while.body
  %count.013 = phi i32 [ %add, %while.body ], [ 0, %entry ]
  %sp.012 = phi %struct.sv** [ %incdec.ptr1, %while.body ], [ %0, %entry ]
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %sp.012, i64 -1
  %8 = load %struct.sv** %sp.012, align 8, !tbaa !0
  %call = tail call i32 @Perl_do_chomp(%struct.sv* %8) #7
  %add = add nsw i32 %call, %count.013
  %cmp = icmp ugt %struct.sv** %incdec.ptr1, %add.ptr
  br i1 %cmp, label %while.body, label %while.cond.while.end_crit_edge

while.cond.while.end_crit_edge:                   ; preds = %while.body
  %phitmp = sext i32 %add to i64
  br label %while.end

while.end:                                        ; preds = %while.cond.while.end_crit_edge, %entry
  %count.0.lcssa = phi i64 [ %phitmp, %while.cond.while.end_crit_edge ], [ 0, %entry ]
  %sp.0.lcssa = phi %struct.sv** [ %incdec.ptr1, %while.cond.while.end_crit_edge ], [ %0, %entry ]
  tail call void @Perl_sv_setiv(%struct.sv* %7, i64 %count.0.lcssa) #7
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %9 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %9, 16384
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  %call2 = tail call i32 @Perl_mg_set(%struct.sv* %7) #7
  br label %if.end

if.end:                                           ; preds = %while.end, %if.then
  %incdec.ptr3 = getelementptr inbounds %struct.sv** %sp.0.lcssa, i64 1
  store %struct.sv* %7, %struct.sv** %incdec.ptr3, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr3, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %10 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %10, i64 0, i32 0
  %11 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %11
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_defined() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %tobool = icmp eq %struct.sv* %1, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %2 = load i8** %sv_any, align 8, !tbaa !0
  %tobool1 = icmp eq i8* %2, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.sv* @PL_sv_no, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %3 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %3, i64 0, i32 0
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 255
  switch i32 %and, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb17
    i32 12, label %sw.bb35
  ]

sw.bb:                                            ; preds = %if.end
  %xav_max = getelementptr inbounds i8* %2, i64 16
  %5 = bitcast i8* %xav_max to i64*
  %6 = load i64* %5, align 8, !tbaa !3
  %cmp = icmp sgt i64 %6, -1
  br i1 %cmp, label %if.then13, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %sw.bb
  %and6 = and i32 %4, 8192
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %lor.lhs.false8, label %if.then13

lor.lhs.false8:                                   ; preds = %lor.lhs.false4
  %and10 = and i32 %4, 32768
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %sw.epilog, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false8
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 80) #7
  %tobool12 = icmp eq %struct.magic* %call, null
  br i1 %tobool12, label %sw.epilog, label %if.then13

if.then13:                                        ; preds = %land.lhs.true, %lor.lhs.false4, %sw.bb
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next15 = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  br label %return

sw.bb17:                                          ; preds = %if.end
  %8 = bitcast i8* %2 to %struct.he***
  %9 = load %struct.he*** %8, align 8, !tbaa !0
  %tobool19 = icmp eq %struct.he** %9, null
  br i1 %tobool19, label %lor.lhs.false20, label %if.then31

lor.lhs.false20:                                  ; preds = %sw.bb17
  %and22 = and i32 %4, 8192
  %tobool23 = icmp eq i32 %and22, 0
  br i1 %tobool23, label %lor.lhs.false24, label %if.then31

lor.lhs.false24:                                  ; preds = %lor.lhs.false20
  %and26 = and i32 %4, 32768
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %sw.epilog, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %lor.lhs.false24
  %call29 = tail call %struct.magic* @Perl_mg_find(%struct.sv* %1, i32 80) #7
  %tobool30 = icmp eq %struct.magic* %call29, null
  br i1 %tobool30, label %sw.epilog, label %if.then31

if.then31:                                        ; preds = %land.lhs.true28, %lor.lhs.false20, %sw.bb17
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %10 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next33 = getelementptr inbounds %struct.op* %10, i64 0, i32 0
  br label %return

sw.bb35:                                          ; preds = %if.end
  %xcv_root = getelementptr inbounds i8* %2, i64 72
  %11 = bitcast i8* %xcv_root to %struct.op**
  %12 = load %struct.op** %11, align 8, !tbaa !0
  %tobool37 = icmp eq %struct.op* %12, null
  br i1 %tobool37, label %lor.lhs.false38, label %if.then41

lor.lhs.false38:                                  ; preds = %sw.bb35
  %xcv_xsub = getelementptr inbounds i8* %2, i64 80
  %13 = bitcast i8* %xcv_xsub to void (%struct.cv*)**
  %14 = load void (%struct.cv*)** %13, align 8, !tbaa !0
  %tobool40 = icmp eq void (%struct.cv*)* %14, null
  br i1 %tobool40, label %sw.epilog, label %if.then41

if.then41:                                        ; preds = %lor.lhs.false38, %sw.bb35
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next43 = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  br label %return

sw.default:                                       ; preds = %if.end
  %and46 = and i32 %4, 8192
  %tobool47 = icmp eq i32 %and46, 0
  br i1 %tobool47, label %if.end50, label %if.then48

if.then48:                                        ; preds = %sw.default
  %call49 = tail call i32 @Perl_mg_get(%struct.sv* %1) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end50

if.end50:                                         ; preds = %sw.default, %if.then48
  %16 = phi i32 [ %4, %sw.default ], [ %.pre, %if.then48 ]
  %and52 = and i32 %16, 118423552
  %tobool53 = icmp eq i32 %and52, 0
  br i1 %tobool53, label %sw.epilog, label %if.then54

if.then54:                                        ; preds = %if.end50
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %17 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next56 = getelementptr inbounds %struct.op* %17, i64 0, i32 0
  br label %return

sw.epilog:                                        ; preds = %if.end50, %land.lhs.true, %lor.lhs.false8, %land.lhs.true28, %lor.lhs.false24, %lor.lhs.false38
  store %struct.sv* @PL_sv_no, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %18 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next59 = getelementptr inbounds %struct.op* %18, i64 0, i32 0
  br label %return

return:                                           ; preds = %sw.epilog, %if.then54, %if.then41, %if.then31, %if.then13, %if.then
  %retval.0.in = phi %struct.op** [ %op_next56, %if.then54 ], [ %op_next59, %sw.epilog ], [ %op_next43, %if.then41 ], [ %op_next33, %if.then31 ], [ %op_next15, %if.then13 ], [ %op_next, %if.then ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_undef() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %2 = load i8* %op_private, align 1, !tbaa !1
  %tobool = icmp eq i8 %2, 0
  br i1 %tobool, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  %3 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %sp.0 = phi %struct.sv** [ %call, %if.then1 ], [ %0, %if.then ]
  %incdec.ptr = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  br label %return

if.end2:                                          ; preds = %entry
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %tobool4 = icmp eq %struct.sv* %5, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end2
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %6 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next7 = getelementptr inbounds %struct.op* %6, i64 0, i32 0
  br label %return

if.end8:                                          ; preds = %if.end2
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 9961472
  %tobool9 = icmp eq i32 %and, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end8
  tail call void @Perl_sv_force_normal(%struct.sv* %5) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end11

if.end11:                                         ; preds = %if.end8, %if.then10
  %8 = phi i32 [ %7, %if.end8 ], [ %.pre, %if.then10 ]
  %and13 = and i32 %8, 255
  switch i32 %and13, label %sw.default [
    i32 0, label %sw.epilog
    i32 10, label %sw.bb
    i32 11, label %sw.bb14
    i32 12, label %sw.bb15
    i32 14, label %sw.bb57
    i32 13, label %sw.bb62
  ]

sw.bb:                                            ; preds = %if.end11
  %9 = bitcast %struct.sv* %5 to %struct.av*
  tail call void @Perl_av_undef(%struct.av* %9) #7
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end11
  %10 = bitcast %struct.sv* %5 to %struct.hv*
  tail call void @Perl_hv_undef(%struct.hv* %10) #7
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end11
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp16 = icmp eq %struct.sv* %12, null
  br i1 %cmp16, label %lor.lhs.false25, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb15
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings17 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings17, align 8, !tbaa !0
  %cmp18 = icmp eq %struct.sv* %14, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp18, label %lor.lhs.false25, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %land.lhs.true
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings20 = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings20, align 8, !tbaa !0
  %cmp21 = icmp eq %struct.sv* %16, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp21, label %land.lhs.true33, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true19
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings22 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings22, align 8, !tbaa !0
  %sv_any = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %19 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_pv = bitcast i8* %19 to i8**
  %20 = load i8** %xpv_pv, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds i8* %20, i64 3
  %21 = load i8* %arrayidx, align 1, !tbaa !1
  %and23 = and i8 %21, 1
  %tobool24 = icmp eq i8 %and23, 0
  br i1 %tobool24, label %lor.lhs.false25, label %land.lhs.true33

lor.lhs.false25:                                  ; preds = %lor.lhs.false, %land.lhs.true, %sw.bb15
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings26 = getelementptr inbounds %struct.cop* %22, i64 0, i32 14
  %23 = load %struct.sv** %cop_warnings26, align 8, !tbaa !0
  %cmp27 = icmp eq %struct.sv* %23, null
  br i1 %cmp27, label %land.lhs.true29, label %sw.bb57

land.lhs.true29:                                  ; preds = %lor.lhs.false25
  %24 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and31 = and i8 %24, 1
  %tobool32 = icmp eq i8 %and31, 0
  br i1 %tobool32, label %sw.bb57, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %lor.lhs.false, %land.lhs.true29, %land.lhs.true19
  %25 = bitcast %struct.sv* %5 to %struct.cv*
  %call34 = tail call %struct.sv* @Perl_cv_const_sv(%struct.cv* %25) #7
  %tobool35 = icmp eq %struct.sv* %call34, null
  br i1 %tobool35, label %sw.bb57, label %if.then36

if.then36:                                        ; preds = %land.lhs.true33
  %sv_any37 = bitcast %struct.sv* %5 to %struct.xpvcv**
  %26 = load %struct.xpvcv** %sv_any37, align 8, !tbaa !0
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %26, i64 0, i32 17
  %27 = load i16* %xcv_flags, align 2, !tbaa !5
  %and39 = and i16 %27, 4
  %tobool40 = icmp eq i16 %and39, 0
  br i1 %tobool40, label %cond.false, label %cond.end54

cond.false:                                       ; preds = %if.then36
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %26, i64 0, i32 12
  %28 = load %struct.gv** %xcv_gv, align 8, !tbaa !0
  %sv_any42 = getelementptr inbounds %struct.gv* %28, i64 0, i32 0
  %29 = load %struct.xpvgv** %sv_any42, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %29, i64 0, i32 7
  %30 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_egv = getelementptr inbounds %struct.gp* %30, i64 0, i32 6
  %31 = load %struct.gv** %gp_egv, align 8, !tbaa !0
  %tobool43 = icmp eq %struct.gv* %31, null
  %. = select i1 %tobool43, %struct.gv* %28, %struct.gv* %31
  %sv_any53 = getelementptr inbounds %struct.gv* %., i64 0, i32 0
  %32 = load %struct.xpvgv** %sv_any53, align 8, !tbaa !0
  %xgv_name = getelementptr inbounds %struct.xpvgv* %32, i64 0, i32 8
  %33 = load i8** %xgv_name, align 8, !tbaa !0
  br label %cond.end54

cond.end54:                                       ; preds = %if.then36, %cond.false
  %cond55 = phi i8* [ %33, %cond.false ], [ getelementptr inbounds ([12 x i8]* @.str28, i64 0, i64 0), %if.then36 ]
  tail call void (i32, i8*, ...)* @Perl_warner(i32 12, i8* getelementptr inbounds ([33 x i8]* @.str27, i64 0, i64 0), i8* %cond55) #7
  br label %sw.bb57

sw.bb57:                                          ; preds = %land.lhs.true33, %land.lhs.true29, %lor.lhs.false25, %cond.end54, %if.end11
  %34 = bitcast %struct.sv* %5 to %struct.cv*
  %sv_any58 = bitcast %struct.sv* %5 to %struct.xpvcv**
  %35 = load %struct.xpvcv** %sv_any58, align 8, !tbaa !0
  %xcv_gv59 = getelementptr inbounds %struct.xpvcv* %35, i64 0, i32 12
  %36 = load %struct.gv** %xcv_gv59, align 8, !tbaa !0
  tail call void @Perl_cv_undef(%struct.cv* %34) #7
  %37 = load %struct.xpvcv** %sv_any58, align 8, !tbaa !0
  %xcv_gv61 = getelementptr inbounds %struct.xpvcv* %37, i64 0, i32 12
  store %struct.gv* %36, %struct.gv** %xcv_gv61, align 8, !tbaa !0
  br label %sw.epilog

sw.bb62:                                          ; preds = %if.end11
  %and64 = and i32 %8, 1048576
  %tobool65 = icmp eq i32 %and64, 0
  br i1 %tobool65, label %if.else, label %if.then66

if.then66:                                        ; preds = %sw.bb62
  %cmp67 = icmp eq %struct.sv* %5, @PL_sv_undef
  br i1 %cmp67, label %sw.epilog, label %if.then69

if.then69:                                        ; preds = %if.then66
  tail call void @Perl_sv_setsv_flags(%struct.sv* %5, %struct.sv* @PL_sv_undef, i32 2) #7
  %38 = load i32* %sv_flags, align 4, !tbaa !4
  %and71 = and i32 %38, 16384
  %tobool72 = icmp eq i32 %and71, 0
  br i1 %tobool72, label %sw.epilog, label %if.then73

if.then73:                                        ; preds = %if.then69
  %call74 = tail call i32 @Perl_mg_set(%struct.sv* %5) #7
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb62
  %39 = bitcast %struct.sv* %5 to %struct.gv*
  tail call void @Perl_gp_free(%struct.gv* %39) #7
  %call77 = tail call i8* @Perl_safesysmalloc(i64 88) #7
  %40 = bitcast i8* %call77 to %struct.gp*
  tail call void @llvm.memset.p0i8.i64(i8* %call77, i8 0, i64 88, i32 1, i1 false)
  %call78 = tail call %struct.gp* @Perl_gp_ref(%struct.gp* %40) #7
  %sv_any79 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %41 = load i8** %sv_any79, align 8, !tbaa !0
  %xgv_gp80 = getelementptr inbounds i8* %41, i64 56
  %42 = bitcast i8* %xgv_gp80 to %struct.gp**
  store %struct.gp* %call78, %struct.gp** %42, align 8, !tbaa !0
  %call81 = tail call %struct.sv* @Perl_newSV(i64 0) #7
  %43 = load i8** %sv_any79, align 8, !tbaa !0
  %xgv_gp83 = getelementptr inbounds i8* %43, i64 56
  %44 = bitcast i8* %xgv_gp83 to %struct.gp**
  %45 = load %struct.gp** %44, align 8, !tbaa !0
  %gp_sv = getelementptr inbounds %struct.gp* %45, i64 0, i32 0
  store %struct.sv* %call81, %struct.sv** %gp_sv, align 8, !tbaa !0
  %46 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_line = getelementptr inbounds %struct.cop* %46, i64 0, i32 13
  %47 = load i32* %cop_line, align 4, !tbaa !4
  %48 = load i8** %sv_any79, align 8, !tbaa !0
  %xgv_gp85 = getelementptr inbounds i8* %48, i64 56
  %49 = bitcast i8* %xgv_gp85 to %struct.gp**
  %50 = load %struct.gp** %49, align 8, !tbaa !0
  %gp_line = getelementptr inbounds %struct.gp* %50, i64 0, i32 10
  store i32 %47, i32* %gp_line, align 4, !tbaa !4
  %gp_egv88 = getelementptr inbounds %struct.gp* %50, i64 0, i32 6
  store %struct.gv* %39, %struct.gv** %gp_egv88, align 8, !tbaa !0
  %51 = load i8** %sv_any79, align 8, !tbaa !0
  %52 = getelementptr inbounds i8* %51, i64 88
  %53 = load i8* %52, align 1, !tbaa !1
  %or = or i8 %53, 2
  store i8 %or, i8* %52, align 1, !tbaa !1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end11
  %cmp95 = icmp ugt i32 %and13, 3
  br i1 %cmp95, label %land.lhs.true97, label %if.end116

land.lhs.true97:                                  ; preds = %sw.default
  %sv_any98 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %54 = load i8** %sv_any98, align 8, !tbaa !0
  %xpv_pv99 = bitcast i8* %54 to i8**
  %55 = load i8** %xpv_pv99, align 8, !tbaa !0
  %tobool100 = icmp eq i8* %55, null
  br i1 %tobool100, label %if.end116, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %land.lhs.true97
  %xpv_len = getelementptr inbounds i8* %54, i64 16
  %56 = bitcast i8* %xpv_len to i64*
  %57 = load i64* %56, align 8, !tbaa !3
  %tobool103 = icmp eq i64 %57, 0
  br i1 %tobool103, label %if.end116, label %if.then104

if.then104:                                       ; preds = %land.lhs.true101
  %and106 = and i32 %8, 2097152
  %tobool107 = icmp eq i32 %and106, 0
  br i1 %tobool107, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then104
  %call108 = tail call i32 @Perl_sv_backoff(%struct.sv* %5) #7
  %.pre182 = load i8** %sv_any98, align 8, !tbaa !0
  %xpv_pv111.phi.trans.insert = bitcast i8* %.pre182 to i8**
  %.pre183 = load i8** %xpv_pv111.phi.trans.insert, align 8, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %if.then104, %land.rhs
  %58 = phi i8* [ %55, %if.then104 ], [ %.pre183, %land.rhs ]
  tail call void @Perl_safesysfree(i8* %58) #7
  %59 = load i8** %sv_any98, align 8, !tbaa !0
  %xpv_pv113 = bitcast i8* %59 to i8**
  store i8* null, i8** %xpv_pv113, align 8, !tbaa !0
  %60 = load i8** %sv_any98, align 8, !tbaa !0
  %xpv_len115 = getelementptr inbounds i8* %60, i64 16
  %61 = bitcast i8* %xpv_len115 to i64*
  store i64 0, i64* %61, align 8, !tbaa !3
  %.pre184 = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end116

if.end116:                                        ; preds = %land.lhs.true101, %land.lhs.true97, %land.end, %sw.default
  %62 = phi i32 [ %8, %land.lhs.true101 ], [ %8, %land.lhs.true97 ], [ %.pre184, %land.end ], [ %8, %sw.default ]
  %and118 = and i32 %62, 1223753727
  store i32 %and118, i32* %sv_flags, align 4, !tbaa !4
  %and120 = and i32 %62, 2097152
  %tobool121 = icmp eq i32 %and120, 0
  br i1 %tobool121, label %land.end125, label %land.rhs122

land.rhs122:                                      ; preds = %if.end116
  %call123 = tail call i32 @Perl_sv_backoff(%struct.sv* %5) #7
  %.pre185 = load i32* %sv_flags, align 4, !tbaa !4
  br label %land.end125

land.end125:                                      ; preds = %if.end116, %land.rhs122
  %63 = phi i32 [ %and118, %if.end116 ], [ %.pre185, %land.rhs122 ]
  %and128 = and i32 %63, 16384
  %tobool129 = icmp eq i32 %and128, 0
  br i1 %tobool129, label %sw.epilog, label %if.then130

if.then130:                                       ; preds = %land.end125
  %call131 = tail call i32 @Perl_mg_set(%struct.sv* %5) #7
  br label %sw.epilog

sw.epilog:                                        ; preds = %land.end125, %if.then69, %if.then66, %if.then130, %if.else, %if.then73, %sw.bb57, %sw.bb14, %sw.bb, %if.end11
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %64 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next134 = getelementptr inbounds %struct.op* %64, i64 0, i32 0
  br label %return

return:                                           ; preds = %sw.epilog, %if.then5, %if.end
  %retval.0.in = phi %struct.op** [ %op_next134, %sw.epilog ], [ %op_next7, %if.then5 ], [ %op_next, %if.end ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_force_normal(%struct.sv*) #1

; Function Attrs: optsize
declare void @Perl_av_undef(%struct.av*) #1

; Function Attrs: optsize
declare void @Perl_hv_undef(%struct.hv*) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_cv_const_sv(%struct.cv*) #1

; Function Attrs: optsize
declare void @Perl_cv_undef(%struct.cv*) #1

; Function Attrs: optsize
declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i32) #1

; Function Attrs: optsize
declare void @Perl_gp_free(%struct.gv*) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #3

; Function Attrs: optsize
declare %struct.gp* @Perl_gp_ref(%struct.gp*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_predec() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 254
  %cmp = icmp ugt i32 %and, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #7
  br label %return

if.end:                                           ; preds = %entry
  %3 = and i32 %2, -2138636288
  %4 = icmp eq i32 %3, 65536
  br i1 %4, label %land.lhs.true14, label %if.else

land.lhs.true14:                                  ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %5, i64 24
  %6 = bitcast i8* %xiv_iv to i64*
  %7 = load i64* %6, align 8, !tbaa !3
  %cmp15 = icmp eq i64 %7, -9223372036854775808
  br i1 %cmp15, label %if.else, label %if.then16

if.then16:                                        ; preds = %land.lhs.true14
  %dec = add nsw i64 %7, -1
  store i64 %dec, i64* %6, align 8, !tbaa !3
  %and20 = and i32 %2, -100663297
  store i32 %and20, i32* %sv_flags, align 4, !tbaa !4
  br label %if.end21

if.else:                                          ; preds = %land.lhs.true14, %if.end
  tail call void @Perl_sv_dec(%struct.sv* %1) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags22.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre40 = load i32* %sv_flags22.phi.trans.insert, align 4, !tbaa !4
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then16
  %8 = phi i32 [ %.pre40, %if.else ], [ %and20, %if.then16 ]
  %9 = phi %struct.sv* [ %.pre, %if.else ], [ %1, %if.then16 ]
  %and23 = and i32 %8, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end21
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %9) #7
  br label %if.end27

if.end27:                                         ; preds = %if.end21, %if.then25
  %10 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %10, i64 0, i32 0
  %11 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end27, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %11, %if.end27 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_dec(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_postinc() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 254
  %cmp = icmp ugt i32 %and, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #7
  br label %return

if.end:                                           ; preds = %entry
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %5, i32 2) #7
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags1 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags1, align 4, !tbaa !4
  %9 = and i32 %8, -2138636288
  %10 = icmp eq i32 %9, 65536
  br i1 %10, label %land.lhs.true14, label %if.else

land.lhs.true14:                                  ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %11, i64 24
  %12 = bitcast i8* %xiv_iv to i64*
  %13 = load i64* %12, align 8, !tbaa !3
  %cmp15 = icmp eq i64 %13, 9223372036854775807
  br i1 %cmp15, label %if.else, label %if.then16

if.then16:                                        ; preds = %land.lhs.true14
  %inc = add nsw i64 %13, 1
  store i64 %inc, i64* %12, align 8, !tbaa !3
  %and20 = and i32 %8, -100663297
  store i32 %and20, i32* %sv_flags1, align 4, !tbaa !4
  br label %if.end21

if.else:                                          ; preds = %land.lhs.true14, %if.end
  tail call void @Perl_sv_inc(%struct.sv* %7) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags22.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre50 = load i32* %sv_flags22.phi.trans.insert, align 4, !tbaa !4
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then16
  %14 = phi i32 [ %.pre50, %if.else ], [ %and20, %if.then16 ]
  %15 = phi %struct.sv* [ %.pre, %if.else ], [ %7, %if.then16 ]
  %and23 = and i32 %14, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end21
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %15) #7
  br label %if.end27

if.end27:                                         ; preds = %if.end21, %if.then25
  %sv_flags28 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %16 = load i32* %sv_flags28, align 4, !tbaa !4
  %and29 = and i32 %16, 118423552
  %tobool30 = icmp eq i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end27
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 0) #7
  br label %if.end32

if.end32:                                         ; preds = %if.end27, %if.then31
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  %17 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %17, i64 0, i32 0
  %18 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end32, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %18, %if.end32 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_inc(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_postdec() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 254
  %cmp = icmp ugt i32 %and, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_modify, i64 0, i64 0)) #7
  br label %return

if.end:                                           ; preds = %entry
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %5, i32 2) #7
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags1 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags1, align 4, !tbaa !4
  %9 = and i32 %8, -2138636288
  %10 = icmp eq i32 %9, 65536
  br i1 %10, label %land.lhs.true14, label %if.else

land.lhs.true14:                                  ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %11, i64 24
  %12 = bitcast i8* %xiv_iv to i64*
  %13 = load i64* %12, align 8, !tbaa !3
  %cmp15 = icmp eq i64 %13, -9223372036854775808
  br i1 %cmp15, label %if.else, label %if.then16

if.then16:                                        ; preds = %land.lhs.true14
  %dec = add nsw i64 %13, -1
  store i64 %dec, i64* %12, align 8, !tbaa !3
  %and20 = and i32 %8, -100663297
  store i32 %and20, i32* %sv_flags1, align 4, !tbaa !4
  br label %if.end21

if.else:                                          ; preds = %land.lhs.true14, %if.end
  tail call void @Perl_sv_dec(%struct.sv* %7) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags22.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre43 = load i32* %sv_flags22.phi.trans.insert, align 4, !tbaa !4
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then16
  %14 = phi i32 [ %.pre43, %if.else ], [ %and20, %if.then16 ]
  %15 = phi %struct.sv* [ %.pre, %if.else ], [ %7, %if.then16 ]
  %and23 = and i32 %14, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end21
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %15) #7
  br label %if.end27

if.end27:                                         ; preds = %if.end21, %if.then25
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  %16 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %16, i64 0, i32 0
  %17 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end27, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %17, %if.end27 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_pow() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %add.ptr32.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 16, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %add.ptr32.pre-phi = phi %struct.sv** [ %add.ptr32.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %16 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags33 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags33, align 4, !tbaa !4
  %and34 = and i32 %17, 16777216
  %tobool35 = icmp eq i32 %and34, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end58

land.lhs.true36:                                  ; preds = %if.end31
  %18 = and i32 %17, 393216
  %or.cond.not = icmp ne i32 %18, 0
  %and49 = and i32 %17, 65536
  %tobool50 = icmp eq i32 %and49, 0
  %or.cond450 = and i1 %or.cond.not, %tobool50
  br i1 %or.cond450, label %cond.false53, label %if.end58

cond.false53:                                     ; preds = %land.lhs.true36
  %call55 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  %.pre = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags60.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre470 = load i32* %sv_flags60.phi.trans.insert, align 4, !tbaa !4
  br label %if.end58

if.end58:                                         ; preds = %land.lhs.true36, %if.end31, %cond.false53
  %19 = phi i32 [ %17, %land.lhs.true36 ], [ %17, %if.end31 ], [ %.pre470, %cond.false53 ]
  %20 = phi %struct.sv* [ %16, %land.lhs.true36 ], [ %16, %if.end31 ], [ %.pre, %cond.false53 ]
  %and61 = and i32 %19, 65536
  %tobool62 = icmp eq i32 %and61, 0
  br i1 %tobool62, label %if.end58.float_it_crit_edge, label %if.then63

if.end58.float_it_crit_edge:                      ; preds = %if.end58
  %.pre474 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags278.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre474, i64 0, i32 2
  %.pre475 = load i32* %sv_flags278.phi.trans.insert, align 4, !tbaa !4
  br label %float_it

if.then63:                                        ; preds = %if.end58
  %and66 = and i32 %19, -2147418112
  %cmp = icmp eq i32 %and66, -2147418112
  %conv68 = zext i1 %cmp to i8
  %sv_any72 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %21 = load i8** %sv_any72, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %21, i64 24
  %22 = bitcast i8* %xuv_uv to i64*
  %23 = load i64* %22, align 8, !tbaa !3
  br i1 %cmp, label %if.end82, label %if.else73

if.else73:                                        ; preds = %if.then63
  %cmp77 = icmp sgt i64 %23, -1
  %sub = sub nsw i64 0, %23
  %.sub = select i1 %cmp77, i64 %23, i64 %sub
  %.conv68 = select i1 %cmp77, i8 1, i8 %conv68
  br label %if.end82

if.end82:                                         ; preds = %if.then63, %if.else73
  %baseuv.0 = phi i64 [ %.sub, %if.else73 ], [ %23, %if.then63 ]
  %baseuok.0 = phi i8 [ %.conv68, %if.else73 ], [ %conv68, %if.then63 ]
  %24 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags83 = getelementptr inbounds %struct.sv* %24, i64 0, i32 2
  %25 = load i32* %sv_flags83, align 4, !tbaa !4
  %and84 = and i32 %25, 16777216
  %tobool85 = icmp eq i32 %and84, 0
  br i1 %tobool85, label %land.lhs.true86, label %if.end105

land.lhs.true86:                                  ; preds = %if.end82
  %26 = and i32 %25, 393216
  %or.cond446.not = icmp ne i32 %26, 0
  %and96 = and i32 %25, 65536
  %tobool97 = icmp eq i32 %and96, 0
  %or.cond451 = and i1 %or.cond446.not, %tobool97
  br i1 %or.cond451, label %cond.false101, label %if.end105

cond.false101:                                    ; preds = %land.lhs.true86
  %call102 = tail call i64 @Perl_sv_2iv(%struct.sv* %24) #7
  %.pre471 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags106.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre471, i64 0, i32 2
  %.pre472 = load i32* %sv_flags106.phi.trans.insert, align 4, !tbaa !4
  br label %if.end105

if.end105:                                        ; preds = %land.lhs.true86, %if.end82, %cond.false101
  %27 = phi i32 [ %25, %land.lhs.true86 ], [ %25, %if.end82 ], [ %.pre472, %cond.false101 ]
  %28 = phi %struct.sv* [ %24, %land.lhs.true86 ], [ %24, %if.end82 ], [ %.pre471, %cond.false101 ]
  %and107 = and i32 %27, 65536
  %tobool108 = icmp eq i32 %and107, 0
  br i1 %tobool108, label %float_it, label %if.then109

if.then109:                                       ; preds = %if.end105
  %and111 = and i32 %27, -2147418112
  %cmp112 = icmp eq i32 %and111, -2147418112
  %sv_any115 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %29 = load i8** %sv_any115, align 8, !tbaa !0
  %xuv_uv116 = getelementptr inbounds i8* %29, i64 24
  %30 = bitcast i8* %xuv_uv116 to i64*
  %31 = load i64* %30, align 8, !tbaa !3
  %cmp121 = icmp sgt i64 %31, -1
  %or.cond449 = or i1 %cmp112, %cmp121
  br i1 %or.cond449, label %if.end126, label %float_it

if.end126:                                        ; preds = %if.then109
  %sub127 = add i64 %baseuv.0, -1
  %and128 = and i64 %sub127, %baseuv.0
  %tobool129 = icmp eq i64 %and128, 0
  br i1 %tobool129, label %if.then130, label %while.body

if.then130:                                       ; preds = %if.end126
  %tobool132 = icmp eq i8 %baseuok.0, 0
  %conv134 = uitofp i64 %baseuv.0 to double
  br i1 %tobool132, label %cond.false135, label %for.cond.preheader

cond.false135:                                    ; preds = %if.then130
  %sub137 = fsub double -0.000000e+00, %conv134
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then130, %cond.false135
  %base.0.ph = phi double [ %sub137, %cond.false135 ], [ %conv134, %if.then130 ]
  %tobool140454 = icmp eq i64 %31, 0
  br i1 %tobool140454, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.cond.preheader ]
  %power.1458 = phi i64 [ %power.2, %for.inc ], [ %31, %for.cond.preheader ]
  %base.0456 = phi double [ %mul151, %for.inc ], [ %base.0.ph, %for.cond.preheader ]
  %result.0455 = phi double [ %result.1, %for.inc ], [ 1.000000e+00, %for.cond.preheader ]
  %shl = shl i64 1, %indvars.iv
  %and142 = and i64 %shl, %power.1458
  %tobool143 = icmp eq i64 %and142, 0
  br i1 %tobool143, label %for.inc, label %if.then144

if.then144:                                       ; preds = %for.body
  %mul = fmul double %result.0455, %base.0456
  %sub145 = sub i64 %power.1458, %shl
  %cmp146 = icmp eq i64 %power.1458, %shl
  br i1 %cmp146, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body, %if.then144
  %result.1 = phi double [ %mul, %if.then144 ], [ %result.0455, %for.body ]
  %power.2 = phi i64 [ %sub145, %if.then144 ], [ %power.1458, %for.body ]
  %mul151 = fmul double %base.0456, %base.0456
  %indvars.iv.next = add i64 %indvars.iv, 1
  %tobool140 = icmp eq i64 %power.2, 0
  br i1 %tobool140, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.then144, %for.cond.preheader
  %result.2 = phi double [ 1.000000e+00, %for.cond.preheader ], [ %mul, %if.then144 ], [ %result.1, %for.inc ]
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %result.2) #7
  %sv_flags153 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %32 = load i32* %sv_flags153, align 4, !tbaa !4
  %and154 = and i32 %32, 16384
  %tobool155 = icmp eq i32 %and154, 0
  br i1 %tobool155, label %if.end158, label %if.then156

if.then156:                                       ; preds = %for.end
  %call157 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  %.pre473 = load i32* %sv_flags153, align 4, !tbaa !4
  br label %if.end158

if.end158:                                        ; preds = %for.end, %if.then156
  %33 = phi i32 [ %32, %for.end ], [ %.pre473, %if.then156 ]
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %and160 = and i32 %33, 16777216
  %tobool161 = icmp eq i32 %and160, 0
  br i1 %tobool161, label %land.lhs.true162, label %if.end181

land.lhs.true162:                                 ; preds = %if.end158
  %34 = and i32 %33, 393216
  %or.cond447.not = icmp ne i32 %34, 0
  %and172 = and i32 %33, 65536
  %tobool173 = icmp eq i32 %and172, 0
  %or.cond452 = and i1 %or.cond447.not, %tobool173
  br i1 %or.cond452, label %cond.false177, label %if.end181

cond.false177:                                    ; preds = %land.lhs.true162
  %call178 = tail call i64 @Perl_sv_2iv(%struct.sv* %cond) #7
  br label %if.end181

if.end181:                                        ; preds = %land.lhs.true162, %if.end158, %cond.false177
  store %struct.sv** %add.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %35 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next182 = getelementptr inbounds %struct.op* %35, i64 0, i32 0
  br label %return

while.body:                                       ; preds = %if.end126, %while.body
  %shr467 = phi i32 [ %shr, %while.body ], [ 32, %if.end126 ]
  %lowbit.0466 = phi i32 [ %lowbit.0.add, %while.body ], [ 0, %if.end126 ]
  %highbit.0465 = phi i32 [ %sub196.highbit.0, %while.body ], [ 64, %if.end126 ]
  %add = add i32 %shr467, %lowbit.0466
  %neg = shl i32 -1, %add
  %conv190 = sext i32 %neg to i64
  %and191 = and i64 %conv190, %baseuv.0
  %tobool192 = icmp eq i64 %and191, 0
  %sub196 = select i1 %tobool192, i32 %shr467, i32 0
  %sub196.highbit.0 = sub i32 %highbit.0465, %sub196
  %lowbit.0.add = select i1 %tobool192, i32 %lowbit.0466, i32 %add
  %sub186 = sub i32 %sub196.highbit.0, %lowbit.0.add
  %shr = lshr i32 %sub186, 1
  %tobool187 = icmp eq i32 %shr, 0
  br i1 %tobool187, label %while.end, label %while.body

while.end:                                        ; preds = %while.body
  %conv198 = zext i32 %sub196.highbit.0 to i64
  %mul199 = mul i64 %conv198, %31
  %cmp200 = icmp ult i64 %mul199, 65
  br i1 %cmp200, label %for.cond206.preheader, label %float_it

for.cond206.preheader:                            ; preds = %while.end
  %tobool207459 = icmp eq i64 %31, 0
  br i1 %tobool207459, label %for.end225, label %for.body208

for.body208:                                      ; preds = %for.cond206.preheader, %for.inc222
  %indvars.iv468 = phi i64 [ %indvars.iv.next469, %for.inc222 ], [ 0, %for.cond206.preheader ]
  %base204.0462 = phi i64 [ %mul223, %for.inc222 ], [ %baseuv.0, %for.cond206.preheader ]
  %result203.0461 = phi i64 [ %result203.1, %for.inc222 ], [ 1, %for.cond206.preheader ]
  %power.3460 = phi i64 [ %power.4, %for.inc222 ], [ %31, %for.cond206.preheader ]
  %shl211 = shl i64 1, %indvars.iv468
  %and212 = and i64 %shl211, %power.3460
  %tobool213 = icmp eq i64 %and212, 0
  br i1 %tobool213, label %for.inc222, label %if.then214

if.then214:                                       ; preds = %for.body208
  %mul215 = mul i64 %base204.0462, %result203.0461
  %sub216 = sub i64 %power.3460, %shl211
  %cmp217 = icmp eq i64 %power.3460, %shl211
  br i1 %cmp217, label %for.end225, label %for.inc222

for.inc222:                                       ; preds = %for.body208, %if.then214
  %power.4 = phi i64 [ %sub216, %if.then214 ], [ %power.3460, %for.body208 ]
  %result203.1 = phi i64 [ %mul215, %if.then214 ], [ %result203.0461, %for.body208 ]
  %mul223 = mul i64 %base204.0462, %base204.0462
  %indvars.iv.next469 = add i64 %indvars.iv468, 1
  %tobool207 = icmp eq i64 %power.4, 0
  br i1 %tobool207, label %for.end225, label %for.body208

for.end225:                                       ; preds = %for.inc222, %if.then214, %for.cond206.preheader
  %result203.2 = phi i64 [ 1, %for.cond206.preheader ], [ %mul215, %if.then214 ], [ %result203.1, %for.inc222 ]
  %tobool228 = icmp eq i8 %baseuok.0, 0
  br i1 %tobool228, label %lor.lhs.false229, label %if.then231

lor.lhs.false229:                                 ; preds = %for.end225
  %conv185 = and i64 %31, 1
  %tobool230 = icmp eq i64 %conv185, 0
  br i1 %tobool230, label %if.then231, label %if.else238

if.then231:                                       ; preds = %lor.lhs.false229, %for.end225
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %result203.2) #7
  %sv_flags232 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %36 = load i32* %sv_flags232, align 4, !tbaa !4
  %and233 = and i32 %36, 16384
  %tobool234 = icmp eq i32 %and233, 0
  br i1 %tobool234, label %if.end237, label %if.then235

if.then235:                                       ; preds = %if.then231
  %call236 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end237

if.end237:                                        ; preds = %if.then231, %if.then235
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end270

if.else238:                                       ; preds = %lor.lhs.false229
  %cmp239 = icmp sgt i64 %result203.2, -1
  br i1 %cmp239, label %if.then241, label %if.else249

if.then241:                                       ; preds = %if.else238
  %sub242 = sub nsw i64 0, %result203.2
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %sub242) #7
  %sv_flags243 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %37 = load i32* %sv_flags243, align 4, !tbaa !4
  %and244 = and i32 %37, 16384
  %tobool245 = icmp eq i32 %and244, 0
  br i1 %tobool245, label %if.end248, label %if.then246

if.then246:                                       ; preds = %if.then241
  %call247 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end248

if.end248:                                        ; preds = %if.then241, %if.then246
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end270

if.else249:                                       ; preds = %if.else238
  %cmp250 = icmp eq i64 %result203.2, -9223372036854775808
  br i1 %cmp250, label %if.then252, label %if.else259

if.then252:                                       ; preds = %if.else249
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 -9223372036854775808) #7
  %sv_flags253 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %38 = load i32* %sv_flags253, align 4, !tbaa !4
  %and254 = and i32 %38, 16384
  %tobool255 = icmp eq i32 %and254, 0
  br i1 %tobool255, label %if.end258, label %if.then256

if.then256:                                       ; preds = %if.then252
  %call257 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end258

if.end258:                                        ; preds = %if.then252, %if.then256
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end270

if.else259:                                       ; preds = %if.else249
  %conv260 = uitofp i64 %result203.2 to double
  %sub261 = fsub double -0.000000e+00, %conv260
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %sub261) #7
  %sv_flags262 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %39 = load i32* %sv_flags262, align 4, !tbaa !4
  %and263 = and i32 %39, 16384
  %tobool264 = icmp eq i32 %and263, 0
  br i1 %tobool264, label %if.end267, label %if.then265

if.then265:                                       ; preds = %if.else259
  %call266 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end267

if.end267:                                        ; preds = %if.else259, %if.then265
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end270

if.end270:                                        ; preds = %if.end248, %if.end267, %if.end258, %if.end237
  store %struct.sv** %add.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %40 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next271 = getelementptr inbounds %struct.op* %40, i64 0, i32 0
  br label %return

float_it:                                         ; preds = %if.end58.float_it_crit_edge, %if.then109, %if.end105, %while.end
  %41 = phi i32 [ %27, %while.end ], [ %27, %if.end105 ], [ %.pre475, %if.end58.float_it_crit_edge ], [ %27, %if.then109 ]
  %42 = phi %struct.sv* [ %28, %while.end ], [ %28, %if.end105 ], [ %.pre474, %if.end58.float_it_crit_edge ], [ %28, %if.then109 ]
  %is_int.0 = phi i8 [ 1, %while.end ], [ 0, %if.end105 ], [ 0, %if.end58.float_it_crit_edge ], [ 0, %if.then109 ]
  store %struct.sv* %42, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and279 = and i32 %41, 131072
  %tobool280 = icmp eq i32 %and279, 0
  br i1 %tobool280, label %cond.false283, label %cond.true281

cond.true281:                                     ; preds = %float_it
  %sv_any282 = getelementptr inbounds %struct.sv* %42, i64 0, i32 0
  %43 = load i8** %sv_any282, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %43, i64 32
  %44 = bitcast i8* %xnv_nv to double*
  %45 = load double* %44, align 8, !tbaa !6
  br label %cond.end285

cond.false283:                                    ; preds = %float_it
  %call284 = tail call double @Perl_sv_2nv(%struct.sv* %42) #7
  br label %cond.end285

cond.end285:                                      ; preds = %cond.false283, %cond.true281
  %cond286 = phi double [ %45, %cond.true281 ], [ %call284, %cond.false283 ]
  %46 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags288 = getelementptr inbounds %struct.sv* %46, i64 0, i32 2
  %47 = load i32* %sv_flags288, align 4, !tbaa !4
  %and289 = and i32 %47, 131072
  %tobool290 = icmp eq i32 %and289, 0
  br i1 %tobool290, label %cond.false294, label %cond.true291

cond.true291:                                     ; preds = %cond.end285
  %sv_any292 = getelementptr inbounds %struct.sv* %46, i64 0, i32 0
  %48 = load i8** %sv_any292, align 8, !tbaa !0
  %xnv_nv293 = getelementptr inbounds i8* %48, i64 32
  %49 = bitcast i8* %xnv_nv293 to double*
  %50 = load double* %49, align 8, !tbaa !6
  br label %cond.end296

cond.false294:                                    ; preds = %cond.end285
  %call295 = tail call double @Perl_sv_2nv(%struct.sv* %46) #7
  br label %cond.end296

cond.end296:                                      ; preds = %cond.false294, %cond.true291
  %cond297 = phi double [ %50, %cond.true291 ], [ %call295, %cond.false294 ]
  %call298 = tail call double @pow(double %cond297, double %cond286) #7
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %call298) #7
  %sv_flags299 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %51 = load i32* %sv_flags299, align 4, !tbaa !4
  %and300 = and i32 %51, 16384
  %tobool301 = icmp eq i32 %and300, 0
  br i1 %tobool301, label %if.end304, label %if.then302

if.then302:                                       ; preds = %cond.end296
  %call303 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end304

if.end304:                                        ; preds = %cond.end296, %if.then302
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %tobool305 = icmp eq i8 %is_int.0, 0
  br i1 %tobool305, label %if.end330, label %if.then306

if.then306:                                       ; preds = %if.end304
  %52 = load i32* %sv_flags299, align 4, !tbaa !4
  %and308 = and i32 %52, 16777216
  %tobool309 = icmp eq i32 %and308, 0
  br i1 %tobool309, label %land.lhs.true310, label %if.end330

land.lhs.true310:                                 ; preds = %if.then306
  %53 = and i32 %52, 393216
  %or.cond448.not = icmp ne i32 %53, 0
  %and320 = and i32 %52, 65536
  %tobool321 = icmp eq i32 %and320, 0
  %or.cond453 = and i1 %or.cond448.not, %tobool321
  br i1 %or.cond453, label %cond.false325, label %if.end330

cond.false325:                                    ; preds = %land.lhs.true310
  %call326 = tail call i64 @Perl_sv_2iv(%struct.sv* %cond) #7
  br label %if.end330

if.end330:                                        ; preds = %land.lhs.true310, %if.then306, %if.end304, %cond.false325
  store %struct.sv** %add.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %54 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next331 = getelementptr inbounds %struct.op* %54, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end330, %if.end270, %if.end181, %if.end29
  %retval.0.in = phi %struct.op** [ %op_next, %if.end29 ], [ %op_next271, %if.end270 ], [ %op_next331, %if.end330 ], [ %op_next182, %if.end181 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i64 @Perl_sv_2iv(%struct.sv*) #1

; Function Attrs: optsize
declare void @Perl_sv_setnv(%struct.sv*, double) #1

; Function Attrs: optsize
declare void @Perl_sv_setuv(%struct.sv*, i64) #1

; Function Attrs: optsize
declare double @Perl_sv_2nv(%struct.sv*) #1

; Function Attrs: optsize
declare double @pow(double, double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_multiply() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %if.end31, label %if.then

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 10, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end, %lor.lhs.false
  %16 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags32 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags32, align 4, !tbaa !4
  %and33 = and i32 %17, 16777216
  %tobool34 = icmp eq i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true35, label %if.end52

land.lhs.true35:                                  ; preds = %if.end31
  %18 = and i32 %17, 393216
  %or.cond.not = icmp ne i32 %18, 0
  %and45 = and i32 %17, 65536
  %tobool46 = icmp eq i32 %and45, 0
  %or.cond349 = and i1 %or.cond.not, %tobool46
  br i1 %or.cond349, label %cond.false48, label %if.end52

cond.false48:                                     ; preds = %land.lhs.true35
  %call49 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags53.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre351 = load i32* %sv_flags53.phi.trans.insert, align 4, !tbaa !4
  br label %if.end52

if.end52:                                         ; preds = %land.lhs.true35, %if.end31, %cond.false48
  %19 = phi i32 [ %17, %land.lhs.true35 ], [ %17, %if.end31 ], [ %.pre351, %cond.false48 ]
  %20 = phi %struct.sv* [ %16, %land.lhs.true35 ], [ %16, %if.end31 ], [ %.pre, %cond.false48 ]
  %and54 = and i32 %19, 65536
  %tobool55 = icmp eq i32 %and54, 0
  %incdec.ptr216.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %tobool55, label %if.end214, label %if.then56

if.then56:                                        ; preds = %if.end52
  %21 = load %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  %sv_flags58 = getelementptr inbounds %struct.sv* %21, i64 0, i32 2
  %22 = load i32* %sv_flags58, align 4, !tbaa !4
  %and59 = and i32 %22, 16777216
  %tobool60 = icmp eq i32 %and59, 0
  br i1 %tobool60, label %land.lhs.true61, label %if.end85

land.lhs.true61:                                  ; preds = %if.then56
  %23 = and i32 %22, 393216
  %or.cond345.not = icmp ne i32 %23, 0
  %and74 = and i32 %22, 65536
  %tobool75 = icmp eq i32 %and74, 0
  %or.cond350 = and i1 %or.cond345.not, %tobool75
  br i1 %or.cond350, label %cond.false80, label %if.end85

cond.false80:                                     ; preds = %land.lhs.true61
  %call82 = tail call i64 @Perl_sv_2iv(%struct.sv* %21) #7
  %.pre352 = load %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  %sv_flags87.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre352, i64 0, i32 2
  %.pre353 = load i32* %sv_flags87.phi.trans.insert, align 4, !tbaa !4
  br label %if.end85

if.end85:                                         ; preds = %land.lhs.true61, %if.then56, %cond.false80
  %24 = phi i32 [ %22, %land.lhs.true61 ], [ %22, %if.then56 ], [ %.pre353, %cond.false80 ]
  %25 = phi %struct.sv* [ %21, %land.lhs.true61 ], [ %21, %if.then56 ], [ %.pre352, %cond.false80 ]
  %and88 = and i32 %24, 65536
  %tobool89 = icmp eq i32 %and88, 0
  br i1 %tobool89, label %if.end85.if.end214_crit_edge, label %if.then90

if.end85.if.end214_crit_edge:                     ; preds = %if.end85
  %.pre354 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags217.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre354, i64 0, i32 2
  %.pre355 = load i32* %sv_flags217.phi.trans.insert, align 4, !tbaa !4
  br label %if.end214

if.then90:                                        ; preds = %if.end85
  %and93 = and i32 %24, -2147418112
  %cmp = icmp eq i32 %and93, -2147418112
  %conv95 = zext i1 %cmp to i8
  %26 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags96 = getelementptr inbounds %struct.sv* %26, i64 0, i32 2
  %27 = load i32* %sv_flags96, align 4, !tbaa !4
  %and97 = and i32 %27, -2147418112
  %cmp98 = icmp eq i32 %and97, -2147418112
  %conv100 = zext i1 %cmp98 to i8
  %sv_any104 = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %28 = load i8** %sv_any104, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  br i1 %cmp, label %if.end114, label %if.else105

if.else105:                                       ; preds = %if.then90
  %cmp109 = icmp sgt i64 %30, -1
  %sub = sub nsw i64 0, %30
  %.sub = select i1 %cmp109, i64 %30, i64 %sub
  %.conv95 = select i1 %cmp109, i8 1, i8 %conv95
  br label %if.end114

if.end114:                                        ; preds = %if.else105, %if.then90
  %alow.0 = phi i64 [ %30, %if.then90 ], [ %.sub, %if.else105 ]
  %auvok.0 = phi i8 [ %conv95, %if.then90 ], [ %.conv95, %if.else105 ]
  %sv_any117 = getelementptr inbounds %struct.sv* %26, i64 0, i32 0
  %31 = load i8** %sv_any117, align 8, !tbaa !0
  %xuv_uv118 = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xuv_uv118 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  br i1 %cmp98, label %if.end128, label %if.else119

if.else119:                                       ; preds = %if.end114
  %cmp122 = icmp sgt i64 %33, -1
  %sub126 = sub nsw i64 0, %33
  %.sub126 = select i1 %cmp122, i64 %33, i64 %sub126
  %.conv100 = select i1 %cmp122, i8 1, i8 %conv100
  br label %if.end128

if.end128:                                        ; preds = %if.else119, %if.end114
  %blow.0 = phi i64 [ %33, %if.end114 ], [ %.sub126, %if.else119 ]
  %buvok.0 = phi i8 [ %conv100, %if.end114 ], [ %.conv100, %if.else119 ]
  %shr = lshr i64 %alow.0, 32
  %and129 = and i64 %alow.0, 4294967295
  %shr130 = lshr i64 %blow.0, 32
  %and131 = and i64 %blow.0, 4294967295
  %tobool132.not = icmp eq i64 %shr, 0
  %tobool134 = icmp eq i64 %shr130, 0
  %or.cond346 = or i1 %tobool132.not, %tobool134
  br i1 %or.cond346, label %if.else136, label %if.end214

if.else136:                                       ; preds = %if.end128
  %34 = or i64 %shr130, %shr
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %if.then140, label %if.else169

if.then140:                                       ; preds = %if.else136
  %mul = mul i64 %and131, %and129
  %cmp143 = icmp eq i8 %auvok.0, %buvok.0
  br i1 %cmp143, label %if.then145, label %if.else154

if.then145:                                       ; preds = %if.then140
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %mul) #7
  %sv_flags147 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %36 = load i32* %sv_flags147, align 4, !tbaa !4
  %and148 = and i32 %36, 16384
  %tobool149 = icmp eq i32 %and148, 0
  br i1 %tobool149, label %if.end152, label %if.then150

if.then150:                                       ; preds = %if.then145
  %call151 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end152

if.end152:                                        ; preds = %if.then145, %if.then150
  store %struct.sv* %cond, %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr216.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %37 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next153 = getelementptr inbounds %struct.op* %37, i64 0, i32 0
  br label %return

if.else154:                                       ; preds = %if.then140
  %cmp155 = icmp ult i64 %mul, -9223372036854775807
  br i1 %cmp155, label %if.then157, label %if.end214

if.then157:                                       ; preds = %if.else154
  %sub159 = sub nsw i64 0, %mul
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %sub159) #7
  %sv_flags160 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %38 = load i32* %sv_flags160, align 4, !tbaa !4
  %and161 = and i32 %38, 16384
  %tobool162 = icmp eq i32 %and161, 0
  br i1 %tobool162, label %if.end165, label %if.then163

if.then163:                                       ; preds = %if.then157
  %call164 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end165

if.end165:                                        ; preds = %if.then157, %if.then163
  store %struct.sv* %cond, %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr216.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %39 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next166 = getelementptr inbounds %struct.op* %39, i64 0, i32 0
  br label %return

if.else169:                                       ; preds = %if.else136
  %shr.shr130 = select i1 %tobool134, i64 %shr, i64 %shr130
  %and131.and129 = select i1 %tobool134, i64 %and131, i64 %and129
  %mul173 = mul i64 %shr.shr130, %and131.and129
  %tobool175 = icmp ugt i64 %mul173, 4294967295
  br i1 %tobool175, label %if.end214, label %if.then176

if.then176:                                       ; preds = %if.else169
  %and129.and131 = select i1 %tobool134, i64 %and129, i64 %and131
  %shl = shl i64 %mul173, 32
  %mul177 = mul i64 %and129.and131, %and131.and129
  %uadd = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %mul177, i64 %shl)
  %40 = extractvalue { i64, i1 } %uadd, 0
  %cmp178 = extractvalue { i64, i1 } %uadd, 1
  br i1 %cmp178, label %if.end214, label %if.then180

if.then180:                                       ; preds = %if.then176
  %cmp183 = icmp eq i8 %auvok.0, %buvok.0
  br i1 %cmp183, label %if.then185, label %if.else194

if.then185:                                       ; preds = %if.then180
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %40) #7
  %sv_flags187 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %41 = load i32* %sv_flags187, align 4, !tbaa !4
  %and188 = and i32 %41, 16384
  %tobool189 = icmp eq i32 %and188, 0
  br i1 %tobool189, label %if.end192, label %if.then190

if.then190:                                       ; preds = %if.then185
  %call191 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end192

if.end192:                                        ; preds = %if.then185, %if.then190
  store %struct.sv* %cond, %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr216.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next193 = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  br label %return

if.else194:                                       ; preds = %if.then180
  %cmp195 = icmp ult i64 %40, -9223372036854775807
  br i1 %cmp195, label %if.then197, label %if.end214

if.then197:                                       ; preds = %if.else194
  %sub199 = sub nsw i64 0, %40
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %sub199) #7
  %sv_flags200 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %43 = load i32* %sv_flags200, align 4, !tbaa !4
  %and201 = and i32 %43, 16384
  %tobool202 = icmp eq i32 %and201, 0
  br i1 %tobool202, label %if.end205, label %if.then203

if.then203:                                       ; preds = %if.then197
  %call204 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end205

if.end205:                                        ; preds = %if.then197, %if.then203
  store %struct.sv* %cond, %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr216.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %44 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next206 = getelementptr inbounds %struct.op* %44, i64 0, i32 0
  br label %return

if.end214:                                        ; preds = %if.end52, %if.end85.if.end214_crit_edge, %if.end128, %if.then176, %if.else154, %if.else194, %if.else169
  %45 = phi i32 [ %.pre355, %if.end85.if.end214_crit_edge ], [ %27, %if.end128 ], [ %27, %if.then176 ], [ %27, %if.else154 ], [ %27, %if.else194 ], [ %27, %if.else169 ], [ %19, %if.end52 ]
  %46 = phi %struct.sv* [ %.pre354, %if.end85.if.end214_crit_edge ], [ %26, %if.end128 ], [ %26, %if.then176 ], [ %26, %if.else154 ], [ %26, %if.else194 ], [ %26, %if.else169 ], [ %20, %if.end52 ]
  store %struct.sv* %46, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and218 = and i32 %45, 131072
  %tobool219 = icmp eq i32 %and218, 0
  br i1 %tobool219, label %cond.false222, label %cond.true220

cond.true220:                                     ; preds = %if.end214
  %sv_any221 = getelementptr inbounds %struct.sv* %46, i64 0, i32 0
  %47 = load i8** %sv_any221, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %47, i64 32
  %48 = bitcast i8* %xnv_nv to double*
  %49 = load double* %48, align 8, !tbaa !6
  br label %cond.end224

cond.false222:                                    ; preds = %if.end214
  %call223 = tail call double @Perl_sv_2nv(%struct.sv* %46) #7
  br label %cond.end224

cond.end224:                                      ; preds = %cond.false222, %cond.true220
  %cond225 = phi double [ %49, %cond.true220 ], [ %call223, %cond.false222 ]
  %50 = load %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  %sv_flags227 = getelementptr inbounds %struct.sv* %50, i64 0, i32 2
  %51 = load i32* %sv_flags227, align 4, !tbaa !4
  %and228 = and i32 %51, 131072
  %tobool229 = icmp eq i32 %and228, 0
  br i1 %tobool229, label %cond.false233, label %cond.true230

cond.true230:                                     ; preds = %cond.end224
  %sv_any231 = getelementptr inbounds %struct.sv* %50, i64 0, i32 0
  %52 = load i8** %sv_any231, align 8, !tbaa !0
  %xnv_nv232 = getelementptr inbounds i8* %52, i64 32
  %53 = bitcast i8* %xnv_nv232 to double*
  %54 = load double* %53, align 8, !tbaa !6
  br label %cond.end235

cond.false233:                                    ; preds = %cond.end224
  %call234 = tail call double @Perl_sv_2nv(%struct.sv* %50) #7
  br label %cond.end235

cond.end235:                                      ; preds = %cond.false233, %cond.true230
  %cond236 = phi double [ %54, %cond.true230 ], [ %call234, %cond.false233 ]
  %mul237 = fmul double %cond225, %cond236
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %mul237) #7
  %sv_flags238 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %55 = load i32* %sv_flags238, align 4, !tbaa !4
  %and239 = and i32 %55, 16384
  %tobool240 = icmp eq i32 %and239, 0
  br i1 %tobool240, label %if.end243, label %if.then241

if.then241:                                       ; preds = %cond.end235
  %call242 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end243

if.end243:                                        ; preds = %cond.end235, %if.then241
  store %struct.sv* %cond, %struct.sv** %incdec.ptr216.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr216.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %56 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next244 = getelementptr inbounds %struct.op* %56, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end243, %if.end205, %if.end192, %if.end165, %if.end152, %if.end29
  %retval.0.in = phi %struct.op** [ %op_next, %if.end29 ], [ %op_next244, %if.end243 ], [ %op_next193, %if.end192 ], [ %op_next206, %if.end205 ], [ %op_next153, %if.end152 ], [ %op_next166, %if.end165 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_divide() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %if.end31, label %if.then

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 12, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  %16 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end, %lor.lhs.false
  %17 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags32 = getelementptr inbounds %struct.sv* %17, i64 0, i32 2
  %18 = load i32* %sv_flags32, align 4, !tbaa !4
  %and33 = and i32 %18, 16777216
  %tobool34 = icmp eq i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true35, label %if.end52

land.lhs.true35:                                  ; preds = %if.end31
  %19 = and i32 %18, 393216
  %or.cond291.not = icmp ne i32 %19, 0
  %and45 = and i32 %18, 65536
  %tobool46 = icmp eq i32 %and45, 0
  %or.cond293 = and i1 %or.cond291.not, %tobool46
  br i1 %or.cond293, label %cond.false48, label %if.end52

cond.false48:                                     ; preds = %land.lhs.true35
  %call49 = tail call i64 @Perl_sv_2iv(%struct.sv* %17) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags53.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre295 = load i32* %sv_flags53.phi.trans.insert, align 4, !tbaa !4
  br label %if.end52

if.end52:                                         ; preds = %land.lhs.true35, %if.end31, %cond.false48
  %20 = phi i32 [ %18, %land.lhs.true35 ], [ %18, %if.end31 ], [ %.pre295, %cond.false48 ]
  %21 = phi %struct.sv* [ %17, %land.lhs.true35 ], [ %17, %if.end31 ], [ %.pre, %cond.false48 ]
  %and54 = and i32 %20, 65536
  %tobool55 = icmp eq i32 %and54, 0
  %incdec.ptr185.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %tobool55, label %if.end183, label %if.then56

if.then56:                                        ; preds = %if.end52
  %22 = load %struct.sv** %incdec.ptr185.pre, align 8, !tbaa !0
  %sv_flags58 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i32* %sv_flags58, align 4, !tbaa !4
  %and59 = and i32 %23, 16777216
  %tobool60 = icmp eq i32 %and59, 0
  br i1 %tobool60, label %land.lhs.true61, label %if.end85

land.lhs.true61:                                  ; preds = %if.then56
  %24 = and i32 %23, 393216
  %or.cond292.not = icmp ne i32 %24, 0
  %and74 = and i32 %23, 65536
  %tobool75 = icmp eq i32 %and74, 0
  %or.cond294 = and i1 %or.cond292.not, %tobool75
  br i1 %or.cond294, label %cond.false80, label %if.end85

cond.false80:                                     ; preds = %land.lhs.true61
  %call82 = tail call i64 @Perl_sv_2iv(%struct.sv* %22) #7
  %.pre296 = load %struct.sv** %incdec.ptr185.pre, align 8, !tbaa !0
  %sv_flags87.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre296, i64 0, i32 2
  %.pre297 = load i32* %sv_flags87.phi.trans.insert, align 4, !tbaa !4
  br label %if.end85

if.end85:                                         ; preds = %land.lhs.true61, %if.then56, %cond.false80
  %25 = phi i32 [ %23, %land.lhs.true61 ], [ %23, %if.then56 ], [ %.pre297, %cond.false80 ]
  %26 = phi %struct.sv* [ %22, %land.lhs.true61 ], [ %22, %if.then56 ], [ %.pre296, %cond.false80 ]
  %and88 = and i32 %25, 65536
  %tobool89 = icmp eq i32 %and88, 0
  br i1 %tobool89, label %if.end85.if.end183_crit_edge, label %if.then90

if.end85.if.end183_crit_edge:                     ; preds = %if.end85
  %.pre298 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags186.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre298, i64 0, i32 2
  %.pre299 = load i32* %sv_flags186.phi.trans.insert, align 4, !tbaa !4
  br label %if.end183

if.then90:                                        ; preds = %if.end85
  %and93 = and i32 %25, -2147418112
  %cmp = icmp eq i32 %and93, -2147418112
  %conv95 = zext i1 %cmp to i8
  %27 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags96 = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %28 = load i32* %sv_flags96, align 4, !tbaa !4
  %and97 = and i32 %28, -2147418112
  %cmp98 = icmp eq i32 %and97, -2147418112
  %conv100 = zext i1 %cmp98 to i8
  %sv_any105 = getelementptr inbounds %struct.sv* %27, i64 0, i32 0
  %29 = load i8** %sv_any105, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %29, i64 24
  %30 = bitcast i8* %xuv_uv to i64*
  %31 = load i64* %30, align 8, !tbaa !3
  br i1 %cmp98, label %if.end114, label %if.else106

if.else106:                                       ; preds = %if.then90
  %cmp109 = icmp sgt i64 %31, -1
  %sub = sub nsw i64 0, %31
  %.sub = select i1 %cmp109, i64 %31, i64 %sub
  %.conv100 = select i1 %cmp109, i8 1, i8 %conv100
  br label %if.end114

if.end114:                                        ; preds = %if.else106, %if.then90
  %right102.0 = phi i64 [ %31, %if.then90 ], [ %.sub, %if.else106 ]
  %right_non_neg.0 = phi i8 [ %conv100, %if.then90 ], [ %.conv100, %if.else106 ]
  %cmp115 = icmp eq i64 %right102.0, 0
  br i1 %cmp115, label %if.then117, label %if.end119

if.then117:                                       ; preds = %if.end114
  %call118 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([25 x i8]* @.str29, i64 0, i64 0)) #7
  br label %return

if.end119:                                        ; preds = %if.end114
  %sv_any123 = getelementptr inbounds %struct.sv* %26, i64 0, i32 0
  %32 = load i8** %sv_any123, align 8, !tbaa !0
  %xuv_uv124 = getelementptr inbounds i8* %32, i64 24
  %33 = bitcast i8* %xuv_uv124 to i64*
  %34 = load i64* %33, align 8, !tbaa !3
  br i1 %cmp, label %if.end135, label %if.else125

if.else125:                                       ; preds = %if.end119
  %cmp129 = icmp sgt i64 %34, -1
  %sub133 = sub nsw i64 0, %34
  %.sub133 = select i1 %cmp129, i64 %34, i64 %sub133
  %.conv95 = select i1 %cmp129, i8 1, i8 %conv95
  br label %if.end135

if.end135:                                        ; preds = %if.else125, %if.end119
  %left101.0 = phi i64 [ %34, %if.end119 ], [ %.sub133, %if.else125 ]
  %left_non_neg.0 = phi i8 [ %conv95, %if.end119 ], [ %.conv95, %if.else125 ]
  %cmp136 = icmp uge i64 %left101.0, %right102.0
  %cmp139 = icmp ugt i64 %left101.0, 4294967296
  %or.cond = and i1 %cmp136, %cmp139
  br i1 %or.cond, label %if.then141, label %if.end183

if.then141:                                       ; preds = %if.end135
  %div = udiv i64 %left101.0, %right102.0
  %mul = mul i64 %div, %right102.0
  %cmp142 = icmp eq i64 %mul, %left101.0
  br i1 %cmp142, label %if.then144, label %if.end183

if.then144:                                       ; preds = %if.then141
  %cmp148 = icmp eq i8 %left_non_neg.0, %right_non_neg.0
  br i1 %cmp148, label %if.then150, label %if.end158

if.then150:                                       ; preds = %if.then144
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %div) #7
  %sv_flags151 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %35 = load i32* %sv_flags151, align 4, !tbaa !4
  %and152 = and i32 %35, 16384
  %tobool153 = icmp eq i32 %and152, 0
  br i1 %tobool153, label %if.end156, label %if.then154

if.then154:                                       ; preds = %if.then150
  %call155 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end156

if.end156:                                        ; preds = %if.then150, %if.then154
  store %struct.sv* %cond, %struct.sv** %incdec.ptr185.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr185.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %36 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next157 = getelementptr inbounds %struct.op* %36, i64 0, i32 0
  %37 = load %struct.op** %op_next157, align 8, !tbaa !0
  br label %return

if.end158:                                        ; preds = %if.then144
  %cmp159 = icmp ult i64 %div, -9223372036854775807
  br i1 %cmp159, label %if.then161, label %if.else169

if.then161:                                       ; preds = %if.end158
  %sub162 = sub nsw i64 0, %div
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %sub162) #7
  %sv_flags163 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %38 = load i32* %sv_flags163, align 4, !tbaa !4
  %and164 = and i32 %38, 16384
  %tobool165 = icmp eq i32 %and164, 0
  br i1 %tobool165, label %if.end178, label %if.then166

if.then166:                                       ; preds = %if.then161
  %call167 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end178

if.else169:                                       ; preds = %if.end158
  %conv170 = uitofp i64 %div to double
  %sub171 = fsub double -0.000000e+00, %conv170
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %sub171) #7
  %sv_flags172 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %39 = load i32* %sv_flags172, align 4, !tbaa !4
  %and173 = and i32 %39, 16384
  %tobool174 = icmp eq i32 %and173, 0
  br i1 %tobool174, label %if.end178, label %if.then175

if.then175:                                       ; preds = %if.else169
  %call176 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end178

if.end178:                                        ; preds = %if.then175, %if.else169, %if.then166, %if.then161
  store %struct.sv* %cond, %struct.sv** %incdec.ptr185.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr185.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %40 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next179 = getelementptr inbounds %struct.op* %40, i64 0, i32 0
  %41 = load %struct.op** %op_next179, align 8, !tbaa !0
  br label %return

if.end183:                                        ; preds = %if.end52, %if.end85.if.end183_crit_edge, %if.then141, %if.end135
  %42 = phi i32 [ %.pre299, %if.end85.if.end183_crit_edge ], [ %28, %if.then141 ], [ %28, %if.end135 ], [ %20, %if.end52 ]
  %43 = phi %struct.sv* [ %.pre298, %if.end85.if.end183_crit_edge ], [ %27, %if.then141 ], [ %27, %if.end135 ], [ %21, %if.end52 ]
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and187 = and i32 %42, 131072
  %tobool188 = icmp eq i32 %and187, 0
  br i1 %tobool188, label %cond.false191, label %cond.true189

cond.true189:                                     ; preds = %if.end183
  %sv_any190 = getelementptr inbounds %struct.sv* %43, i64 0, i32 0
  %44 = load i8** %sv_any190, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %44, i64 32
  %45 = bitcast i8* %xnv_nv to double*
  %46 = load double* %45, align 8, !tbaa !6
  br label %cond.end193

cond.false191:                                    ; preds = %if.end183
  %call192 = tail call double @Perl_sv_2nv(%struct.sv* %43) #7
  br label %cond.end193

cond.end193:                                      ; preds = %cond.false191, %cond.true189
  %cond194 = phi double [ %46, %cond.true189 ], [ %call192, %cond.false191 ]
  %47 = load %struct.sv** %incdec.ptr185.pre, align 8, !tbaa !0
  store %struct.sv* %47, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags197 = getelementptr inbounds %struct.sv* %47, i64 0, i32 2
  %48 = load i32* %sv_flags197, align 4, !tbaa !4
  %and198 = and i32 %48, 131072
  %tobool199 = icmp eq i32 %and198, 0
  br i1 %tobool199, label %cond.false203, label %cond.true200

cond.true200:                                     ; preds = %cond.end193
  %sv_any201 = getelementptr inbounds %struct.sv* %47, i64 0, i32 0
  %49 = load i8** %sv_any201, align 8, !tbaa !0
  %xnv_nv202 = getelementptr inbounds i8* %49, i64 32
  %50 = bitcast i8* %xnv_nv202 to double*
  %51 = load double* %50, align 8, !tbaa !6
  br label %cond.end205

cond.false203:                                    ; preds = %cond.end193
  %call204 = tail call double @Perl_sv_2nv(%struct.sv* %47) #7
  br label %cond.end205

cond.end205:                                      ; preds = %cond.false203, %cond.true200
  %cond206 = phi double [ %51, %cond.true200 ], [ %call204, %cond.false203 ]
  %cmp207 = fcmp oeq double %cond194, 0.000000e+00
  br i1 %cmp207, label %if.then209, label %if.end211

if.then209:                                       ; preds = %cond.end205
  %call210 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([25 x i8]* @.str29, i64 0, i64 0)) #7
  br label %return

if.end211:                                        ; preds = %cond.end205
  %div212 = fdiv double %cond206, %cond194
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %div212) #7
  %sv_flags213 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %52 = load i32* %sv_flags213, align 4, !tbaa !4
  %and214 = and i32 %52, 16384
  %tobool215 = icmp eq i32 %and214, 0
  br i1 %tobool215, label %if.end218, label %if.then216

if.then216:                                       ; preds = %if.end211
  %call217 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end218

if.end218:                                        ; preds = %if.end211, %if.then216
  store %struct.sv* %cond, %struct.sv** %incdec.ptr185.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr185.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %53 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next220 = getelementptr inbounds %struct.op* %53, i64 0, i32 0
  %54 = load %struct.op** %op_next220, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end218, %if.then209, %if.end178, %if.end156, %if.then117, %if.end29
  %retval.0 = phi %struct.op* [ %16, %if.end29 ], [ %call118, %if.then117 ], [ %37, %if.end156 ], [ %41, %if.end178 ], [ %call210, %if.then209 ], [ %54, %if.end218 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_modulo() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %if.end31, label %if.then

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 14, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  %16 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end, %lor.lhs.false
  %17 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags34 = getelementptr inbounds %struct.sv* %17, i64 0, i32 2
  %18 = load i32* %sv_flags34, align 4, !tbaa !4
  %and35 = and i32 %18, 16777216
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end54

land.lhs.true37:                                  ; preds = %if.end31
  %19 = and i32 %18, 393216
  %or.cond.not = icmp ne i32 %19, 0
  %and47 = and i32 %18, 65536
  %tobool48 = icmp eq i32 %and47, 0
  %or.cond338 = and i1 %or.cond.not, %tobool48
  br i1 %or.cond338, label %cond.false50, label %if.end54

cond.false50:                                     ; preds = %land.lhs.true37
  %call51 = tail call i64 @Perl_sv_2iv(%struct.sv* %17) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags55.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre340 = load i32* %sv_flags55.phi.trans.insert, align 4, !tbaa !4
  br label %if.end54

if.end54:                                         ; preds = %land.lhs.true37, %if.end31, %cond.false50
  %20 = phi i32 [ %18, %land.lhs.true37 ], [ %18, %if.end31 ], [ %.pre340, %cond.false50 ]
  %21 = phi %struct.sv* [ %17, %land.lhs.true37 ], [ %17, %if.end31 ], [ %.pre, %cond.false50 ]
  %and56 = and i32 %20, 65536
  %tobool57 = icmp eq i32 %and56, 0
  br i1 %tobool57, label %if.else77, label %if.then58

if.then58:                                        ; preds = %if.end54
  %and60 = and i32 %20, -2147418112
  %lnot = icmp ne i32 %and60, -2147418112
  %conv62 = zext i1 %lnot to i8
  %incdec.ptr68 = getelementptr inbounds %struct.sv** %0, i64 -1
  %sv_any69 = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %22 = load i8** %sv_any69, align 8, !tbaa !0
  %xiv_iv70 = getelementptr inbounds i8* %22, i64 24
  %23 = bitcast i8* %xiv_iv70 to i64*
  %24 = load i64* %23, align 8, !tbaa !3
  br i1 %lnot, label %if.else67, label %if.end101

if.else67:                                        ; preds = %if.then58
  %cmp71 = icmp sgt i64 %24, -1
  %sub = sub nsw i64 0, %24
  %.sub = select i1 %cmp71, i64 %24, i64 %sub
  %.conv62 = select i1 %cmp71, i8 0, i8 %conv62
  br label %if.end101

if.else77:                                        ; preds = %if.end54
  %incdec.ptr78 = getelementptr inbounds %struct.sv** %0, i64 -1
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and80 = and i32 %20, 131072
  %tobool81 = icmp eq i32 %and80, 0
  br i1 %tobool81, label %cond.false84, label %cond.true82

cond.true82:                                      ; preds = %if.else77
  %sv_any83 = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %25 = load i8** %sv_any83, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %25, i64 32
  %26 = bitcast i8* %xnv_nv to double*
  %27 = load double* %26, align 8, !tbaa !6
  br label %cond.end86

cond.false84:                                     ; preds = %if.else77
  %call85 = tail call double @Perl_sv_2nv(%struct.sv* %21) #7
  br label %cond.end86

cond.end86:                                       ; preds = %cond.false84, %cond.true82
  %cond87 = phi double [ %27, %cond.true82 ], [ %call85, %cond.false84 ]
  %cmp88 = fcmp olt double %cond87, 0.000000e+00
  %conv90 = zext i1 %cmp88 to i8
  br i1 %cmp88, label %if.then92, label %if.end94

if.then92:                                        ; preds = %cond.end86
  %sub93 = fsub double -0.000000e+00, %cond87
  br label %if.end94

if.end94:                                         ; preds = %if.then92, %cond.end86
  %dright.0 = phi double [ %sub93, %if.then92 ], [ %cond87, %cond.end86 ]
  %cmp95 = fcmp olt double %dright.0, 0x43F0000000000000
  br i1 %cmp95, label %if.then97, label %if.end101

if.then97:                                        ; preds = %if.end94
  %call98 = tail call i64 @Perl_cast_uv(double %dright.0) #7
  br label %if.end101

if.end101:                                        ; preds = %if.end94, %if.then58, %if.else67, %if.then97
  %right33.0 = phi i64 [ %call98, %if.then97 ], [ %.sub, %if.else67 ], [ %24, %if.then58 ], [ 0, %if.end94 ]
  %right_neg.0 = phi i8 [ %conv90, %if.then97 ], [ %.conv62, %if.else67 ], [ %conv62, %if.then58 ], [ %conv90, %if.end94 ]
  %use_double.0 = phi i8 [ 0, %if.then97 ], [ 0, %if.else67 ], [ 0, %if.then58 ], [ 1, %if.end94 ]
  %dright_valid.0 = phi i8 [ 1, %if.then97 ], [ 0, %if.else67 ], [ 0, %if.then58 ], [ 0, %if.end94 ]
  %dright.1 = phi double [ %dright.0, %if.then97 ], [ 0.000000e+00, %if.else67 ], [ 0.000000e+00, %if.then58 ], [ %dright.0, %if.end94 ]
  %sp.0 = phi %struct.sv** [ %incdec.ptr78, %if.then97 ], [ %incdec.ptr68, %if.else67 ], [ %incdec.ptr68, %if.then58 ], [ %incdec.ptr78, %if.end94 ]
  %28 = load %struct.sv** %sp.0, align 8, !tbaa !0
  %sv_flags102 = getelementptr inbounds %struct.sv* %28, i64 0, i32 2
  %29 = load i32* %sv_flags102, align 4, !tbaa !4
  %and103 = and i32 %29, 16777216
  %tobool104 = icmp eq i32 %and103, 0
  br i1 %tobool104, label %land.lhs.true105, label %if.end124

land.lhs.true105:                                 ; preds = %if.end101
  %30 = and i32 %29, 393216
  %or.cond323.not = icmp ne i32 %30, 0
  %and115 = and i32 %29, 65536
  %tobool116 = icmp eq i32 %and115, 0
  %or.cond339 = and i1 %or.cond323.not, %tobool116
  br i1 %or.cond339, label %cond.false120, label %if.end124

cond.false120:                                    ; preds = %land.lhs.true105
  %call121 = tail call i64 @Perl_sv_2iv(%struct.sv* %28) #7
  br label %if.end124

if.end124:                                        ; preds = %land.lhs.true105, %if.end101, %cond.false120
  %tobool125 = icmp ne i8 %use_double.0, 0
  %.pre341 = load %struct.sv** %sp.0, align 8, !tbaa !0
  %sv_flags161.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre341, i64 0, i32 2
  %.pre342 = load i32* %sv_flags161.phi.trans.insert, align 4, !tbaa !4
  br i1 %tobool125, label %if.else159, label %land.lhs.true126

land.lhs.true126:                                 ; preds = %if.end124
  %and128 = and i32 %.pre342, 65536
  %tobool129 = icmp eq i32 %and128, 0
  br i1 %tobool129, label %if.else159, label %if.then134

if.then134:                                       ; preds = %land.lhs.true126
  %and136 = and i32 %.pre342, -2147418112
  %lnot139 = icmp ne i32 %and136, -2147418112
  %conv141 = zext i1 %lnot139 to i8
  %incdec.ptr148 = getelementptr inbounds %struct.sv** %sp.0, i64 -1
  %sv_any149 = getelementptr inbounds %struct.sv* %.pre341, i64 0, i32 0
  %31 = load i8** %sv_any149, align 8, !tbaa !0
  %xiv_iv150 = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xiv_iv150 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  br i1 %lnot139, label %if.else147, label %if.else216

if.else147:                                       ; preds = %if.then134
  %cmp151 = icmp sgt i64 %33, -1
  %sub155 = sub nsw i64 0, %33
  %.sub155 = select i1 %cmp151, i64 %33, i64 %sub155
  %.conv141 = select i1 %cmp151, i8 0, i8 %conv141
  br label %if.else216

if.else159:                                       ; preds = %if.end124, %land.lhs.true126
  %incdec.ptr160 = getelementptr inbounds %struct.sv** %sp.0, i64 -1
  store %struct.sv* %.pre341, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and162 = and i32 %.pre342, 131072
  %tobool163 = icmp eq i32 %and162, 0
  br i1 %tobool163, label %cond.false167, label %cond.true164

cond.true164:                                     ; preds = %if.else159
  %sv_any165 = getelementptr inbounds %struct.sv* %.pre341, i64 0, i32 0
  %34 = load i8** %sv_any165, align 8, !tbaa !0
  %xnv_nv166 = getelementptr inbounds i8* %34, i64 32
  %35 = bitcast i8* %xnv_nv166 to double*
  %36 = load double* %35, align 8, !tbaa !6
  br label %cond.end169

cond.false167:                                    ; preds = %if.else159
  %call168 = tail call double @Perl_sv_2nv(%struct.sv* %.pre341) #7
  br label %cond.end169

cond.end169:                                      ; preds = %cond.false167, %cond.true164
  %cond170 = phi double [ %36, %cond.true164 ], [ %call168, %cond.false167 ]
  %cmp171 = fcmp olt double %cond170, 0.000000e+00
  %conv173 = zext i1 %cmp171 to i8
  br i1 %cmp171, label %if.then175, label %if.end177

if.then175:                                       ; preds = %cond.end169
  %sub176 = fsub double -0.000000e+00, %cond170
  br label %if.end177

if.end177:                                        ; preds = %if.then175, %cond.end169
  %dleft.0 = phi double [ %sub176, %if.then175 ], [ %cond170, %cond.end169 ]
  br i1 %tobool125, label %if.then197, label %if.then179

if.then179:                                       ; preds = %if.end177
  %cmp180 = fcmp olt double %dleft.0, 0x43F0000000000000
  br i1 %cmp180, label %if.end195, label %if.else184

if.else184:                                       ; preds = %if.then179
  %add = fadd double %dleft.0, 5.000000e-01
  %call185 = tail call double @floor(double %add) #9
  %tobool186 = icmp eq i8 %dright_valid.0, 0
  br i1 %tobool186, label %if.else190, label %if.then187

if.then187:                                       ; preds = %if.else184
  %add188 = fadd double %dright.1, 5.000000e-01
  %call189 = tail call double @floor(double %add188) #9
  br label %if.then197

if.else190:                                       ; preds = %if.else184
  %conv191 = uitofp i64 %right33.0 to double
  br label %if.then197

if.end195:                                        ; preds = %if.then179
  %call183 = tail call i64 @Perl_cast_uv(double %dleft.0) #7
  br label %if.else216

if.then197:                                       ; preds = %if.end177, %if.then187, %if.else190
  %dright.2.ph = phi double [ %dright.1, %if.end177 ], [ %call189, %if.then187 ], [ %conv191, %if.else190 ]
  %dleft.1.ph = phi double [ %dleft.0, %if.end177 ], [ %call185, %if.then187 ], [ %call185, %if.else190 ]
  %tobool198 = fcmp une double %dright.2.ph, 0.000000e+00
  br i1 %tobool198, label %if.end201, label %if.then199

if.then199:                                       ; preds = %if.then197
  %call200 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str30, i64 0, i64 0)) #7
  br label %return

if.end201:                                        ; preds = %if.then197
  %call202 = tail call double @fmod(double %dleft.1.ph, double %dright.2.ph) #7
  %cmp205 = icmp ne i8 %conv173, %right_neg.0
  %tobool208 = fcmp une double %call202, 0.000000e+00
  %or.cond324 = and i1 %cmp205, %tobool208
  br i1 %or.cond324, label %if.then209, label %if.end211

if.then209:                                       ; preds = %if.end201
  %sub210 = fsub double %dright.2.ph, %call202
  br label %if.end211

if.end211:                                        ; preds = %if.end201, %if.then209
  %dans.0 = phi double [ %sub210, %if.then209 ], [ %call202, %if.end201 ]
  %tobool212 = icmp eq i8 %right_neg.0, 0
  br i1 %tobool212, label %if.end215, label %if.then213

if.then213:                                       ; preds = %if.end211
  %sub214 = fsub double -0.000000e+00, %dans.0
  br label %if.end215

if.end215:                                        ; preds = %if.end211, %if.then213
  %dans.1 = phi double [ %sub214, %if.then213 ], [ %dans.0, %if.end211 ]
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %dans.1) #7
  br label %if.end242

if.else216:                                       ; preds = %if.else147, %if.then134, %if.end195
  %sp.1337 = phi %struct.sv** [ %incdec.ptr160, %if.end195 ], [ %incdec.ptr148, %if.then134 ], [ %incdec.ptr148, %if.else147 ]
  %left_neg.0336 = phi i8 [ %conv173, %if.end195 ], [ %conv141, %if.then134 ], [ %.conv141, %if.else147 ]
  %left32.0335 = phi i64 [ %call183, %if.end195 ], [ %33, %if.then134 ], [ %.sub155, %if.else147 ]
  %tobool217 = icmp eq i64 %right33.0, 0
  br i1 %tobool217, label %if.then218, label %if.end220

if.then218:                                       ; preds = %if.else216
  %call219 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str30, i64 0, i64 0)) #7
  br label %return

if.end220:                                        ; preds = %if.else216
  %rem = urem i64 %left32.0335, %right33.0
  %cmp223 = icmp eq i8 %left_neg.0336, %right_neg.0
  %tobool226 = icmp eq i64 %rem, 0
  %or.cond325 = or i1 %cmp223, %tobool226
  %sub228 = sub i64 %right33.0, %rem
  %ans.0 = select i1 %or.cond325, i64 %rem, i64 %sub228
  %tobool230 = icmp eq i8 %right_neg.0, 0
  br i1 %tobool230, label %if.else240, label %if.then231

if.then231:                                       ; preds = %if.end220
  %cmp232 = icmp ult i64 %ans.0, -9223372036854775806
  br i1 %cmp232, label %if.then234, label %if.else236

if.then234:                                       ; preds = %if.then231
  %add235 = sub i64 0, %ans.0
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %add235) #7
  br label %if.end242

if.else236:                                       ; preds = %if.then231
  %conv237 = uitofp i64 %ans.0 to double
  %sub238 = fsub double -0.000000e+00, %conv237
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %sub238) #7
  br label %if.end242

if.else240:                                       ; preds = %if.end220
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %ans.0) #7
  br label %if.end242

if.end242:                                        ; preds = %if.else240, %if.else236, %if.then234, %if.end215
  %sp.1330 = phi %struct.sv** [ %sp.1337, %if.else240 ], [ %sp.1337, %if.else236 ], [ %sp.1337, %if.then234 ], [ %incdec.ptr160, %if.end215 ]
  %sv_flags243 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %37 = load i32* %sv_flags243, align 4, !tbaa !4
  %and244 = and i32 %37, 16384
  %tobool245 = icmp eq i32 %and244, 0
  br i1 %tobool245, label %if.end248, label %if.then246

if.then246:                                       ; preds = %if.end242
  %call247 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end248

if.end248:                                        ; preds = %if.end242, %if.then246
  %incdec.ptr249 = getelementptr inbounds %struct.sv** %sp.1330, i64 1
  store %struct.sv* %cond, %struct.sv** %incdec.ptr249, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr249, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %38 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next250 = getelementptr inbounds %struct.op* %38, i64 0, i32 0
  %39 = load %struct.op** %op_next250, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end248, %if.then218, %if.then199, %if.end29
  %retval.0 = phi %struct.op* [ %16, %if.end29 ], [ %39, %if.end248 ], [ %call200, %if.then199 ], [ %call219, %if.then218 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i64 @Perl_cast_uv(double) #1

; Function Attrs: nounwind optsize readnone
declare double @floor(double) #5

; Function Attrs: optsize
declare double @fmod(double, double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_repeat() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr32.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 52, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge384 = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge384, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr32.pre-phi = phi %struct.sv** [ %incdec.ptr32.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags33 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags33, align 4, !tbaa !4
  %and34 = and i32 %16, 8192
  %tobool35 = icmp eq i32 %and34, 0
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %if.end31
  %call37 = call i32 @Perl_mg_get(%struct.sv* %15) #7
  %.pre = load i32* %sv_flags33, align 4, !tbaa !4
  br label %if.end38

if.end38:                                         ; preds = %if.end31, %if.then36
  %17 = phi i32 [ %16, %if.end31 ], [ %.pre, %if.then36 ]
  %and40 = and i32 %17, 16777216
  %tobool41 = icmp eq i32 %and40, 0
  br i1 %tobool41, label %if.else76, label %if.then42

if.then42:                                        ; preds = %if.end38
  %and44 = and i32 %17, -2147418112
  %cmp = icmp eq i32 %and44, -2147418112
  %and48 = and i32 %17, 65536
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %cmp, label %if.then46, label %if.else60

if.then46:                                        ; preds = %if.then42
  br i1 %tobool49, label %cond.true50, label %cond.false51

cond.true50:                                      ; preds = %if.then46
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %18, i64 24
  %19 = bitcast i8* %xuv_uv to i64*
  %20 = load i64* %19, align 8, !tbaa !3
  br label %cond.end53

cond.false51:                                     ; preds = %if.then46
  %call52 = call i64 @Perl_sv_2uv(%struct.sv* %15) #7
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false51, %cond.true50
  %cond54 = phi i64 [ %20, %cond.true50 ], [ %call52, %cond.false51 ]
  %cmp55 = icmp slt i64 %cond54, 0
  %.cond54 = select i1 %cmp55, i64 9223372036854775807, i64 %cond54
  br label %if.end108

if.else60:                                        ; preds = %if.then42
  br i1 %tobool49, label %cond.true64, label %cond.false66

cond.true64:                                      ; preds = %if.else60
  %sv_any65 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %21 = load i8** %sv_any65, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %21, i64 24
  %22 = bitcast i8* %xiv_iv to i64*
  %23 = load i64* %22, align 8, !tbaa !3
  br label %cond.end68

cond.false66:                                     ; preds = %if.else60
  %call67 = call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false66, %cond.true64
  %cond69 = phi i64 [ %23, %cond.true64 ], [ %call67, %cond.false66 ]
  %cmp70 = icmp slt i64 %cond69, 0
  %.cond69 = select i1 %cmp70, i64 0, i64 %cond69
  br label %if.end108

if.else76:                                        ; preds = %if.end38
  %and78 = and i32 %17, 33554432
  %tobool79 = icmp eq i32 %and78, 0
  br i1 %tobool79, label %if.else96, label %if.then80

if.then80:                                        ; preds = %if.else76
  %and82 = and i32 %17, 131072
  %tobool83 = icmp eq i32 %and82, 0
  br i1 %tobool83, label %cond.false86, label %cond.true84

cond.true84:                                      ; preds = %if.then80
  %sv_any85 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %24 = load i8** %sv_any85, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %24, i64 32
  %25 = bitcast i8* %xnv_nv to double*
  %26 = load double* %25, align 8, !tbaa !6
  br label %cond.end88

cond.false86:                                     ; preds = %if.then80
  %call87 = call double @Perl_sv_2nv(%struct.sv* %15) #7
  br label %cond.end88

cond.end88:                                       ; preds = %cond.false86, %cond.true84
  %cond89 = phi double [ %26, %cond.true84 ], [ %call87, %cond.false86 ]
  %cmp90 = fcmp olt double %cond89, 0.000000e+00
  br i1 %cmp90, label %if.end108, label %if.else93

if.else93:                                        ; preds = %cond.end88
  %conv94 = fptosi double %cond89 to i64
  br label %if.end108

if.else96:                                        ; preds = %if.else76
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and98 = and i32 %17, 65536
  %tobool99 = icmp eq i32 %and98, 0
  br i1 %tobool99, label %cond.false103, label %cond.true100

cond.true100:                                     ; preds = %if.else96
  %sv_any101 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %27 = load i8** %sv_any101, align 8, !tbaa !0
  %xiv_iv102 = getelementptr inbounds i8* %27, i64 24
  %28 = bitcast i8* %xiv_iv102 to i64*
  %29 = load i64* %28, align 8, !tbaa !3
  br label %if.end108

cond.false103:                                    ; preds = %if.else96
  %call104 = call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %if.end108

if.end108:                                        ; preds = %cond.end88, %cond.true100, %cond.false103, %cond.end68, %cond.end53, %if.else93
  %count.0 = phi i64 [ %conv94, %if.else93 ], [ %.cond54, %cond.end53 ], [ %.cond69, %cond.end68 ], [ %29, %cond.true100 ], [ %call104, %cond.false103 ], [ 0, %cond.end88 ]
  %30 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags109 = getelementptr inbounds %struct.op* %30, i64 0, i32 6
  %31 = load i8* %op_flags109, align 1, !tbaa !1
  %conv110 = zext i8 %31 to i32
  %and111 = and i32 %conv110, 3
  %tobool112 = icmp eq i32 %and111, 0
  br i1 %tobool112, label %cond.false120, label %cond.true113

cond.true113:                                     ; preds = %if.end108
  %cmp117 = icmp eq i32 %and111, 3
  %cond119 = zext i1 %cmp117 to i32
  br label %cond.end122

cond.false120:                                    ; preds = %if.end108
  %call121 = call i32 @Perl_dowantarray() #7
  br label %cond.end122

cond.end122:                                      ; preds = %cond.false120, %cond.true113
  %cond123 = phi i32 [ %cond119, %cond.true113 ], [ %call121, %cond.false120 ]
  %cmp124 = icmp eq i32 %cond123, 1
  br i1 %cmp124, label %land.lhs.true126, label %if.else195

land.lhs.true126:                                 ; preds = %cond.end122
  %32 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %32, i64 0, i32 7
  %33 = load i8* %op_private, align 1, !tbaa !1
  %and128 = and i8 %33, 64
  %tobool129 = icmp eq i8 %and128, 0
  br i1 %tobool129, label %if.else195, label %if.then130

if.then130:                                       ; preds = %land.lhs.true126
  %34 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %35 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr131 = getelementptr inbounds i32* %35, i64 -1
  store i32* %incdec.ptr131, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %36 = load i32* %35, align 4, !tbaa !4
  %idx.ext = sext i32 %36 to i64
  %add.ptr132 = getelementptr inbounds %struct.sv** %34, i64 %idx.ext
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %incdec.ptr32.pre-phi to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %add.ptr132 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div378 = lshr exact i64 %sub.ptr.sub, 3
  %conv133 = trunc i64 %sub.ptr.div378 to i32
  %sext = shl i64 %sub.ptr.sub, 29
  %conv134 = ashr exact i64 %sext, 32
  %mul = mul nsw i64 %conv134, %count.0
  %conv135 = trunc i64 %mul to i32
  %cmp136 = icmp sgt i32 %conv133, 0
  %cmp139 = icmp sgt i32 %conv135, 0
  %or.cond = and i1 %cmp136, %cmp139
  br i1 %or.cond, label %land.lhs.true141, label %if.end149

land.lhs.true141:                                 ; preds = %if.then130
  %cmp142 = icmp slt i32 %conv135, %conv133
  br i1 %cmp142, label %if.then148, label %lor.lhs.false144

lor.lhs.false144:                                 ; preds = %land.lhs.true141
  %sext383 = shl i64 %mul, 32
  %conv145 = ashr exact i64 %sext383, 32
  %cmp146 = icmp slt i64 %conv145, %count.0
  br i1 %cmp146, label %if.then148, label %if.end149

if.then148:                                       ; preds = %lor.lhs.false144, %land.lhs.true141
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([33 x i8]* @Perl_pp_repeat.oom_list_extend, i64 0, i64 0)) #7
  br label %if.end149

if.end149:                                        ; preds = %if.then148, %lor.lhs.false144, %if.then130
  %37 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast150 = ptrtoint %struct.sv** %37 to i64
  %sub.ptr.sub152 = sub i64 %sub.ptr.lhs.cast150, %sub.ptr.rhs.cast
  %sub.ptr.div153 = ashr exact i64 %sub.ptr.sub152, 3
  %sext379 = shl i64 %mul, 32
  %conv154 = ashr exact i64 %sext379, 32
  %cmp155 = icmp slt i64 %sub.ptr.div153, %conv154
  br i1 %cmp155, label %if.then157, label %if.end166

if.then157:                                       ; preds = %if.end149
  %38 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.rhs.cast159 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.sub160 = sub i64 %sub.ptr.rhs.cast, %sub.ptr.rhs.cast159
  %call163 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr32.pre-phi, %struct.sv** %add.ptr132, i32 %conv135) #7
  %39 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %40 = shl i64 %sub.ptr.sub160, 29
  %idx.ext164 = ashr i64 %40, 32
  %add.ptr165 = getelementptr inbounds %struct.sv** %39, i64 %idx.ext164
  br label %if.end166

if.end166:                                        ; preds = %if.then157, %if.end149
  %mark.0 = phi %struct.sv** [ %add.ptr165, %if.then157 ], [ %add.ptr132, %if.end149 ]
  %sp.0 = phi %struct.sv** [ %call163, %if.then157 ], [ %incdec.ptr32.pre-phi, %if.end149 ]
  %cmp167 = icmp sgt i64 %count.0, 1
  br i1 %cmp167, label %while.cond.preheader, label %if.else187

while.cond.preheader:                             ; preds = %if.end166
  %cmp170386 = icmp ugt %struct.sv** %sp.0, %mark.0
  br i1 %cmp170386, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond.preheader, %if.end176
  %sp.1387 = phi %struct.sv** [ %incdec.ptr177, %if.end176 ], [ %sp.0, %while.cond.preheader ]
  %41 = load %struct.sv** %sp.1387, align 8, !tbaa !0
  %tobool172 = icmp eq %struct.sv* %41, null
  br i1 %tobool172, label %if.end176, label %if.then173

if.then173:                                       ; preds = %while.body
  %sv_flags174 = getelementptr inbounds %struct.sv* %41, i64 0, i32 2
  %42 = load i32* %sv_flags174, align 4, !tbaa !4
  %and175 = and i32 %42, -2049
  store i32 %and175, i32* %sv_flags174, align 4, !tbaa !4
  br label %if.end176

if.end176:                                        ; preds = %while.body, %if.then173
  %incdec.ptr177 = getelementptr inbounds %struct.sv** %sp.1387, i64 -1
  %cmp170 = icmp ugt %struct.sv** %incdec.ptr177, %mark.0
  br i1 %cmp170, label %while.body, label %while.end

while.end:                                        ; preds = %if.end176, %while.cond.preheader
  %sp.1.lcssa = phi %struct.sv** [ %sp.0, %while.cond.preheader ], [ %incdec.ptr177, %if.end176 ]
  %incdec.ptr178 = getelementptr inbounds %struct.sv** %mark.0, i64 1
  %incdec.ptr178.sum = add i64 %conv134, 1
  %add.ptr180 = getelementptr inbounds %struct.sv** %mark.0, i64 %incdec.ptr178.sum
  %43 = bitcast %struct.sv** %add.ptr180 to i8*
  %44 = bitcast %struct.sv** %incdec.ptr178 to i8*
  %conv183 = trunc i64 %sub.ptr.sub to i32
  %sub = add nsw i64 %count.0, 4294967295
  %conv184 = trunc i64 %sub to i32
  call void @Perl_repeatcpy(i8* %43, i8* %44, i32 %conv183, i32 %conv184) #7
  %add.ptr186 = getelementptr inbounds %struct.sv** %sp.1.lcssa, i64 %conv154
  br label %return

if.else187:                                       ; preds = %if.end166
  %cmp188 = icmp slt i64 %count.0, 1
  br i1 %cmp188, label %if.then190, label %return

if.then190:                                       ; preds = %if.else187
  %idx.neg = sub i64 0, %conv134
  %add.ptr192 = getelementptr inbounds %struct.sv** %sp.0, i64 %idx.neg
  br label %return

if.else195:                                       ; preds = %land.lhs.true126, %cond.end122
  %incdec.ptr196 = getelementptr inbounds %struct.sv** %0, i64 -2
  %45 = load %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  %cmp197 = icmp eq %struct.sv* %cond, %45
  br i1 %cmp197, label %if.end200, label %if.then199

if.then199:                                       ; preds = %if.else195
  call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %45, i32 2) #7
  br label %if.end200

if.end200:                                        ; preds = %if.else195, %if.then199
  %sv_flags201 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %46 = load i32* %sv_flags201, align 4, !tbaa !4
  %and202 = and i32 %46, 10223616
  %cmp203 = icmp eq i32 %and202, 262144
  br i1 %cmp203, label %cond.true205, label %cond.false208

cond.true205:                                     ; preds = %if.end200
  %sv_any206 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %47 = load i8** %sv_any206, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %47, i64 8
  %48 = bitcast i8* %xpv_cur to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  store i64 %49, i64* %len, align 8, !tbaa !3
  br label %cond.end210

cond.false208:                                    ; preds = %if.end200
  %call209 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %cond, i64* %len, i32 2) #7
  %.pre388 = load i32* %sv_flags201, align 4, !tbaa !4
  br label %cond.end210

cond.end210:                                      ; preds = %cond.false208, %cond.true205
  %50 = phi i32 [ %.pre388, %cond.false208 ], [ %46, %cond.true205 ]
  %and213 = and i32 %50, 536870912
  %tobool214 = icmp eq i32 %and213, 0
  br i1 %tobool214, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %cond.end210
  %51 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private215 = getelementptr inbounds %struct.cop* %51, i64 0, i32 7
  %52 = load i8* %op_private215, align 1, !tbaa !1
  %and217 = and i8 %52, 8
  %lnot = icmp eq i8 %and217, 0
  %phitmp = select i1 %lnot, i32 1760624639, i32 1223753727
  br label %land.end

land.end:                                         ; preds = %cond.end210, %land.rhs
  %53 = phi i32 [ 1223753727, %cond.end210 ], [ %phitmp, %land.rhs ]
  %cmp220 = icmp eq i64 %count.0, 1
  br i1 %cmp220, label %if.end263, label %if.then222

if.then222:                                       ; preds = %land.end
  %cmp223 = icmp slt i64 %count.0, 1
  br i1 %cmp223, label %if.then225, label %if.else228

if.then225:                                       ; preds = %if.then222
  %sv_any226 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %54 = load i8** %sv_any226, align 8, !tbaa !0
  %xpv_cur227 = getelementptr inbounds i8* %54, i64 8
  %55 = bitcast i8* %xpv_cur227 to i64*
  store i64 0, i64* %55, align 8, !tbaa !3
  br label %if.end257

if.else228:                                       ; preds = %if.then222
  %56 = load i64* %len, align 8, !tbaa !3
  %mul230 = mul i64 %56, %count.0
  %div = udiv i64 -1, %count.0
  %cmp231 = icmp ugt i64 %56, %div
  br i1 %cmp231, label %if.then233, label %if.end234

if.then233:                                       ; preds = %if.else228
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @Perl_pp_repeat.oom_string_extend, i64 0, i64 0)) #7
  br label %if.end234

if.end234:                                        ; preds = %if.else228, %if.then233
  %sv_any235 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %57 = load i8** %sv_any235, align 8, !tbaa !0
  %xpv_len = getelementptr inbounds i8* %57, i64 16
  %58 = bitcast i8* %xpv_len to i64*
  %59 = load i64* %58, align 8, !tbaa !3
  %add = add i64 %mul230, 1
  %cmp236 = icmp ult i64 %59, %add
  br i1 %cmp236, label %cond.true238, label %cond.end244

cond.true238:                                     ; preds = %if.end234
  %call240 = call i8* @Perl_sv_grow(%struct.sv* %cond, i64 %add) #7
  %.pre389 = load i8** %sv_any235, align 8, !tbaa !0
  br label %cond.end244

cond.end244:                                      ; preds = %if.end234, %cond.true238
  %60 = phi i8* [ %.pre389, %cond.true238 ], [ %57, %if.end234 ]
  %xpv_pv247 = bitcast i8* %60 to i8**
  %61 = load i8** %xpv_pv247, align 8, !tbaa !0
  %62 = load i64* %len, align 8, !tbaa !3
  %add.ptr248 = getelementptr inbounds i8* %61, i64 %62
  %conv251 = trunc i64 %62 to i32
  %sub252 = add nsw i64 %count.0, 4294967295
  %conv253 = trunc i64 %sub252 to i32
  call void @Perl_repeatcpy(i8* %add.ptr248, i8* %61, i32 %conv251, i32 %conv253) #7
  %63 = load i8** %sv_any235, align 8, !tbaa !0
  %xpv_cur255 = getelementptr inbounds i8* %63, i64 8
  %64 = bitcast i8* %xpv_cur255 to i64*
  %65 = load i64* %64, align 8, !tbaa !3
  %mul256 = mul i64 %65, %count.0
  store i64 %mul256, i64* %64, align 8, !tbaa !3
  br label %if.end257

if.end257:                                        ; preds = %cond.end244, %if.then225
  %66 = phi i64 [ %mul256, %cond.end244 ], [ 0, %if.then225 ]
  %67 = phi i8* [ %63, %cond.end244 ], [ %54, %if.then225 ]
  %xpv_pv259 = bitcast i8* %67 to i8**
  %68 = load i8** %xpv_pv259, align 8, !tbaa !0
  %add.ptr262 = getelementptr inbounds i8* %68, i64 %66
  store i8 0, i8* %add.ptr262, align 1, !tbaa !1
  br label %if.end263

if.end263:                                        ; preds = %land.end, %if.end257
  %69 = load i32* %sv_flags201, align 4, !tbaa !4
  %storemerge.in = and i32 %69, %53
  %storemerge = or i32 %storemerge.in, 67371008
  store i32 %storemerge, i32* %sv_flags201, align 4, !tbaa !4
  %70 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private275 = getelementptr inbounds %struct.op* %70, i64 0, i32 7
  %71 = load i8* %op_private275, align 1, !tbaa !1
  %and277 = and i8 %71, 64
  %tobool278 = icmp eq i8 %and277, 0
  br i1 %tobool278, label %if.end284, label %if.then279

if.then279:                                       ; preds = %if.end263
  %72 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %73 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr281 = getelementptr inbounds i32* %73, i64 -1
  store i32* %incdec.ptr281, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %74 = load i32* %73, align 4, !tbaa !4
  %idx.ext282 = sext i32 %74 to i64
  %add.ptr283 = getelementptr inbounds %struct.sv** %72, i64 %idx.ext282
  br label %if.end284

if.end284:                                        ; preds = %if.end263, %if.then279
  %sp.2 = phi %struct.sv** [ %add.ptr283, %if.then279 ], [ %incdec.ptr196, %if.end263 ]
  %and286 = and i32 %69, 16384
  %tobool287 = icmp eq i32 %and286, 0
  br i1 %tobool287, label %if.end290, label %if.then288

if.then288:                                       ; preds = %if.end284
  %call289 = call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end290

if.end290:                                        ; preds = %if.end284, %if.then288
  %incdec.ptr291 = getelementptr inbounds %struct.sv** %sp.2, i64 1
  store %struct.sv* %cond, %struct.sv** %incdec.ptr291, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.else187, %if.end290, %if.then190, %while.end, %if.end29
  %storemerge385 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %add.ptr186, %while.end ], [ %add.ptr192, %if.then190 ], [ %incdec.ptr291, %if.end290 ], [ %sp.0, %if.else187 ]
  store %struct.sv** %storemerge385, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i64 @Perl_sv_2uv(%struct.sv*) #1

; Function Attrs: optsize
declare void @Perl_repeatcpy(i8*, i8*, i32, i32) #1

; Function Attrs: optsize
declare i8* @Perl_sv_pvn_force_flags(%struct.sv*, i64*, i32) #1

; Function Attrs: optsize
declare i8* @Perl_sv_grow(%struct.sv*, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_subtract() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %add.ptr32.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 8, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %add.ptr32.pre-phi = phi %struct.sv** [ %add.ptr32.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %16 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags33 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags33, align 4, !tbaa !4
  %18 = and i32 %17, 118431744
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end31
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags41 = getelementptr inbounds %struct.op* %20, i64 0, i32 6
  %21 = load i8* %op_flags41, align 1, !tbaa !1
  %and43 = and i8 %21, 64
  %lnot = icmp eq i8 %and43, 0
  br label %lor.end

lor.end:                                          ; preds = %if.end31, %lor.rhs
  %22 = phi i1 [ %lnot, %lor.rhs ], [ true, %if.end31 ]
  %23 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags46 = getelementptr inbounds %struct.sv* %23, i64 0, i32 2
  %24 = load i32* %sv_flags46, align 4, !tbaa !4
  %and47 = and i32 %24, 16777216
  %tobool48 = icmp eq i32 %and47, 0
  br i1 %tobool48, label %land.lhs.true49, label %if.end66

land.lhs.true49:                                  ; preds = %lor.end
  %25 = and i32 %24, 393216
  %or.cond356.not = icmp ne i32 %25, 0
  %and59 = and i32 %24, 65536
  %tobool60 = icmp eq i32 %and59, 0
  %or.cond365 = and i1 %or.cond356.not, %tobool60
  br i1 %or.cond365, label %cond.false62, label %if.end66

cond.false62:                                     ; preds = %land.lhs.true49
  %call63 = tail call i64 @Perl_sv_2iv(%struct.sv* %23) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags67.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre367 = load i32* %sv_flags67.phi.trans.insert, align 4, !tbaa !4
  br label %if.end66

if.end66:                                         ; preds = %land.lhs.true49, %lor.end, %cond.false62
  %26 = phi i32 [ %24, %land.lhs.true49 ], [ %24, %lor.end ], [ %.pre367, %cond.false62 ]
  %and68 = and i32 %26, 65536
  %tobool69 = icmp eq i32 %and68, 0
  br i1 %tobool69, label %if.end214, label %if.then70

if.then70:                                        ; preds = %if.end66
  br i1 %22, label %if.else73, label %if.then130

if.else73:                                        ; preds = %if.then70
  %27 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags75 = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %28 = load i32* %sv_flags75, align 4, !tbaa !4
  %and76 = and i32 %28, 16777216
  %tobool77 = icmp eq i32 %and76, 0
  br i1 %tobool77, label %land.lhs.true78, label %if.end102

land.lhs.true78:                                  ; preds = %if.else73
  %29 = and i32 %28, 393216
  %or.cond357.not = icmp ne i32 %29, 0
  %and91 = and i32 %28, 65536
  %tobool92 = icmp eq i32 %and91, 0
  %or.cond366 = and i1 %or.cond357.not, %tobool92
  br i1 %or.cond366, label %cond.false97, label %if.end102

cond.false97:                                     ; preds = %land.lhs.true78
  %call99 = tail call i64 @Perl_sv_2iv(%struct.sv* %27) #7
  %.pre368 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags104.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre368, i64 0, i32 2
  %.pre369 = load i32* %sv_flags104.phi.trans.insert, align 4, !tbaa !4
  br label %if.end102

if.end102:                                        ; preds = %land.lhs.true78, %if.else73, %cond.false97
  %30 = phi i32 [ %28, %land.lhs.true78 ], [ %28, %if.else73 ], [ %.pre369, %cond.false97 ]
  %31 = phi %struct.sv* [ %27, %land.lhs.true78 ], [ %27, %if.else73 ], [ %.pre368, %cond.false97 ]
  %and105 = and i32 %30, 65536
  %tobool106 = icmp eq i32 %and105, 0
  br i1 %tobool106, label %if.end214, label %if.then107

if.then107:                                       ; preds = %if.end102
  %and110 = and i32 %30, -2147418112
  %cmp = icmp eq i32 %and110, -2147418112
  %conv112 = zext i1 %cmp to i8
  %sv_any116 = getelementptr inbounds %struct.sv* %31, i64 0, i32 0
  %32 = load i8** %sv_any116, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %32, i64 24
  %33 = bitcast i8* %xuv_uv to i64*
  %34 = load i64* %33, align 8, !tbaa !3
  br i1 %cmp, label %if.then130, label %if.else117

if.else117:                                       ; preds = %if.then107
  %cmp121 = icmp sgt i64 %34, -1
  %sub = sub nsw i64 0, %34
  %.sub = select i1 %cmp121, i64 %34, i64 %sub
  %.conv112 = select i1 %cmp121, i8 1, i8 %conv112
  br label %if.then130

if.then130:                                       ; preds = %if.then107, %if.then70, %if.else117
  %auv.1.ph = phi i64 [ 0, %if.then70 ], [ %.sub, %if.else117 ], [ %34, %if.then107 ]
  %auvok.1.ph = phi i8 [ 1, %if.then70 ], [ %.conv112, %if.else117 ], [ %conv112, %if.then107 ]
  %35 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags131 = getelementptr inbounds %struct.sv* %35, i64 0, i32 2
  %36 = load i32* %sv_flags131, align 4, !tbaa !4
  %and132 = and i32 %36, -2147418112
  %cmp133 = icmp eq i32 %and132, -2147418112
  %conv135 = zext i1 %cmp133 to i8
  %sv_any138 = getelementptr inbounds %struct.sv* %35, i64 0, i32 0
  %37 = load i8** %sv_any138, align 8, !tbaa !0
  %xuv_uv139 = getelementptr inbounds i8* %37, i64 24
  %38 = bitcast i8* %xuv_uv139 to i64*
  %39 = load i64* %38, align 8, !tbaa !3
  br i1 %cmp133, label %if.end149, label %if.else140

if.else140:                                       ; preds = %if.then130
  %cmp143 = icmp sgt i64 %39, -1
  %sub147 = sub nsw i64 0, %39
  %.sub147 = select i1 %cmp143, i64 %39, i64 %sub147
  %.conv135 = select i1 %cmp143, i8 1, i8 %conv135
  br label %if.end149

if.end149:                                        ; preds = %if.else140, %if.then130
  %buv.0 = phi i64 [ %39, %if.then130 ], [ %.sub147, %if.else140 ]
  %buvok.0 = phi i8 [ %conv135, %if.then130 ], [ %.conv135, %if.else140 ]
  %conv150 = sext i8 %auvok.1.ph to i32
  %conv151355 = zext i8 %buvok.0 to i32
  %tobool152 = icmp eq i32 %conv150, %conv151355
  br i1 %tobool152, label %if.else158, label %if.then153

if.then153:                                       ; preds = %if.end149
  %uadd = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %auv.1.ph, i64 %buv.0)
  %40 = extractvalue { i64, i1 } %uadd, 0
  %cmp154 = extractvalue { i64, i1 } %uadd, 1
  br i1 %cmp154, label %if.end214, label %if.then179

if.else158:                                       ; preds = %if.end149
  %cmp159 = icmp ult i64 %auv.1.ph, %buv.0
  br i1 %cmp159, label %if.else167, label %if.end177

if.else167:                                       ; preds = %if.else158
  %sub168 = sub i64 %buv.0, %auv.1.ph
  %cmp169 = icmp ugt i64 %sub168, %buv.0
  br i1 %cmp169, label %if.end214, label %if.end177.thread

if.end177.thread:                                 ; preds = %if.else167
  %lnot173 = icmp eq i8 %auvok.1.ph, 0
  %conv174 = zext i1 %lnot173 to i8
  br label %if.then179

if.end177:                                        ; preds = %if.else158
  %sub162 = sub i64 %auv.1.ph, %buv.0
  %not.cmp163 = icmp ugt i64 %sub162, %auv.1.ph
  br i1 %not.cmp163, label %if.end214, label %if.then179

if.then179:                                       ; preds = %if.end177, %if.then153, %if.end177.thread
  %result.0363 = phi i64 [ %sub168, %if.end177.thread ], [ %sub162, %if.end177 ], [ %40, %if.then153 ]
  %auvok.2362 = phi i8 [ %conv174, %if.end177.thread ], [ %auvok.1.ph, %if.end177 ], [ %auvok.1.ph, %if.then153 ]
  %tobool181 = icmp eq i8 %auvok.2362, 0
  br i1 %tobool181, label %if.else189, label %if.then182

if.then182:                                       ; preds = %if.then179
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %result.0363) #7
  %sv_flags183 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %41 = load i32* %sv_flags183, align 4, !tbaa !4
  %and184 = and i32 %41, 16384
  %tobool185 = icmp eq i32 %and184, 0
  br i1 %tobool185, label %if.end188, label %if.then186

if.then186:                                       ; preds = %if.then182
  %call187 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end188

if.end188:                                        ; preds = %if.then182, %if.then186
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end210

if.else189:                                       ; preds = %if.then179
  %cmp190 = icmp ult i64 %result.0363, -9223372036854775807
  br i1 %cmp190, label %if.then192, label %if.else200

if.then192:                                       ; preds = %if.else189
  %sub193 = sub nsw i64 0, %result.0363
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %sub193) #7
  %sv_flags194 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %42 = load i32* %sv_flags194, align 4, !tbaa !4
  %and195 = and i32 %42, 16384
  %tobool196 = icmp eq i32 %and195, 0
  br i1 %tobool196, label %if.end199, label %if.then197

if.then197:                                       ; preds = %if.then192
  %call198 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end199

if.end199:                                        ; preds = %if.then192, %if.then197
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end210

if.else200:                                       ; preds = %if.else189
  %conv201 = uitofp i64 %result.0363 to double
  %sub202 = fsub double -0.000000e+00, %conv201
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %sub202) #7
  %sv_flags203 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %43 = load i32* %sv_flags203, align 4, !tbaa !4
  %and204 = and i32 %43, 16384
  %tobool205 = icmp eq i32 %and204, 0
  br i1 %tobool205, label %if.end208, label %if.then206

if.then206:                                       ; preds = %if.else200
  %call207 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end208

if.end208:                                        ; preds = %if.else200, %if.then206
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  br label %if.end210

if.end210:                                        ; preds = %if.end199, %if.end208, %if.end188
  store %struct.sv** %add.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %44 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next211 = getelementptr inbounds %struct.op* %44, i64 0, i32 0
  br label %return

if.end214:                                        ; preds = %if.end177, %if.else167, %if.then153, %if.end66, %if.end102
  %45 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags216 = getelementptr inbounds %struct.sv* %45, i64 0, i32 2
  %46 = load i32* %sv_flags216, align 4, !tbaa !4
  %47 = and i32 %46, 118431744
  %48 = icmp eq i32 %47, 0
  br i1 %48, label %lor.rhs224, label %lor.end231

lor.rhs224:                                       ; preds = %if.end214
  %49 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags225 = getelementptr inbounds %struct.op* %49, i64 0, i32 6
  %50 = load i8* %op_flags225, align 1, !tbaa !1
  %and227 = and i8 %50, 64
  %lnot229 = icmp eq i8 %and227, 0
  br label %lor.end231

lor.end231:                                       ; preds = %if.end214, %lor.rhs224
  %51 = phi i1 [ %lnot229, %lor.rhs224 ], [ true, %if.end214 ]
  %52 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %52, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags235 = getelementptr inbounds %struct.sv* %52, i64 0, i32 2
  %53 = load i32* %sv_flags235, align 4, !tbaa !4
  %and236 = and i32 %53, 131072
  %tobool237 = icmp eq i32 %and236, 0
  br i1 %tobool237, label %cond.false240, label %cond.true238

cond.true238:                                     ; preds = %lor.end231
  %sv_any239 = getelementptr inbounds %struct.sv* %52, i64 0, i32 0
  %54 = load i8** %sv_any239, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %54, i64 32
  %55 = bitcast i8* %xnv_nv to double*
  %56 = load double* %55, align 8, !tbaa !6
  br label %cond.end242

cond.false240:                                    ; preds = %lor.end231
  %call241 = tail call double @Perl_sv_2nv(%struct.sv* %52) #7
  br label %cond.end242

cond.end242:                                      ; preds = %cond.false240, %cond.true238
  %cond243 = phi double [ %56, %cond.true238 ], [ %call241, %cond.false240 ]
  br i1 %51, label %if.end254, label %if.then245

if.then245:                                       ; preds = %cond.end242
  %sub246 = fsub double -0.000000e+00, %cond243
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %sub246) #7
  %sv_flags247 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %57 = load i32* %sv_flags247, align 4, !tbaa !4
  %and248 = and i32 %57, 16384
  %tobool249 = icmp eq i32 %and248, 0
  br i1 %tobool249, label %if.end252, label %if.then250

if.then250:                                       ; preds = %if.then245
  %call251 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end252

if.end252:                                        ; preds = %if.then245, %if.then250
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  store %struct.sv** %add.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %58 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next253 = getelementptr inbounds %struct.op* %58, i64 0, i32 0
  br label %return

if.end254:                                        ; preds = %cond.end242
  %59 = load %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags255 = getelementptr inbounds %struct.sv* %59, i64 0, i32 2
  %60 = load i32* %sv_flags255, align 4, !tbaa !4
  %and256 = and i32 %60, 131072
  %tobool257 = icmp eq i32 %and256, 0
  br i1 %tobool257, label %cond.false261, label %cond.true258

cond.true258:                                     ; preds = %if.end254
  %sv_any259 = getelementptr inbounds %struct.sv* %59, i64 0, i32 0
  %61 = load i8** %sv_any259, align 8, !tbaa !0
  %xnv_nv260 = getelementptr inbounds i8* %61, i64 32
  %62 = bitcast i8* %xnv_nv260 to double*
  %63 = load double* %62, align 8, !tbaa !6
  br label %cond.end263

cond.false261:                                    ; preds = %if.end254
  %call262 = tail call double @Perl_sv_2nv(%struct.sv* %59) #7
  br label %cond.end263

cond.end263:                                      ; preds = %cond.false261, %cond.true258
  %cond264 = phi double [ %63, %cond.true258 ], [ %call262, %cond.false261 ]
  %sub265 = fsub double %cond264, %cond243
  tail call void @Perl_sv_setnv(%struct.sv* %cond, double %sub265) #7
  %sv_flags266 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %64 = load i32* %sv_flags266, align 4, !tbaa !4
  %and267 = and i32 %64, 16384
  %tobool268 = icmp eq i32 %and267, 0
  br i1 %tobool268, label %if.end271, label %if.then269

if.then269:                                       ; preds = %cond.end263
  %call270 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end271

if.end271:                                        ; preds = %cond.end263, %if.then269
  store %struct.sv* %cond, %struct.sv** %add.ptr32.pre-phi, align 8, !tbaa !0
  store %struct.sv** %add.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %65 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next272 = getelementptr inbounds %struct.op* %65, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end271, %if.end252, %if.end210, %if.end29
  %retval.0.in = phi %struct.op** [ %op_next, %if.end29 ], [ %op_next211, %if.end210 ], [ %op_next272, %if.end271 ], [ %op_next253, %if.end252 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_left_shift() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr32.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 18, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr32.pre-phi = phi %struct.sv** [ %incdec.ptr32.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags33 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags33, align 4, !tbaa !4
  %and34 = and i32 %16, 65536
  %tobool35 = icmp eq i32 %and34, 0
  br i1 %tobool35, label %cond.false37, label %cond.true36

cond.true36:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  br label %cond.end39

cond.false37:                                     ; preds = %if.end31
  %call38 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false37, %cond.true36
  %cond40 = phi i64 [ %19, %cond.true36 ], [ %call38, %cond.false37 ]
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %20, i64 0, i32 7
  %21 = load i8* %op_private, align 1, !tbaa !1
  %and42 = and i8 %21, 1
  %tobool43 = icmp eq i8 %and42, 0
  %22 = load %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags45 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i32* %sv_flags45, align 4, !tbaa !4
  %and46 = and i32 %23, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool43, label %if.else61, label %if.then44

if.then44:                                        ; preds = %cond.end39
  br i1 %tobool47, label %cond.true48, label %cond.false51

cond.true48:                                      ; preds = %if.then44
  %sv_any49 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %24 = load i8** %sv_any49, align 8, !tbaa !0
  %xiv_iv50 = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv50 to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end53

cond.false51:                                     ; preds = %if.then44
  %call52 = tail call i64 @Perl_sv_2iv(%struct.sv* %22) #7
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false51, %cond.true48
  %cond54 = phi i64 [ %26, %cond.true48 ], [ %call52, %cond.false51 ]
  %shl = shl i64 %cond54, %cond40
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %shl) #7
  %sv_flags55 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %27 = load i32* %sv_flags55, align 4, !tbaa !4
  %and56 = and i32 %27, 16384
  %tobool57 = icmp eq i32 %and56, 0
  br i1 %tobool57, label %if.end78, label %if.then58

if.then58:                                        ; preds = %cond.end53
  %call59 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end78

if.else61:                                        ; preds = %cond.end39
  br i1 %tobool47, label %cond.true65, label %cond.false67

cond.true65:                                      ; preds = %if.else61
  %sv_any66 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %28 = load i8** %sv_any66, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  br label %cond.end69

cond.false67:                                     ; preds = %if.else61
  %call68 = tail call i64 @Perl_sv_2uv(%struct.sv* %22) #7
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false67, %cond.true65
  %cond70 = phi i64 [ %30, %cond.true65 ], [ %call68, %cond.false67 ]
  %shl71 = shl i64 %cond70, %cond40
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %shl71) #7
  %sv_flags72 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %31 = load i32* %sv_flags72, align 4, !tbaa !4
  %and73 = and i32 %31, 16384
  %tobool74 = icmp eq i32 %and73, 0
  br i1 %tobool74, label %if.end78, label %if.then75

if.then75:                                        ; preds = %cond.end69
  %call76 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end78

if.end78:                                         ; preds = %if.then75, %cond.end69, %if.then58, %cond.end53
  store %struct.sv* %cond, %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end78, %if.end29
  %storemerge108 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr32.pre-phi, %if.end78 ]
  store %struct.sv** %storemerge108, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_right_shift() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr32.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 20, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr32.pre-phi = phi %struct.sv** [ %incdec.ptr32.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags33 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags33, align 4, !tbaa !4
  %and34 = and i32 %16, 65536
  %tobool35 = icmp eq i32 %and34, 0
  br i1 %tobool35, label %cond.false37, label %cond.true36

cond.true36:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  br label %cond.end39

cond.false37:                                     ; preds = %if.end31
  %call38 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false37, %cond.true36
  %cond40 = phi i64 [ %19, %cond.true36 ], [ %call38, %cond.false37 ]
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %20, i64 0, i32 7
  %21 = load i8* %op_private, align 1, !tbaa !1
  %and42 = and i8 %21, 1
  %tobool43 = icmp eq i8 %and42, 0
  %22 = load %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  %sv_flags45 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i32* %sv_flags45, align 4, !tbaa !4
  %and46 = and i32 %23, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool43, label %if.else61, label %if.then44

if.then44:                                        ; preds = %cond.end39
  br i1 %tobool47, label %cond.true48, label %cond.false51

cond.true48:                                      ; preds = %if.then44
  %sv_any49 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %24 = load i8** %sv_any49, align 8, !tbaa !0
  %xiv_iv50 = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv50 to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end53

cond.false51:                                     ; preds = %if.then44
  %call52 = tail call i64 @Perl_sv_2iv(%struct.sv* %22) #7
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false51, %cond.true48
  %cond54 = phi i64 [ %26, %cond.true48 ], [ %call52, %cond.false51 ]
  %shr = ashr i64 %cond54, %cond40
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %shr) #7
  %sv_flags55 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %27 = load i32* %sv_flags55, align 4, !tbaa !4
  %and56 = and i32 %27, 16384
  %tobool57 = icmp eq i32 %and56, 0
  br i1 %tobool57, label %if.end78, label %if.then58

if.then58:                                        ; preds = %cond.end53
  %call59 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end78

if.else61:                                        ; preds = %cond.end39
  br i1 %tobool47, label %cond.true65, label %cond.false67

cond.true65:                                      ; preds = %if.else61
  %sv_any66 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %28 = load i8** %sv_any66, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  br label %cond.end69

cond.false67:                                     ; preds = %if.else61
  %call68 = tail call i64 @Perl_sv_2uv(%struct.sv* %22) #7
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false67, %cond.true65
  %cond70 = phi i64 [ %30, %cond.true65 ], [ %call68, %cond.false67 ]
  %shr71 = lshr i64 %cond70, %cond40
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %shr71) #7
  %sv_flags72 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %31 = load i32* %sv_flags72, align 4, !tbaa !4
  %and73 = and i32 %31, 16384
  %tobool74 = icmp eq i32 %and73, 0
  br i1 %tobool74, label %if.end78, label %if.then75

if.then75:                                        ; preds = %cond.end69
  %call76 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end78

if.end78:                                         ; preds = %if.then75, %cond.end69, %if.then58, %cond.end53
  store %struct.sv* %cond, %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end78, %if.end29
  %storemerge108 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr32.pre-phi, %if.end78 ]
  store %struct.sv** %storemerge108, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_lt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 28, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry, %lor.lhs.false
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %9, 16777216
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end24

land.lhs.true11:                                  ; preds = %if.end7
  %10 = and i32 %9, 393216
  %or.cond.not = icmp ne i32 %10, 0
  %and21 = and i32 %9, 65536
  %tobool22 = icmp eq i32 %and21, 0
  %or.cond258 = and i1 %or.cond.not, %tobool22
  br i1 %or.cond258, label %cond.false, label %if.end24

cond.false:                                       ; preds = %land.lhs.true11
  %call23 = tail call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags25.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre260 = load i32* %sv_flags25.phi.trans.insert, align 4, !tbaa !4
  br label %if.end24

if.end24:                                         ; preds = %land.lhs.true11, %if.end7, %cond.false
  %11 = phi i32 [ %9, %land.lhs.true11 ], [ %9, %if.end7 ], [ %.pre260, %cond.false ]
  %12 = phi %struct.sv* [ %8, %land.lhs.true11 ], [ %8, %if.end7 ], [ %.pre, %cond.false ]
  %and26 = and i32 %11, 65536
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.else, label %if.then28

if.then28:                                        ; preds = %if.end24
  %add.ptr29 = getelementptr inbounds %struct.sv** %0, i64 -1
  %13 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags30 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags30, align 4, !tbaa !4
  %and31 = and i32 %14, 16777216
  %tobool32 = icmp eq i32 %and31, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.end57

land.lhs.true33:                                  ; preds = %if.then28
  %15 = and i32 %14, 393216
  %or.cond254.not = icmp ne i32 %15, 0
  %and46 = and i32 %14, 65536
  %tobool47 = icmp eq i32 %and46, 0
  %or.cond259 = and i1 %or.cond254.not, %tobool47
  br i1 %or.cond259, label %cond.false52, label %if.end57

cond.false52:                                     ; preds = %land.lhs.true33
  %call54 = tail call i64 @Perl_sv_2iv(%struct.sv* %13) #7
  %.pre261 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags59.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre261, i64 0, i32 2
  %.pre262 = load i32* %sv_flags59.phi.trans.insert, align 4, !tbaa !4
  br label %if.end57

if.end57:                                         ; preds = %land.lhs.true33, %if.then28, %cond.false52
  %16 = phi i32 [ %14, %land.lhs.true33 ], [ %14, %if.then28 ], [ %.pre262, %cond.false52 ]
  %17 = phi %struct.sv* [ %13, %land.lhs.true33 ], [ %13, %if.then28 ], [ %.pre261, %cond.false52 ]
  %and60 = and i32 %16, 65536
  %tobool61 = icmp eq i32 %and60, 0
  br i1 %tobool61, label %if.end57.if.end169_crit_edge, label %if.then62

if.end57.if.end169_crit_edge:                     ; preds = %if.end57
  %.pre263 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags171.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre263, i64 0, i32 2
  %.pre264 = load i32* %sv_flags171.phi.trans.insert, align 4, !tbaa !4
  br label %if.end169

if.then62:                                        ; preds = %if.end57
  %and65 = and i32 %16, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %18 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags67 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags67, align 4, !tbaa !4
  %and68 = and i32 %19, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %brmerge = or i1 %cmp, %cmp69
  br i1 %brmerge, label %if.end86, label %if.then75

if.then75:                                        ; preds = %if.then62
  %sv_any77 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %20 = load i8** %sv_any77, align 8, !tbaa !0
  %xiv_iv78 = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv78 to i64*
  %22 = load i64* %21, align 8, !tbaa !3
  %sv_any79 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %23 = load i8** %sv_any79, align 8, !tbaa !0
  %xiv_iv80 = getelementptr inbounds i8* %23, i64 24
  %24 = bitcast i8* %xiv_iv80 to i64*
  %25 = load i64* %24, align 8, !tbaa !3
  %cmp82 = icmp slt i64 %22, %25
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond84, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %26 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next85 = getelementptr inbounds %struct.op* %26, i64 0, i32 0
  br label %return

if.end86:                                         ; preds = %if.then62
  %27 = and i32 %and65, %19
  %brmerge255 = icmp eq i32 %27, -2147418112
  br i1 %brmerge255, label %if.then92, label %if.end102

if.then92:                                        ; preds = %if.end86
  %sv_any94 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %28 = load i8** %sv_any94, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  %sv_any95 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %31 = load i8** %sv_any95, align 8, !tbaa !0
  %xuv_uv96 = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xuv_uv96 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  %cmp98 = icmp ult i64 %30, %33
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond100, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %34 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next101 = getelementptr inbounds %struct.op* %34, i64 0, i32 0
  br label %return

if.end102:                                        ; preds = %if.end86
  br i1 %cmp, label %if.then104, label %if.end121

if.then104:                                       ; preds = %if.end102
  %sv_any107 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %35 = load i8** %sv_any107, align 8, !tbaa !0
  %xiv_iv108 = getelementptr inbounds i8* %35, i64 24
  %36 = bitcast i8* %xiv_iv108 to i64*
  %37 = load i64* %36, align 8, !tbaa !3
  %cmp110 = icmp slt i64 %37, 0
  br i1 %cmp110, label %if.then112, label %if.end114

if.then112:                                       ; preds = %if.then104
  store %struct.sv* @PL_sv_no, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %38 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next113 = getelementptr inbounds %struct.op* %38, i64 0, i32 0
  br label %return

if.end114:                                        ; preds = %if.then104
  %sv_any115 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %39 = load i8** %sv_any115, align 8, !tbaa !0
  %xuv_uv116 = getelementptr inbounds i8* %39, i64 24
  %40 = bitcast i8* %xuv_uv116 to i64*
  %41 = load i64* %40, align 8, !tbaa !3
  %cmp117 = icmp ult i64 %41, %37
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond119, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next120 = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  br label %return

if.end121:                                        ; preds = %if.end102
  %sv_any125 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %43 = load i8** %sv_any125, align 8, !tbaa !0
  %xiv_iv126 = getelementptr inbounds i8* %43, i64 24
  %44 = bitcast i8* %xiv_iv126 to i64*
  %45 = load i64* %44, align 8, !tbaa !3
  %cmp127 = icmp slt i64 %45, 0
  br i1 %cmp127, label %if.then129, label %if.end132

if.then129:                                       ; preds = %if.end121
  store %struct.sv* @PL_sv_yes, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %46 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next131 = getelementptr inbounds %struct.op* %46, i64 0, i32 0
  br label %return

if.end132:                                        ; preds = %if.end121
  %sv_any133 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %47 = load i8** %sv_any133, align 8, !tbaa !0
  %xuv_uv134 = getelementptr inbounds i8* %47, i64 24
  %48 = bitcast i8* %xuv_uv134 to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  %cmp136 = icmp ult i64 %45, %49
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond138, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %50 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next139 = getelementptr inbounds %struct.op* %50, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %if.end24
  %51 = and i32 %11, 268959744
  %52 = icmp eq i32 %51, 524288
  %add.ptr149 = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %52, label %land.lhs.true148, label %if.end169

land.lhs.true148:                                 ; preds = %if.else
  %53 = load %struct.sv** %add.ptr149, align 8, !tbaa !0
  %sv_flags150 = getelementptr inbounds %struct.sv* %53, i64 0, i32 2
  %54 = load i32* %sv_flags150, align 4, !tbaa !4
  %55 = and i32 %54, 268959744
  %56 = icmp eq i32 %55, 524288
  br i1 %56, label %if.then158, label %if.end169

if.then158:                                       ; preds = %land.lhs.true148
  %sv_any160 = getelementptr inbounds %struct.sv* %53, i64 0, i32 0
  %57 = load i8** %sv_any160, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %57 to %struct.sv**
  %58 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any162 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %59 = load i8** %sv_any162, align 8, !tbaa !0
  %xrv_rv163 = bitcast i8* %59 to %struct.sv**
  %60 = load %struct.sv** %xrv_rv163, align 8, !tbaa !0
  %cmp164 = icmp ult %struct.sv* %58, %60
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond166, %struct.sv** %add.ptr149, align 8, !tbaa !0
  store %struct.sv** %add.ptr149, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %61 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next167 = getelementptr inbounds %struct.op* %61, i64 0, i32 0
  br label %return

if.end169:                                        ; preds = %if.else, %if.end57.if.end169_crit_edge, %land.lhs.true148
  %incdec.ptr170.pre-phi = phi %struct.sv** [ %add.ptr29, %if.end57.if.end169_crit_edge ], [ %add.ptr149, %land.lhs.true148 ], [ %add.ptr149, %if.else ]
  %62 = phi i32 [ %.pre264, %if.end57.if.end169_crit_edge ], [ %11, %land.lhs.true148 ], [ %11, %if.else ]
  %63 = phi %struct.sv* [ %.pre263, %if.end57.if.end169_crit_edge ], [ %12, %land.lhs.true148 ], [ %12, %if.else ]
  store %struct.sv* %63, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and172 = and i32 %62, 131072
  %tobool173 = icmp eq i32 %and172, 0
  br i1 %tobool173, label %cond.false176, label %cond.true174

cond.true174:                                     ; preds = %if.end169
  %sv_any175 = getelementptr inbounds %struct.sv* %63, i64 0, i32 0
  %64 = load i8** %sv_any175, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %64, i64 32
  %65 = bitcast i8* %xnv_nv to double*
  %66 = load double* %65, align 8, !tbaa !6
  br label %cond.end178

cond.false176:                                    ; preds = %if.end169
  %call177 = tail call double @Perl_sv_2nv(%struct.sv* %63) #7
  br label %cond.end178

cond.end178:                                      ; preds = %cond.false176, %cond.true174
  %cond179 = phi double [ %66, %cond.true174 ], [ %call177, %cond.false176 ]
  %67 = load %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  %sv_flags180 = getelementptr inbounds %struct.sv* %67, i64 0, i32 2
  %68 = load i32* %sv_flags180, align 4, !tbaa !4
  %and181 = and i32 %68, 131072
  %tobool182 = icmp eq i32 %and181, 0
  br i1 %tobool182, label %cond.false186, label %cond.true183

cond.true183:                                     ; preds = %cond.end178
  %sv_any184 = getelementptr inbounds %struct.sv* %67, i64 0, i32 0
  %69 = load i8** %sv_any184, align 8, !tbaa !0
  %xnv_nv185 = getelementptr inbounds i8* %69, i64 32
  %70 = bitcast i8* %xnv_nv185 to double*
  %71 = load double* %70, align 8, !tbaa !6
  br label %cond.end188

cond.false186:                                    ; preds = %cond.end178
  %call187 = tail call double @Perl_sv_2nv(%struct.sv* %67) #7
  br label %cond.end188

cond.end188:                                      ; preds = %cond.false186, %cond.true183
  %cond189 = phi double [ %71, %cond.true183 ], [ %call187, %cond.false186 ]
  %cmp190 = fcmp olt double %cond189, %cond179
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond192, %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr170.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %72 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next193 = getelementptr inbounds %struct.op* %72, i64 0, i32 0
  br label %return

return:                                           ; preds = %cond.end188, %if.then158, %if.end132, %if.then129, %if.end114, %if.then112, %if.then92, %if.then75, %if.then6
  %retval.0.in = phi %struct.op** [ %op_next, %if.then6 ], [ %op_next101, %if.then92 ], [ %op_next113, %if.then112 ], [ %op_next120, %if.end114 ], [ %op_next131, %if.then129 ], [ %op_next139, %if.end132 ], [ %op_next85, %if.then75 ], [ %op_next193, %cond.end188 ], [ %op_next167, %if.then158 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_gt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 30, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry, %lor.lhs.false
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %9, 16777216
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end24

land.lhs.true11:                                  ; preds = %if.end7
  %10 = and i32 %9, 393216
  %or.cond.not = icmp ne i32 %10, 0
  %and21 = and i32 %9, 65536
  %tobool22 = icmp eq i32 %and21, 0
  %or.cond258 = and i1 %or.cond.not, %tobool22
  br i1 %or.cond258, label %cond.false, label %if.end24

cond.false:                                       ; preds = %land.lhs.true11
  %call23 = tail call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags25.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre260 = load i32* %sv_flags25.phi.trans.insert, align 4, !tbaa !4
  br label %if.end24

if.end24:                                         ; preds = %land.lhs.true11, %if.end7, %cond.false
  %11 = phi i32 [ %9, %land.lhs.true11 ], [ %9, %if.end7 ], [ %.pre260, %cond.false ]
  %12 = phi %struct.sv* [ %8, %land.lhs.true11 ], [ %8, %if.end7 ], [ %.pre, %cond.false ]
  %and26 = and i32 %11, 65536
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.else, label %if.then28

if.then28:                                        ; preds = %if.end24
  %add.ptr29 = getelementptr inbounds %struct.sv** %0, i64 -1
  %13 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags30 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags30, align 4, !tbaa !4
  %and31 = and i32 %14, 16777216
  %tobool32 = icmp eq i32 %and31, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.end57

land.lhs.true33:                                  ; preds = %if.then28
  %15 = and i32 %14, 393216
  %or.cond254.not = icmp ne i32 %15, 0
  %and46 = and i32 %14, 65536
  %tobool47 = icmp eq i32 %and46, 0
  %or.cond259 = and i1 %or.cond254.not, %tobool47
  br i1 %or.cond259, label %cond.false52, label %if.end57

cond.false52:                                     ; preds = %land.lhs.true33
  %call54 = tail call i64 @Perl_sv_2iv(%struct.sv* %13) #7
  %.pre261 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags59.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre261, i64 0, i32 2
  %.pre262 = load i32* %sv_flags59.phi.trans.insert, align 4, !tbaa !4
  br label %if.end57

if.end57:                                         ; preds = %land.lhs.true33, %if.then28, %cond.false52
  %16 = phi i32 [ %14, %land.lhs.true33 ], [ %14, %if.then28 ], [ %.pre262, %cond.false52 ]
  %17 = phi %struct.sv* [ %13, %land.lhs.true33 ], [ %13, %if.then28 ], [ %.pre261, %cond.false52 ]
  %and60 = and i32 %16, 65536
  %tobool61 = icmp eq i32 %and60, 0
  br i1 %tobool61, label %if.end57.if.end169_crit_edge, label %if.then62

if.end57.if.end169_crit_edge:                     ; preds = %if.end57
  %.pre263 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags171.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre263, i64 0, i32 2
  %.pre264 = load i32* %sv_flags171.phi.trans.insert, align 4, !tbaa !4
  br label %if.end169

if.then62:                                        ; preds = %if.end57
  %and65 = and i32 %16, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %18 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags67 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags67, align 4, !tbaa !4
  %and68 = and i32 %19, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %brmerge = or i1 %cmp, %cmp69
  br i1 %brmerge, label %if.end86, label %if.then75

if.then75:                                        ; preds = %if.then62
  %sv_any77 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %20 = load i8** %sv_any77, align 8, !tbaa !0
  %xiv_iv78 = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv78 to i64*
  %22 = load i64* %21, align 8, !tbaa !3
  %sv_any79 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %23 = load i8** %sv_any79, align 8, !tbaa !0
  %xiv_iv80 = getelementptr inbounds i8* %23, i64 24
  %24 = bitcast i8* %xiv_iv80 to i64*
  %25 = load i64* %24, align 8, !tbaa !3
  %cmp82 = icmp sgt i64 %22, %25
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond84, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %26 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next85 = getelementptr inbounds %struct.op* %26, i64 0, i32 0
  br label %return

if.end86:                                         ; preds = %if.then62
  %27 = and i32 %and65, %19
  %brmerge255 = icmp eq i32 %27, -2147418112
  br i1 %brmerge255, label %if.then92, label %if.end102

if.then92:                                        ; preds = %if.end86
  %sv_any94 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %28 = load i8** %sv_any94, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  %sv_any95 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %31 = load i8** %sv_any95, align 8, !tbaa !0
  %xuv_uv96 = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xuv_uv96 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  %cmp98 = icmp ugt i64 %30, %33
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond100, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %34 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next101 = getelementptr inbounds %struct.op* %34, i64 0, i32 0
  br label %return

if.end102:                                        ; preds = %if.end86
  br i1 %cmp, label %if.then104, label %if.end121

if.then104:                                       ; preds = %if.end102
  %sv_any107 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %35 = load i8** %sv_any107, align 8, !tbaa !0
  %xiv_iv108 = getelementptr inbounds i8* %35, i64 24
  %36 = bitcast i8* %xiv_iv108 to i64*
  %37 = load i64* %36, align 8, !tbaa !3
  %cmp110 = icmp slt i64 %37, 0
  br i1 %cmp110, label %if.then112, label %if.end114

if.then112:                                       ; preds = %if.then104
  store %struct.sv* @PL_sv_yes, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %38 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next113 = getelementptr inbounds %struct.op* %38, i64 0, i32 0
  br label %return

if.end114:                                        ; preds = %if.then104
  %sv_any115 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %39 = load i8** %sv_any115, align 8, !tbaa !0
  %xuv_uv116 = getelementptr inbounds i8* %39, i64 24
  %40 = bitcast i8* %xuv_uv116 to i64*
  %41 = load i64* %40, align 8, !tbaa !3
  %cmp117 = icmp ugt i64 %41, %37
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond119, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next120 = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  br label %return

if.end121:                                        ; preds = %if.end102
  %sv_any125 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %43 = load i8** %sv_any125, align 8, !tbaa !0
  %xiv_iv126 = getelementptr inbounds i8* %43, i64 24
  %44 = bitcast i8* %xiv_iv126 to i64*
  %45 = load i64* %44, align 8, !tbaa !3
  %cmp127 = icmp slt i64 %45, 0
  br i1 %cmp127, label %if.then129, label %if.end132

if.then129:                                       ; preds = %if.end121
  store %struct.sv* @PL_sv_no, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %46 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next131 = getelementptr inbounds %struct.op* %46, i64 0, i32 0
  br label %return

if.end132:                                        ; preds = %if.end121
  %sv_any133 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %47 = load i8** %sv_any133, align 8, !tbaa !0
  %xuv_uv134 = getelementptr inbounds i8* %47, i64 24
  %48 = bitcast i8* %xuv_uv134 to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  %cmp136 = icmp ugt i64 %45, %49
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond138, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %50 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next139 = getelementptr inbounds %struct.op* %50, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %if.end24
  %51 = and i32 %11, 268959744
  %52 = icmp eq i32 %51, 524288
  %add.ptr149 = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %52, label %land.lhs.true148, label %if.end169

land.lhs.true148:                                 ; preds = %if.else
  %53 = load %struct.sv** %add.ptr149, align 8, !tbaa !0
  %sv_flags150 = getelementptr inbounds %struct.sv* %53, i64 0, i32 2
  %54 = load i32* %sv_flags150, align 4, !tbaa !4
  %55 = and i32 %54, 268959744
  %56 = icmp eq i32 %55, 524288
  br i1 %56, label %if.then158, label %if.end169

if.then158:                                       ; preds = %land.lhs.true148
  %sv_any160 = getelementptr inbounds %struct.sv* %53, i64 0, i32 0
  %57 = load i8** %sv_any160, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %57 to %struct.sv**
  %58 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any162 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %59 = load i8** %sv_any162, align 8, !tbaa !0
  %xrv_rv163 = bitcast i8* %59 to %struct.sv**
  %60 = load %struct.sv** %xrv_rv163, align 8, !tbaa !0
  %cmp164 = icmp ugt %struct.sv* %58, %60
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond166, %struct.sv** %add.ptr149, align 8, !tbaa !0
  store %struct.sv** %add.ptr149, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %61 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next167 = getelementptr inbounds %struct.op* %61, i64 0, i32 0
  br label %return

if.end169:                                        ; preds = %if.else, %if.end57.if.end169_crit_edge, %land.lhs.true148
  %incdec.ptr170.pre-phi = phi %struct.sv** [ %add.ptr29, %if.end57.if.end169_crit_edge ], [ %add.ptr149, %land.lhs.true148 ], [ %add.ptr149, %if.else ]
  %62 = phi i32 [ %.pre264, %if.end57.if.end169_crit_edge ], [ %11, %land.lhs.true148 ], [ %11, %if.else ]
  %63 = phi %struct.sv* [ %.pre263, %if.end57.if.end169_crit_edge ], [ %12, %land.lhs.true148 ], [ %12, %if.else ]
  store %struct.sv* %63, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and172 = and i32 %62, 131072
  %tobool173 = icmp eq i32 %and172, 0
  br i1 %tobool173, label %cond.false176, label %cond.true174

cond.true174:                                     ; preds = %if.end169
  %sv_any175 = getelementptr inbounds %struct.sv* %63, i64 0, i32 0
  %64 = load i8** %sv_any175, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %64, i64 32
  %65 = bitcast i8* %xnv_nv to double*
  %66 = load double* %65, align 8, !tbaa !6
  br label %cond.end178

cond.false176:                                    ; preds = %if.end169
  %call177 = tail call double @Perl_sv_2nv(%struct.sv* %63) #7
  br label %cond.end178

cond.end178:                                      ; preds = %cond.false176, %cond.true174
  %cond179 = phi double [ %66, %cond.true174 ], [ %call177, %cond.false176 ]
  %67 = load %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  %sv_flags180 = getelementptr inbounds %struct.sv* %67, i64 0, i32 2
  %68 = load i32* %sv_flags180, align 4, !tbaa !4
  %and181 = and i32 %68, 131072
  %tobool182 = icmp eq i32 %and181, 0
  br i1 %tobool182, label %cond.false186, label %cond.true183

cond.true183:                                     ; preds = %cond.end178
  %sv_any184 = getelementptr inbounds %struct.sv* %67, i64 0, i32 0
  %69 = load i8** %sv_any184, align 8, !tbaa !0
  %xnv_nv185 = getelementptr inbounds i8* %69, i64 32
  %70 = bitcast i8* %xnv_nv185 to double*
  %71 = load double* %70, align 8, !tbaa !6
  br label %cond.end188

cond.false186:                                    ; preds = %cond.end178
  %call187 = tail call double @Perl_sv_2nv(%struct.sv* %67) #7
  br label %cond.end188

cond.end188:                                      ; preds = %cond.false186, %cond.true183
  %cond189 = phi double [ %71, %cond.true183 ], [ %call187, %cond.false186 ]
  %cmp190 = fcmp ogt double %cond189, %cond179
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond192, %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr170.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %72 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next193 = getelementptr inbounds %struct.op* %72, i64 0, i32 0
  br label %return

return:                                           ; preds = %cond.end188, %if.then158, %if.end132, %if.then129, %if.end114, %if.then112, %if.then92, %if.then75, %if.then6
  %retval.0.in = phi %struct.op** [ %op_next, %if.then6 ], [ %op_next101, %if.then92 ], [ %op_next113, %if.then112 ], [ %op_next120, %if.end114 ], [ %op_next131, %if.then129 ], [ %op_next139, %if.end132 ], [ %op_next85, %if.then75 ], [ %op_next193, %cond.end188 ], [ %op_next167, %if.then158 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_le() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 29, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry, %lor.lhs.false
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %9, 16777216
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end24

land.lhs.true11:                                  ; preds = %if.end7
  %10 = and i32 %9, 393216
  %or.cond.not = icmp ne i32 %10, 0
  %and21 = and i32 %9, 65536
  %tobool22 = icmp eq i32 %and21, 0
  %or.cond258 = and i1 %or.cond.not, %tobool22
  br i1 %or.cond258, label %cond.false, label %if.end24

cond.false:                                       ; preds = %land.lhs.true11
  %call23 = tail call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags25.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre260 = load i32* %sv_flags25.phi.trans.insert, align 4, !tbaa !4
  br label %if.end24

if.end24:                                         ; preds = %land.lhs.true11, %if.end7, %cond.false
  %11 = phi i32 [ %9, %land.lhs.true11 ], [ %9, %if.end7 ], [ %.pre260, %cond.false ]
  %12 = phi %struct.sv* [ %8, %land.lhs.true11 ], [ %8, %if.end7 ], [ %.pre, %cond.false ]
  %and26 = and i32 %11, 65536
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.else, label %if.then28

if.then28:                                        ; preds = %if.end24
  %add.ptr29 = getelementptr inbounds %struct.sv** %0, i64 -1
  %13 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags30 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags30, align 4, !tbaa !4
  %and31 = and i32 %14, 16777216
  %tobool32 = icmp eq i32 %and31, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.end57

land.lhs.true33:                                  ; preds = %if.then28
  %15 = and i32 %14, 393216
  %or.cond254.not = icmp ne i32 %15, 0
  %and46 = and i32 %14, 65536
  %tobool47 = icmp eq i32 %and46, 0
  %or.cond259 = and i1 %or.cond254.not, %tobool47
  br i1 %or.cond259, label %cond.false52, label %if.end57

cond.false52:                                     ; preds = %land.lhs.true33
  %call54 = tail call i64 @Perl_sv_2iv(%struct.sv* %13) #7
  %.pre261 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags59.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre261, i64 0, i32 2
  %.pre262 = load i32* %sv_flags59.phi.trans.insert, align 4, !tbaa !4
  br label %if.end57

if.end57:                                         ; preds = %land.lhs.true33, %if.then28, %cond.false52
  %16 = phi i32 [ %14, %land.lhs.true33 ], [ %14, %if.then28 ], [ %.pre262, %cond.false52 ]
  %17 = phi %struct.sv* [ %13, %land.lhs.true33 ], [ %13, %if.then28 ], [ %.pre261, %cond.false52 ]
  %and60 = and i32 %16, 65536
  %tobool61 = icmp eq i32 %and60, 0
  br i1 %tobool61, label %if.end57.if.end169_crit_edge, label %if.then62

if.end57.if.end169_crit_edge:                     ; preds = %if.end57
  %.pre263 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags171.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre263, i64 0, i32 2
  %.pre264 = load i32* %sv_flags171.phi.trans.insert, align 4, !tbaa !4
  br label %if.end169

if.then62:                                        ; preds = %if.end57
  %and65 = and i32 %16, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %18 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags67 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags67, align 4, !tbaa !4
  %and68 = and i32 %19, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %brmerge = or i1 %cmp, %cmp69
  br i1 %brmerge, label %if.end86, label %if.then75

if.then75:                                        ; preds = %if.then62
  %sv_any77 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %20 = load i8** %sv_any77, align 8, !tbaa !0
  %xiv_iv78 = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv78 to i64*
  %22 = load i64* %21, align 8, !tbaa !3
  %sv_any79 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %23 = load i8** %sv_any79, align 8, !tbaa !0
  %xiv_iv80 = getelementptr inbounds i8* %23, i64 24
  %24 = bitcast i8* %xiv_iv80 to i64*
  %25 = load i64* %24, align 8, !tbaa !3
  %cmp82 = icmp sle i64 %22, %25
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond84, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %26 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next85 = getelementptr inbounds %struct.op* %26, i64 0, i32 0
  br label %return

if.end86:                                         ; preds = %if.then62
  %27 = and i32 %and65, %19
  %brmerge255 = icmp eq i32 %27, -2147418112
  br i1 %brmerge255, label %if.then92, label %if.end102

if.then92:                                        ; preds = %if.end86
  %sv_any94 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %28 = load i8** %sv_any94, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  %sv_any95 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %31 = load i8** %sv_any95, align 8, !tbaa !0
  %xuv_uv96 = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xuv_uv96 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  %cmp98 = icmp ule i64 %30, %33
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond100, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %34 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next101 = getelementptr inbounds %struct.op* %34, i64 0, i32 0
  br label %return

if.end102:                                        ; preds = %if.end86
  br i1 %cmp, label %if.then104, label %if.end121

if.then104:                                       ; preds = %if.end102
  %sv_any107 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %35 = load i8** %sv_any107, align 8, !tbaa !0
  %xiv_iv108 = getelementptr inbounds i8* %35, i64 24
  %36 = bitcast i8* %xiv_iv108 to i64*
  %37 = load i64* %36, align 8, !tbaa !3
  %cmp110 = icmp slt i64 %37, 0
  br i1 %cmp110, label %if.then112, label %if.end114

if.then112:                                       ; preds = %if.then104
  store %struct.sv* @PL_sv_no, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %38 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next113 = getelementptr inbounds %struct.op* %38, i64 0, i32 0
  br label %return

if.end114:                                        ; preds = %if.then104
  %sv_any115 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %39 = load i8** %sv_any115, align 8, !tbaa !0
  %xuv_uv116 = getelementptr inbounds i8* %39, i64 24
  %40 = bitcast i8* %xuv_uv116 to i64*
  %41 = load i64* %40, align 8, !tbaa !3
  %cmp117 = icmp ule i64 %41, %37
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond119, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next120 = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  br label %return

if.end121:                                        ; preds = %if.end102
  %sv_any125 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %43 = load i8** %sv_any125, align 8, !tbaa !0
  %xiv_iv126 = getelementptr inbounds i8* %43, i64 24
  %44 = bitcast i8* %xiv_iv126 to i64*
  %45 = load i64* %44, align 8, !tbaa !3
  %cmp127 = icmp slt i64 %45, 0
  br i1 %cmp127, label %if.then129, label %if.end132

if.then129:                                       ; preds = %if.end121
  store %struct.sv* @PL_sv_yes, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %46 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next131 = getelementptr inbounds %struct.op* %46, i64 0, i32 0
  br label %return

if.end132:                                        ; preds = %if.end121
  %sv_any133 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %47 = load i8** %sv_any133, align 8, !tbaa !0
  %xuv_uv134 = getelementptr inbounds i8* %47, i64 24
  %48 = bitcast i8* %xuv_uv134 to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  %cmp136 = icmp ule i64 %45, %49
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond138, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %50 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next139 = getelementptr inbounds %struct.op* %50, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %if.end24
  %51 = and i32 %11, 268959744
  %52 = icmp eq i32 %51, 524288
  %add.ptr149 = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %52, label %land.lhs.true148, label %if.end169

land.lhs.true148:                                 ; preds = %if.else
  %53 = load %struct.sv** %add.ptr149, align 8, !tbaa !0
  %sv_flags150 = getelementptr inbounds %struct.sv* %53, i64 0, i32 2
  %54 = load i32* %sv_flags150, align 4, !tbaa !4
  %55 = and i32 %54, 268959744
  %56 = icmp eq i32 %55, 524288
  br i1 %56, label %if.then158, label %if.end169

if.then158:                                       ; preds = %land.lhs.true148
  %sv_any160 = getelementptr inbounds %struct.sv* %53, i64 0, i32 0
  %57 = load i8** %sv_any160, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %57 to %struct.sv**
  %58 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any162 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %59 = load i8** %sv_any162, align 8, !tbaa !0
  %xrv_rv163 = bitcast i8* %59 to %struct.sv**
  %60 = load %struct.sv** %xrv_rv163, align 8, !tbaa !0
  %cmp164 = icmp ule %struct.sv* %58, %60
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond166, %struct.sv** %add.ptr149, align 8, !tbaa !0
  store %struct.sv** %add.ptr149, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %61 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next167 = getelementptr inbounds %struct.op* %61, i64 0, i32 0
  br label %return

if.end169:                                        ; preds = %if.else, %if.end57.if.end169_crit_edge, %land.lhs.true148
  %incdec.ptr170.pre-phi = phi %struct.sv** [ %add.ptr29, %if.end57.if.end169_crit_edge ], [ %add.ptr149, %land.lhs.true148 ], [ %add.ptr149, %if.else ]
  %62 = phi i32 [ %.pre264, %if.end57.if.end169_crit_edge ], [ %11, %land.lhs.true148 ], [ %11, %if.else ]
  %63 = phi %struct.sv* [ %.pre263, %if.end57.if.end169_crit_edge ], [ %12, %land.lhs.true148 ], [ %12, %if.else ]
  store %struct.sv* %63, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and172 = and i32 %62, 131072
  %tobool173 = icmp eq i32 %and172, 0
  br i1 %tobool173, label %cond.false176, label %cond.true174

cond.true174:                                     ; preds = %if.end169
  %sv_any175 = getelementptr inbounds %struct.sv* %63, i64 0, i32 0
  %64 = load i8** %sv_any175, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %64, i64 32
  %65 = bitcast i8* %xnv_nv to double*
  %66 = load double* %65, align 8, !tbaa !6
  br label %cond.end178

cond.false176:                                    ; preds = %if.end169
  %call177 = tail call double @Perl_sv_2nv(%struct.sv* %63) #7
  br label %cond.end178

cond.end178:                                      ; preds = %cond.false176, %cond.true174
  %cond179 = phi double [ %66, %cond.true174 ], [ %call177, %cond.false176 ]
  %67 = load %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  %sv_flags180 = getelementptr inbounds %struct.sv* %67, i64 0, i32 2
  %68 = load i32* %sv_flags180, align 4, !tbaa !4
  %and181 = and i32 %68, 131072
  %tobool182 = icmp eq i32 %and181, 0
  br i1 %tobool182, label %cond.false186, label %cond.true183

cond.true183:                                     ; preds = %cond.end178
  %sv_any184 = getelementptr inbounds %struct.sv* %67, i64 0, i32 0
  %69 = load i8** %sv_any184, align 8, !tbaa !0
  %xnv_nv185 = getelementptr inbounds i8* %69, i64 32
  %70 = bitcast i8* %xnv_nv185 to double*
  %71 = load double* %70, align 8, !tbaa !6
  br label %cond.end188

cond.false186:                                    ; preds = %cond.end178
  %call187 = tail call double @Perl_sv_2nv(%struct.sv* %67) #7
  br label %cond.end188

cond.end188:                                      ; preds = %cond.false186, %cond.true183
  %cond189 = phi double [ %71, %cond.true183 ], [ %call187, %cond.false186 ]
  %cmp190 = fcmp ole double %cond189, %cond179
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond192, %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr170.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %72 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next193 = getelementptr inbounds %struct.op* %72, i64 0, i32 0
  br label %return

return:                                           ; preds = %cond.end188, %if.then158, %if.end132, %if.then129, %if.end114, %if.then112, %if.then92, %if.then75, %if.then6
  %retval.0.in = phi %struct.op** [ %op_next, %if.then6 ], [ %op_next101, %if.then92 ], [ %op_next113, %if.then112 ], [ %op_next120, %if.end114 ], [ %op_next131, %if.then129 ], [ %op_next139, %if.end132 ], [ %op_next85, %if.then75 ], [ %op_next193, %cond.end188 ], [ %op_next167, %if.then158 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_ge() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 31, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry, %lor.lhs.false
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %9, 16777216
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end24

land.lhs.true11:                                  ; preds = %if.end7
  %10 = and i32 %9, 393216
  %or.cond.not = icmp ne i32 %10, 0
  %and21 = and i32 %9, 65536
  %tobool22 = icmp eq i32 %and21, 0
  %or.cond258 = and i1 %or.cond.not, %tobool22
  br i1 %or.cond258, label %cond.false, label %if.end24

cond.false:                                       ; preds = %land.lhs.true11
  %call23 = tail call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags25.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre260 = load i32* %sv_flags25.phi.trans.insert, align 4, !tbaa !4
  br label %if.end24

if.end24:                                         ; preds = %land.lhs.true11, %if.end7, %cond.false
  %11 = phi i32 [ %9, %land.lhs.true11 ], [ %9, %if.end7 ], [ %.pre260, %cond.false ]
  %12 = phi %struct.sv* [ %8, %land.lhs.true11 ], [ %8, %if.end7 ], [ %.pre, %cond.false ]
  %and26 = and i32 %11, 65536
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.else, label %if.then28

if.then28:                                        ; preds = %if.end24
  %add.ptr29 = getelementptr inbounds %struct.sv** %0, i64 -1
  %13 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags30 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags30, align 4, !tbaa !4
  %and31 = and i32 %14, 16777216
  %tobool32 = icmp eq i32 %and31, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.end57

land.lhs.true33:                                  ; preds = %if.then28
  %15 = and i32 %14, 393216
  %or.cond254.not = icmp ne i32 %15, 0
  %and46 = and i32 %14, 65536
  %tobool47 = icmp eq i32 %and46, 0
  %or.cond259 = and i1 %or.cond254.not, %tobool47
  br i1 %or.cond259, label %cond.false52, label %if.end57

cond.false52:                                     ; preds = %land.lhs.true33
  %call54 = tail call i64 @Perl_sv_2iv(%struct.sv* %13) #7
  %.pre261 = load %struct.sv** %add.ptr29, align 8, !tbaa !0
  %sv_flags59.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre261, i64 0, i32 2
  %.pre262 = load i32* %sv_flags59.phi.trans.insert, align 4, !tbaa !4
  br label %if.end57

if.end57:                                         ; preds = %land.lhs.true33, %if.then28, %cond.false52
  %16 = phi i32 [ %14, %land.lhs.true33 ], [ %14, %if.then28 ], [ %.pre262, %cond.false52 ]
  %17 = phi %struct.sv* [ %13, %land.lhs.true33 ], [ %13, %if.then28 ], [ %.pre261, %cond.false52 ]
  %and60 = and i32 %16, 65536
  %tobool61 = icmp eq i32 %and60, 0
  br i1 %tobool61, label %if.end57.if.end169_crit_edge, label %if.then62

if.end57.if.end169_crit_edge:                     ; preds = %if.end57
  %.pre263 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags171.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre263, i64 0, i32 2
  %.pre264 = load i32* %sv_flags171.phi.trans.insert, align 4, !tbaa !4
  br label %if.end169

if.then62:                                        ; preds = %if.end57
  %and65 = and i32 %16, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %18 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags67 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags67, align 4, !tbaa !4
  %and68 = and i32 %19, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %brmerge = or i1 %cmp, %cmp69
  br i1 %brmerge, label %if.end86, label %if.then75

if.then75:                                        ; preds = %if.then62
  %sv_any77 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %20 = load i8** %sv_any77, align 8, !tbaa !0
  %xiv_iv78 = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xiv_iv78 to i64*
  %22 = load i64* %21, align 8, !tbaa !3
  %sv_any79 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %23 = load i8** %sv_any79, align 8, !tbaa !0
  %xiv_iv80 = getelementptr inbounds i8* %23, i64 24
  %24 = bitcast i8* %xiv_iv80 to i64*
  %25 = load i64* %24, align 8, !tbaa !3
  %cmp82 = icmp sge i64 %22, %25
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond84, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %26 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next85 = getelementptr inbounds %struct.op* %26, i64 0, i32 0
  br label %return

if.end86:                                         ; preds = %if.then62
  %27 = and i32 %and65, %19
  %brmerge255 = icmp eq i32 %27, -2147418112
  br i1 %brmerge255, label %if.then92, label %if.end102

if.then92:                                        ; preds = %if.end86
  %sv_any94 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %28 = load i8** %sv_any94, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xuv_uv to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  %sv_any95 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %31 = load i8** %sv_any95, align 8, !tbaa !0
  %xuv_uv96 = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xuv_uv96 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  %cmp98 = icmp uge i64 %30, %33
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond100, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %34 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next101 = getelementptr inbounds %struct.op* %34, i64 0, i32 0
  br label %return

if.end102:                                        ; preds = %if.end86
  br i1 %cmp, label %if.then104, label %if.end121

if.then104:                                       ; preds = %if.end102
  %sv_any107 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %35 = load i8** %sv_any107, align 8, !tbaa !0
  %xiv_iv108 = getelementptr inbounds i8* %35, i64 24
  %36 = bitcast i8* %xiv_iv108 to i64*
  %37 = load i64* %36, align 8, !tbaa !3
  %cmp110 = icmp slt i64 %37, 0
  br i1 %cmp110, label %if.then112, label %if.end114

if.then112:                                       ; preds = %if.then104
  store %struct.sv* @PL_sv_yes, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %38 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next113 = getelementptr inbounds %struct.op* %38, i64 0, i32 0
  br label %return

if.end114:                                        ; preds = %if.then104
  %sv_any115 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %39 = load i8** %sv_any115, align 8, !tbaa !0
  %xuv_uv116 = getelementptr inbounds i8* %39, i64 24
  %40 = bitcast i8* %xuv_uv116 to i64*
  %41 = load i64* %40, align 8, !tbaa !3
  %cmp117 = icmp uge i64 %41, %37
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond119, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next120 = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  br label %return

if.end121:                                        ; preds = %if.end102
  %sv_any125 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %43 = load i8** %sv_any125, align 8, !tbaa !0
  %xiv_iv126 = getelementptr inbounds i8* %43, i64 24
  %44 = bitcast i8* %xiv_iv126 to i64*
  %45 = load i64* %44, align 8, !tbaa !3
  %cmp127 = icmp slt i64 %45, 0
  br i1 %cmp127, label %if.then129, label %if.end132

if.then129:                                       ; preds = %if.end121
  store %struct.sv* @PL_sv_no, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %46 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next131 = getelementptr inbounds %struct.op* %46, i64 0, i32 0
  br label %return

if.end132:                                        ; preds = %if.end121
  %sv_any133 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %47 = load i8** %sv_any133, align 8, !tbaa !0
  %xuv_uv134 = getelementptr inbounds i8* %47, i64 24
  %48 = bitcast i8* %xuv_uv134 to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  %cmp136 = icmp uge i64 %45, %49
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond138, %struct.sv** %add.ptr29, align 8, !tbaa !0
  store %struct.sv** %add.ptr29, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %50 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next139 = getelementptr inbounds %struct.op* %50, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %if.end24
  %51 = and i32 %11, 268959744
  %52 = icmp eq i32 %51, 524288
  %add.ptr149 = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %52, label %land.lhs.true148, label %if.end169

land.lhs.true148:                                 ; preds = %if.else
  %53 = load %struct.sv** %add.ptr149, align 8, !tbaa !0
  %sv_flags150 = getelementptr inbounds %struct.sv* %53, i64 0, i32 2
  %54 = load i32* %sv_flags150, align 4, !tbaa !4
  %55 = and i32 %54, 268959744
  %56 = icmp eq i32 %55, 524288
  br i1 %56, label %if.then158, label %if.end169

if.then158:                                       ; preds = %land.lhs.true148
  %sv_any160 = getelementptr inbounds %struct.sv* %53, i64 0, i32 0
  %57 = load i8** %sv_any160, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %57 to %struct.sv**
  %58 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any162 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %59 = load i8** %sv_any162, align 8, !tbaa !0
  %xrv_rv163 = bitcast i8* %59 to %struct.sv**
  %60 = load %struct.sv** %xrv_rv163, align 8, !tbaa !0
  %cmp164 = icmp uge %struct.sv* %58, %60
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond166, %struct.sv** %add.ptr149, align 8, !tbaa !0
  store %struct.sv** %add.ptr149, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %61 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next167 = getelementptr inbounds %struct.op* %61, i64 0, i32 0
  br label %return

if.end169:                                        ; preds = %if.else, %if.end57.if.end169_crit_edge, %land.lhs.true148
  %incdec.ptr170.pre-phi = phi %struct.sv** [ %add.ptr29, %if.end57.if.end169_crit_edge ], [ %add.ptr149, %land.lhs.true148 ], [ %add.ptr149, %if.else ]
  %62 = phi i32 [ %.pre264, %if.end57.if.end169_crit_edge ], [ %11, %land.lhs.true148 ], [ %11, %if.else ]
  %63 = phi %struct.sv* [ %.pre263, %if.end57.if.end169_crit_edge ], [ %12, %land.lhs.true148 ], [ %12, %if.else ]
  store %struct.sv* %63, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and172 = and i32 %62, 131072
  %tobool173 = icmp eq i32 %and172, 0
  br i1 %tobool173, label %cond.false176, label %cond.true174

cond.true174:                                     ; preds = %if.end169
  %sv_any175 = getelementptr inbounds %struct.sv* %63, i64 0, i32 0
  %64 = load i8** %sv_any175, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %64, i64 32
  %65 = bitcast i8* %xnv_nv to double*
  %66 = load double* %65, align 8, !tbaa !6
  br label %cond.end178

cond.false176:                                    ; preds = %if.end169
  %call177 = tail call double @Perl_sv_2nv(%struct.sv* %63) #7
  br label %cond.end178

cond.end178:                                      ; preds = %cond.false176, %cond.true174
  %cond179 = phi double [ %66, %cond.true174 ], [ %call177, %cond.false176 ]
  %67 = load %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  %sv_flags180 = getelementptr inbounds %struct.sv* %67, i64 0, i32 2
  %68 = load i32* %sv_flags180, align 4, !tbaa !4
  %and181 = and i32 %68, 131072
  %tobool182 = icmp eq i32 %and181, 0
  br i1 %tobool182, label %cond.false186, label %cond.true183

cond.true183:                                     ; preds = %cond.end178
  %sv_any184 = getelementptr inbounds %struct.sv* %67, i64 0, i32 0
  %69 = load i8** %sv_any184, align 8, !tbaa !0
  %xnv_nv185 = getelementptr inbounds i8* %69, i64 32
  %70 = bitcast i8* %xnv_nv185 to double*
  %71 = load double* %70, align 8, !tbaa !6
  br label %cond.end188

cond.false186:                                    ; preds = %cond.end178
  %call187 = tail call double @Perl_sv_2nv(%struct.sv* %67) #7
  br label %cond.end188

cond.end188:                                      ; preds = %cond.false186, %cond.true183
  %cond189 = phi double [ %71, %cond.true183 ], [ %call187, %cond.false186 ]
  %cmp190 = fcmp oge double %cond189, %cond179
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond192, %struct.sv** %incdec.ptr170.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr170.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %72 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next193 = getelementptr inbounds %struct.op* %72, i64 0, i32 0
  br label %return

return:                                           ; preds = %cond.end188, %if.then158, %if.end132, %if.then129, %if.end114, %if.then112, %if.then92, %if.then75, %if.then6
  %retval.0.in = phi %struct.op** [ %op_next, %if.then6 ], [ %op_next101, %if.then92 ], [ %op_next113, %if.then112 ], [ %op_next120, %if.end114 ], [ %op_next131, %if.then129 ], [ %op_next139, %if.end132 ], [ %op_next85, %if.then75 ], [ %op_next193, %cond.end188 ], [ %op_next167, %if.then158 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_ne() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 33, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry, %lor.lhs.false
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags8, align 4, !tbaa !4
  %10 = and i32 %9, 268959744
  %11 = icmp eq i32 %10, 524288
  br i1 %11, label %land.lhs.true15, label %if.end31

land.lhs.true15:                                  ; preds = %if.end7
  %add.ptr16 = getelementptr inbounds %struct.sv** %0, i64 -1
  %12 = load %struct.sv** %add.ptr16, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags17, align 4, !tbaa !4
  %14 = and i32 %13, 268959744
  %15 = icmp eq i32 %14, 524288
  br i1 %15, label %if.then25, label %if.end31

if.then25:                                        ; preds = %land.lhs.true15
  %sv_any = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %16 = load i8** %sv_any, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %16 to %struct.sv**
  %17 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any28 = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %18 = load i8** %sv_any28, align 8, !tbaa !0
  %xrv_rv29 = bitcast i8* %18 to %struct.sv**
  %19 = load %struct.sv** %xrv_rv29, align 8, !tbaa !0
  %cmp = icmp ne %struct.sv* %17, %19
  %cond = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %add.ptr16, align 8, !tbaa !0
  store %struct.sv** %add.ptr16, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next30 = getelementptr inbounds %struct.op* %20, i64 0, i32 0
  br label %return

if.end31:                                         ; preds = %land.lhs.true15, %if.end7
  %and33 = and i32 %9, 16777216
  %tobool34 = icmp eq i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true35, label %if.end50

land.lhs.true35:                                  ; preds = %if.end31
  %21 = and i32 %9, 393216
  %or.cond220.not = icmp ne i32 %21, 0
  %and45 = and i32 %9, 65536
  %tobool46 = icmp eq i32 %and45, 0
  %or.cond222 = and i1 %or.cond220.not, %tobool46
  br i1 %or.cond222, label %cond.false, label %if.end50

cond.false:                                       ; preds = %land.lhs.true35
  %call48 = tail call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags51.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre224 = load i32* %sv_flags51.phi.trans.insert, align 4, !tbaa !4
  br label %if.end50

if.end50:                                         ; preds = %land.lhs.true35, %if.end31, %cond.false
  %22 = phi i32 [ %9, %land.lhs.true35 ], [ %9, %if.end31 ], [ %.pre224, %cond.false ]
  %23 = phi %struct.sv* [ %8, %land.lhs.true35 ], [ %8, %if.end31 ], [ %.pre, %cond.false ]
  %and52 = and i32 %22, 65536
  %tobool53 = icmp eq i32 %and52, 0
  %incdec.ptr144.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %tobool53, label %if.end143, label %if.then54

if.then54:                                        ; preds = %if.end50
  %24 = load %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  %sv_flags56 = getelementptr inbounds %struct.sv* %24, i64 0, i32 2
  %25 = load i32* %sv_flags56, align 4, !tbaa !4
  %and57 = and i32 %25, 16777216
  %tobool58 = icmp eq i32 %and57, 0
  br i1 %tobool58, label %land.lhs.true59, label %if.end83

land.lhs.true59:                                  ; preds = %if.then54
  %26 = and i32 %25, 393216
  %or.cond221.not = icmp ne i32 %26, 0
  %and72 = and i32 %25, 65536
  %tobool73 = icmp eq i32 %and72, 0
  %or.cond223 = and i1 %or.cond221.not, %tobool73
  br i1 %or.cond223, label %cond.false78, label %if.end83

cond.false78:                                     ; preds = %land.lhs.true59
  %call80 = tail call i64 @Perl_sv_2iv(%struct.sv* %24) #7
  %.pre225 = load %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  %sv_flags85.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre225, i64 0, i32 2
  %.pre226 = load i32* %sv_flags85.phi.trans.insert, align 4, !tbaa !4
  br label %if.end83

if.end83:                                         ; preds = %land.lhs.true59, %if.then54, %cond.false78
  %27 = phi i32 [ %25, %land.lhs.true59 ], [ %25, %if.then54 ], [ %.pre226, %cond.false78 ]
  %.pn218.pre = phi %struct.sv* [ %24, %land.lhs.true59 ], [ %24, %if.then54 ], [ %.pre225, %cond.false78 ]
  %and86 = and i32 %27, 65536
  %tobool87 = icmp eq i32 %and86, 0
  br i1 %tobool87, label %if.end83.if.end143_crit_edge, label %if.then88

if.end83.if.end143_crit_edge:                     ; preds = %if.end83
  %.pre227 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags145.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre227, i64 0, i32 2
  %.pre228 = load i32* %sv_flags145.phi.trans.insert, align 4, !tbaa !4
  br label %if.end143

if.then88:                                        ; preds = %if.end83
  %and91 = and i32 %27, -2147418112
  %cmp92 = icmp eq i32 %and91, -2147418112
  %28 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags94 = getelementptr inbounds %struct.sv* %28, i64 0, i32 2
  %29 = load i32* %sv_flags94, align 4, !tbaa !4
  %and95 = and i32 %29, -2147418112
  %cmp96 = icmp eq i32 %and95, -2147418112
  %cmp101tmp = xor i1 %cmp92, %cmp96
  br i1 %cmp101tmp, label %if.end112, label %if.then103

if.then103:                                       ; preds = %if.then88
  %sv_any105 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %30 = load i8** %sv_any105, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %30, i64 24
  %31 = bitcast i8* %xuv_uv to i64*
  %32 = load i64* %31, align 8, !tbaa !3
  %sv_any106 = getelementptr inbounds %struct.sv* %.pn218.pre, i64 0, i32 0
  %33 = load i8** %sv_any106, align 8, !tbaa !0
  %xuv_uv107 = getelementptr inbounds i8* %33, i64 24
  %34 = bitcast i8* %xuv_uv107 to i64*
  %35 = load i64* %34, align 8, !tbaa !3
  %cmp108 = icmp ne i64 %35, %32
  %cond110 = select i1 %cmp108, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond110, %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr144.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %36 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next111 = getelementptr inbounds %struct.op* %36, i64 0, i32 0
  br label %return

if.end112:                                        ; preds = %if.then88
  br i1 %cmp92, label %if.then114, label %if.else

if.then114:                                       ; preds = %if.end112
  %sv_any115 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %37 = load i8** %sv_any115, align 8, !tbaa !0
  %xiv_iv116 = getelementptr inbounds i8* %37, i64 24
  %38 = bitcast i8* %xiv_iv116 to i64*
  %39 = load i64* %38, align 8, !tbaa !3
  %cmp118 = icmp slt i64 %39, 0
  br i1 %cmp118, label %if.then120, label %if.end137

if.then120:                                       ; preds = %if.then114
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr144.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %40 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next121 = getelementptr inbounds %struct.op* %40, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %if.end112
  %sv_any126 = getelementptr inbounds %struct.sv* %.pn218.pre, i64 0, i32 0
  %41 = load i8** %sv_any126, align 8, !tbaa !0
  %xiv_iv127 = getelementptr inbounds i8* %41, i64 24
  %42 = bitcast i8* %xiv_iv127 to i64*
  %43 = load i64* %42, align 8, !tbaa !3
  %cmp129 = icmp slt i64 %43, 0
  br i1 %cmp129, label %if.then131, label %if.end137

if.then131:                                       ; preds = %if.else
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr144.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %44 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next132 = getelementptr inbounds %struct.op* %44, i64 0, i32 0
  br label %return

if.end137:                                        ; preds = %if.then114, %if.else
  %.pn218 = phi %struct.sv* [ %28, %if.else ], [ %.pn218.pre, %if.then114 ]
  %iv.0 = phi i64 [ %43, %if.else ], [ %39, %if.then114 ]
  %.pn.in = getelementptr inbounds %struct.sv* %.pn218, i64 0, i32 0
  %.pn = load i8** %.pn.in, align 8
  %uv.0.in.in = getelementptr inbounds i8* %.pn, i64 24
  %uv.0.in = bitcast i8* %uv.0.in.in to i64*
  %uv.0 = load i64* %uv.0.in, align 8
  %cmp138 = icmp ne i64 %iv.0, %uv.0
  %cond140 = select i1 %cmp138, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond140, %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr144.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %45 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next141 = getelementptr inbounds %struct.op* %45, i64 0, i32 0
  br label %return

if.end143:                                        ; preds = %if.end50, %if.end83.if.end143_crit_edge
  %46 = phi i32 [ %.pre228, %if.end83.if.end143_crit_edge ], [ %22, %if.end50 ]
  %47 = phi %struct.sv* [ %.pre227, %if.end83.if.end143_crit_edge ], [ %23, %if.end50 ]
  store %struct.sv* %47, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and146 = and i32 %46, 131072
  %tobool147 = icmp eq i32 %and146, 0
  br i1 %tobool147, label %cond.false150, label %cond.true148

cond.true148:                                     ; preds = %if.end143
  %sv_any149 = getelementptr inbounds %struct.sv* %47, i64 0, i32 0
  %48 = load i8** %sv_any149, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %48, i64 32
  %49 = bitcast i8* %xnv_nv to double*
  %50 = load double* %49, align 8, !tbaa !6
  br label %cond.end152

cond.false150:                                    ; preds = %if.end143
  %call151 = tail call double @Perl_sv_2nv(%struct.sv* %47) #7
  br label %cond.end152

cond.end152:                                      ; preds = %cond.false150, %cond.true148
  %cond153 = phi double [ %50, %cond.true148 ], [ %call151, %cond.false150 ]
  %51 = load %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  %sv_flags154 = getelementptr inbounds %struct.sv* %51, i64 0, i32 2
  %52 = load i32* %sv_flags154, align 4, !tbaa !4
  %and155 = and i32 %52, 131072
  %tobool156 = icmp eq i32 %and155, 0
  br i1 %tobool156, label %cond.false160, label %cond.true157

cond.true157:                                     ; preds = %cond.end152
  %sv_any158 = getelementptr inbounds %struct.sv* %51, i64 0, i32 0
  %53 = load i8** %sv_any158, align 8, !tbaa !0
  %xnv_nv159 = getelementptr inbounds i8* %53, i64 32
  %54 = bitcast i8* %xnv_nv159 to double*
  %55 = load double* %54, align 8, !tbaa !6
  br label %cond.end162

cond.false160:                                    ; preds = %cond.end152
  %call161 = tail call double @Perl_sv_2nv(%struct.sv* %51) #7
  br label %cond.end162

cond.end162:                                      ; preds = %cond.false160, %cond.true157
  %cond163 = phi double [ %55, %cond.true157 ], [ %call161, %cond.false160 ]
  %cmp164 = fcmp une double %cond163, %cond153
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond166, %struct.sv** %incdec.ptr144.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr144.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %56 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next167 = getelementptr inbounds %struct.op* %56, i64 0, i32 0
  br label %return

return:                                           ; preds = %cond.end162, %if.end137, %if.then131, %if.then120, %if.then103, %if.then25, %if.then6
  %retval.0.in = phi %struct.op** [ %op_next, %if.then6 ], [ %op_next111, %if.then103 ], [ %op_next121, %if.then120 ], [ %op_next141, %if.end137 ], [ %op_next132, %if.then131 ], [ %op_next167, %cond.end162 ], [ %op_next30, %if.then25 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_ncmp() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end21, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %8, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end21, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 34, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end21, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !1
  %and7 = and i8 %12, 64
  %tobool8 = icmp eq i8 %and7, 0
  %sv_flags10 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  br i1 %tobool8, label %lor.lhs.false9, label %if.then13

lor.lhs.false9:                                   ; preds = %if.then6
  %13 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %13, 1024
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %if.end19, label %if.then13

if.then13:                                        ; preds = %if.then6, %lor.lhs.false9
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags10, align 4, !tbaa !4
  %and15 = and i32 %14, 16384
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then13
  %call18 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end19

if.end19:                                         ; preds = %lor.lhs.false9, %if.then17, %if.then13
  %storemerge = phi %struct.sv* [ %4, %if.then13 ], [ %4, %if.then17 ], [ %call, %lor.lhs.false9 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  br label %return

if.end21:                                         ; preds = %land.lhs.true, %entry, %lor.lhs.false
  %16 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags22 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags22, align 4, !tbaa !4
  %18 = and i32 %17, 268959744
  %19 = icmp eq i32 %18, 524288
  br i1 %19, label %land.lhs.true29, label %if.end56

land.lhs.true29:                                  ; preds = %if.end21
  %add.ptr30 = getelementptr inbounds %struct.sv** %0, i64 -1
  %20 = load %struct.sv** %add.ptr30, align 8, !tbaa !0
  %sv_flags31 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i32* %sv_flags31, align 4, !tbaa !4
  %22 = and i32 %21, 268959744
  %23 = icmp eq i32 %22, 524288
  br i1 %23, label %if.then39, label %if.end56

if.then39:                                        ; preds = %land.lhs.true29
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %24 = load i8** %sv_any, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %24 to %struct.sv**
  %25 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any43 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %26 = load i8** %sv_any43, align 8, !tbaa !0
  %xrv_rv44 = bitcast i8* %26 to %struct.sv**
  %27 = load %struct.sv** %xrv_rv44, align 8, !tbaa !0
  %cmp = icmp ugt %struct.sv* %27, %25
  %conv45 = zext i1 %cmp to i64
  %cmp46 = icmp ult %struct.sv* %27, %25
  %conv47 = zext i1 %cmp46 to i64
  %sub = sub i64 %conv45, %conv47
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %sub) #7
  %sv_flags49 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %28 = load i32* %sv_flags49, align 4, !tbaa !4
  %and50 = and i32 %28, 16384
  %tobool51 = icmp eq i32 %and50, 0
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %if.then39
  %call53 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end54

if.end54:                                         ; preds = %if.then39, %if.then52
  store %struct.sv* %4, %struct.sv** %add.ptr30, align 8, !tbaa !0
  store %struct.sv** %add.ptr30, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %29 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next55 = getelementptr inbounds %struct.op* %29, i64 0, i32 0
  br label %return

if.end56:                                         ; preds = %land.lhs.true29, %if.end21
  %and58 = and i32 %17, 16777216
  %tobool59 = icmp eq i32 %and58, 0
  br i1 %tobool59, label %land.lhs.true60, label %if.end74

land.lhs.true60:                                  ; preds = %if.end56
  %30 = and i32 %17, 393216
  %or.cond373.not = icmp ne i32 %30, 0
  %and70 = and i32 %17, 65536
  %tobool71 = icmp eq i32 %and70, 0
  %or.cond379 = and i1 %or.cond373.not, %tobool71
  br i1 %or.cond379, label %cond.false, label %if.end74

cond.false:                                       ; preds = %land.lhs.true60
  %call73 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags75.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre381 = load i32* %sv_flags75.phi.trans.insert, align 4, !tbaa !4
  br label %if.end74

if.end74:                                         ; preds = %land.lhs.true60, %if.end56, %cond.false
  %31 = phi i32 [ %17, %land.lhs.true60 ], [ %17, %if.end56 ], [ %.pre381, %cond.false ]
  %32 = phi %struct.sv* [ %16, %land.lhs.true60 ], [ %16, %if.end56 ], [ %.pre, %cond.false ]
  %and76 = and i32 %31, 65536
  %tobool77 = icmp eq i32 %and76, 0
  %incdec.ptr227.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br i1 %tobool77, label %if.end225, label %if.then78

if.then78:                                        ; preds = %if.end74
  %33 = load %struct.sv** %incdec.ptr227.pre, align 8, !tbaa !0
  %sv_flags80 = getelementptr inbounds %struct.sv* %33, i64 0, i32 2
  %34 = load i32* %sv_flags80, align 4, !tbaa !4
  %and81 = and i32 %34, 16777216
  %tobool82 = icmp eq i32 %and81, 0
  br i1 %tobool82, label %land.lhs.true83, label %if.end107

land.lhs.true83:                                  ; preds = %if.then78
  %35 = and i32 %34, 393216
  %or.cond374.not = icmp ne i32 %35, 0
  %and96 = and i32 %34, 65536
  %tobool97 = icmp eq i32 %and96, 0
  %or.cond380 = and i1 %or.cond374.not, %tobool97
  br i1 %or.cond380, label %cond.false102, label %if.end107

cond.false102:                                    ; preds = %land.lhs.true83
  %call104 = tail call i64 @Perl_sv_2iv(%struct.sv* %33) #7
  %.pre382 = load %struct.sv** %incdec.ptr227.pre, align 8, !tbaa !0
  %sv_flags109.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre382, i64 0, i32 2
  %.pre383 = load i32* %sv_flags109.phi.trans.insert, align 4, !tbaa !4
  br label %if.end107

if.end107:                                        ; preds = %land.lhs.true83, %if.then78, %cond.false102
  %36 = phi i32 [ %34, %land.lhs.true83 ], [ %34, %if.then78 ], [ %.pre383, %cond.false102 ]
  %37 = phi %struct.sv* [ %33, %land.lhs.true83 ], [ %33, %if.then78 ], [ %.pre382, %cond.false102 ]
  %and110 = and i32 %36, 65536
  %tobool111 = icmp eq i32 %and110, 0
  br i1 %tobool111, label %if.end107.if.end225_crit_edge, label %if.then112

if.end107.if.end225_crit_edge:                    ; preds = %if.end107
  %.pre384 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags228.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre384, i64 0, i32 2
  %.pre385 = load i32* %sv_flags228.phi.trans.insert, align 4, !tbaa !4
  br label %if.end225

if.then112:                                       ; preds = %if.end107
  %and115 = and i32 %36, -2147418112
  %cmp116 = icmp eq i32 %and115, -2147418112
  %38 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags119 = getelementptr inbounds %struct.sv* %38, i64 0, i32 2
  %39 = load i32* %sv_flags119, align 4, !tbaa !4
  %and120 = and i32 %39, -2147418112
  %cmp121 = icmp eq i32 %and120, -2147418112
  %brmerge = or i1 %cmp116, %cmp121
  br i1 %brmerge, label %if.else143, label %if.then127

if.then127:                                       ; preds = %if.then112
  %sv_any129 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %40 = load i8** %sv_any129, align 8, !tbaa !0
  %xiv_iv130 = getelementptr inbounds i8* %40, i64 24
  %41 = bitcast i8* %xiv_iv130 to i64*
  %42 = load i64* %41, align 8, !tbaa !3
  %sv_any131 = getelementptr inbounds %struct.sv* %38, i64 0, i32 0
  %43 = load i8** %sv_any131, align 8, !tbaa !0
  %xiv_iv132 = getelementptr inbounds i8* %43, i64 24
  %44 = bitcast i8* %xiv_iv132 to i64*
  %45 = load i64* %44, align 8, !tbaa !3
  %cmp133 = icmp sgt i64 %42, %45
  br i1 %cmp133, label %if.end214, label %if.else136

if.else136:                                       ; preds = %if.then127
  %cmp137 = icmp slt i64 %42, %45
  %. = sext i1 %cmp137 to i64
  br label %if.end214

if.else143:                                       ; preds = %if.then112
  %46 = and i32 %and115, %39
  %brmerge375 = icmp eq i32 %46, -2147418112
  br i1 %brmerge375, label %if.then149, label %if.else164

if.then149:                                       ; preds = %if.else143
  %sv_any151 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %47 = load i8** %sv_any151, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %47, i64 24
  %48 = bitcast i8* %xuv_uv to i64*
  %49 = load i64* %48, align 8, !tbaa !3
  %sv_any152 = getelementptr inbounds %struct.sv* %38, i64 0, i32 0
  %50 = load i8** %sv_any152, align 8, !tbaa !0
  %xuv_uv153 = getelementptr inbounds i8* %50, i64 24
  %51 = bitcast i8* %xuv_uv153 to i64*
  %52 = load i64* %51, align 8, !tbaa !3
  %cmp154 = icmp ugt i64 %49, %52
  br i1 %cmp154, label %if.end214, label %if.else157

if.else157:                                       ; preds = %if.then149
  %cmp158 = icmp ult i64 %49, %52
  %.376 = sext i1 %cmp158 to i64
  br label %if.end214

if.else164:                                       ; preds = %if.else143
  br i1 %cmp116, label %if.then166, label %if.else189

if.then166:                                       ; preds = %if.else164
  %sv_any169 = getelementptr inbounds %struct.sv* %38, i64 0, i32 0
  %53 = load i8** %sv_any169, align 8, !tbaa !0
  %xiv_iv170 = getelementptr inbounds i8* %53, i64 24
  %54 = bitcast i8* %xiv_iv170 to i64*
  %55 = load i64* %54, align 8, !tbaa !3
  %cmp171 = icmp slt i64 %55, 0
  br i1 %cmp171, label %if.end214, label %if.else174

if.else174:                                       ; preds = %if.then166
  %sv_any176 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %56 = load i8** %sv_any176, align 8, !tbaa !0
  %xuv_uv177 = getelementptr inbounds i8* %56, i64 24
  %57 = bitcast i8* %xuv_uv177 to i64*
  %58 = load i64* %57, align 8, !tbaa !3
  %cmp178 = icmp ugt i64 %58, %55
  br i1 %cmp178, label %if.end214, label %if.else181

if.else181:                                       ; preds = %if.else174
  %cmp182 = icmp ult i64 %58, %55
  %.377 = sext i1 %cmp182 to i64
  br label %if.end214

if.else189:                                       ; preds = %if.else164
  %sv_any193 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %59 = load i8** %sv_any193, align 8, !tbaa !0
  %xiv_iv194 = getelementptr inbounds i8* %59, i64 24
  %60 = bitcast i8* %xiv_iv194 to i64*
  %61 = load i64* %60, align 8, !tbaa !3
  %cmp195 = icmp slt i64 %61, 0
  br i1 %cmp195, label %if.end214, label %if.else198

if.else198:                                       ; preds = %if.else189
  %sv_any199 = getelementptr inbounds %struct.sv* %38, i64 0, i32 0
  %62 = load i8** %sv_any199, align 8, !tbaa !0
  %xuv_uv200 = getelementptr inbounds i8* %62, i64 24
  %63 = bitcast i8* %xuv_uv200 to i64*
  %64 = load i64* %63, align 8, !tbaa !3
  %cmp201 = icmp ugt i64 %61, %64
  br i1 %cmp201, label %if.end214, label %if.else204

if.else204:                                       ; preds = %if.else198
  %cmp205 = icmp ult i64 %61, %64
  %.378 = sext i1 %cmp205 to i64
  br label %if.end214

if.end214:                                        ; preds = %if.else204, %if.else198, %if.else189, %if.else181, %if.else174, %if.then166, %if.else157, %if.then149, %if.else136, %if.then127
  %value.0 = phi i64 [ 1, %if.then127 ], [ %., %if.else136 ], [ 1, %if.then149 ], [ %.376, %if.else157 ], [ 1, %if.then166 ], [ 1, %if.else174 ], [ %.377, %if.else181 ], [ -1, %if.else189 ], [ 1, %if.else198 ], [ %.378, %if.else204 ]
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %value.0) #7
  %sv_flags217 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %65 = load i32* %sv_flags217, align 4, !tbaa !4
  %and218 = and i32 %65, 16384
  %tobool219 = icmp eq i32 %and218, 0
  br i1 %tobool219, label %if.end222, label %if.then220

if.then220:                                       ; preds = %if.end214
  %call221 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end222

if.end222:                                        ; preds = %if.end214, %if.then220
  store %struct.sv* %4, %struct.sv** %incdec.ptr227.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr227.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %66 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next223 = getelementptr inbounds %struct.op* %66, i64 0, i32 0
  br label %return

if.end225:                                        ; preds = %if.end74, %if.end107.if.end225_crit_edge
  %67 = phi i32 [ %.pre385, %if.end107.if.end225_crit_edge ], [ %31, %if.end74 ]
  %68 = phi %struct.sv* [ %.pre384, %if.end107.if.end225_crit_edge ], [ %32, %if.end74 ]
  store %struct.sv* %68, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %and229 = and i32 %67, 131072
  %tobool230 = icmp eq i32 %and229, 0
  br i1 %tobool230, label %cond.false233, label %cond.true231

cond.true231:                                     ; preds = %if.end225
  %sv_any232 = getelementptr inbounds %struct.sv* %68, i64 0, i32 0
  %69 = load i8** %sv_any232, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %69, i64 32
  %70 = bitcast i8* %xnv_nv to double*
  %71 = load double* %70, align 8, !tbaa !6
  br label %cond.end235

cond.false233:                                    ; preds = %if.end225
  %call234 = tail call double @Perl_sv_2nv(%struct.sv* %68) #7
  br label %cond.end235

cond.end235:                                      ; preds = %cond.false233, %cond.true231
  %cond236 = phi double [ %71, %cond.true231 ], [ %call234, %cond.false233 ]
  %72 = load %struct.sv** %incdec.ptr227.pre, align 8, !tbaa !0
  %sv_flags238 = getelementptr inbounds %struct.sv* %72, i64 0, i32 2
  %73 = load i32* %sv_flags238, align 4, !tbaa !4
  %and239 = and i32 %73, 131072
  %tobool240 = icmp eq i32 %and239, 0
  br i1 %tobool240, label %cond.false244, label %cond.true241

cond.true241:                                     ; preds = %cond.end235
  %sv_any242 = getelementptr inbounds %struct.sv* %72, i64 0, i32 0
  %74 = load i8** %sv_any242, align 8, !tbaa !0
  %xnv_nv243 = getelementptr inbounds i8* %74, i64 32
  %75 = bitcast i8* %xnv_nv243 to double*
  %76 = load double* %75, align 8, !tbaa !6
  br label %cond.end246

cond.false244:                                    ; preds = %cond.end235
  %call245 = tail call double @Perl_sv_2nv(%struct.sv* %72) #7
  br label %cond.end246

cond.end246:                                      ; preds = %cond.false244, %cond.true241
  %cond247 = phi double [ %76, %cond.true241 ], [ %call245, %cond.false244 ]
  %call255 = tail call i32 @__isnan(double %cond247) #7
  %tobool256 = icmp eq i32 %call255, 0
  br i1 %tobool256, label %cond.true267, label %if.then274

cond.true267:                                     ; preds = %cond.end246
  %call268 = tail call i32 @__isnan(double %cond236) #7
  %tobool269 = icmp eq i32 %call268, 0
  br i1 %tobool269, label %if.end276, label %if.then274

if.then274:                                       ; preds = %cond.true267, %cond.end246
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr227.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr227.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %77 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next275 = getelementptr inbounds %struct.op* %77, i64 0, i32 0
  br label %return

if.end276:                                        ; preds = %cond.true267
  %cmp277 = fcmp ogt double %cond247, %cond236
  %conv278 = zext i1 %cmp277 to i64
  %cmp279 = fcmp olt double %cond247, %cond236
  %conv280 = zext i1 %cmp279 to i64
  %sub281 = sub i64 %conv278, %conv280
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %sub281) #7
  %sv_flags283 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %78 = load i32* %sv_flags283, align 4, !tbaa !4
  %and284 = and i32 %78, 16384
  %tobool285 = icmp eq i32 %and284, 0
  br i1 %tobool285, label %if.end288, label %if.then286

if.then286:                                       ; preds = %if.end276
  %call287 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end288

if.end288:                                        ; preds = %if.end276, %if.then286
  store %struct.sv* %4, %struct.sv** %incdec.ptr227.pre, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr227.pre, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %79 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next289 = getelementptr inbounds %struct.op* %79, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end288, %if.then274, %if.end222, %if.end54, %if.end19
  %retval.0.in = phi %struct.op** [ %op_next, %if.end19 ], [ %op_next223, %if.end222 ], [ %op_next275, %if.then274 ], [ %op_next289, %if.end288 ], [ %op_next55, %if.end54 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i32 @__isnan(double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_slt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 36, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %8 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %call11 = tail call i32 @Perl_sv_cmp(%struct.sv* %8, %struct.sv* %7) #7
  %cmp12 = icmp slt i32 %call11, 0
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %if.end7 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i32 @Perl_sv_cmp(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sgt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 38, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %8 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %call11 = tail call i32 @Perl_sv_cmp(%struct.sv* %8, %struct.sv* %7) #7
  %cmp12 = icmp sgt i32 %call11, 0
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %if.end7 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sle() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 37, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %8 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %call11 = tail call i32 @Perl_sv_cmp(%struct.sv* %8, %struct.sv* %7) #7
  %cmp12 = icmp slt i32 %call11, 1
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %if.end7 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sge() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 39, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %8 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %call11 = tail call i32 @Perl_sv_cmp(%struct.sv* %8, %struct.sv* %7) #7
  %cmp12 = icmp sgt i32 %call11, -1
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %if.end7 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_seq() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 40, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %8 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %call11 = tail call i32 @Perl_sv_eq(%struct.sv* %8, %struct.sv* %7) #7
  %tobool12 = icmp ne i32 %call11, 0
  %cond = select i1 %tobool12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %if.end7 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i32 @Perl_sv_eq(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sne() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 41, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  %8 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %call11 = tail call i32 @Perl_sv_eq(%struct.sv* %8, %struct.sv* %7) #7
  %lnot = icmp eq i32 %call11, 0
  %cond = select i1 %lnot, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end7, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %if.end7 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_scmp() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %entry.if.end21_crit_edge, label %if.then

entry.if.end21_crit_edge:                         ; preds = %entry
  %incdec.ptr23.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %8, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end21, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 35, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end21, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !1
  %and7 = and i8 %12, 64
  %tobool8 = icmp eq i8 %and7, 0
  %sv_flags10 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  br i1 %tobool8, label %lor.lhs.false9, label %if.then13

lor.lhs.false9:                                   ; preds = %if.then6
  %13 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %13, 1024
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %if.end19, label %if.then13

if.then13:                                        ; preds = %if.then6, %lor.lhs.false9
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags10, align 4, !tbaa !4
  %and15 = and i32 %14, 16384
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then13
  %call18 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end19

if.end19:                                         ; preds = %lor.lhs.false9, %if.then17, %if.then13
  %storemerge = phi %struct.sv* [ %4, %if.then13 ], [ %4, %if.then17 ], [ %call, %lor.lhs.false9 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end21:                                         ; preds = %land.lhs.true, %entry.if.end21_crit_edge, %lor.lhs.false
  %incdec.ptr23.pre-phi = phi %struct.sv** [ %incdec.ptr23.pre, %entry.if.end21_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  %16 = load %struct.sv** %incdec.ptr23.pre-phi, align 8, !tbaa !0
  %call25 = tail call i32 @Perl_sv_cmp(%struct.sv* %16, %struct.sv* %15) #7
  %conv26 = sext i32 %call25 to i64
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %conv26) #7
  %sv_flags27 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %17 = load i32* %sv_flags27, align 4, !tbaa !4
  %and28 = and i32 %17, 16384
  %tobool29 = icmp eq i32 %and28, 0
  br i1 %tobool29, label %if.end32, label %if.then30

if.then30:                                        ; preds = %if.end21
  %call31 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end32

if.end32:                                         ; preds = %if.end21, %if.then30
  store %struct.sv* %4, %struct.sv** %incdec.ptr23.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end32, %if.end19
  %storemerge54 = phi %struct.sv** [ %incdec.ptr, %if.end19 ], [ %incdec.ptr23.pre-phi, %if.end32 ]
  store %struct.sv** %storemerge54, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_bit_and() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 22, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  %16 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags35 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags35, align 4, !tbaa !4
  %and36 = and i32 %17, 50331648
  %tobool37 = icmp eq i32 %and36, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then42

lor.lhs.false38:                                  ; preds = %if.end31
  %sv_flags39 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %18 = load i32* %sv_flags39, align 4, !tbaa !4
  %and40 = and i32 %18, 50331648
  %tobool41 = icmp eq i32 %and40, 0
  br i1 %tobool41, label %if.else100, label %if.then42

if.then42:                                        ; preds = %lor.lhs.false38, %if.end31
  %19 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %19, i64 0, i32 7
  %20 = load i8* %op_private, align 1, !tbaa !1
  %and44 = and i8 %20, 1
  %tobool45 = icmp eq i8 %and44, 0
  %and48 = and i32 %17, 65536
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool45, label %if.else72, label %if.then46

if.then46:                                        ; preds = %if.then42
  br i1 %tobool49, label %cond.true50, label %cond.false51

cond.true50:                                      ; preds = %if.then46
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %21 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %21, i64 24
  %22 = bitcast i8* %xiv_iv to i64*
  %23 = load i64* %22, align 8, !tbaa !3
  br label %cond.end53

cond.false51:                                     ; preds = %if.then46
  %call52 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false51, %cond.true50
  %cond54 = phi i64 [ %23, %cond.true50 ], [ %call52, %cond.false51 ]
  %sv_flags55 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %24 = load i32* %sv_flags55, align 4, !tbaa !4
  %and56 = and i32 %24, 65536
  %tobool57 = icmp eq i32 %and56, 0
  br i1 %tobool57, label %cond.false61, label %cond.true58

cond.true58:                                      ; preds = %cond.end53
  %sv_any59 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %25 = load i8** %sv_any59, align 8, !tbaa !0
  %xiv_iv60 = getelementptr inbounds i8* %25, i64 24
  %26 = bitcast i8* %xiv_iv60 to i64*
  %27 = load i64* %26, align 8, !tbaa !3
  br label %cond.end63

cond.false61:                                     ; preds = %cond.end53
  %call62 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end63

cond.end63:                                       ; preds = %cond.false61, %cond.true58
  %cond64 = phi i64 [ %27, %cond.true58 ], [ %call62, %cond.false61 ]
  %and65 = and i64 %cond64, %cond54
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %and65) #7
  %sv_flags66 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %28 = load i32* %sv_flags66, align 4, !tbaa !4
  %and67 = and i32 %28, 16384
  %tobool68 = icmp eq i32 %and67, 0
  br i1 %tobool68, label %if.end71, label %if.then69

if.then69:                                        ; preds = %cond.end63
  %call70 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end71

if.end71:                                         ; preds = %cond.end63, %if.then69
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

if.else72:                                        ; preds = %if.then42
  br i1 %tobool49, label %cond.true76, label %cond.false78

cond.true76:                                      ; preds = %if.else72
  %sv_any77 = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %29 = load i8** %sv_any77, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %29, i64 24
  %30 = bitcast i8* %xuv_uv to i64*
  %31 = load i64* %30, align 8, !tbaa !3
  br label %cond.end80

cond.false78:                                     ; preds = %if.else72
  %call79 = tail call i64 @Perl_sv_2uv(%struct.sv* %16) #7
  br label %cond.end80

cond.end80:                                       ; preds = %cond.false78, %cond.true76
  %cond81 = phi i64 [ %31, %cond.true76 ], [ %call79, %cond.false78 ]
  %sv_flags82 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %32 = load i32* %sv_flags82, align 4, !tbaa !4
  %and83 = and i32 %32, 65536
  %tobool84 = icmp eq i32 %and83, 0
  br i1 %tobool84, label %cond.false88, label %cond.true85

cond.true85:                                      ; preds = %cond.end80
  %sv_any86 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %33 = load i8** %sv_any86, align 8, !tbaa !0
  %xuv_uv87 = getelementptr inbounds i8* %33, i64 24
  %34 = bitcast i8* %xuv_uv87 to i64*
  %35 = load i64* %34, align 8, !tbaa !3
  br label %cond.end90

cond.false88:                                     ; preds = %cond.end80
  %call89 = tail call i64 @Perl_sv_2uv(%struct.sv* %15) #7
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false88, %cond.true85
  %cond91 = phi i64 [ %35, %cond.true85 ], [ %call89, %cond.false88 ]
  %and92 = and i64 %cond91, %cond81
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %and92) #7
  %sv_flags93 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %36 = load i32* %sv_flags93, align 4, !tbaa !4
  %and94 = and i32 %36, 16384
  %tobool95 = icmp eq i32 %and94, 0
  br i1 %tobool95, label %if.end98, label %if.then96

if.then96:                                        ; preds = %cond.end90
  %call97 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end98

if.end98:                                         ; preds = %cond.end90, %if.then96
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

if.else100:                                       ; preds = %lor.lhs.false38
  %37 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_type = getelementptr inbounds %struct.op* %37, i64 0, i32 4
  %38 = load i16* %op_type, align 2, !tbaa !5
  %conv101 = zext i16 %38 to i32
  tail call void @Perl_do_vop(i32 %conv101, %struct.sv* %cond, %struct.sv* %16, %struct.sv* %15) #7
  %sv_flags102 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %39 = load i32* %sv_flags102, align 4, !tbaa !4
  %and103 = and i32 %39, 16384
  %tobool104 = icmp eq i32 %and103, 0
  br i1 %tobool104, label %if.end107, label %if.then105

if.then105:                                       ; preds = %if.else100
  %call106 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end107

if.end107:                                        ; preds = %if.else100, %if.then105
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end107, %if.end98, %if.end71, %if.end29
  %storemerge149 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr33.pre-phi, %if.end71 ], [ %incdec.ptr33.pre-phi, %if.end98 ], [ %incdec.ptr33.pre-phi, %if.end107 ]
  store %struct.sv** %storemerge149, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_do_vop(i32, %struct.sv*, %struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_bit_xor() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 26, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  %16 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags35 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags35, align 4, !tbaa !4
  %and36 = and i32 %17, 50331648
  %tobool37 = icmp eq i32 %and36, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then42

lor.lhs.false38:                                  ; preds = %if.end31
  %sv_flags39 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %18 = load i32* %sv_flags39, align 4, !tbaa !4
  %and40 = and i32 %18, 50331648
  %tobool41 = icmp eq i32 %and40, 0
  br i1 %tobool41, label %if.else131, label %if.then42

if.then42:                                        ; preds = %lor.lhs.false38, %if.end31
  %19 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %19, i64 0, i32 7
  %20 = load i8* %op_private, align 1, !tbaa !1
  %and44 = and i8 %20, 1
  %tobool45 = icmp eq i8 %and44, 0
  %21 = and i32 %17, 118431744
  %22 = icmp eq i32 %21, 0
  br i1 %tobool45, label %if.else87, label %if.then46

if.then46:                                        ; preds = %if.then42
  br i1 %22, label %lor.lhs.false54, label %cond.true59

lor.lhs.false54:                                  ; preds = %if.then46
  %op_flags55 = getelementptr inbounds %struct.op* %19, i64 0, i32 6
  %23 = load i8* %op_flags55, align 1, !tbaa !1
  %and57 = and i8 %23, 64
  %tobool58 = icmp eq i8 %and57, 0
  br i1 %tobool58, label %cond.true59, label %cond.end69

cond.true59:                                      ; preds = %if.then46, %lor.lhs.false54
  %and61 = and i32 %17, 65536
  %tobool62 = icmp eq i32 %and61, 0
  br i1 %tobool62, label %cond.false64, label %cond.true63

cond.true63:                                      ; preds = %cond.true59
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %24 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end69

cond.false64:                                     ; preds = %cond.true59
  %call65 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  br label %cond.end69

cond.end69:                                       ; preds = %lor.lhs.false54, %cond.true63, %cond.false64
  %cond70 = phi i64 [ %26, %cond.true63 ], [ %call65, %cond.false64 ], [ 0, %lor.lhs.false54 ]
  %sv_flags71 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %27 = load i32* %sv_flags71, align 4, !tbaa !4
  %and72 = and i32 %27, 65536
  %tobool73 = icmp eq i32 %and72, 0
  br i1 %tobool73, label %cond.false77, label %cond.true74

cond.true74:                                      ; preds = %cond.end69
  %sv_any75 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %28 = load i8** %sv_any75, align 8, !tbaa !0
  %xiv_iv76 = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xiv_iv76 to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  br label %cond.end79

cond.false77:                                     ; preds = %cond.end69
  %call78 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end79

cond.end79:                                       ; preds = %cond.false77, %cond.true74
  %cond80 = phi i64 [ %30, %cond.true74 ], [ %call78, %cond.false77 ]
  %xor = xor i64 %cond80, %cond70
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %xor) #7
  %sv_flags81 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %31 = load i32* %sv_flags81, align 4, !tbaa !4
  %and82 = and i32 %31, 16384
  %tobool83 = icmp eq i32 %and82, 0
  br i1 %tobool83, label %if.end86, label %if.then84

if.then84:                                        ; preds = %cond.end79
  %call85 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end86

if.end86:                                         ; preds = %cond.end79, %if.then84
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

if.else87:                                        ; preds = %if.then42
  br i1 %22, label %lor.lhs.false95, label %cond.true100

lor.lhs.false95:                                  ; preds = %if.else87
  %op_flags96 = getelementptr inbounds %struct.op* %19, i64 0, i32 6
  %32 = load i8* %op_flags96, align 1, !tbaa !1
  %and98 = and i8 %32, 64
  %tobool99 = icmp eq i8 %and98, 0
  br i1 %tobool99, label %cond.true100, label %cond.end111

cond.true100:                                     ; preds = %if.else87, %lor.lhs.false95
  %and102 = and i32 %17, 65536
  %tobool103 = icmp eq i32 %and102, 0
  br i1 %tobool103, label %cond.false106, label %cond.true104

cond.true104:                                     ; preds = %cond.true100
  %sv_any105 = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %33 = load i8** %sv_any105, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %33, i64 24
  %34 = bitcast i8* %xuv_uv to i64*
  %35 = load i64* %34, align 8, !tbaa !3
  br label %cond.end111

cond.false106:                                    ; preds = %cond.true100
  %call107 = tail call i64 @Perl_sv_2uv(%struct.sv* %16) #7
  br label %cond.end111

cond.end111:                                      ; preds = %lor.lhs.false95, %cond.true104, %cond.false106
  %cond112 = phi i64 [ %35, %cond.true104 ], [ %call107, %cond.false106 ], [ 0, %lor.lhs.false95 ]
  %sv_flags113 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %36 = load i32* %sv_flags113, align 4, !tbaa !4
  %and114 = and i32 %36, 65536
  %tobool115 = icmp eq i32 %and114, 0
  br i1 %tobool115, label %cond.false119, label %cond.true116

cond.true116:                                     ; preds = %cond.end111
  %sv_any117 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %37 = load i8** %sv_any117, align 8, !tbaa !0
  %xuv_uv118 = getelementptr inbounds i8* %37, i64 24
  %38 = bitcast i8* %xuv_uv118 to i64*
  %39 = load i64* %38, align 8, !tbaa !3
  br label %cond.end121

cond.false119:                                    ; preds = %cond.end111
  %call120 = tail call i64 @Perl_sv_2uv(%struct.sv* %15) #7
  br label %cond.end121

cond.end121:                                      ; preds = %cond.false119, %cond.true116
  %cond122 = phi i64 [ %39, %cond.true116 ], [ %call120, %cond.false119 ]
  %xor123 = xor i64 %cond122, %cond112
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %xor123) #7
  %sv_flags124 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %40 = load i32* %sv_flags124, align 4, !tbaa !4
  %and125 = and i32 %40, 16384
  %tobool126 = icmp eq i32 %and125, 0
  br i1 %tobool126, label %if.end129, label %if.then127

if.then127:                                       ; preds = %cond.end121
  %call128 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end129

if.end129:                                        ; preds = %cond.end121, %if.then127
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

if.else131:                                       ; preds = %lor.lhs.false38
  %41 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_type = getelementptr inbounds %struct.op* %41, i64 0, i32 4
  %42 = load i16* %op_type, align 2, !tbaa !5
  %conv132 = zext i16 %42 to i32
  tail call void @Perl_do_vop(i32 %conv132, %struct.sv* %cond, %struct.sv* %16, %struct.sv* %15) #7
  %sv_flags133 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %43 = load i32* %sv_flags133, align 4, !tbaa !4
  %and134 = and i32 %43, 16384
  %tobool135 = icmp eq i32 %and134, 0
  br i1 %tobool135, label %if.end138, label %if.then136

if.then136:                                       ; preds = %if.else131
  %call137 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end138

if.end138:                                        ; preds = %if.else131, %if.then136
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end138, %if.end129, %if.end86, %if.end29
  %storemerge185 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr33.pre-phi, %if.end86 ], [ %incdec.ptr33.pre-phi, %if.end129 ], [ %incdec.ptr33.pre-phi, %if.end138 ]
  store %struct.sv** %storemerge185, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_bit_or() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 24, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  %16 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags35 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags35, align 4, !tbaa !4
  %and36 = and i32 %17, 50331648
  %tobool37 = icmp eq i32 %and36, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then42

lor.lhs.false38:                                  ; preds = %if.end31
  %sv_flags39 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %18 = load i32* %sv_flags39, align 4, !tbaa !4
  %and40 = and i32 %18, 50331648
  %tobool41 = icmp eq i32 %and40, 0
  br i1 %tobool41, label %if.else131, label %if.then42

if.then42:                                        ; preds = %lor.lhs.false38, %if.end31
  %19 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %19, i64 0, i32 7
  %20 = load i8* %op_private, align 1, !tbaa !1
  %and44 = and i8 %20, 1
  %tobool45 = icmp eq i8 %and44, 0
  %21 = and i32 %17, 118431744
  %22 = icmp eq i32 %21, 0
  br i1 %tobool45, label %if.else87, label %if.then46

if.then46:                                        ; preds = %if.then42
  br i1 %22, label %lor.lhs.false54, label %cond.true59

lor.lhs.false54:                                  ; preds = %if.then46
  %op_flags55 = getelementptr inbounds %struct.op* %19, i64 0, i32 6
  %23 = load i8* %op_flags55, align 1, !tbaa !1
  %and57 = and i8 %23, 64
  %tobool58 = icmp eq i8 %and57, 0
  br i1 %tobool58, label %cond.true59, label %cond.end69

cond.true59:                                      ; preds = %if.then46, %lor.lhs.false54
  %and61 = and i32 %17, 65536
  %tobool62 = icmp eq i32 %and61, 0
  br i1 %tobool62, label %cond.false64, label %cond.true63

cond.true63:                                      ; preds = %cond.true59
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %24 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end69

cond.false64:                                     ; preds = %cond.true59
  %call65 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  br label %cond.end69

cond.end69:                                       ; preds = %lor.lhs.false54, %cond.true63, %cond.false64
  %cond70 = phi i64 [ %26, %cond.true63 ], [ %call65, %cond.false64 ], [ 0, %lor.lhs.false54 ]
  %sv_flags71 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %27 = load i32* %sv_flags71, align 4, !tbaa !4
  %and72 = and i32 %27, 65536
  %tobool73 = icmp eq i32 %and72, 0
  br i1 %tobool73, label %cond.false77, label %cond.true74

cond.true74:                                      ; preds = %cond.end69
  %sv_any75 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %28 = load i8** %sv_any75, align 8, !tbaa !0
  %xiv_iv76 = getelementptr inbounds i8* %28, i64 24
  %29 = bitcast i8* %xiv_iv76 to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  br label %cond.end79

cond.false77:                                     ; preds = %cond.end69
  %call78 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end79

cond.end79:                                       ; preds = %cond.false77, %cond.true74
  %cond80 = phi i64 [ %30, %cond.true74 ], [ %call78, %cond.false77 ]
  %or = or i64 %cond80, %cond70
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %or) #7
  %sv_flags81 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %31 = load i32* %sv_flags81, align 4, !tbaa !4
  %and82 = and i32 %31, 16384
  %tobool83 = icmp eq i32 %and82, 0
  br i1 %tobool83, label %if.end86, label %if.then84

if.then84:                                        ; preds = %cond.end79
  %call85 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end86

if.end86:                                         ; preds = %cond.end79, %if.then84
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

if.else87:                                        ; preds = %if.then42
  br i1 %22, label %lor.lhs.false95, label %cond.true100

lor.lhs.false95:                                  ; preds = %if.else87
  %op_flags96 = getelementptr inbounds %struct.op* %19, i64 0, i32 6
  %32 = load i8* %op_flags96, align 1, !tbaa !1
  %and98 = and i8 %32, 64
  %tobool99 = icmp eq i8 %and98, 0
  br i1 %tobool99, label %cond.true100, label %cond.end111

cond.true100:                                     ; preds = %if.else87, %lor.lhs.false95
  %and102 = and i32 %17, 65536
  %tobool103 = icmp eq i32 %and102, 0
  br i1 %tobool103, label %cond.false106, label %cond.true104

cond.true104:                                     ; preds = %cond.true100
  %sv_any105 = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %33 = load i8** %sv_any105, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %33, i64 24
  %34 = bitcast i8* %xuv_uv to i64*
  %35 = load i64* %34, align 8, !tbaa !3
  br label %cond.end111

cond.false106:                                    ; preds = %cond.true100
  %call107 = tail call i64 @Perl_sv_2uv(%struct.sv* %16) #7
  br label %cond.end111

cond.end111:                                      ; preds = %lor.lhs.false95, %cond.true104, %cond.false106
  %cond112 = phi i64 [ %35, %cond.true104 ], [ %call107, %cond.false106 ], [ 0, %lor.lhs.false95 ]
  %sv_flags113 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %36 = load i32* %sv_flags113, align 4, !tbaa !4
  %and114 = and i32 %36, 65536
  %tobool115 = icmp eq i32 %and114, 0
  br i1 %tobool115, label %cond.false119, label %cond.true116

cond.true116:                                     ; preds = %cond.end111
  %sv_any117 = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %37 = load i8** %sv_any117, align 8, !tbaa !0
  %xuv_uv118 = getelementptr inbounds i8* %37, i64 24
  %38 = bitcast i8* %xuv_uv118 to i64*
  %39 = load i64* %38, align 8, !tbaa !3
  br label %cond.end121

cond.false119:                                    ; preds = %cond.end111
  %call120 = tail call i64 @Perl_sv_2uv(%struct.sv* %15) #7
  br label %cond.end121

cond.end121:                                      ; preds = %cond.false119, %cond.true116
  %cond122 = phi i64 [ %39, %cond.true116 ], [ %call120, %cond.false119 ]
  %or123 = or i64 %cond122, %cond112
  tail call void @Perl_sv_setuv(%struct.sv* %cond, i64 %or123) #7
  %sv_flags124 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %40 = load i32* %sv_flags124, align 4, !tbaa !4
  %and125 = and i32 %40, 16384
  %tobool126 = icmp eq i32 %and125, 0
  br i1 %tobool126, label %if.end129, label %if.then127

if.then127:                                       ; preds = %cond.end121
  %call128 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end129

if.end129:                                        ; preds = %cond.end121, %if.then127
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

if.else131:                                       ; preds = %lor.lhs.false38
  %41 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_type = getelementptr inbounds %struct.op* %41, i64 0, i32 4
  %42 = load i16* %op_type, align 2, !tbaa !5
  %conv132 = zext i16 %42 to i32
  tail call void @Perl_do_vop(i32 %conv132, %struct.sv* %cond, %struct.sv* %16, %struct.sv* %15) #7
  %sv_flags133 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %43 = load i32* %sv_flags133, align 4, !tbaa !4
  %and134 = and i32 %43, 16384
  %tobool135 = icmp eq i32 %and134, 0
  br i1 %tobool135, label %if.end138, label %if.then136

if.then136:                                       ; preds = %if.else131
  %call137 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end138

if.end138:                                        ; preds = %if.else131, %if.then136
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end138, %if.end129, %if.end86, %if.end29
  %storemerge185 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr33.pre-phi, %if.end86 ], [ %incdec.ptr33.pre-phi, %if.end129 ], [ %incdec.ptr33.pre-phi, %if.end138 ]
  store %struct.sv** %storemerge185, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_negate() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 57, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %12 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags17, align 4, !tbaa !4
  %and19 = and i32 %13, 8192
  %tobool20 = icmp eq i32 %and19, 0
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end16
  %call22 = call i32 @Perl_mg_get(%struct.sv* %12) #7
  br label %if.end23

if.end23:                                         ; preds = %if.end16, %if.then21
  %and24 = and i32 %13, 65536
  %tobool25 = icmp ne i32 %and24, 0
  %and26 = and i32 %13, 50331648
  %cmp = icmp eq i32 %and26, 16777216
  %or.cond = or i1 %tobool25, %cmp
  %.pr = load i32* %sv_flags17, align 4, !tbaa !4
  br i1 %or.cond, label %oops_its_an_int, label %if.end82

oops_its_an_int:                                  ; preds = %if.end23, %if.end237, %if.end191
  %14 = phi i32 [ %48, %if.end191 ], [ %54, %if.end237 ], [ %.pr, %if.end23 ]
  %tobool30 = icmp slt i32 %14, 0
  %sv_any = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %15 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %15, i64 24
  %16 = bitcast i8* %xiv_iv to i64*
  %17 = load i64* %16, align 8, !tbaa !3
  %cmp32 = icmp eq i64 %17, -9223372036854775808
  br i1 %tobool30, label %if.then31, label %if.else58

if.then31:                                        ; preds = %oops_its_an_int
  br i1 %cmp32, label %if.then33, label %if.else43

if.then33:                                        ; preds = %if.then31
  call void @Perl_sv_setiv(%struct.sv* %4, i64 -9223372036854775808) #7
  %sv_flags36 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %18 = load i32* %sv_flags36, align 4, !tbaa !4
  %and37 = and i32 %18, 16384
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %if.end41, label %if.then39

if.then39:                                        ; preds = %if.then33
  %call40 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end41

if.end41:                                         ; preds = %if.then33, %if.then39
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %19 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next42 = getelementptr inbounds %struct.op* %19, i64 0, i32 0
  br label %return

if.else43:                                        ; preds = %if.then31
  %cmp45 = icmp sgt i64 %17, -1
  br i1 %cmp45, label %if.then46, label %if.end82

if.then46:                                        ; preds = %if.else43
  %sub = sub nsw i64 0, %17
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %sub) #7
  %sv_flags49 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %20 = load i32* %sv_flags49, align 4, !tbaa !4
  %and50 = and i32 %20, 16384
  %tobool51 = icmp eq i32 %and50, 0
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %if.then46
  %call53 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end54

if.end54:                                         ; preds = %if.then46, %if.then52
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %21 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next55 = getelementptr inbounds %struct.op* %21, i64 0, i32 0
  br label %return

if.else58:                                        ; preds = %oops_its_an_int
  br i1 %cmp32, label %if.else73, label %if.then62

if.then62:                                        ; preds = %if.else58
  %sub65 = sub nsw i64 0, %17
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %sub65) #7
  %sv_flags66 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %22 = load i32* %sv_flags66, align 4, !tbaa !4
  %and67 = and i32 %22, 16384
  %tobool68 = icmp eq i32 %and67, 0
  br i1 %tobool68, label %if.end71, label %if.then69

if.then69:                                        ; preds = %if.then62
  %call70 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end71

if.end71:                                         ; preds = %if.then62, %if.then69
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %23 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next72 = getelementptr inbounds %struct.op* %23, i64 0, i32 0
  br label %return

if.else73:                                        ; preds = %if.else58
  call void @Perl_sv_setuv(%struct.sv* %4, i64 -9223372036854775808) #7
  %sv_flags74 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %24 = load i32* %sv_flags74, align 4, !tbaa !4
  %and75 = and i32 %24, 16384
  %tobool76 = icmp eq i32 %and75, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.else73
  %call78 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end79

if.end79:                                         ; preds = %if.else73, %if.then77
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %25 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next80 = getelementptr inbounds %struct.op* %25, i64 0, i32 0
  br label %return

if.end82:                                         ; preds = %if.end23, %if.else43
  %26 = phi i32 [ %14, %if.else43 ], [ %.pr, %if.end23 ]
  %and84 = and i32 %26, 50331648
  %tobool85 = icmp eq i32 %and84, 0
  br i1 %tobool85, label %if.else99, label %if.then86

if.then86:                                        ; preds = %if.end82
  %and88 = and i32 %26, 131072
  %tobool89 = icmp eq i32 %and88, 0
  br i1 %tobool89, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then86
  %sv_any90 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %27 = load i8** %sv_any90, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %27, i64 32
  %28 = bitcast i8* %xnv_nv to double*
  %29 = load double* %28, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.then86
  %call91 = call double @Perl_sv_2nv(%struct.sv* %12) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %29, %cond.true ], [ %call91, %cond.false ]
  %sub92 = fsub double -0.000000e+00, %cond
  call void @Perl_sv_setnv(%struct.sv* %4, double %sub92) #7
  %sv_flags93 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %30 = load i32* %sv_flags93, align 4, !tbaa !4
  %and94 = and i32 %30, 16384
  %tobool95 = icmp eq i32 %and94, 0
  br i1 %tobool95, label %if.end98, label %if.then96

if.then96:                                        ; preds = %cond.end
  %call97 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end98

if.end98:                                         ; preds = %cond.end, %if.then96
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end282

if.else99:                                        ; preds = %if.end82
  %and101 = and i32 %26, 67108864
  %tobool102 = icmp eq i32 %and101, 0
  br i1 %tobool102, label %if.else263, label %if.then103

if.then103:                                       ; preds = %if.else99
  %and105 = and i32 %26, 262144
  %cmp106 = icmp eq i32 %and105, 0
  br i1 %cmp106, label %cond.false110, label %cond.true107

cond.true107:                                     ; preds = %if.then103
  %sv_any108 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %31 = load i8** %sv_any108, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %31, i64 8
  %32 = bitcast i8* %xpv_cur to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  store i64 %33, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %31 to i8**
  %34 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end112

cond.false110:                                    ; preds = %if.then103
  %call111 = call i8* @Perl_sv_2pv_flags(%struct.sv* %12, i64* %len, i32 2) #7
  br label %cond.end112

cond.end112:                                      ; preds = %cond.false110, %cond.true107
  %cond113 = phi i8* [ %34, %cond.true107 ], [ %call111, %cond.false110 ]
  %35 = load i8* %cond113, align 1, !tbaa !1
  %.off = add i8 %35, -65
  %36 = icmp ult i8 %.off, 26
  %.off393 = add i8 %35, -97
  %37 = icmp ult i8 %.off393, 26
  %or.cond395 = or i1 %36, %37
  br i1 %or.cond395, label %if.then132, label %lor.lhs.false128

lor.lhs.false128:                                 ; preds = %cond.end112
  switch i8 %35, label %if.else160 [
    i8 95, label %if.then132
    i8 43, label %if.then141
    i8 45, label %if.then141
  ]

if.then132:                                       ; preds = %lor.lhs.false128, %cond.end112
  call void @Perl_sv_setpvn(%struct.sv* %4, i8* getelementptr inbounds ([2 x i8]* @.str31, i64 0, i64 0), i64 1) #7
  call void @Perl_sv_catsv_flags(%struct.sv* %4, %struct.sv* %12, i32 2) #7
  br label %if.end256

if.then141:                                       ; preds = %lor.lhs.false128, %lor.lhs.false128
  call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %12, i32 2) #7
  %38 = load i8* %cond113, align 1, !tbaa !1
  %cmp143 = icmp eq i8 %38, 45
  %conv146 = select i1 %cmp143, i8 43, i8 45
  %sv_flags147 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %39 = load i32* %sv_flags147, align 4, !tbaa !4
  %and148 = and i32 %39, 10223616
  %cmp149 = icmp eq i32 %and148, 262144
  br i1 %cmp149, label %cond.true151, label %cond.false156

cond.true151:                                     ; preds = %if.then141
  %sv_any152 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %40 = load i8** %sv_any152, align 8, !tbaa !0
  %xpv_cur153 = getelementptr inbounds i8* %40, i64 8
  %41 = bitcast i8* %xpv_cur153 to i64*
  %42 = load i64* %41, align 8, !tbaa !3
  store i64 %42, i64* %len, align 8, !tbaa !3
  %xpv_pv155 = bitcast i8* %40 to i8**
  %43 = load i8** %xpv_pv155, align 8, !tbaa !0
  br label %cond.end158

cond.false156:                                    ; preds = %if.then141
  %call157 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %4, i64* %len, i32 2) #7
  br label %cond.end158

cond.end158:                                      ; preds = %cond.false156, %cond.true151
  %cond159 = phi i8* [ %43, %cond.true151 ], [ %call157, %cond.false156 ]
  store i8 %conv146, i8* %cond159, align 1, !tbaa !1
  br label %if.end256

if.else160:                                       ; preds = %lor.lhs.false128
  %44 = load i32* %sv_flags17, align 4, !tbaa !4
  %and162 = and i32 %44, 536870912
  %tobool163 = icmp eq i32 %and162, 0
  br i1 %tobool163, label %if.else214, label %land.lhs.true164

land.lhs.true164:                                 ; preds = %if.else160
  %45 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %45, i64 0, i32 7
  %46 = load i8* %op_private, align 1, !tbaa !1
  %and166 = and i8 %46, 8
  %tobool167 = icmp eq i8 %and166, 0
  br i1 %tobool167, label %if.then168, label %land.lhs.true164.if.else214_crit_edge

land.lhs.true164.if.else214_crit_edge:            ; preds = %land.lhs.true164
  %.pre397 = load i32* %sv_flags17, align 4, !tbaa !4
  br label %if.else214

if.then168:                                       ; preds = %land.lhs.true164
  %and170 = and i32 %44, 16777216
  %tobool171 = icmp eq i32 %and170, 0
  br i1 %tobool171, label %land.lhs.true172, label %if.end191

land.lhs.true172:                                 ; preds = %if.then168
  %47 = and i32 %44, 393216
  %or.cond389.not = icmp ne i32 %47, 0
  %and182 = and i32 %44, 65536
  %tobool183 = icmp eq i32 %and182, 0
  %or.cond391 = and i1 %or.cond389.not, %tobool183
  br i1 %or.cond391, label %cond.false187, label %if.end191

cond.false187:                                    ; preds = %land.lhs.true172
  %call188 = call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %if.end191

if.end191:                                        ; preds = %land.lhs.true172, %if.then168, %cond.false187
  %48 = load i32* %sv_flags17, align 4, !tbaa !4
  %and193 = and i32 %48, 65536
  %tobool194 = icmp eq i32 %and193, 0
  br i1 %tobool194, label %if.end196, label %oops_its_an_int

if.end196:                                        ; preds = %if.end191
  %and198 = and i32 %48, 131072
  %tobool199 = icmp eq i32 %and198, 0
  br i1 %tobool199, label %if.else212, label %cond.true204

cond.true204:                                     ; preds = %if.end196
  %sv_any205 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %49 = load i8** %sv_any205, align 8, !tbaa !0
  %xnv_nv206 = getelementptr inbounds i8* %49, i64 32
  %50 = bitcast i8* %xnv_nv206 to double*
  %51 = load double* %50, align 8, !tbaa !6
  %sub211 = fsub double -0.000000e+00, %51
  call void @Perl_sv_setnv(%struct.sv* %4, double %sub211) #7
  br label %if.end256

if.else212:                                       ; preds = %if.end196
  call void @Perl_sv_setpvn(%struct.sv* %4, i8* getelementptr inbounds ([2 x i8]* @.str31, i64 0, i64 0), i64 1) #7
  call void @Perl_sv_catsv_flags(%struct.sv* %4, %struct.sv* %12, i32 2) #7
  br label %if.end256

if.else214:                                       ; preds = %land.lhs.true164.if.else214_crit_edge, %if.else160
  %52 = phi i32 [ %.pre397, %land.lhs.true164.if.else214_crit_edge ], [ %44, %if.else160 ]
  %and216 = and i32 %52, 16777216
  %tobool217 = icmp eq i32 %and216, 0
  br i1 %tobool217, label %land.lhs.true218, label %if.end237

land.lhs.true218:                                 ; preds = %if.else214
  %53 = and i32 %52, 393216
  %or.cond390.not = icmp ne i32 %53, 0
  %and228 = and i32 %52, 65536
  %tobool229 = icmp eq i32 %and228, 0
  %or.cond392 = and i1 %or.cond390.not, %tobool229
  br i1 %or.cond392, label %cond.false233, label %if.end237

cond.false233:                                    ; preds = %land.lhs.true218
  %call234 = call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  %.pre = load i32* %sv_flags17, align 4, !tbaa !4
  br label %if.end237

if.end237:                                        ; preds = %land.lhs.true218, %if.else214, %cond.false233
  %54 = phi i32 [ %52, %land.lhs.true218 ], [ %52, %if.else214 ], [ %.pre, %cond.false233 ]
  %and239 = and i32 %54, 65536
  %tobool240 = icmp eq i32 %and239, 0
  br i1 %tobool240, label %if.end242, label %oops_its_an_int

if.end242:                                        ; preds = %if.end237
  %and244 = and i32 %54, 131072
  %tobool245 = icmp eq i32 %and244, 0
  br i1 %tobool245, label %cond.false249, label %cond.true246

cond.true246:                                     ; preds = %if.end242
  %sv_any247 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %55 = load i8** %sv_any247, align 8, !tbaa !0
  %xnv_nv248 = getelementptr inbounds i8* %55, i64 32
  %56 = bitcast i8* %xnv_nv248 to double*
  %57 = load double* %56, align 8, !tbaa !6
  br label %cond.end251

cond.false249:                                    ; preds = %if.end242
  %call250 = call double @Perl_sv_2nv(%struct.sv* %12) #7
  br label %cond.end251

cond.end251:                                      ; preds = %cond.false249, %cond.true246
  %cond252 = phi double [ %57, %cond.true246 ], [ %call250, %cond.false249 ]
  %sub253 = fsub double -0.000000e+00, %cond252
  call void @Perl_sv_setnv(%struct.sv* %4, double %sub253) #7
  br label %if.end256

if.end256:                                        ; preds = %cond.end158, %cond.true204, %if.else212, %cond.end251, %if.then132
  %sv_flags257 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %58 = load i32* %sv_flags257, align 4, !tbaa !4
  %and258 = and i32 %58, 16384
  %tobool259 = icmp eq i32 %and258, 0
  br i1 %tobool259, label %if.end262, label %if.then260

if.then260:                                       ; preds = %if.end256
  %call261 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end262

if.end262:                                        ; preds = %if.end256, %if.then260
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end282

if.else263:                                       ; preds = %if.else99
  %and265 = and i32 %26, 131072
  %tobool266 = icmp eq i32 %and265, 0
  br i1 %tobool266, label %cond.false270, label %cond.true267

cond.true267:                                     ; preds = %if.else263
  %sv_any268 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %59 = load i8** %sv_any268, align 8, !tbaa !0
  %xnv_nv269 = getelementptr inbounds i8* %59, i64 32
  %60 = bitcast i8* %xnv_nv269 to double*
  %61 = load double* %60, align 8, !tbaa !6
  br label %cond.end272

cond.false270:                                    ; preds = %if.else263
  %call271 = call double @Perl_sv_2nv(%struct.sv* %12) #7
  br label %cond.end272

cond.end272:                                      ; preds = %cond.false270, %cond.true267
  %cond273 = phi double [ %61, %cond.true267 ], [ %call271, %cond.false270 ]
  %sub274 = fsub double -0.000000e+00, %cond273
  call void @Perl_sv_setnv(%struct.sv* %4, double %sub274) #7
  %sv_flags275 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %62 = load i32* %sv_flags275, align 4, !tbaa !4
  %and276 = and i32 %62, 16384
  %tobool277 = icmp eq i32 %and276, 0
  br i1 %tobool277, label %if.end280, label %if.then278

if.then278:                                       ; preds = %cond.end272
  %call279 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end280

if.end280:                                        ; preds = %cond.end272, %if.then278
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end282

if.end282:                                        ; preds = %if.end262, %if.end280, %if.end98
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %63 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next283 = getelementptr inbounds %struct.op* %63, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end282, %if.end79, %if.end71, %if.end54, %if.end41, %if.end14
  %retval.0.in = phi %struct.op** [ %op_next, %if.end14 ], [ %op_next42, %if.end41 ], [ %op_next55, %if.end54 ], [ %op_next283, %if.end282 ], [ %op_next72, %if.end71 ], [ %op_next80, %if.end79 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_catsv_flags(%struct.sv*, %struct.sv*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_not() #0 {
entry:
  %0 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %0, 0
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %2 = load %struct.sv** %1, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %3, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %2, %struct.sv* @PL_sv_undef, i32 42, i32 9) #7
  %tobool2 = icmp eq %struct.sv* %call, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %4 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  store %struct.sv* %call, %struct.sv** %4, align 8, !tbaa !0
  store %struct.sv** %4, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %entry, %if.then
  %5 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %6 = load %struct.sv** %5, align 8, !tbaa !0
  %tobool5 = icmp eq %struct.sv* %6, null
  br i1 %tobool5, label %cond.end41, label %cond.false

cond.false:                                       ; preds = %if.end4
  %sv_flags6 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags6, align 4, !tbaa !4
  %and7 = and i32 %7, 262144
  %tobool8 = icmp eq i32 %and7, 0
  br i1 %tobool8, label %cond.false17, label %cond.true9

cond.true9:                                       ; preds = %cond.false
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !0
  %9 = bitcast i8* %8 to %struct.xpv*
  store %struct.xpv* %9, %struct.xpv** @PL_Xpv, align 8, !tbaa !0
  %tobool10 = icmp eq i8* %8, null
  br i1 %tobool10, label %land.end16, label %land.rhs

land.rhs:                                         ; preds = %cond.true9
  %xpv_cur = getelementptr inbounds i8* %8, i64 8
  %10 = bitcast i8* %xpv_cur to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  %cmp = icmp ugt i64 %11, 1
  br i1 %cmp, label %land.end16, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %tobool12 = icmp eq i64 %11, 0
  br i1 %tobool12, label %land.end16, label %land.rhs13

land.rhs13:                                       ; preds = %lor.rhs
  %xpv_pv = bitcast i8* %8 to i8**
  %12 = load i8** %xpv_pv, align 8, !tbaa !0
  %13 = load i8* %12, align 1, !tbaa !1
  %cmp14 = icmp ne i8 %13, 48
  br label %land.end16

land.end16:                                       ; preds = %lor.rhs, %cond.true9, %land.rhs, %land.rhs13
  %14 = phi i1 [ false, %cond.true9 ], [ true, %land.rhs ], [ false, %lor.rhs ], [ %cmp14, %land.rhs13 ]
  %cond = zext i1 %14 to i32
  br label %cond.end41

cond.false17:                                     ; preds = %cond.false
  %and19 = and i32 %7, 65536
  %tobool20 = icmp eq i32 %and19, 0
  br i1 %tobool20, label %cond.false25, label %cond.true21

cond.true21:                                      ; preds = %cond.false17
  %sv_any22 = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %15 = load i8** %sv_any22, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %15, i64 24
  %16 = bitcast i8* %xiv_iv to i64*
  %17 = load i64* %16, align 8, !tbaa !3
  %cmp23 = icmp ne i64 %17, 0
  %conv24 = zext i1 %cmp23 to i32
  br label %cond.end41

cond.false25:                                     ; preds = %cond.false17
  %and27 = and i32 %7, 131072
  %tobool28 = icmp eq i32 %and27, 0
  br i1 %tobool28, label %cond.false33, label %cond.true29

cond.true29:                                      ; preds = %cond.false25
  %sv_any30 = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %18 = load i8** %sv_any30, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %18, i64 32
  %19 = bitcast i8* %xnv_nv to double*
  %20 = load double* %19, align 8, !tbaa !6
  %cmp31 = fcmp une double %20, 0.000000e+00
  %conv32 = zext i1 %cmp31 to i32
  br label %cond.end41

cond.false33:                                     ; preds = %cond.false25
  %call34 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %6) #7
  %conv35 = sext i8 %call34 to i32
  %.pre = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  br label %cond.end41

cond.end41:                                       ; preds = %if.end4, %land.end16, %cond.true29, %cond.false33, %cond.true21
  %21 = phi %struct.sv** [ %5, %if.end4 ], [ %5, %land.end16 ], [ %5, %cond.true21 ], [ %5, %cond.true29 ], [ %.pre, %cond.false33 ]
  %cond42 = phi i32 [ 0, %if.end4 ], [ %cond, %land.end16 ], [ %conv24, %cond.true21 ], [ %conv32, %cond.true29 ], [ %conv35, %cond.false33 ]
  %lnot = icmp eq i32 %cond42, 0
  %cond44 = select i1 %lnot, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond44, %struct.sv** %21, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end41, %if.then3
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare signext i8 @Perl_sv_2bool(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_complement() #0 {
entry:
  %len = alloca i64, align 8
  %l = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 43, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge332 = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge332, %struct.sv** %8, align 8, !tbaa !0
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %12 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %13, 50331648
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %if.else52, label %if.then20

if.then20:                                        ; preds = %if.end16
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %14, i64 0, i32 7
  %15 = load i8* %op_private, align 1, !tbaa !1
  %and21 = and i8 %15, 1
  %tobool22 = icmp eq i8 %and21, 0
  %and25 = and i32 %13, 65536
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool22, label %if.else34, label %if.then23

if.then23:                                        ; preds = %if.then20
  br i1 %tobool26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then23
  %sv_any = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %16 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %16, i64 24
  %17 = bitcast i8* %xiv_iv to i64*
  %18 = load i64* %17, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then23
  %call27 = call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %18, %cond.true ], [ %call27, %cond.false ]
  %neg = xor i64 %cond, -1
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %neg) #7
  %sv_flags28 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %19 = load i32* %sv_flags28, align 4, !tbaa !4
  %and29 = and i32 %19, 16384
  %tobool30 = icmp eq i32 %and29, 0
  br i1 %tobool30, label %if.end33, label %if.then31

if.then31:                                        ; preds = %cond.end
  %call32 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end33

if.end33:                                         ; preds = %cond.end, %if.then31
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end227

if.else34:                                        ; preds = %if.then20
  br i1 %tobool26, label %cond.true38, label %cond.false40

cond.true38:                                      ; preds = %if.else34
  %sv_any39 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %20 = load i8** %sv_any39, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %20, i64 24
  %21 = bitcast i8* %xuv_uv to i64*
  %22 = load i64* %21, align 8, !tbaa !3
  br label %cond.end42

cond.false40:                                     ; preds = %if.else34
  %call41 = call i64 @Perl_sv_2uv(%struct.sv* %12) #7
  br label %cond.end42

cond.end42:                                       ; preds = %cond.false40, %cond.true38
  %cond43 = phi i64 [ %22, %cond.true38 ], [ %call41, %cond.false40 ]
  %neg44 = xor i64 %cond43, -1
  call void @Perl_sv_setuv(%struct.sv* %4, i64 %neg44) #7
  %sv_flags45 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %23 = load i32* %sv_flags45, align 4, !tbaa !4
  %and46 = and i32 %23, 16384
  %tobool47 = icmp eq i32 %and46, 0
  br i1 %tobool47, label %if.end50, label %if.then48

if.then48:                                        ; preds = %cond.end42
  %call49 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end50

if.end50:                                         ; preds = %cond.end42, %if.then48
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end227

if.else52:                                        ; preds = %if.end16
  %and54 = and i32 %13, 262144
  %cmp = icmp eq i32 %and54, 0
  br i1 %cmp, label %cond.false59, label %cond.true56

cond.true56:                                      ; preds = %if.else52
  %sv_any57 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %24 = load i8** %sv_any57, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %24, i64 8
  %25 = bitcast i8* %xpv_cur to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  store i64 %26, i64* %len, align 8, !tbaa !3
  br label %cond.end61

cond.false59:                                     ; preds = %if.else52
  %call60 = call i8* @Perl_sv_2pv_flags(%struct.sv* %12, i64* %len, i32 0) #7
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false59, %cond.true56
  %cmp63 = icmp eq %struct.sv* %4, %12
  br i1 %cmp63, label %if.end66, label %if.then65

if.then65:                                        ; preds = %cond.end61
  call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %12, i32 2) #7
  br label %if.end66

if.end66:                                         ; preds = %cond.end61, %if.then65
  %sv_flags67 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %27 = load i32* %sv_flags67, align 4, !tbaa !4
  %and68 = and i32 %27, 10223616
  %cmp69 = icmp eq i32 %and68, 262144
  br i1 %cmp69, label %cond.true71, label %cond.false76

cond.true71:                                      ; preds = %if.end66
  %sv_any72 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %28 = load i8** %sv_any72, align 8, !tbaa !0
  %xpv_cur73 = getelementptr inbounds i8* %28, i64 8
  %29 = bitcast i8* %xpv_cur73 to i64*
  %30 = load i64* %29, align 8, !tbaa !3
  store i64 %30, i64* %len, align 8, !tbaa !3
  %xpv_pv75 = bitcast i8* %28 to i8**
  %31 = load i8** %xpv_pv75, align 8, !tbaa !0
  br label %cond.end78

cond.false76:                                     ; preds = %if.end66
  %call77 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %4, i64* %len, i32 2) #7
  %.pre = load i64* %len, align 8, !tbaa !3
  %.pre365 = load i32* %sv_flags67, align 4, !tbaa !4
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false76, %cond.true71
  %32 = phi i32 [ %27, %cond.true71 ], [ %.pre365, %cond.false76 ]
  %33 = phi i64 [ %30, %cond.true71 ], [ %.pre, %cond.false76 ]
  %cond79 = phi i8* [ %31, %cond.true71 ], [ %call77, %cond.false76 ]
  %conv80 = trunc i64 %33 to i32
  %and82 = and i32 %32, 536870912
  %tobool83 = icmp eq i32 %and82, 0
  br i1 %tobool83, label %for.cond.preheader, label %if.then84

for.cond.preheader:                               ; preds = %cond.end78
  %tobool199340 = icmp eq i32 %conv80, 0
  br i1 %tobool199340, label %for.end226, label %land.rhs

if.then84:                                        ; preds = %cond.end78
  %add.ptr = getelementptr inbounds i8* %cond79, i64 %33
  %cmp85353 = icmp sgt i64 %33, 0
  br i1 %cmp85353, label %while.body.lr.ph, label %while.end.thread

while.end.thread:                                 ; preds = %if.then84
  %idx.neg367 = sub i64 0, %33
  %add.ptr143368 = getelementptr inbounds i8* %cond79, i64 %idx.neg367
  br label %if.else170

while.body.lr.ph:                                 ; preds = %if.then84
  %sub.ptr.lhs.cast = ptrtoint i8* %add.ptr to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %cond.end135
  %tmps.0357 = phi i8* [ %cond79, %while.body.lr.ph ], [ %add.ptr90, %cond.end135 ]
  %nwide.0356 = phi i64 [ 0, %while.body.lr.ph ], [ %inc141.nwide.0, %cond.end135 ]
  %nchar.0355 = phi i64 [ 0, %while.body.lr.ph ], [ %inc, %cond.end135 ]
  %targlen.0354 = phi i64 [ 0, %while.body.lr.ph ], [ %add, %cond.end135 ]
  %sub.ptr.rhs.cast = ptrtoint i8* %tmps.0357 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call87 = call i64 @Perl_utf8n_to_uvuni(i8* %tmps.0357, i64 %sub.ptr.sub, i64* %l, i32 105) #7
  %34 = load i8* %tmps.0357, align 1, !tbaa !1
  %idxprom = zext i8 %34 to i64
  %arrayidx88 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom
  %35 = load i8* %arrayidx88, align 1, !tbaa !1
  %idx.ext = zext i8 %35 to i64
  %add.ptr90 = getelementptr inbounds i8* %tmps.0357, i64 %idx.ext
  %neg91 = xor i64 %call87, -68719476736
  %cmp92 = icmp ugt i64 %call87, -129
  br i1 %cmp92, label %cond.end135, label %cond.false95

cond.false95:                                     ; preds = %while.body
  %cmp97 = icmp ugt i64 %call87, -2049
  br i1 %cmp97, label %cond.end135, label %cond.false100

cond.false100:                                    ; preds = %cond.false95
  %cmp102 = icmp ugt i64 %call87, -65537
  br i1 %cmp102, label %cond.end135, label %cond.false105

cond.false105:                                    ; preds = %cond.false100
  %cmp107 = icmp ugt i64 %call87, -2097153
  br i1 %cmp107, label %cond.end135, label %cond.false110

cond.false110:                                    ; preds = %cond.false105
  %cmp112 = icmp ugt i64 %call87, -67108865
  br i1 %cmp112, label %cond.end135, label %cond.false115

cond.false115:                                    ; preds = %cond.false110
  %cmp117 = icmp ugt i64 %call87, -2147483649
  br i1 %cmp117, label %cond.end135, label %cond.false120

cond.false120:                                    ; preds = %cond.false115
  %cmp122 = icmp ult i64 %neg91, 68719476736
  %phitmp = select i1 %cmp122, i64 7, i64 13
  br label %cond.end135

cond.end135:                                      ; preds = %cond.false95, %cond.false105, %cond.false120, %cond.false115, %cond.false110, %cond.false100, %while.body
  %cond136 = phi i64 [ 1, %while.body ], [ 2, %cond.false95 ], [ 3, %cond.false100 ], [ 4, %cond.false105 ], [ 5, %cond.false110 ], [ %phitmp, %cond.false120 ], [ 6, %cond.false115 ]
  %add = add i64 %cond136, %targlen.0354
  %inc = add i64 %nchar.0355, 1
  %cmp138 = icmp ugt i64 %call87, 255
  %inc141 = zext i1 %cmp138 to i64
  %inc141.nwide.0 = add i64 %inc141, %nwide.0356
  %cmp85 = icmp ult i8* %add.ptr90, %add.ptr
  br i1 %cmp85, label %while.body, label %while.end

while.end:                                        ; preds = %cond.end135
  %phitmp362 = icmp eq i64 %inc141.nwide.0, 0
  %.pre366 = load i64* %len, align 8, !tbaa !3
  %add.ptr90.sum = sub i64 %idx.ext, %.pre366
  %add.ptr143 = getelementptr inbounds i8* %tmps.0357, i64 %add.ptr90.sum
  br i1 %phitmp362, label %if.else170, label %if.then145

if.then145:                                       ; preds = %while.end
  %add146 = add i64 %add, 1
  %call147 = call i8* @Perl_safesysmalloc(i64 %add146) #7
  call void @llvm.memset.p0i8.i64(i8* %call147, i8 0, i64 %add146, i32 1, i1 false)
  %cmp151349 = icmp ult i8* %add.ptr143, %add.ptr
  br i1 %cmp151349, label %while.body153.lr.ph, label %while.end166

while.body153.lr.ph:                              ; preds = %if.then145
  %sub.ptr.lhs.cast155 = ptrtoint i8* %add.ptr to i64
  br label %while.body153

while.body153:                                    ; preds = %while.body153.lr.ph, %while.body153
  %tmps.1351 = phi i8* [ %add.ptr143, %while.body153.lr.ph ], [ %add.ptr163, %while.body153 ]
  %result.0350 = phi i8* [ %call147, %while.body153.lr.ph ], [ %call165, %while.body153 ]
  %sub.ptr.rhs.cast156 = ptrtoint i8* %tmps.1351 to i64
  %sub.ptr.sub157 = sub i64 %sub.ptr.lhs.cast155, %sub.ptr.rhs.cast156
  %call158 = call i64 @Perl_utf8n_to_uvuni(i8* %tmps.1351, i64 %sub.ptr.sub157, i64* %l, i32 105) #7
  %36 = load i8* %tmps.1351, align 1, !tbaa !1
  %idxprom159 = zext i8 %36 to i64
  %arrayidx160 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom159
  %37 = load i8* %arrayidx160, align 1, !tbaa !1
  %idx.ext162 = zext i8 %37 to i64
  %add.ptr163 = getelementptr inbounds i8* %tmps.1351, i64 %idx.ext162
  %neg164 = xor i64 %call158, -1
  %call165 = call i8* @Perl_uvchr_to_utf8_flags(i8* %result.0350, i64 %neg164, i64 15) #7
  %cmp151 = icmp ult i8* %add.ptr163, %add.ptr
  br i1 %cmp151, label %while.body153, label %while.end166

while.end166:                                     ; preds = %while.body153, %if.then145
  %result.0.lcssa = phi i8* [ %call147, %if.then145 ], [ %call165, %while.body153 ]
  store i8 0, i8* %result.0.lcssa, align 1, !tbaa !1
  %idx.neg167 = sub i64 0, %add
  %add.ptr168 = getelementptr inbounds i8* %result.0.lcssa, i64 %idx.neg167
  call void @Perl_sv_setpvn(%struct.sv* %4, i8* %add.ptr168, i64 %add) #7
  %38 = load i32* %sv_flags67, align 4, !tbaa !4
  %or = or i32 %38, 536870912
  br label %if.end196

if.else170:                                       ; preds = %while.end.thread, %while.end
  %add.ptr143370 = phi i8* [ %add.ptr143368, %while.end.thread ], [ %add.ptr143, %while.end ]
  %nchar.0.lcssa369 = phi i64 [ 0, %while.end.thread ], [ %inc, %while.end ]
  %add171 = add i64 %nchar.0.lcssa369, 1
  %call173 = call i8* @Perl_safesysmalloc(i64 %add171) #7
  call void @llvm.memset.p0i8.i64(i8* %call173, i8 0, i64 %add171, i32 1, i1 false)
  %cmp177345 = icmp ult i8* %add.ptr143370, %add.ptr
  br i1 %cmp177345, label %while.body179, label %while.end191

while.body179:                                    ; preds = %if.else170, %while.body179
  %tmps.2347 = phi i8* [ %add.ptr187, %while.body179 ], [ %add.ptr143370, %if.else170 ]
  %result.1346 = phi i8* [ %incdec.ptr, %while.body179 ], [ %call173, %if.else170 ]
  %call181 = call i64 @Perl_utf8n_to_uvuni(i8* %tmps.2347, i64 0, i64* %l, i32 255) #7
  %conv182 = trunc i64 %call181 to i8
  %39 = load i8* %tmps.2347, align 1, !tbaa !1
  %idxprom183 = zext i8 %39 to i64
  %arrayidx184 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom183
  %40 = load i8* %arrayidx184, align 1, !tbaa !1
  %idx.ext186 = zext i8 %40 to i64
  %add.ptr187 = getelementptr inbounds i8* %tmps.2347, i64 %idx.ext186
  %neg189 = xor i8 %conv182, -1
  %incdec.ptr = getelementptr inbounds i8* %result.1346, i64 1
  store i8 %neg189, i8* %result.1346, align 1, !tbaa !1
  %cmp177 = icmp ult i8* %add.ptr187, %add.ptr
  br i1 %cmp177, label %while.body179, label %while.end191

while.end191:                                     ; preds = %while.body179, %if.else170
  %result.1.lcssa = phi i8* [ %call173, %if.else170 ], [ %incdec.ptr, %while.body179 ]
  store i8 0, i8* %result.1.lcssa, align 1, !tbaa !1
  %idx.neg192 = sub i64 0, %nchar.0.lcssa369
  %add.ptr193 = getelementptr inbounds i8* %result.1.lcssa, i64 %idx.neg192
  call void @Perl_sv_setpvn(%struct.sv* %4, i8* %add.ptr193, i64 %nchar.0.lcssa369) #7
  %41 = load i32* %sv_flags67, align 4, !tbaa !4
  %and195 = and i32 %41, -536870913
  br label %if.end196

if.end196:                                        ; preds = %while.end191, %while.end166
  %storemerge = phi i32 [ %and195, %while.end191 ], [ %or, %while.end166 ]
  %result.2 = phi i8* [ %add.ptr193, %while.end191 ], [ %add.ptr168, %while.end166 ]
  store i32 %storemerge, i32* %sv_flags67, align 4, !tbaa !4
  call void @Perl_safesysfree(i8* %result.2) #7
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next197 = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  br label %return

land.rhs:                                         ; preds = %for.cond.preheader, %for.body
  %tmps.3342 = phi i8* [ %incdec.ptr204, %for.body ], [ %cond79, %for.cond.preheader ]
  %anum.0341 = phi i32 [ %dec, %for.body ], [ %conv80, %for.cond.preheader ]
  %43 = ptrtoint i8* %tmps.3342 to i64
  %rem = and i64 %43, 7
  %tobool200 = icmp eq i64 %rem, 0
  br i1 %tobool200, label %for.end, label %for.body

for.body:                                         ; preds = %land.rhs
  %44 = load i8* %tmps.3342, align 1, !tbaa !1
  %neg202 = xor i8 %44, -1
  store i8 %neg202, i8* %tmps.3342, align 1, !tbaa !1
  %dec = add nsw i32 %anum.0341, -1
  %incdec.ptr204 = getelementptr inbounds i8* %tmps.3342, i64 1
  %tobool199 = icmp eq i32 %dec, 0
  br i1 %tobool199, label %for.end226, label %land.rhs

for.end:                                          ; preds = %land.rhs
  %45 = bitcast i8* %tmps.3342 to i64*
  %cmp207336 = icmp ugt i32 %anum.0341, 7
  br i1 %cmp207336, label %for.body209, label %for.end215

for.body209:                                      ; preds = %for.end, %for.body209
  %tmpl.0338 = phi i64* [ %incdec.ptr214, %for.body209 ], [ %45, %for.end ]
  %anum.1337 = phi i32 [ %sub, %for.body209 ], [ %anum.0341, %for.end ]
  %46 = load i64* %tmpl.0338, align 8, !tbaa !3
  %neg210 = xor i64 %46, -1
  store i64 %neg210, i64* %tmpl.0338, align 8, !tbaa !3
  %sub = add i32 %anum.1337, -8
  %incdec.ptr214 = getelementptr inbounds i64* %tmpl.0338, i64 1
  %cmp207 = icmp ugt i32 %sub, 7
  br i1 %cmp207, label %for.body209, label %for.end215

for.end215:                                       ; preds = %for.body209, %for.end
  %tmpl.0.lcssa = phi i64* [ %45, %for.end ], [ %incdec.ptr214, %for.body209 ]
  %anum.1.lcssa = phi i32 [ %anum.0341, %for.end ], [ %sub, %for.body209 ]
  %cmp217333 = icmp sgt i32 %anum.1.lcssa, 0
  br i1 %cmp217333, label %for.body219.lr.ph, label %for.end226

for.body219.lr.ph:                                ; preds = %for.end215
  %47 = bitcast i64* %tmpl.0.lcssa to i8*
  br label %for.body219

for.body219:                                      ; preds = %for.body219.lr.ph, %for.body219
  %tmps.4335 = phi i8* [ %47, %for.body219.lr.ph ], [ %incdec.ptr225, %for.body219 ]
  %anum.2334 = phi i32 [ %anum.1.lcssa, %for.body219.lr.ph ], [ %dec224, %for.body219 ]
  %48 = load i8* %tmps.4335, align 1, !tbaa !1
  %neg221 = xor i8 %48, -1
  store i8 %neg221, i8* %tmps.4335, align 1, !tbaa !1
  %dec224 = add nsw i32 %anum.2334, -1
  %incdec.ptr225 = getelementptr inbounds i8* %tmps.4335, i64 1
  %cmp217 = icmp sgt i32 %dec224, 0
  br i1 %cmp217, label %for.body219, label %for.end226

for.end226:                                       ; preds = %for.cond.preheader, %for.body, %for.body219, %for.end215
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end227

if.end227:                                        ; preds = %if.end33, %if.end50, %for.end226
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %49 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next228 = getelementptr inbounds %struct.op* %49, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end227, %if.end196, %if.end14
  %retval.0.in = phi %struct.op** [ %op_next, %if.end14 ], [ %op_next228, %if.end227 ], [ %op_next197, %if.end196 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i64 @Perl_utf8n_to_uvuni(i8*, i64, i64*, i32) #1

; Function Attrs: optsize
declare i8* @Perl_uvchr_to_utf8_flags(i8*, i64, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_multiply() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 10, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags34 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags34, align 4, !tbaa !4
  %and35 = and i32 %16, 65536
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %cond.false38, label %cond.true37

cond.true37:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  br label %cond.end40

cond.false38:                                     ; preds = %if.end31
  %call39 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false38, %cond.true37
  %cond41 = phi i64 [ %19, %cond.true37 ], [ %call39, %cond.false38 ]
  %20 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags43 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i32* %sv_flags43, align 4, !tbaa !4
  %and44 = and i32 %21, 65536
  %tobool45 = icmp eq i32 %and44, 0
  br i1 %tobool45, label %cond.false49, label %cond.true46

cond.true46:                                      ; preds = %cond.end40
  %sv_any47 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %22 = load i8** %sv_any47, align 8, !tbaa !0
  %xiv_iv48 = getelementptr inbounds i8* %22, i64 24
  %23 = bitcast i8* %xiv_iv48 to i64*
  %24 = load i64* %23, align 8, !tbaa !3
  br label %cond.end51

cond.false49:                                     ; preds = %cond.end40
  %call50 = tail call i64 @Perl_sv_2iv(%struct.sv* %20) #7
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false49, %cond.true46
  %cond52 = phi i64 [ %24, %cond.true46 ], [ %call50, %cond.false49 ]
  %mul = mul nsw i64 %cond52, %cond41
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %mul) #7
  %sv_flags53 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %25 = load i32* %sv_flags53, align 4, !tbaa !4
  %and54 = and i32 %25, 16384
  %tobool55 = icmp eq i32 %and54, 0
  br i1 %tobool55, label %if.end58, label %if.then56

if.then56:                                        ; preds = %cond.end51
  %call57 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end58

if.end58:                                         ; preds = %cond.end51, %if.then56
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end58, %if.end29
  %storemerge82 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr33.pre-phi, %if.end58 ]
  store %struct.sv** %storemerge82, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_divide() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr32.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 12, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  %16 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr32.pre-phi = phi %struct.sv** [ %incdec.ptr32.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %17 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %17, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags33 = getelementptr inbounds %struct.sv* %17, i64 0, i32 2
  %18 = load i32* %sv_flags33, align 4, !tbaa !4
  %and34 = and i32 %18, 65536
  %tobool35 = icmp eq i32 %and34, 0
  br i1 %tobool35, label %cond.false37, label %cond.true36

cond.true36:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %19 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %19, i64 24
  %20 = bitcast i8* %xiv_iv to i64*
  %21 = load i64* %20, align 8, !tbaa !3
  br label %cond.end39

cond.false37:                                     ; preds = %if.end31
  %call38 = tail call i64 @Perl_sv_2iv(%struct.sv* %17) #7
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false37, %cond.true36
  %cond40 = phi i64 [ %21, %cond.true36 ], [ %call38, %cond.false37 ]
  %cmp = icmp eq i64 %cond40, 0
  br i1 %cmp, label %if.then42, label %if.end44

if.then42:                                        ; preds = %cond.end39
  %call43 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([25 x i8]* @.str29, i64 0, i64 0)) #7
  br label %return

if.end44:                                         ; preds = %cond.end39
  %22 = load %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  store %struct.sv* %22, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags46 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i32* %sv_flags46, align 4, !tbaa !4
  %and47 = and i32 %23, 65536
  %tobool48 = icmp eq i32 %and47, 0
  br i1 %tobool48, label %cond.false52, label %cond.true49

cond.true49:                                      ; preds = %if.end44
  %sv_any50 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %24 = load i8** %sv_any50, align 8, !tbaa !0
  %xiv_iv51 = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv51 to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end54

cond.false52:                                     ; preds = %if.end44
  %call53 = tail call i64 @Perl_sv_2iv(%struct.sv* %22) #7
  br label %cond.end54

cond.end54:                                       ; preds = %cond.false52, %cond.true49
  %cond55 = phi i64 [ %26, %cond.true49 ], [ %call53, %cond.false52 ]
  %div = sdiv i64 %cond55, %cond40
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %div) #7
  %sv_flags56 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %27 = load i32* %sv_flags56, align 4, !tbaa !4
  %and57 = and i32 %27, 16384
  %tobool58 = icmp eq i32 %and57, 0
  br i1 %tobool58, label %if.end61, label %if.then59

if.then59:                                        ; preds = %cond.end54
  %call60 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end61

if.end61:                                         ; preds = %cond.end54, %if.then59
  store %struct.sv* %cond, %struct.sv** %incdec.ptr32.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr32.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %28 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next63 = getelementptr inbounds %struct.op* %28, i64 0, i32 0
  %29 = load %struct.op** %op_next63, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end61, %if.then42, %if.end29
  %retval.0 = phi %struct.op* [ %16, %if.end29 ], [ %call43, %if.then42 ], [ %29, %if.end61 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_modulo() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 14, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  %16 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %17 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %17, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags34 = getelementptr inbounds %struct.sv* %17, i64 0, i32 2
  %18 = load i32* %sv_flags34, align 4, !tbaa !4
  %and35 = and i32 %18, 65536
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %cond.false38, label %cond.true37

cond.true37:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %19 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %19, i64 24
  %20 = bitcast i8* %xiv_iv to i64*
  %21 = load i64* %20, align 8, !tbaa !3
  br label %cond.end40

cond.false38:                                     ; preds = %if.end31
  %call39 = tail call i64 @Perl_sv_2iv(%struct.sv* %17) #7
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false38, %cond.true37
  %cond41 = phi i64 [ %21, %cond.true37 ], [ %call39, %cond.false38 ]
  %22 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags43 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i32* %sv_flags43, align 4, !tbaa !4
  %and44 = and i32 %23, 65536
  %tobool45 = icmp eq i32 %and44, 0
  br i1 %tobool45, label %cond.false49, label %cond.true46

cond.true46:                                      ; preds = %cond.end40
  %sv_any47 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %24 = load i8** %sv_any47, align 8, !tbaa !0
  %xiv_iv48 = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv48 to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end51

cond.false49:                                     ; preds = %cond.end40
  %call50 = tail call i64 @Perl_sv_2iv(%struct.sv* %22) #7
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false49, %cond.true46
  %cond52 = phi i64 [ %26, %cond.true46 ], [ %call50, %cond.false49 ]
  %tobool53 = icmp eq i64 %cond41, 0
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %cond.end51
  %call55 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str30, i64 0, i64 0)) #7
  br label %return

if.end56:                                         ; preds = %cond.end51
  store %struct.op* ()* @Perl_pp_i_modulo_0, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 60), align 8, !tbaa !0
  %27 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_ppaddr = getelementptr inbounds %struct.op* %27, i64 0, i32 2
  store {}* bitcast (%struct.op* ()* @Perl_pp_i_modulo_0 to {}*), {}** %op_ppaddr, align 8, !tbaa !0
  %rem69 = srem i64 %cond52, %cond41
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %rem69) #7
  %sv_flags70 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %28 = load i32* %sv_flags70, align 4, !tbaa !4
  %and71 = and i32 %28, 16384
  %tobool72 = icmp eq i32 %and71, 0
  br i1 %tobool72, label %if.end75, label %if.then73

if.then73:                                        ; preds = %if.end56
  %call74 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end75

if.end75:                                         ; preds = %if.end56, %if.then73
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr33.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %29 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next76 = getelementptr inbounds %struct.op* %29, i64 0, i32 0
  %30 = load %struct.op** %op_next76, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end75, %if.then54, %if.end29
  %retval.0 = phi %struct.op* [ %16, %if.end29 ], [ %30, %if.end75 ], [ %call55, %if.then54 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define internal %struct.op* @Perl_pp_i_modulo_0() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 14, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  %16 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %17 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %17, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags34 = getelementptr inbounds %struct.sv* %17, i64 0, i32 2
  %18 = load i32* %sv_flags34, align 4, !tbaa !4
  %and35 = and i32 %18, 65536
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %cond.false38, label %cond.true37

cond.true37:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %19 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %19, i64 24
  %20 = bitcast i8* %xiv_iv to i64*
  %21 = load i64* %20, align 8, !tbaa !3
  br label %cond.end40

cond.false38:                                     ; preds = %if.end31
  %call39 = tail call i64 @Perl_sv_2iv(%struct.sv* %17) #7
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false38, %cond.true37
  %cond41 = phi i64 [ %21, %cond.true37 ], [ %call39, %cond.false38 ]
  %22 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags43 = getelementptr inbounds %struct.sv* %22, i64 0, i32 2
  %23 = load i32* %sv_flags43, align 4, !tbaa !4
  %and44 = and i32 %23, 65536
  %tobool45 = icmp eq i32 %and44, 0
  br i1 %tobool45, label %cond.false49, label %cond.true46

cond.true46:                                      ; preds = %cond.end40
  %sv_any47 = getelementptr inbounds %struct.sv* %22, i64 0, i32 0
  %24 = load i8** %sv_any47, align 8, !tbaa !0
  %xiv_iv48 = getelementptr inbounds i8* %24, i64 24
  %25 = bitcast i8* %xiv_iv48 to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  br label %cond.end51

cond.false49:                                     ; preds = %cond.end40
  %call50 = tail call i64 @Perl_sv_2iv(%struct.sv* %22) #7
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false49, %cond.true46
  %cond52 = phi i64 [ %26, %cond.true46 ], [ %call50, %cond.false49 ]
  %tobool53 = icmp eq i64 %cond41, 0
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %cond.end51
  %call55 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str30, i64 0, i64 0)) #7
  br label %return

if.end56:                                         ; preds = %cond.end51
  %rem = srem i64 %cond52, %cond41
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %rem) #7
  %sv_flags57 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %27 = load i32* %sv_flags57, align 4, !tbaa !4
  %and58 = and i32 %27, 16384
  %tobool59 = icmp eq i32 %and58, 0
  br i1 %tobool59, label %if.end62, label %if.then60

if.then60:                                        ; preds = %if.end56
  %call61 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end62

if.end62:                                         ; preds = %if.end56, %if.then60
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr33.pre-phi, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %28 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next63 = getelementptr inbounds %struct.op* %28, i64 0, i32 0
  %29 = load %struct.op** %op_next63, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end62, %if.then54, %if.end29
  %retval.0 = phi %struct.op* [ %16, %if.end29 ], [ %29, %if.end62 ], [ %call55, %if.then54 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_add() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 6, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags34 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags34, align 4, !tbaa !4
  %and35 = and i32 %16, 65536
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %cond.false38, label %cond.true37

cond.true37:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  br label %cond.end40

cond.false38:                                     ; preds = %if.end31
  %call39 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false38, %cond.true37
  %cond41 = phi i64 [ %19, %cond.true37 ], [ %call39, %cond.false38 ]
  %20 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags43 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i32* %sv_flags43, align 4, !tbaa !4
  %22 = and i32 %21, 118431744
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %lor.lhs.false50, label %cond.true55

lor.lhs.false50:                                  ; preds = %cond.end40
  %24 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags51 = getelementptr inbounds %struct.op* %24, i64 0, i32 6
  %25 = load i8* %op_flags51, align 1, !tbaa !1
  %and53 = and i8 %25, 64
  %tobool54 = icmp eq i8 %and53, 0
  br i1 %tobool54, label %cond.true55, label %cond.end67

cond.true55:                                      ; preds = %lor.lhs.false50, %cond.end40
  %and57 = and i32 %21, 65536
  %tobool58 = icmp eq i32 %and57, 0
  br i1 %tobool58, label %cond.false62, label %cond.true59

cond.true59:                                      ; preds = %cond.true55
  %sv_any60 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %26 = load i8** %sv_any60, align 8, !tbaa !0
  %xiv_iv61 = getelementptr inbounds i8* %26, i64 24
  %27 = bitcast i8* %xiv_iv61 to i64*
  %28 = load i64* %27, align 8, !tbaa !3
  br label %cond.end67

cond.false62:                                     ; preds = %cond.true55
  %call63 = tail call i64 @Perl_sv_2iv(%struct.sv* %20) #7
  br label %cond.end67

cond.end67:                                       ; preds = %lor.lhs.false50, %cond.true59, %cond.false62
  %cond68 = phi i64 [ %28, %cond.true59 ], [ %call63, %cond.false62 ], [ 0, %lor.lhs.false50 ]
  %add = add nsw i64 %cond68, %cond41
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %add) #7
  %sv_flags69 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %29 = load i32* %sv_flags69, align 4, !tbaa !4
  %and70 = and i32 %29, 16384
  %tobool71 = icmp eq i32 %and70, 0
  br i1 %tobool71, label %if.end74, label %if.then72

if.then72:                                        ; preds = %cond.end67
  %call73 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end74

if.end74:                                         ; preds = %cond.end67, %if.then72
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end74, %if.end29
  %storemerge100 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr33.pre-phi, %if.end74 ]
  store %struct.sv** %storemerge100, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_subtract() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !3
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx1 = getelementptr inbounds %struct.sv** %4, i64 %3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond.in = phi %struct.sv** [ %arrayidx, %cond.true ], [ %arrayidx1, %cond.false ]
  %cond = load %struct.sv** %cond.in, align 8
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool2 = icmp eq i64 %5, 0
  br i1 %tobool2, label %cond.end.if.end31_crit_edge, label %if.then

cond.end.if.end31_crit_edge:                      ; preds = %cond.end
  %incdec.ptr33.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end31

if.then:                                          ; preds = %cond.end
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %8, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 268435456
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %tobool11 = icmp ne i8 %and, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 8, i32 %cond12) #7
  %tobool13 = icmp eq %struct.sv* %call, null
  br i1 %tobool13, label %if.end31, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags15 = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %12, 64
  %tobool18 = icmp eq i8 %and17, 0
  %sv_flags20 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then14
  %13 = load i32* %sv_flags20, align 4, !tbaa !4
  %and21 = and i32 %13, 1024
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.end29, label %if.then23

if.then23:                                        ; preds = %if.then14, %lor.lhs.false19
  tail call void @Perl_sv_setsv_flags(%struct.sv* %cond, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags20, align 4, !tbaa !4
  %and25 = and i32 %14, 16384
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.then23
  %call28 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end29

if.end29:                                         ; preds = %lor.lhs.false19, %if.then27, %if.then23
  %storemerge = phi %struct.sv* [ %cond, %if.then23 ], [ %cond, %if.then27 ], [ %call, %lor.lhs.false19 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %cond.end.if.end31_crit_edge, %lor.lhs.false
  %incdec.ptr33.pre-phi = phi %struct.sv** [ %incdec.ptr33.pre, %cond.end.if.end31_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags34 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags34, align 4, !tbaa !4
  %and35 = and i32 %16, 65536
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %cond.false38, label %cond.true37

cond.true37:                                      ; preds = %if.end31
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  br label %cond.end40

cond.false38:                                     ; preds = %if.end31
  %call39 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false38, %cond.true37
  %cond41 = phi i64 [ %19, %cond.true37 ], [ %call39, %cond.false38 ]
  %20 = load %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  %sv_flags43 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i32* %sv_flags43, align 4, !tbaa !4
  %22 = and i32 %21, 118431744
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %lor.lhs.false50, label %cond.true55

lor.lhs.false50:                                  ; preds = %cond.end40
  %24 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags51 = getelementptr inbounds %struct.op* %24, i64 0, i32 6
  %25 = load i8* %op_flags51, align 1, !tbaa !1
  %and53 = and i8 %25, 64
  %tobool54 = icmp eq i8 %and53, 0
  br i1 %tobool54, label %cond.true55, label %cond.end67

cond.true55:                                      ; preds = %lor.lhs.false50, %cond.end40
  %and57 = and i32 %21, 65536
  %tobool58 = icmp eq i32 %and57, 0
  br i1 %tobool58, label %cond.false62, label %cond.true59

cond.true59:                                      ; preds = %cond.true55
  %sv_any60 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %26 = load i8** %sv_any60, align 8, !tbaa !0
  %xiv_iv61 = getelementptr inbounds i8* %26, i64 24
  %27 = bitcast i8* %xiv_iv61 to i64*
  %28 = load i64* %27, align 8, !tbaa !3
  br label %cond.end67

cond.false62:                                     ; preds = %cond.true55
  %call63 = tail call i64 @Perl_sv_2iv(%struct.sv* %20) #7
  br label %cond.end67

cond.end67:                                       ; preds = %lor.lhs.false50, %cond.true59, %cond.false62
  %cond68 = phi i64 [ %28, %cond.true59 ], [ %call63, %cond.false62 ], [ 0, %lor.lhs.false50 ]
  %sub = sub nsw i64 %cond68, %cond41
  tail call void @Perl_sv_setiv(%struct.sv* %cond, i64 %sub) #7
  %sv_flags69 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %29 = load i32* %sv_flags69, align 4, !tbaa !4
  %and70 = and i32 %29, 16384
  %tobool71 = icmp eq i32 %and70, 0
  br i1 %tobool71, label %if.end74, label %if.then72

if.then72:                                        ; preds = %cond.end67
  %call73 = tail call i32 @Perl_mg_set(%struct.sv* %cond) #7
  br label %if.end74

if.end74:                                         ; preds = %cond.end67, %if.then72
  store %struct.sv* %cond, %struct.sv** %incdec.ptr33.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end74, %if.end29
  %storemerge100 = phi %struct.sv** [ %incdec.ptr, %if.end29 ], [ %incdec.ptr33.pre-phi, %if.end74 ]
  store %struct.sv** %storemerge100, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_lt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 28, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %8, 65536
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end7
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call13, %cond.false ]
  %12 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %13, 65536
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false21, label %cond.true18

cond.true18:                                      ; preds = %cond.end
  %sv_any19 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !0
  %xiv_iv20 = getelementptr inbounds i8* %14, i64 24
  %15 = bitcast i8* %xiv_iv20 to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  br label %cond.end23

cond.false21:                                     ; preds = %cond.end
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false21, %cond.true18
  %cond24 = phi i64 [ %16, %cond.true18 ], [ %call22, %cond.false21 ]
  %cmp = icmp slt i64 %cond24, %cond
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond25, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end23, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %cond.end23 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_gt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 30, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %8, 65536
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end7
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call13, %cond.false ]
  %12 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %13, 65536
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false21, label %cond.true18

cond.true18:                                      ; preds = %cond.end
  %sv_any19 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !0
  %xiv_iv20 = getelementptr inbounds i8* %14, i64 24
  %15 = bitcast i8* %xiv_iv20 to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  br label %cond.end23

cond.false21:                                     ; preds = %cond.end
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false21, %cond.true18
  %cond24 = phi i64 [ %16, %cond.true18 ], [ %call22, %cond.false21 ]
  %cmp = icmp sgt i64 %cond24, %cond
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond25, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end23, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %cond.end23 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_le() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 29, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %8, 65536
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end7
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call13, %cond.false ]
  %12 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %13, 65536
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false21, label %cond.true18

cond.true18:                                      ; preds = %cond.end
  %sv_any19 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !0
  %xiv_iv20 = getelementptr inbounds i8* %14, i64 24
  %15 = bitcast i8* %xiv_iv20 to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  br label %cond.end23

cond.false21:                                     ; preds = %cond.end
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false21, %cond.true18
  %cond24 = phi i64 [ %16, %cond.true18 ], [ %call22, %cond.false21 ]
  %cmp = icmp sle i64 %cond24, %cond
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond25, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end23, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %cond.end23 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_ge() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 31, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %8, 65536
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end7
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call13, %cond.false ]
  %12 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %13, 65536
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false21, label %cond.true18

cond.true18:                                      ; preds = %cond.end
  %sv_any19 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !0
  %xiv_iv20 = getelementptr inbounds i8* %14, i64 24
  %15 = bitcast i8* %xiv_iv20 to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  br label %cond.end23

cond.false21:                                     ; preds = %cond.end
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false21, %cond.true18
  %cond24 = phi i64 [ %16, %cond.true18 ], [ %call22, %cond.false21 ]
  %cmp = icmp sge i64 %cond24, %cond
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond25, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end23, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %cond.end23 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_eq() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 32, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %8, 65536
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end7
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call13, %cond.false ]
  %12 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %13, 65536
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false21, label %cond.true18

cond.true18:                                      ; preds = %cond.end
  %sv_any19 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !0
  %xiv_iv20 = getelementptr inbounds i8* %14, i64 24
  %15 = bitcast i8* %xiv_iv20 to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  br label %cond.end23

cond.false21:                                     ; preds = %cond.end
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false21, %cond.true18
  %cond24 = phi i64 [ %16, %cond.true18 ], [ %call22, %cond.false21 ]
  %cmp = icmp eq i64 %cond24, %cond
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond25, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end23, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %cond.end23 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_ne() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %1, 0
  br i1 %tobool, label %entry.if.end7_crit_edge, label %if.then

entry.if.end7_crit_edge:                          ; preds = %entry
  %incdec.ptr9.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %4, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %5, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %3, %struct.sv* %2, i32 33, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %6, i64 -1
  store %struct.sv* %call, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %entry.if.end7_crit_edge, %lor.lhs.false
  %incdec.ptr9.pre-phi = phi %struct.sv** [ %incdec.ptr9.pre, %entry.if.end7_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %7 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %8, 65536
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end7
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  %call13 = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call13, %cond.false ]
  %12 = load %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %13, 65536
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false21, label %cond.true18

cond.true18:                                      ; preds = %cond.end
  %sv_any19 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %14 = load i8** %sv_any19, align 8, !tbaa !0
  %xiv_iv20 = getelementptr inbounds i8* %14, i64 24
  %15 = bitcast i8* %xiv_iv20 to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  br label %cond.end23

cond.false21:                                     ; preds = %cond.end
  %call22 = tail call i64 @Perl_sv_2iv(%struct.sv* %12) #7
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false21, %cond.true18
  %cond24 = phi i64 [ %16, %cond.true18 ], [ %call22, %cond.false21 ]
  %cmp = icmp ne i64 %cond24, %cond
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  store %struct.sv* %cond25, %struct.sv** %incdec.ptr9.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end23, %if.then6
  %storemerge = phi %struct.sv** [ %incdec.ptr, %if.then6 ], [ %incdec.ptr9.pre-phi, %cond.end23 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_ncmp() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %entry.if.end21_crit_edge, label %if.then

entry.if.end21_crit_edge:                         ; preds = %entry
  %incdec.ptr23.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %8, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end21, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 34, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end21, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !1
  %and7 = and i8 %12, 64
  %tobool8 = icmp eq i8 %and7, 0
  %sv_flags10 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  br i1 %tobool8, label %lor.lhs.false9, label %if.then13

lor.lhs.false9:                                   ; preds = %if.then6
  %13 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %13, 1024
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %if.end19, label %if.then13

if.then13:                                        ; preds = %if.then6, %lor.lhs.false9
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags10, align 4, !tbaa !4
  %and15 = and i32 %14, 16384
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then13
  %call18 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end19

if.end19:                                         ; preds = %lor.lhs.false9, %if.then17, %if.then13
  %storemerge = phi %struct.sv* [ %4, %if.then13 ], [ %4, %if.then17 ], [ %call, %lor.lhs.false9 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end21:                                         ; preds = %land.lhs.true, %entry.if.end21_crit_edge, %lor.lhs.false
  %incdec.ptr23.pre-phi = phi %struct.sv** [ %incdec.ptr23.pre, %entry.if.end21_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags24 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags24, align 4, !tbaa !4
  %and25 = and i32 %16, 65536
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end21
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %17, i64 24
  %18 = bitcast i8* %xiv_iv to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end21
  %call27 = tail call i64 @Perl_sv_2iv(%struct.sv* %15) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %19, %cond.true ], [ %call27, %cond.false ]
  %20 = load %struct.sv** %incdec.ptr23.pre-phi, align 8, !tbaa !0
  %sv_flags29 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i32* %sv_flags29, align 4, !tbaa !4
  %and30 = and i32 %21, 65536
  %tobool31 = icmp eq i32 %and30, 0
  br i1 %tobool31, label %cond.false35, label %cond.true32

cond.true32:                                      ; preds = %cond.end
  %sv_any33 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %22 = load i8** %sv_any33, align 8, !tbaa !0
  %xiv_iv34 = getelementptr inbounds i8* %22, i64 24
  %23 = bitcast i8* %xiv_iv34 to i64*
  %24 = load i64* %23, align 8, !tbaa !3
  br label %cond.end37

cond.false35:                                     ; preds = %cond.end
  %call36 = tail call i64 @Perl_sv_2iv(%struct.sv* %20) #7
  br label %cond.end37

cond.end37:                                       ; preds = %cond.false35, %cond.true32
  %cond38 = phi i64 [ %24, %cond.true32 ], [ %call36, %cond.false35 ]
  %cmp = icmp sgt i64 %cond38, %cond
  br i1 %cmp, label %if.end47, label %if.else41

if.else41:                                        ; preds = %cond.end37
  %cmp42 = icmp slt i64 %cond38, %cond
  %. = sext i1 %cmp42 to i64
  br label %if.end47

if.end47:                                         ; preds = %if.else41, %cond.end37
  %value.0 = phi i64 [ 1, %cond.end37 ], [ %., %if.else41 ]
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %value.0) #7
  %sv_flags49 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %25 = load i32* %sv_flags49, align 4, !tbaa !4
  %and50 = and i32 %25, 16384
  %tobool51 = icmp eq i32 %and50, 0
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %if.end47
  %call53 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end54

if.end54:                                         ; preds = %if.end47, %if.then52
  store %struct.sv* %4, %struct.sv** %incdec.ptr23.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end54, %if.end19
  %storemerge79 = phi %struct.sv** [ %incdec.ptr, %if.end19 ], [ %incdec.ptr23.pre-phi, %if.end54 ]
  store %struct.sv** %storemerge79, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_i_negate() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 57, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %11 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %12, 65536
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv to i64*
  %15 = load i64* %14, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call i64 @Perl_sv_2iv(%struct.sv* %11) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %15, %cond.true ], [ %call20, %cond.false ]
  %sub = sub nsw i64 0, %cond
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %sub) #7
  %sv_flags21 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %16 = load i32* %sv_flags21, align 4, !tbaa !4
  %and22 = and i32 %16, 16384
  %tobool23 = icmp eq i32 %and22, 0
  br i1 %tobool23, label %if.end26, label %if.then24

if.then24:                                        ; preds = %cond.end
  %call25 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end26

if.end26:                                         ; preds = %cond.end, %if.then24
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end26, %if.end14
  %storemerge45 = phi %struct.sv** [ %8, %if.end14 ], [ %0, %if.end26 ]
  store %struct.sv** %storemerge45, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_atan2() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %entry.if.end21_crit_edge, label %if.then

entry.if.end21_crit_edge:                         ; preds = %entry
  %incdec.ptr23.pre = getelementptr inbounds %struct.sv** %0, i64 -1
  br label %if.end21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %add.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %7 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %8, 268435456
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %land.lhs.true

lor.lhs.false:                                    ; preds = %if.then
  %sv_flags2 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %9 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end21, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %7, %struct.sv* %6, i32 46, i32 0) #7
  %tobool5 = icmp eq %struct.sv* %call, null
  br i1 %tobool5, label %if.end21, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %10 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %10, i64 -1
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %11, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !1
  %and7 = and i8 %12, 64
  %tobool8 = icmp eq i8 %and7, 0
  %sv_flags10 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  br i1 %tobool8, label %lor.lhs.false9, label %if.then13

lor.lhs.false9:                                   ; preds = %if.then6
  %13 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %13, 1024
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %if.end19, label %if.then13

if.then13:                                        ; preds = %if.then6, %lor.lhs.false9
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %14 = load i32* %sv_flags10, align 4, !tbaa !4
  %and15 = and i32 %14, 16384
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then13
  %call18 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end19

if.end19:                                         ; preds = %lor.lhs.false9, %if.then17, %if.then13
  %storemerge = phi %struct.sv* [ %4, %if.then13 ], [ %4, %if.then17 ], [ %call, %lor.lhs.false9 ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  br label %return

if.end21:                                         ; preds = %land.lhs.true, %entry.if.end21_crit_edge, %lor.lhs.false
  %incdec.ptr23.pre-phi = phi %struct.sv** [ %incdec.ptr23.pre, %entry.if.end21_crit_edge ], [ %add.ptr, %lor.lhs.false ], [ %add.ptr, %land.lhs.true ]
  %15 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags24 = getelementptr inbounds %struct.sv* %15, i64 0, i32 2
  %16 = load i32* %sv_flags24, align 4, !tbaa !4
  %and25 = and i32 %16, 131072
  %tobool26 = icmp eq i32 %and25, 0
  br i1 %tobool26, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end21
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %17 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %17, i64 32
  %18 = bitcast i8* %xnv_nv to double*
  %19 = load double* %18, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.end21
  %call27 = tail call double @Perl_sv_2nv(%struct.sv* %15) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %19, %cond.true ], [ %call27, %cond.false ]
  %20 = load %struct.sv** %incdec.ptr23.pre-phi, align 8, !tbaa !0
  %sv_flags29 = getelementptr inbounds %struct.sv* %20, i64 0, i32 2
  %21 = load i32* %sv_flags29, align 4, !tbaa !4
  %and30 = and i32 %21, 131072
  %tobool31 = icmp eq i32 %and30, 0
  br i1 %tobool31, label %cond.false35, label %cond.true32

cond.true32:                                      ; preds = %cond.end
  %sv_any33 = getelementptr inbounds %struct.sv* %20, i64 0, i32 0
  %22 = load i8** %sv_any33, align 8, !tbaa !0
  %xnv_nv34 = getelementptr inbounds i8* %22, i64 32
  %23 = bitcast i8* %xnv_nv34 to double*
  %24 = load double* %23, align 8, !tbaa !6
  br label %cond.end37

cond.false35:                                     ; preds = %cond.end
  %call36 = tail call double @Perl_sv_2nv(%struct.sv* %20) #7
  br label %cond.end37

cond.end37:                                       ; preds = %cond.false35, %cond.true32
  %cond38 = phi double [ %24, %cond.true32 ], [ %call36, %cond.false35 ]
  %call39 = tail call double @atan2(double %cond38, double %cond) #7
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call39) #7
  %sv_flags40 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %25 = load i32* %sv_flags40, align 4, !tbaa !4
  %and41 = and i32 %25, 16384
  %tobool42 = icmp eq i32 %and41, 0
  br i1 %tobool42, label %if.end45, label %if.then43

if.then43:                                        ; preds = %cond.end37
  %call44 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end45

if.end45:                                         ; preds = %cond.end37, %if.then43
  store %struct.sv* %4, %struct.sv** %incdec.ptr23.pre-phi, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end45, %if.end19
  %storemerge68 = phi %struct.sv** [ %incdec.ptr, %if.end19 ], [ %incdec.ptr23.pre-phi, %if.end45 ]
  store %struct.sv** %storemerge68, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare double @atan2(double, double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sin() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 48, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %11 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %11, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %12, 131072
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %13, i64 32
  %14 = bitcast i8* %xnv_nv to double*
  %15 = load double* %14, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call double @Perl_sv_2nv(%struct.sv* %11) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %15, %cond.true ], [ %call20, %cond.false ]
  %call21 = tail call double @sin(double %cond) #7
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call21) #7
  %sv_flags22 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %16 = load i32* %sv_flags22, align 4, !tbaa !4
  %and23 = and i32 %16, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %cond.end
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end27

if.end27:                                         ; preds = %cond.end, %if.then25
  %17 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %17 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end27
  %call29 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end27
  %sp.0 = phi %struct.sv** [ %call29, %if.then28 ], [ %incdec.ptr, %if.end27 ]
  %incdec.ptr31 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr31, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end30, %if.end14
  %storemerge53 = phi %struct.sv** [ %8, %if.end14 ], [ %incdec.ptr31, %if.end30 ]
  store %struct.sv** %storemerge53, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare double @sin(double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_cos() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 47, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %11 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %11, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %12, 131072
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %13, i64 32
  %14 = bitcast i8* %xnv_nv to double*
  %15 = load double* %14, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call double @Perl_sv_2nv(%struct.sv* %11) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %15, %cond.true ], [ %call20, %cond.false ]
  %call21 = tail call double @cos(double %cond) #7
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call21) #7
  %sv_flags22 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %16 = load i32* %sv_flags22, align 4, !tbaa !4
  %and23 = and i32 %16, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %cond.end
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end27

if.end27:                                         ; preds = %cond.end, %if.then25
  %17 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %17 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end27
  %call29 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end27
  %sp.0 = phi %struct.sv** [ %call29, %if.then28 ], [ %incdec.ptr, %if.end27 ]
  %incdec.ptr31 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr31, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end30, %if.end14
  %storemerge53 = phi %struct.sv** [ %8, %if.end14 ], [ %incdec.ptr31, %if.end30 ]
  store %struct.sv** %storemerge53, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare double @cos(double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_rand() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %5, 15
  %cmp = icmp eq i8 %and, 0
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %6, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and2 = and i32 %7, 131072
  %tobool = icmp eq i32 %and2, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %8, i64 32
  %9 = bitcast i8* %xnv_nv to double*
  %10 = load double* %9, align 8, !tbaa !6
  br label %if.end

cond.false:                                       ; preds = %if.else
  %call = tail call double @Perl_sv_2nv(%struct.sv* %6) #7
  br label %if.end

if.end:                                           ; preds = %cond.true, %cond.false, %entry
  %sp.0 = phi %struct.sv** [ %0, %entry ], [ %incdec.ptr, %cond.false ], [ %incdec.ptr, %cond.true ]
  %value.0 = phi double [ 1.000000e+00, %entry ], [ %call, %cond.false ], [ %10, %cond.true ]
  %cmp3 = fcmp oeq double %value.0, 0.000000e+00
  %value.1 = select i1 %cmp3, double 1.000000e+00, double %value.0
  %11 = load i8* @PL_srand_called, align 1, !tbaa !1
  %tobool7 = icmp eq i8 %11, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %call9 = tail call i32 @Perl_seed() #7
  tail call void @spec_srand(i32 %call9) #7
  store i8 1, i8* @PL_srand_called, align 1, !tbaa !1
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then8
  %call11 = tail call double @spec_rand() #7
  %mul = fmul double %value.1, %call11
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %mul) #7
  %sv_flags12 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %12 = load i32* %sv_flags12, align 4, !tbaa !4
  %and13 = and i32 %12, 16384
  %tobool14 = icmp eq i32 %and13, 0
  br i1 %tobool14, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.end10
  %call16 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end17

if.end17:                                         ; preds = %if.end10, %if.then15
  %13 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %13 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %sp.0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp18 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end17
  %call21 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.0, %struct.sv** %sp.0, i32 1) #7
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end17
  %sp.1 = phi %struct.sv** [ %call21, %if.then20 ], [ %sp.0, %if.end17 ]
  %incdec.ptr23 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr23, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr23, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %14, i64 0, i32 0
  %15 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %15
}

; Function Attrs: optsize
declare void @spec_srand(i32) #1

; Function Attrs: optsize
declare i32 @Perl_seed() #1

; Function Attrs: optsize
declare double @spec_rand() #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_srand() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %2 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %2, 15
  %cmp = icmp eq i8 %and, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call i32 @Perl_seed() #7
  %conv2 = zext i32 %call to i64
  br label %if.end

if.else:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %3 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %4, 65536
  %tobool = icmp eq i32 %and3, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any = getelementptr inbounds %struct.sv* %3, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %5, i64 24
  %6 = bitcast i8* %xuv_uv to i64*
  %7 = load i64* %6, align 8, !tbaa !3
  br label %if.end

cond.false:                                       ; preds = %if.else
  %call4 = tail call i64 @Perl_sv_2uv(%struct.sv* %3) #7
  br label %if.end

if.end:                                           ; preds = %cond.true, %cond.false, %if.then
  %sp.0 = phi %struct.sv** [ %0, %if.then ], [ %incdec.ptr, %cond.false ], [ %incdec.ptr, %cond.true ]
  %anum.0 = phi i64 [ %conv2, %if.then ], [ %call4, %cond.false ], [ %7, %cond.true ]
  %conv5 = trunc i64 %anum.0 to i32
  tail call void @spec_srand(i32 %conv5) #7
  store i8 1, i8* @PL_srand_called, align 1, !tbaa !1
  %8 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %sp.0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp6 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %call9 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.0, %struct.sv** %sp.0, i32 1) #7
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end
  %sp.1 = phi %struct.sv** [ %call9, %if.then8 ], [ %sp.0, %if.end ]
  %incdec.ptr11 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr11, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr11, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %9 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %9, i64 0, i32 0
  %10 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %10
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_exp() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 49, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %11 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %11, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %12, 131072
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %13, i64 32
  %14 = bitcast i8* %xnv_nv to double*
  %15 = load double* %14, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call double @Perl_sv_2nv(%struct.sv* %11) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %15, %cond.true ], [ %call20, %cond.false ]
  %call21 = tail call double @exp(double %cond) #7
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call21) #7
  %sv_flags22 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %16 = load i32* %sv_flags22, align 4, !tbaa !4
  %and23 = and i32 %16, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %cond.end
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end27

if.end27:                                         ; preds = %cond.end, %if.then25
  %17 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %17 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end27
  %call29 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end27
  %sp.0 = phi %struct.sv** [ %call29, %if.then28 ], [ %incdec.ptr, %if.end27 ]
  %incdec.ptr31 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr31, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end30, %if.end14
  %storemerge53 = phi %struct.sv** [ %8, %if.end14 ], [ %incdec.ptr31, %if.end30 ]
  store %struct.sv** %storemerge53, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare double @exp(double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_log() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 50, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  %12 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %13 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %13, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %14, 131072
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %15 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %15, i64 32
  %16 = bitcast i8* %xnv_nv to double*
  %17 = load double* %16, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call double @Perl_sv_2nv(%struct.sv* %13) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %17, %cond.true ], [ %call20, %cond.false ]
  %cmp = fcmp ugt double %cond, 0.000000e+00
  br i1 %cmp, label %if.end23, label %if.then21

if.then21:                                        ; preds = %cond.end
  %call22 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str32, i64 0, i64 0), double %cond) #7
  br label %return

if.end23:                                         ; preds = %cond.end
  %call24 = tail call double @log(double %cond) #7
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call24) #7
  %sv_flags25 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %18 = load i32* %sv_flags25, align 4, !tbaa !4
  %and26 = and i32 %18, 16384
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.end23
  %call29 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end30

if.end30:                                         ; preds = %if.end23, %if.then28
  %19 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp31 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end30
  %call33 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end30
  %sp.0 = phi %struct.sv** [ %call33, %if.then32 ], [ %incdec.ptr, %if.end30 ]
  %incdec.ptr35 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr35, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr35, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next36 = getelementptr inbounds %struct.op* %20, i64 0, i32 0
  %21 = load %struct.op** %op_next36, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end34, %if.then21, %if.end14
  %retval.0 = phi %struct.op* [ %12, %if.end14 ], [ %call22, %if.then21 ], [ %21, %if.end34 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare double @log(double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sqrt() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 51, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  %12 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %13 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %13, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %14 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %14, 131072
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %15 = load i8** %sv_any, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %15, i64 32
  %16 = bitcast i8* %xnv_nv to double*
  %17 = load double* %16, align 8, !tbaa !6
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call double @Perl_sv_2nv(%struct.sv* %13) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %17, %cond.true ], [ %call20, %cond.false ]
  %cmp = fcmp olt double %cond, 0.000000e+00
  br i1 %cmp, label %if.then21, label %if.end23

if.then21:                                        ; preds = %cond.end
  %call22 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([22 x i8]* @.str33, i64 0, i64 0), double %cond) #7
  br label %return

if.end23:                                         ; preds = %cond.end
  %call24 = tail call double @sqrt(double %cond) #7
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call24) #7
  %sv_flags25 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %18 = load i32* %sv_flags25, align 4, !tbaa !4
  %and26 = and i32 %18, 16384
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.end23
  %call29 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end30

if.end30:                                         ; preds = %if.end23, %if.then28
  %19 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp31 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end30
  %call33 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end30
  %sp.0 = phi %struct.sv** [ %call33, %if.then32 ], [ %incdec.ptr, %if.end30 ]
  %incdec.ptr35 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr35, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr35, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next36 = getelementptr inbounds %struct.op* %20, i64 0, i32 0
  %21 = load %struct.op** %op_next36, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end34, %if.then21, %if.end14
  %retval.0 = phi %struct.op* [ %12, %if.end14 ], [ %call22, %if.then21 ], [ %21, %if.end34 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare double @sqrt(double) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_int() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 64, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %11 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %12, 65536
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv to i64*
  %15 = load i64* %14, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call i64 @Perl_sv_2iv(%struct.sv* %11) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags21.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre170 = load i32* %sv_flags21.phi.trans.insert, align 4, !tbaa !4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %16 = phi i32 [ %12, %cond.true ], [ %.pre170, %cond.false ]
  %17 = phi %struct.sv* [ %11, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i64 [ %15, %cond.true ], [ %call20, %cond.false ]
  %and22 = and i32 %16, 118423552
  %tobool23 = icmp eq i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.else31

if.then24:                                        ; preds = %cond.end
  tail call void @Perl_sv_setuv(%struct.sv* %4, i64 0) #7
  %sv_flags25 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %18 = load i32* %sv_flags25, align 4, !tbaa !4
  %and26 = and i32 %18, 16384
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.then24
  %call29 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end30

if.end30:                                         ; preds = %if.then24, %if.then28
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else31:                                        ; preds = %cond.end
  %and33 = and i32 %16, 65536
  %tobool34 = icmp eq i32 %and33, 0
  br i1 %tobool34, label %if.else63, label %if.then35

if.then35:                                        ; preds = %if.else31
  %tobool38 = icmp slt i32 %16, 0
  br i1 %tobool38, label %cond.end47, label %if.else55

cond.end47:                                       ; preds = %if.then35
  %sv_any44 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %19 = load i8** %sv_any44, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %19, i64 24
  %20 = bitcast i8* %xuv_uv to i64*
  %21 = load i64* %20, align 8, !tbaa !3
  tail call void @Perl_sv_setuv(%struct.sv* %4, i64 %21) #7
  %sv_flags49 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %22 = load i32* %sv_flags49, align 4, !tbaa !4
  %and50 = and i32 %22, 16384
  %tobool51 = icmp eq i32 %and50, 0
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %cond.end47
  %call53 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end54

if.end54:                                         ; preds = %cond.end47, %if.then52
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else55:                                        ; preds = %if.then35
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %cond) #7
  %sv_flags56 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %23 = load i32* %sv_flags56, align 4, !tbaa !4
  %and57 = and i32 %23, 16384
  %tobool58 = icmp eq i32 %and57, 0
  br i1 %tobool58, label %if.end61, label %if.then59

if.then59:                                        ; preds = %if.else55
  %call60 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end61

if.end61:                                         ; preds = %if.else55, %if.then59
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else63:                                        ; preds = %if.else31
  %and65 = and i32 %16, 131072
  %tobool66 = icmp eq i32 %and65, 0
  br i1 %tobool66, label %cond.false69, label %cond.true67

cond.true67:                                      ; preds = %if.else63
  %sv_any68 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %24 = load i8** %sv_any68, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %24, i64 32
  %25 = bitcast i8* %xnv_nv to double*
  %26 = load double* %25, align 8, !tbaa !6
  br label %cond.end71

cond.false69:                                     ; preds = %if.else63
  %call70 = tail call double @Perl_sv_2nv(%struct.sv* %17) #7
  br label %cond.end71

cond.end71:                                       ; preds = %cond.false69, %cond.true67
  %cond72 = phi double [ %26, %cond.true67 ], [ %call70, %cond.false69 ]
  %cmp = fcmp ult double %cond72, 0.000000e+00
  br i1 %cmp, label %if.else92, label %if.then73

if.then73:                                        ; preds = %cond.end71
  %cmp74 = fcmp olt double %cond72, 0x43F0000000000000
  br i1 %cmp74, label %if.then75, label %if.else83

if.then75:                                        ; preds = %if.then73
  %call76 = tail call i64 @Perl_cast_uv(double %cond72) #7
  tail call void @Perl_sv_setuv(%struct.sv* %4, i64 %call76) #7
  %sv_flags77 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %27 = load i32* %sv_flags77, align 4, !tbaa !4
  %and78 = and i32 %27, 16384
  %tobool79 = icmp eq i32 %and78, 0
  br i1 %tobool79, label %if.end82, label %if.then80

if.then80:                                        ; preds = %if.then75
  %call81 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end82

if.end82:                                         ; preds = %if.then75, %if.then80
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else83:                                        ; preds = %if.then73
  %call84 = tail call double @floor(double %cond72) #9
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call84) #7
  %sv_flags85 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %28 = load i32* %sv_flags85, align 4, !tbaa !4
  %and86 = and i32 %28, 16384
  %tobool87 = icmp eq i32 %and86, 0
  br i1 %tobool87, label %if.end90, label %if.then88

if.then88:                                        ; preds = %if.else83
  %call89 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end90

if.end90:                                         ; preds = %if.else83, %if.then88
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else92:                                        ; preds = %cond.end71
  %cmp93 = fcmp ogt double %cond72, 0xC3E0000000000000
  br i1 %cmp93, label %if.then94, label %if.else102

if.then94:                                        ; preds = %if.else92
  %call95 = tail call i64 @Perl_cast_iv(double %cond72) #7
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %call95) #7
  %sv_flags96 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %29 = load i32* %sv_flags96, align 4, !tbaa !4
  %and97 = and i32 %29, 16384
  %tobool98 = icmp eq i32 %and97, 0
  br i1 %tobool98, label %if.end101, label %if.then99

if.then99:                                        ; preds = %if.then94
  %call100 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end101

if.end101:                                        ; preds = %if.then94, %if.then99
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else102:                                       ; preds = %if.else92
  %call103 = tail call double @ceil(double %cond72) #9
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %call103) #7
  %sv_flags104 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %30 = load i32* %sv_flags104, align 4, !tbaa !4
  %and105 = and i32 %30, 16384
  %tobool106 = icmp eq i32 %and105, 0
  br i1 %tobool106, label %if.end109, label %if.then107

if.then107:                                       ; preds = %if.else102
  %call108 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end109

if.end109:                                        ; preds = %if.else102, %if.then107
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end30, %if.end90, %if.end82, %if.end109, %if.end101, %if.end54, %if.end61, %if.end14
  %storemerge169 = phi %struct.sv** [ %8, %if.end14 ], [ %0, %if.end61 ], [ %0, %if.end54 ], [ %0, %if.end101 ], [ %0, %if.end109 ], [ %0, %if.end82 ], [ %0, %if.end90 ], [ %0, %if.end30 ]
  store %struct.sv** %storemerge169, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i64 @Perl_cast_iv(double) #1

; Function Attrs: nounwind optsize readnone
declare double @ceil(double) #5

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_abs() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load i64* @PL_amagic_generation, align 8, !tbaa !3
  %tobool = icmp eq i64 %5, 0
  br i1 %tobool, label %if.end16, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %7, 268435456
  %tobool2 = icmp eq i32 %and, 0
  br i1 %tobool2, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %call = tail call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 1, i32 9) #7
  %tobool3 = icmp eq %struct.sv* %call, null
  br i1 %tobool3, label %if.end16, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %sv_flags5 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags5, align 4, !tbaa !4
  %and6 = and i32 %9, 1024
  %tobool7 = icmp eq i32 %and6, 0
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.then4
  tail call void @Perl_sv_setsv_flags(%struct.sv* %4, %struct.sv* %call, i32 2) #7
  %10 = load i32* %sv_flags5, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.then8
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end14

if.end14:                                         ; preds = %if.then4, %if.then12, %if.then8
  %storemerge = phi %struct.sv* [ %4, %if.then8 ], [ %4, %if.then12 ], [ %call, %if.then4 ]
  store %struct.sv* %storemerge, %struct.sv** %8, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %entry, %if.then
  %11 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags17 = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags17, align 4, !tbaa !4
  %and18 = and i32 %12, 65536
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end16
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %13 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv to i64*
  %15 = load i64* %14, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  %call20 = tail call i64 @Perl_sv_2iv(%struct.sv* %11) #7
  %.pre = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags21.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre158 = load i32* %sv_flags21.phi.trans.insert, align 4, !tbaa !4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %16 = phi i32 [ %12, %cond.true ], [ %.pre158, %cond.false ]
  %17 = phi %struct.sv* [ %11, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i64 [ %15, %cond.true ], [ %call20, %cond.false ]
  %and22 = and i32 %16, 118423552
  %tobool23 = icmp eq i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.else31

if.then24:                                        ; preds = %cond.end
  tail call void @Perl_sv_setuv(%struct.sv* %4, i64 0) #7
  %sv_flags25 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %18 = load i32* %sv_flags25, align 4, !tbaa !4
  %and26 = and i32 %18, 16384
  %tobool27 = icmp eq i32 %and26, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.then24
  %call29 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end30

if.end30:                                         ; preds = %if.then24, %if.then28
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else31:                                        ; preds = %cond.end
  %and33 = and i32 %16, 65536
  %tobool34 = icmp eq i32 %and33, 0
  br i1 %tobool34, label %if.else82, label %if.then35

if.then35:                                        ; preds = %if.else31
  %tobool38 = icmp slt i32 %16, 0
  br i1 %tobool38, label %cond.end47, label %if.else55

cond.end47:                                       ; preds = %if.then35
  %sv_any44 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %19 = load i8** %sv_any44, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %19, i64 24
  %20 = bitcast i8* %xuv_uv to i64*
  %21 = load i64* %20, align 8, !tbaa !3
  tail call void @Perl_sv_setuv(%struct.sv* %4, i64 %21) #7
  %sv_flags49 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %22 = load i32* %sv_flags49, align 4, !tbaa !4
  %and50 = and i32 %22, 16384
  %tobool51 = icmp eq i32 %and50, 0
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %cond.end47
  %call53 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end54

if.end54:                                         ; preds = %cond.end47, %if.then52
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else55:                                        ; preds = %if.then35
  %cmp = icmp sgt i64 %cond, -1
  br i1 %cmp, label %if.then56, label %if.else63

if.then56:                                        ; preds = %if.else55
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %cond) #7
  %sv_flags57 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %23 = load i32* %sv_flags57, align 4, !tbaa !4
  %and58 = and i32 %23, 16384
  %tobool59 = icmp eq i32 %and58, 0
  br i1 %tobool59, label %if.end62, label %if.then60

if.then60:                                        ; preds = %if.then56
  %call61 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end62

if.end62:                                         ; preds = %if.then56, %if.then60
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else63:                                        ; preds = %if.else55
  %cmp64 = icmp eq i64 %cond, -9223372036854775808
  br i1 %cmp64, label %if.else72, label %if.then65

if.then65:                                        ; preds = %if.else63
  %sub = sub nsw i64 0, %cond
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %sub) #7
  %sv_flags66 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %24 = load i32* %sv_flags66, align 4, !tbaa !4
  %and67 = and i32 %24, 16384
  %tobool68 = icmp eq i32 %and67, 0
  br i1 %tobool68, label %if.end71, label %if.then69

if.then69:                                        ; preds = %if.then65
  %call70 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end71

if.end71:                                         ; preds = %if.then65, %if.then69
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else72:                                        ; preds = %if.else63
  tail call void @Perl_sv_setuv(%struct.sv* %4, i64 -9223372036854775808) #7
  %sv_flags73 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %25 = load i32* %sv_flags73, align 4, !tbaa !4
  %and74 = and i32 %25, 16384
  %tobool75 = icmp eq i32 %and74, 0
  br i1 %tobool75, label %if.end78, label %if.then76

if.then76:                                        ; preds = %if.else72
  %call77 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end78

if.end78:                                         ; preds = %if.else72, %if.then76
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

if.else82:                                        ; preds = %if.else31
  %and84 = and i32 %16, 131072
  %tobool85 = icmp eq i32 %and84, 0
  br i1 %tobool85, label %cond.false88, label %cond.true86

cond.true86:                                      ; preds = %if.else82
  %sv_any87 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %26 = load i8** %sv_any87, align 8, !tbaa !0
  %xnv_nv = getelementptr inbounds i8* %26, i64 32
  %27 = bitcast i8* %xnv_nv to double*
  %28 = load double* %27, align 8, !tbaa !6
  br label %cond.end90

cond.false88:                                     ; preds = %if.else82
  %call89 = tail call double @Perl_sv_2nv(%struct.sv* %17) #7
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false88, %cond.true86
  %cond91 = phi double [ %28, %cond.true86 ], [ %call89, %cond.false88 ]
  %cmp92 = fcmp olt double %cond91, 0.000000e+00
  br i1 %cmp92, label %if.then93, label %if.end95

if.then93:                                        ; preds = %cond.end90
  %sub94 = fsub double -0.000000e+00, %cond91
  br label %if.end95

if.end95:                                         ; preds = %if.then93, %cond.end90
  %value.0 = phi double [ %sub94, %if.then93 ], [ %cond91, %cond.end90 ]
  tail call void @Perl_sv_setnv(%struct.sv* %4, double %value.0) #7
  %sv_flags96 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %29 = load i32* %sv_flags96, align 4, !tbaa !4
  %and97 = and i32 %29, 16384
  %tobool98 = icmp eq i32 %and97, 0
  br i1 %tobool98, label %if.end101, label %if.then99

if.then99:                                        ; preds = %if.end95
  %call100 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end101

if.end101:                                        ; preds = %if.end95, %if.then99
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end30, %if.end54, %if.end71, %if.end78, %if.end62, %if.end101, %if.end14
  %storemerge157 = phi %struct.sv** [ %8, %if.end14 ], [ %0, %if.end101 ], [ %0, %if.end62 ], [ %0, %if.end78 ], [ %0, %if.end71 ], [ %0, %if.end54 ], [ %0, %if.end30 ]
  store %struct.sv** %storemerge157, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_hex() #0 {
entry:
  %flags = alloca i32, align 4
  %len = alloca i64, align 8
  %result_nv = alloca double, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  store i32 1, i32* %flags, align 4, !tbaa !4
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !3
  store i64 %9, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %7 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %len, i32 2) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %11 = phi i32 [ %6, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %10, %cond.true ], [ %call, %cond.false ]
  %and3 = and i32 %11, 536870912
  %tobool = icmp eq i32 %and3, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %12, i64 0, i32 7
  %13 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %13, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call6 = call %struct.sv* @Perl_newSVsv(%struct.sv* %5) #7
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call6) #7
  %sv_flags8 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 2
  %14 = load i32* %sv_flags8, align 4, !tbaa !4
  %or = or i32 %14, 536870912
  store i32 %or, i32* %sv_flags8, align 4, !tbaa !4
  %call9 = call signext i8 @Perl_sv_utf8_downgrade(%struct.sv* %call7, i8 signext 0) #7
  %sv_any10 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 0
  %15 = load i8** %sv_any10, align 8, !tbaa !0
  %xpv_pv11 = bitcast i8* %15 to i8**
  %16 = load i8** %xpv_pv11, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %cond.end, %if.then
  %tmps.0 = phi i8* [ %cond, %land.lhs.true ], [ %16, %if.then ], [ %cond, %cond.end ]
  %call12 = call i64 @Perl_grok_hex(i8* %tmps.0, i64* %len, i32* %flags, double* %result_nv) #7
  %17 = load i32* %flags, align 4, !tbaa !4
  %and13 = and i32 %17, 2
  %tobool14 = icmp eq i32 %and13, 0
  br i1 %tobool14, label %if.else, label %if.then15

if.then15:                                        ; preds = %if.end
  %18 = load double* %result_nv, align 8, !tbaa !6
  call void @Perl_sv_setnv(%struct.sv* %4, double %18) #7
  %sv_flags16 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %19 = load i32* %sv_flags16, align 4, !tbaa !4
  %and17 = and i32 %19, 16384
  %tobool18 = icmp eq i32 %and17, 0
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.then15
  %call20 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end21

if.end21:                                         ; preds = %if.then15, %if.then19
  %20 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %20 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp22 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %call25 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %sp.0 = phi %struct.sv** [ %call25, %if.then24 ], [ %incdec.ptr, %if.end21 ]
  %incdec.ptr27 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr27, align 8, !tbaa !0
  br label %if.end44

if.else:                                          ; preds = %if.end
  call void @Perl_sv_setuv(%struct.sv* %4, i64 %call12) #7
  %sv_flags28 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %21 = load i32* %sv_flags28, align 4, !tbaa !4
  %and29 = and i32 %21, 16384
  %tobool30 = icmp eq i32 %and29, 0
  br i1 %tobool30, label %if.end33, label %if.then31

if.then31:                                        ; preds = %if.else
  %call32 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.then31
  %22 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast34 = ptrtoint %struct.sv** %22 to i64
  %sub.ptr.rhs.cast35 = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub36 = sub i64 %sub.ptr.lhs.cast34, %sub.ptr.rhs.cast35
  %cmp38 = icmp slt i64 %sub.ptr.sub36, 8
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end33
  %call41 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %if.end33
  %sp.1 = phi %struct.sv** [ %call41, %if.then40 ], [ %incdec.ptr, %if.end33 ]
  %incdec.ptr43 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr43, align 8, !tbaa !0
  br label %if.end44

if.end44:                                         ; preds = %if.end42, %if.end26
  %sp.2 = phi %struct.sv** [ %incdec.ptr27, %if.end26 ], [ %incdec.ptr43, %if.end42 ]
  store %struct.sv** %sp.2, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %23 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %23, i64 0, i32 0
  %24 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %24
}

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

; Function Attrs: optsize
declare signext i8 @Perl_sv_utf8_downgrade(%struct.sv*, i8 signext) #1

; Function Attrs: optsize
declare i64 @Perl_grok_hex(i8*, i64*, i32*, double*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_oct() #0 {
entry:
  %flags = alloca i32, align 4
  %len = alloca i64, align 8
  %result_nv = alloca double, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  store i32 1, i32* %flags, align 4, !tbaa !4
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !3
  store i64 %9, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %7 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %len, i32 2) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %11 = phi i32 [ %6, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %10, %cond.true ], [ %call, %cond.false ]
  %and3 = and i32 %11, 536870912
  %tobool = icmp eq i32 %and3, 0
  br i1 %tobool, label %while.cond.preheader, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %12, i64 0, i32 7
  %13 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %13, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %if.then, label %while.cond.preheader

if.then:                                          ; preds = %land.lhs.true
  %call6 = call %struct.sv* @Perl_newSVsv(%struct.sv* %5) #7
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call6) #7
  %sv_flags8 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 2
  %14 = load i32* %sv_flags8, align 4, !tbaa !4
  %or = or i32 %14, 536870912
  store i32 %or, i32* %sv_flags8, align 4, !tbaa !4
  %call9 = call signext i8 @Perl_sv_utf8_downgrade(%struct.sv* %call7, i8 signext 0) #7
  %sv_any10 = getelementptr inbounds %struct.sv* %call7, i64 0, i32 0
  %15 = load i8** %sv_any10, align 8, !tbaa !0
  %xpv_pv11 = bitcast i8* %15 to i8**
  %16 = load i8** %xpv_pv11, align 8, !tbaa !0
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then, %cond.end, %land.lhs.true
  %tmps.0.ph = phi i8* [ %cond, %land.lhs.true ], [ %cond, %cond.end ], [ %16, %if.then ]
  %17 = load i8* %tmps.0.ph, align 1, !tbaa !1
  %tobool13121 = icmp eq i8 %17, 0
  br i1 %tobool13121, label %if.else51, label %land.lhs.true14.lr.ph

land.lhs.true14.lr.ph:                            ; preds = %while.cond.preheader
  %.pre125 = load i64* %len, align 8, !tbaa !3
  br label %land.lhs.true14

land.lhs.true14:                                  ; preds = %land.lhs.true14.lr.ph, %while.body
  %18 = phi i64 [ %.pre125, %land.lhs.true14.lr.ph ], [ %dec, %while.body ]
  %.pr = phi i8 [ %17, %land.lhs.true14.lr.ph ], [ %19, %while.body ]
  %tmps.0122 = phi i8* [ %tmps.0.ph, %land.lhs.true14.lr.ph ], [ %incdec.ptr33, %while.body ]
  %tobool15 = icmp eq i64 %18, 0
  br i1 %tobool15, label %while.end, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true14
  switch i8 %.pr, label %if.end40 [
    i8 32, label %while.body
    i8 9, label %while.body
    i8 10, label %while.body
    i8 13, label %while.body
    i8 12, label %while.body
    i8 48, label %if.then37
  ]

while.body:                                       ; preds = %land.rhs, %land.rhs, %land.rhs, %land.rhs, %land.rhs
  %incdec.ptr33 = getelementptr inbounds i8* %tmps.0122, i64 1
  %dec = add i64 %18, -1
  store i64 %dec, i64* %len, align 8, !tbaa !3
  %19 = load i8* %incdec.ptr33, align 1, !tbaa !1
  %tobool13 = icmp eq i8 %19, 0
  br i1 %tobool13, label %if.else51, label %land.lhs.true14

while.end:                                        ; preds = %land.lhs.true14
  %cmp35 = icmp eq i8 %.pr, 48
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %land.rhs, %while.end
  %incdec.ptr38 = getelementptr inbounds i8* %tmps.0122, i64 1
  %dec39 = add i64 %18, -1
  store i64 %dec39, i64* %len, align 8, !tbaa !3
  %.pre124 = load i8* %incdec.ptr38, align 1, !tbaa !1
  br label %if.end40

if.end40:                                         ; preds = %land.rhs, %if.then37, %while.end
  %20 = phi i8 [ %.pre124, %if.then37 ], [ %.pr, %while.end ], [ %.pr, %land.rhs ]
  %tmps.1 = phi i8* [ %incdec.ptr38, %if.then37 ], [ %tmps.0122, %while.end ], [ %tmps.0122, %land.rhs ]
  switch i8 %20, label %if.else51 [
    i8 120, label %if.then44
    i8 98, label %if.then49
  ]

if.then44:                                        ; preds = %if.end40
  %call45 = call i64 @Perl_grok_hex(i8* %tmps.1, i64* %len, i32* %flags, double* %result_nv) #7
  br label %if.end54

if.then49:                                        ; preds = %if.end40
  %call50 = call i64 @Perl_grok_bin(i8* %tmps.1, i64* %len, i32* %flags, double* %result_nv) #7
  br label %if.end54

if.else51:                                        ; preds = %while.cond.preheader, %while.body, %if.end40
  %tmps.1126 = phi i8* [ %tmps.1, %if.end40 ], [ %incdec.ptr33, %while.body ], [ %tmps.0.ph, %while.cond.preheader ]
  %call52 = call i64 @Perl_grok_oct(i8* %tmps.1126, i64* %len, i32* %flags, double* %result_nv) #7
  br label %if.end54

if.end54:                                         ; preds = %if.then49, %if.else51, %if.then44
  %result_uv.0 = phi i64 [ %call45, %if.then44 ], [ %call50, %if.then49 ], [ %call52, %if.else51 ]
  %21 = load i32* %flags, align 4, !tbaa !4
  %and55 = and i32 %21, 2
  %tobool56 = icmp eq i32 %and55, 0
  br i1 %tobool56, label %if.else70, label %if.then57

if.then57:                                        ; preds = %if.end54
  %22 = load double* %result_nv, align 8, !tbaa !6
  call void @Perl_sv_setnv(%struct.sv* %4, double %22) #7
  %sv_flags58 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %23 = load i32* %sv_flags58, align 4, !tbaa !4
  %and59 = and i32 %23, 16384
  %tobool60 = icmp eq i32 %and59, 0
  br i1 %tobool60, label %if.end63, label %if.then61

if.then61:                                        ; preds = %if.then57
  %call62 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end63

if.end63:                                         ; preds = %if.then57, %if.then61
  %24 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp64 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp64, label %if.then66, label %if.end68

if.then66:                                        ; preds = %if.end63
  %call67 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end68

if.end68:                                         ; preds = %if.then66, %if.end63
  %sp.0 = phi %struct.sv** [ %call67, %if.then66 ], [ %incdec.ptr, %if.end63 ]
  %incdec.ptr69 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr69, align 8, !tbaa !0
  br label %if.end87

if.else70:                                        ; preds = %if.end54
  call void @Perl_sv_setuv(%struct.sv* %4, i64 %result_uv.0) #7
  %sv_flags71 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %25 = load i32* %sv_flags71, align 4, !tbaa !4
  %and72 = and i32 %25, 16384
  %tobool73 = icmp eq i32 %and72, 0
  br i1 %tobool73, label %if.end76, label %if.then74

if.then74:                                        ; preds = %if.else70
  %call75 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end76

if.end76:                                         ; preds = %if.else70, %if.then74
  %26 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast77 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.rhs.cast78 = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub79 = sub i64 %sub.ptr.lhs.cast77, %sub.ptr.rhs.cast78
  %cmp81 = icmp slt i64 %sub.ptr.sub79, 8
  br i1 %cmp81, label %if.then83, label %if.end85

if.then83:                                        ; preds = %if.end76
  %call84 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end85

if.end85:                                         ; preds = %if.then83, %if.end76
  %sp.1 = phi %struct.sv** [ %call84, %if.then83 ], [ %incdec.ptr, %if.end76 ]
  %incdec.ptr86 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr86, align 8, !tbaa !0
  br label %if.end87

if.end87:                                         ; preds = %if.end85, %if.end68
  %sp.2 = phi %struct.sv** [ %incdec.ptr69, %if.end68 ], [ %incdec.ptr86, %if.end85 ]
  store %struct.sv** %sp.2, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %27 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %27, i64 0, i32 0
  %28 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %28
}

; Function Attrs: optsize
declare i64 @Perl_grok_bin(i8*, i64*, i32*, double*) #1

; Function Attrs: optsize
declare i64 @Perl_grok_oct(i8*, i64*, i32*, double*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_length() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 536870912
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %7, i64 0, i32 7
  %8 = load i8* %op_private, align 1, !tbaa !1
  %and1 = and i8 %8, 8
  %tobool2 = icmp eq i8 %and1, 0
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %call = tail call i64 @Perl_sv_len_utf8(%struct.sv* %5) #7
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %call) #7
  %sv_flags3 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %9 = load i32* %sv_flags3, align 4, !tbaa !4
  %and4 = and i32 %9, 16384
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.end15, label %if.then6

if.then6:                                         ; preds = %if.then
  %call7 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end15

if.else:                                          ; preds = %land.lhs.true, %entry
  %call8 = tail call i64 @Perl_sv_len(%struct.sv* %5) #7
  tail call void @Perl_sv_setiv(%struct.sv* %4, i64 %call8) #7
  %sv_flags9 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %10 = load i32* %sv_flags9, align 4, !tbaa !4
  %and10 = and i32 %10, 16384
  %tobool11 = icmp eq i32 %and10, 0
  br i1 %tobool11, label %if.end15, label %if.then12

if.then12:                                        ; preds = %if.else
  %call13 = tail call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.else, %if.then6, %if.then
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %11 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %11, i64 0, i32 0
  %12 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %12
}

; Function Attrs: optsize
declare i64 @Perl_sv_len_utf8(%struct.sv*) #1

; Function Attrs: optsize
declare i64 @Perl_sv_len(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_substr() #0 {
entry:
  %curlen = alloca i64, align 8
  %pos = alloca i32, align 4
  %rem = alloca i32, align 4
  %repl_len = alloca i64, align 8
  %n_a = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %5, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !1
  %and2 = and i8 %6, 8
  %tobool3 = icmp eq i8 %and2, 0
  br i1 %tobool3, label %lor.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %call = call i32 @Perl_is_lvalue_sub() #7
  %tobool4 = icmp ne i32 %call, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry, %land.rhs
  %7 = phi i1 [ true, %entry ], [ false, %lor.rhs ], [ %tobool4, %land.rhs ]
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %8, i64 0, i32 12
  %9 = load i32* %cop_arybase, align 4, !tbaa !4
  %10 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private5 = getelementptr inbounds %struct.op* %10, i64 0, i32 7
  %11 = load i8* %op_private5, align 1, !tbaa !1
  %conv6 = zext i8 %11 to i32
  %and7 = and i32 %conv6, 7
  %12 = load i8* @PL_tainting, align 1, !tbaa !1
  %tobool8 = icmp eq i8 %12, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %lor.end
  call void @Perl_sv_untaint(%struct.sv* %4) #7
  br label %if.end

if.end:                                           ; preds = %lor.end, %if.then
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %13 = load i32* %sv_flags, align 4, !tbaa !4
  %and9 = and i32 %13, -536870913
  store i32 %and9, i32* %sv_flags, align 4, !tbaa !4
  %cmp = icmp ugt i32 %and7, 2
  br i1 %cmp, label %if.then11, label %if.end46

if.then11:                                        ; preds = %if.end
  %cmp12 = icmp ugt i32 %and7, 3
  br i1 %cmp12, label %if.then14, label %if.end34

if.then14:                                        ; preds = %if.then11
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %14 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags15 = getelementptr inbounds %struct.sv* %14, i64 0, i32 2
  %15 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %15, 262144
  %cmp17 = icmp eq i32 %and16, 0
  br i1 %cmp17, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then14
  %sv_any = getelementptr inbounds %struct.sv* %14, i64 0, i32 0
  %16 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %16, i64 8
  %17 = bitcast i8* %xpv_cur to i64*
  %18 = load i64* %17, align 8, !tbaa !3
  store i64 %18, i64* %repl_len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %16 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.then14
  %call20 = call i8* @Perl_sv_2pv_flags(%struct.sv* %14, i64* %repl_len, i32 2) #7
  %.pre = load i32* %sv_flags15, align 4, !tbaa !4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %20 = phi i32 [ %15, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %19, %cond.true ], [ %call20, %cond.false ]
  %and22 = and i32 %20, 536870912
  %tobool23 = icmp eq i32 %and22, 0
  br i1 %tobool23, label %land.end32, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private24 = getelementptr inbounds %struct.cop* %21, i64 0, i32 7
  %22 = load i8* %op_private24, align 1, !tbaa !1
  %and26 = and i8 %22, 8
  %tobool27 = icmp eq i8 %and26, 0
  br i1 %tobool27, label %land.rhs28, label %land.end32

land.rhs28:                                       ; preds = %land.lhs.true
  %sv_any29 = getelementptr inbounds %struct.sv* %14, i64 0, i32 0
  %23 = load i8** %sv_any29, align 8, !tbaa !0
  %xpv_cur30 = getelementptr inbounds i8* %23, i64 8
  %24 = bitcast i8* %xpv_cur30 to i64*
  %25 = load i64* %24, align 8, !tbaa !3
  %tobool31 = icmp ne i64 %25, 0
  br label %land.end32

land.end32:                                       ; preds = %land.lhs.true, %cond.end, %land.rhs28
  %26 = phi i1 [ false, %land.lhs.true ], [ false, %cond.end ], [ %tobool31, %land.rhs28 ]
  %conv33 = zext i1 %26 to i8
  br label %if.end34

if.end34:                                         ; preds = %land.end32, %if.then11
  %repl_sv.0 = phi %struct.sv* [ %14, %land.end32 ], [ null, %if.then11 ]
  %repl.0 = phi i8* [ %cond, %land.end32 ], [ null, %if.then11 ]
  %repl_is_utf8.0 = phi i8 [ %conv33, %land.end32 ], [ 0, %if.then11 ]
  %sp.0 = phi %struct.sv** [ %incdec.ptr, %land.end32 ], [ %0, %if.then11 ]
  %incdec.ptr35 = getelementptr inbounds %struct.sv** %sp.0, i64 -1
  %27 = load %struct.sv** %sp.0, align 8, !tbaa !0
  store %struct.sv* %27, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags36 = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %28 = load i32* %sv_flags36, align 4, !tbaa !4
  %and37 = and i32 %28, 65536
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %cond.false41, label %cond.true39

cond.true39:                                      ; preds = %if.end34
  %sv_any40 = getelementptr inbounds %struct.sv* %27, i64 0, i32 0
  %29 = load i8** %sv_any40, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %29, i64 24
  %30 = bitcast i8* %xiv_iv to i64*
  %31 = load i64* %30, align 8, !tbaa !3
  br label %cond.end43

cond.false41:                                     ; preds = %if.end34
  %call42 = call i64 @Perl_sv_2iv(%struct.sv* %27) #7
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false41, %cond.true39
  %cond44 = phi i64 [ %31, %cond.true39 ], [ %call42, %cond.false41 ]
  %conv45 = trunc i64 %cond44 to i32
  br label %if.end46

if.end46:                                         ; preds = %cond.end43, %if.end
  %len.0 = phi i32 [ %conv45, %cond.end43 ], [ 0, %if.end ]
  %repl_sv.1 = phi %struct.sv* [ %repl_sv.0, %cond.end43 ], [ null, %if.end ]
  %repl.1 = phi i8* [ %repl.0, %cond.end43 ], [ null, %if.end ]
  %repl_is_utf8.1 = phi i8 [ %repl_is_utf8.0, %cond.end43 ], [ 0, %if.end ]
  %sp.1 = phi %struct.sv** [ %incdec.ptr35, %cond.end43 ], [ %0, %if.end ]
  %incdec.ptr47 = getelementptr inbounds %struct.sv** %sp.1, i64 -1
  %32 = load %struct.sv** %sp.1, align 8, !tbaa !0
  store %struct.sv* %32, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags48 = getelementptr inbounds %struct.sv* %32, i64 0, i32 2
  %33 = load i32* %sv_flags48, align 4, !tbaa !4
  %and49 = and i32 %33, 65536
  %tobool50 = icmp eq i32 %and49, 0
  br i1 %tobool50, label %cond.false54, label %cond.true51

cond.true51:                                      ; preds = %if.end46
  %sv_any52 = getelementptr inbounds %struct.sv* %32, i64 0, i32 0
  %34 = load i8** %sv_any52, align 8, !tbaa !0
  %xiv_iv53 = getelementptr inbounds i8* %34, i64 24
  %35 = bitcast i8* %xiv_iv53 to i64*
  %36 = load i64* %35, align 8, !tbaa !3
  br label %cond.end56

cond.false54:                                     ; preds = %if.end46
  %call55 = call i64 @Perl_sv_2iv(%struct.sv* %32) #7
  br label %cond.end56

cond.end56:                                       ; preds = %cond.false54, %cond.true51
  %cond57 = phi i64 [ %36, %cond.true51 ], [ %call55, %cond.false54 ]
  %conv58 = trunc i64 %cond57 to i32
  store i32 %conv58, i32* %pos, align 4, !tbaa !4
  %incdec.ptr59 = getelementptr inbounds %struct.sv** %sp.1, i64 -2
  %37 = load %struct.sv** %incdec.ptr47, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr59, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %tobool60 = icmp eq %struct.sv* %repl_sv.1, null
  br i1 %tobool60, label %cond.end56.if.end86_crit_edge, label %if.then61

cond.end56.if.end86_crit_edge:                    ; preds = %cond.end56
  %sv_flags87.pre = getelementptr inbounds %struct.sv* %37, i64 0, i32 2
  br label %if.end86

if.then61:                                        ; preds = %cond.end56
  %tobool62 = icmp eq i8 %repl_is_utf8.1, 0
  %sv_flags64 = getelementptr inbounds %struct.sv* %37, i64 0, i32 2
  %38 = load i32* %sv_flags64, align 4, !tbaa !4
  %and65 = and i32 %38, 536870912
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool62, label %if.else, label %if.then63

if.then63:                                        ; preds = %if.then61
  br i1 %tobool66, label %land.lhs.true67, label %if.then72

land.lhs.true67:                                  ; preds = %if.then63
  %39 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private68 = getelementptr inbounds %struct.cop* %39, i64 0, i32 7
  %40 = load i8* %op_private68, align 1, !tbaa !1
  %and70 = and i8 %40, 8
  %tobool71 = icmp eq i8 %and70, 0
  br i1 %tobool71, label %if.end86, label %if.then72

if.then72:                                        ; preds = %land.lhs.true67, %if.then63
  %call73 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %37, i32 2) #7
  br label %if.end86

if.else:                                          ; preds = %if.then61
  br i1 %tobool66, label %land.lhs.true78, label %if.end86

land.lhs.true78:                                  ; preds = %if.else
  %41 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private79 = getelementptr inbounds %struct.cop* %41, i64 0, i32 7
  %42 = load i8* %op_private79, align 1, !tbaa !1
  %and81 = lshr i8 %42, 3
  %and81.lobit = and i8 %and81, 1
  %43 = xor i8 %and81.lobit, 1
  br label %if.end86

if.end86:                                         ; preds = %land.lhs.true67, %cond.end56.if.end86_crit_edge, %land.lhs.true78, %if.then72, %if.else
  %sv_flags87.pre-phi = phi i32* [ %sv_flags87.pre, %cond.end56.if.end86_crit_edge ], [ %sv_flags64, %land.lhs.true78 ], [ %sv_flags64, %if.then72 ], [ %sv_flags64, %if.else ], [ %sv_flags64, %land.lhs.true67 ]
  %repl_need_utf8_upgrade.0 = phi i8 [ 0, %cond.end56.if.end86_crit_edge ], [ %43, %land.lhs.true78 ], [ 0, %if.then72 ], [ 0, %if.else ], [ 0, %land.lhs.true67 ]
  %44 = load i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  %and88 = and i32 %44, 262144
  %cmp89 = icmp eq i32 %and88, 0
  br i1 %cmp89, label %cond.false96, label %cond.true91

cond.true91:                                      ; preds = %if.end86
  %sv_any92 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %45 = load i8** %sv_any92, align 8, !tbaa !0
  %xpv_cur93 = getelementptr inbounds i8* %45, i64 8
  %46 = bitcast i8* %xpv_cur93 to i64*
  %47 = load i64* %46, align 8, !tbaa !3
  store i64 %47, i64* %curlen, align 8, !tbaa !3
  %xpv_pv95 = bitcast i8* %45 to i8**
  %48 = load i8** %xpv_pv95, align 8, !tbaa !0
  br label %cond.end98

cond.false96:                                     ; preds = %if.end86
  %call97 = call i8* @Perl_sv_2pv_flags(%struct.sv* %37, i64* %curlen, i32 2) #7
  %.pre482 = load i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  br label %cond.end98

cond.end98:                                       ; preds = %cond.false96, %cond.true91
  %49 = phi i32 [ %44, %cond.true91 ], [ %.pre482, %cond.false96 ]
  %cond99 = phi i8* [ %48, %cond.true91 ], [ %call97, %cond.false96 ]
  %and101 = and i32 %49, 536870912
  %tobool102 = icmp eq i32 %and101, 0
  br i1 %tobool102, label %if.end116, label %land.lhs.true103

land.lhs.true103:                                 ; preds = %cond.end98
  %50 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private104 = getelementptr inbounds %struct.cop* %50, i64 0, i32 7
  %51 = load i8* %op_private104, align 1, !tbaa !1
  %and106 = and i8 %51, 8
  %tobool107 = icmp eq i8 %and106, 0
  br i1 %tobool107, label %if.then108, label %if.end116

if.then108:                                       ; preds = %land.lhs.true103
  %call109 = call i64 @Perl_sv_len_utf8(%struct.sv* %37) #7
  %52 = load i64* %curlen, align 8, !tbaa !3
  %cmp110 = icmp eq i64 %call109, %52
  br i1 %cmp110, label %if.end116, label %if.else113

if.else113:                                       ; preds = %if.then108
  store i64 %call109, i64* %curlen, align 8, !tbaa !3
  br label %if.end116

if.end116:                                        ; preds = %if.then108, %land.lhs.true103, %cond.end98, %if.else113
  %utf8_curlen.0 = phi i64 [ %call109, %if.else113 ], [ 0, %cond.end98 ], [ 0, %land.lhs.true103 ], [ 0, %if.then108 ]
  %53 = load i32* %pos, align 4, !tbaa !4
  %cmp117 = icmp slt i32 %53, %9
  br i1 %cmp117, label %if.else140, label %if.then119

if.then119:                                       ; preds = %if.end116
  %sub = sub nsw i32 %53, %9
  store i32 %sub, i32* %pos, align 4, !tbaa !4
  %54 = load i64* %curlen, align 8, !tbaa !3
  %conv120480 = zext i32 %sub to i64
  %sub121 = sub i64 %54, %conv120480
  %conv122 = trunc i64 %sub121 to i32
  store i32 %conv122, i32* %rem, align 4, !tbaa !4
  br i1 %cmp, label %if.then125, label %if.end174

if.then125:                                       ; preds = %if.then119
  %cmp126 = icmp slt i32 %len.0, 0
  br i1 %cmp126, label %if.then128, label %if.else133

if.then128:                                       ; preds = %if.then125
  %add = add nsw i32 %conv122, %len.0
  %cmp129 = icmp slt i32 %add, 0
  %.add = select i1 %cmp129, i32 0, i32 %add
  store i32 %.add, i32* %rem, align 4, !tbaa !4
  br label %if.end174

if.else133:                                       ; preds = %if.then125
  %cmp134 = icmp sgt i32 %conv122, %len.0
  br i1 %cmp134, label %if.then136, label %if.end174

if.then136:                                       ; preds = %if.else133
  store i32 %len.0, i32* %rem, align 4, !tbaa !4
  br label %if.end174

if.else140:                                       ; preds = %if.end116
  %55 = load i64* %curlen, align 8, !tbaa !3
  %conv141476 = zext i32 %53 to i64
  %add142 = add i64 %55, %conv141476
  %conv143 = trunc i64 %add142 to i32
  store i32 %conv143, i32* %pos, align 4, !tbaa !4
  %cmp144 = icmp ult i32 %and7, 3
  br i1 %cmp144, label %if.then146, label %if.else148

if.then146:                                       ; preds = %if.else140
  %conv147 = trunc i64 %55 to i32
  br label %if.end168

if.else148:                                       ; preds = %if.else140
  %cmp149 = icmp sgt i32 %len.0, -1
  br i1 %cmp149, label %if.then151, label %if.else159

if.then151:                                       ; preds = %if.else148
  %add152 = add nsw i32 %conv143, %len.0
  store i32 %add152, i32* %rem, align 4, !tbaa !4
  %conv153 = trunc i64 %55 to i32
  %cmp154 = icmp sgt i32 %add152, %conv153
  %conv153.add152 = select i1 %cmp154, i32 %conv153, i32 %add152
  br label %if.end168

if.else159:                                       ; preds = %if.else148
  %conv160477 = zext i32 %len.0 to i64
  %add161 = add i64 %55, %conv160477
  %conv162 = trunc i64 %add161 to i32
  %cmp163 = icmp slt i32 %conv162, %conv143
  %.conv162 = select i1 %cmp163, i32 %conv143, i32 %conv162
  br label %if.end168

if.end168:                                        ; preds = %if.then151, %if.then146, %if.else159
  %storemerge486 = phi i32 [ %.conv162, %if.else159 ], [ %conv153.add152, %if.then151 ], [ %conv147, %if.then146 ]
  store i32 %storemerge486, i32* %rem, align 4, !tbaa !4
  %cmp169 = icmp slt i32 %conv143, 0
  br i1 %cmp169, label %if.then171, label %if.end172

if.then171:                                       ; preds = %if.end168
  store i32 0, i32* %pos, align 4, !tbaa !4
  br label %if.end172

if.end172:                                        ; preds = %if.then171, %if.end168
  %56 = phi i32 [ 0, %if.then171 ], [ %conv143, %if.end168 ]
  %sub173 = sub nsw i32 %storemerge486, %56
  store i32 %sub173, i32* %rem, align 4, !tbaa !4
  br label %if.end174

if.end174:                                        ; preds = %if.then119, %if.else133, %if.then136, %if.then128, %if.end172
  %57 = phi i32 [ %.add, %if.then128 ], [ %len.0, %if.then136 ], [ %conv122, %if.else133 ], [ %conv122, %if.then119 ], [ %sub173, %if.end172 ]
  %58 = phi i32 [ %sub, %if.then128 ], [ %sub, %if.then136 ], [ %sub, %if.else133 ], [ %sub, %if.then119 ], [ %56, %if.end172 ]
  %fail.0 = phi i32 [ %conv122, %if.then128 ], [ %conv122, %if.then136 ], [ %conv122, %if.else133 ], [ %conv122, %if.then119 ], [ %storemerge486, %if.end172 ]
  %cmp175 = icmp slt i32 %fail.0, 0
  br i1 %cmp175, label %if.then177, label %if.else211

if.then177:                                       ; preds = %if.end174
  %.not = xor i1 %7, true
  %tobool179 = icmp eq i8* %repl.1, null
  %or.cond = and i1 %tobool179, %.not
  br i1 %or.cond, label %if.end181, label %if.then180

if.then180:                                       ; preds = %if.then177
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([25 x i8]* @.str34, i64 0, i64 0)) #7
  br label %if.end181

if.end181:                                        ; preds = %if.then177, %if.then180
  %59 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %59, i64 0, i32 14
  %60 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp182 = icmp eq %struct.sv* %60, null
  br i1 %cmp182, label %lor.lhs.false200, label %land.lhs.true184

land.lhs.true184:                                 ; preds = %if.end181
  %61 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings185 = getelementptr inbounds %struct.cop* %61, i64 0, i32 14
  %62 = load %struct.sv** %cop_warnings185, align 8, !tbaa !0
  %cmp186 = icmp eq %struct.sv* %62, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp186, label %lor.lhs.false200, label %land.lhs.true188

land.lhs.true188:                                 ; preds = %land.lhs.true184
  %63 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings189 = getelementptr inbounds %struct.cop* %63, i64 0, i32 14
  %64 = load %struct.sv** %cop_warnings189, align 8, !tbaa !0
  %cmp190 = icmp eq %struct.sv* %64, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp190, label %if.then208, label %lor.lhs.false192

lor.lhs.false192:                                 ; preds = %land.lhs.true188
  %65 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings193 = getelementptr inbounds %struct.cop* %65, i64 0, i32 14
  %66 = load %struct.sv** %cop_warnings193, align 8, !tbaa !0
  %sv_any194 = getelementptr inbounds %struct.sv* %66, i64 0, i32 0
  %67 = load i8** %sv_any194, align 8, !tbaa !0
  %xpv_pv195 = bitcast i8* %67 to i8**
  %68 = load i8** %xpv_pv195, align 8, !tbaa !0
  %arrayidx196 = getelementptr inbounds i8* %68, i64 6
  %69 = load i8* %arrayidx196, align 1, !tbaa !1
  %and198 = and i8 %69, 64
  %tobool199 = icmp eq i8 %and198, 0
  br i1 %tobool199, label %lor.lhs.false200, label %if.then208

lor.lhs.false200:                                 ; preds = %lor.lhs.false192, %land.lhs.true184, %if.end181
  %70 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings201 = getelementptr inbounds %struct.cop* %70, i64 0, i32 14
  %71 = load %struct.sv** %cop_warnings201, align 8, !tbaa !0
  %cmp202 = icmp eq %struct.sv* %71, null
  br i1 %cmp202, label %land.lhs.true204, label %if.end209

land.lhs.true204:                                 ; preds = %lor.lhs.false200
  %72 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and206 = and i8 %72, 1
  %tobool207 = icmp eq i8 %and206, 0
  br i1 %tobool207, label %if.end209, label %if.then208

if.then208:                                       ; preds = %lor.lhs.false192, %land.lhs.true204, %land.lhs.true188
  call void (i32, i8*, ...)* @Perl_warner(i32 27, i8* getelementptr inbounds ([25 x i8]* @.str34, i64 0, i64 0)) #7
  br label %if.end209

if.end209:                                        ; preds = %land.lhs.true204, %if.then208, %lor.lhs.false200
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr47, align 8, !tbaa !0
  br label %return

if.else211:                                       ; preds = %if.end174
  %tobool212 = icmp ne i64 %utf8_curlen.0, 0
  br i1 %tobool212, label %if.then213, label %if.end214

if.then213:                                       ; preds = %if.else211
  call void @Perl_sv_pos_u2b(%struct.sv* %37, i32* %pos, i32* %rem) #7
  %.pre483 = load i32* %pos, align 4, !tbaa !4
  br label %if.end214

if.end214:                                        ; preds = %if.then213, %if.else211
  %73 = phi i32 [ %.pre483, %if.then213 ], [ %58, %if.else211 ]
  %idx.ext = sext i32 %73 to i64
  %add.ptr = getelementptr inbounds i8* %cond99, i64 %idx.ext
  %74 = load i32* %sv_flags, align 4, !tbaa !4
  %and216 = and i32 %74, 255
  switch i32 %and216, label %cond.false229 [
    i32 0, label %if.end234
    i32 9, label %cond.true224
  ]

cond.true224:                                     ; preds = %if.end214
  br i1 %7, label %lor.lhs.false226, label %if.then231

lor.lhs.false226:                                 ; preds = %cond.true224
  %sv_refcnt = getelementptr inbounds %struct.sv* %4, i64 0, i32 1
  %75 = load i32* %sv_refcnt, align 4, !tbaa !4
  %cmp227 = icmp ugt i32 %75, 1
  br i1 %cmp227, label %if.then231, label %if.end234

cond.false229:                                    ; preds = %if.end214
  br i1 %7, label %if.then231, label %if.end234

if.then231:                                       ; preds = %cond.false229, %lor.lhs.false226, %cond.true224
  %call232 = call %struct.sv* @Perl_sv_newmortal() #7
  br label %if.end234

if.end234:                                        ; preds = %cond.false229, %lor.lhs.false226, %if.end214, %if.then231
  %targ.0 = phi %struct.sv* [ %call232, %if.then231 ], [ %4, %if.end214 ], [ %4, %lor.lhs.false226 ], [ %4, %cond.false229 ]
  %76 = load i32* %rem, align 4, !tbaa !4
  %conv235 = sext i32 %76 to i64
  call void @Perl_sv_setpvn(%struct.sv* %targ.0, i8* %add.ptr, i64 %conv235) #7
  br i1 %tobool212, label %if.then237, label %if.end239

if.then237:                                       ; preds = %if.end234
  %sv_flags238 = getelementptr inbounds %struct.sv* %targ.0, i64 0, i32 2
  %77 = load i32* %sv_flags238, align 4, !tbaa !4
  %or = or i32 %77, 536870912
  store i32 %or, i32* %sv_flags238, align 4, !tbaa !4
  br label %if.end239

if.end239:                                        ; preds = %if.then237, %if.end234
  %tobool240 = icmp eq i8* %repl.1, null
  br i1 %tobool240, label %if.else285, label %if.then241

if.then241:                                       ; preds = %if.end239
  %tobool242 = icmp eq i8 %repl_need_utf8_upgrade.0, 0
  br i1 %tobool242, label %if.end274, label %if.then243

if.then243:                                       ; preds = %if.then241
  %call244 = call %struct.sv* @Perl_newSVsv(%struct.sv* %repl_sv.1) #7
  %call245 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %call244, i32 2) #7
  %sv_flags246 = getelementptr inbounds %struct.sv* %call244, i64 0, i32 2
  %78 = load i32* %sv_flags246, align 4, !tbaa !4
  %and247 = and i32 %78, 262144
  %cmp248 = icmp eq i32 %and247, 0
  br i1 %cmp248, label %cond.false255, label %cond.true250

cond.true250:                                     ; preds = %if.then243
  %sv_any251 = getelementptr inbounds %struct.sv* %call244, i64 0, i32 0
  %79 = load i8** %sv_any251, align 8, !tbaa !0
  %xpv_cur252 = getelementptr inbounds i8* %79, i64 8
  %80 = bitcast i8* %xpv_cur252 to i64*
  %81 = load i64* %80, align 8, !tbaa !3
  store i64 %81, i64* %repl_len, align 8, !tbaa !3
  %xpv_pv254 = bitcast i8* %79 to i8**
  %82 = load i8** %xpv_pv254, align 8, !tbaa !0
  br label %cond.end257

cond.false255:                                    ; preds = %if.then243
  %call256 = call i8* @Perl_sv_2pv_flags(%struct.sv* %call244, i64* %repl_len, i32 2) #7
  %.pre485 = load i32* %sv_flags246, align 4, !tbaa !4
  br label %cond.end257

cond.end257:                                      ; preds = %cond.false255, %cond.true250
  %83 = phi i32 [ %78, %cond.true250 ], [ %.pre485, %cond.false255 ]
  %cond258 = phi i8* [ %82, %cond.true250 ], [ %call256, %cond.false255 ]
  %and260 = and i32 %83, 536870912
  %tobool261 = icmp eq i32 %and260, 0
  br i1 %tobool261, label %land.end271, label %land.lhs.true262

land.lhs.true262:                                 ; preds = %cond.end257
  %84 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private263 = getelementptr inbounds %struct.cop* %84, i64 0, i32 7
  %85 = load i8* %op_private263, align 1, !tbaa !1
  %and265 = and i8 %85, 8
  %tobool266 = icmp eq i8 %and265, 0
  br i1 %tobool266, label %land.rhs267, label %land.end271

land.rhs267:                                      ; preds = %land.lhs.true262
  %sv_any268 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %86 = load i8** %sv_any268, align 8, !tbaa !0
  %xpv_cur269 = getelementptr inbounds i8* %86, i64 8
  %87 = bitcast i8* %xpv_cur269 to i64*
  %88 = load i64* %87, align 8, !tbaa !3
  %tobool270 = icmp ne i64 %88, 0
  br label %land.end271

land.end271:                                      ; preds = %land.lhs.true262, %cond.end257, %land.rhs267
  %89 = phi i1 [ false, %land.lhs.true262 ], [ false, %cond.end257 ], [ %tobool270, %land.rhs267 ]
  %conv273 = zext i1 %89 to i8
  br label %if.end274

if.end274:                                        ; preds = %if.then241, %land.end271
  %repl.2 = phi i8* [ %cond258, %land.end271 ], [ %repl.1, %if.then241 ]
  %repl_is_utf8.2 = phi i8 [ %conv273, %land.end271 ], [ %repl_is_utf8.1, %if.then241 ]
  %repl_sv_copy.0 = phi %struct.sv* [ %call244, %land.end271 ], [ null, %if.then241 ]
  %90 = load i32* %pos, align 4, !tbaa !4
  %conv275 = sext i32 %90 to i64
  %91 = load i32* %rem, align 4, !tbaa !4
  %conv276 = sext i32 %91 to i64
  %92 = load i64* %repl_len, align 8, !tbaa !3
  call void @Perl_sv_insert(%struct.sv* %37, i64 %conv275, i64 %conv276, i8* %repl.2, i64 %92) #7
  %tobool277 = icmp eq i8 %repl_is_utf8.2, 0
  br i1 %tobool277, label %if.end281, label %if.then278

if.then278:                                       ; preds = %if.end274
  %93 = load i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  %or280 = or i32 %93, 536870912
  store i32 %or280, i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  br label %if.end281

if.end281:                                        ; preds = %if.end274, %if.then278
  %tobool282 = icmp eq %struct.sv* %repl_sv_copy.0, null
  br i1 %tobool282, label %if.end395, label %if.then283

if.then283:                                       ; preds = %if.end281
  call void @Perl_sv_free(%struct.sv* %repl_sv_copy.0) #7
  br label %if.end395

if.else285:                                       ; preds = %if.end239
  br i1 %7, label %if.then287, label %if.end395

if.then287:                                       ; preds = %if.else285
  %94 = load i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  %and289 = and i32 %94, 8192
  %tobool290 = icmp eq i32 %and289, 0
  br i1 %tobool290, label %if.then291, label %if.end349

if.then291:                                       ; preds = %if.then287
  %and293 = and i32 %94, 524288
  %tobool294 = icmp eq i32 %and293, 0
  br i1 %tobool294, label %if.end338, label %if.then295

if.then295:                                       ; preds = %if.then291
  %and297 = and i32 %94, 10223616
  %cmp298 = icmp eq i32 %and297, 262144
  br i1 %cmp298, label %cond.true300, label %cond.false305

cond.true300:                                     ; preds = %if.then295
  %sv_any301 = getelementptr inbounds %struct.sv* %37, i64 0, i32 0
  %95 = load i8** %sv_any301, align 8, !tbaa !0
  %xpv_cur302 = getelementptr inbounds i8* %95, i64 8
  %96 = bitcast i8* %xpv_cur302 to i64*
  %97 = load i64* %96, align 8, !tbaa !3
  store i64 %97, i64* %n_a, align 8, !tbaa !3
  br label %cond.end307

cond.false305:                                    ; preds = %if.then295
  %call306 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %37, i64* %n_a, i32 2) #7
  br label %cond.end307

cond.end307:                                      ; preds = %cond.false305, %cond.true300
  %98 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings309 = getelementptr inbounds %struct.cop* %98, i64 0, i32 14
  %99 = load %struct.sv** %cop_warnings309, align 8, !tbaa !0
  %cmp310 = icmp eq %struct.sv* %99, null
  br i1 %cmp310, label %lor.lhs.false328, label %land.lhs.true312

land.lhs.true312:                                 ; preds = %cond.end307
  %100 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings313 = getelementptr inbounds %struct.cop* %100, i64 0, i32 14
  %101 = load %struct.sv** %cop_warnings313, align 8, !tbaa !0
  %cmp314 = icmp eq %struct.sv* %101, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp314, label %lor.lhs.false328, label %land.lhs.true316

land.lhs.true316:                                 ; preds = %land.lhs.true312
  %102 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings317 = getelementptr inbounds %struct.cop* %102, i64 0, i32 14
  %103 = load %struct.sv** %cop_warnings317, align 8, !tbaa !0
  %cmp318 = icmp eq %struct.sv* %103, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp318, label %if.then336, label %lor.lhs.false320

lor.lhs.false320:                                 ; preds = %land.lhs.true316
  %104 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings321 = getelementptr inbounds %struct.cop* %104, i64 0, i32 14
  %105 = load %struct.sv** %cop_warnings321, align 8, !tbaa !0
  %sv_any322 = getelementptr inbounds %struct.sv* %105, i64 0, i32 0
  %106 = load i8** %sv_any322, align 8, !tbaa !0
  %xpv_pv323 = bitcast i8* %106 to i8**
  %107 = load i8** %xpv_pv323, align 8, !tbaa !0
  %arrayidx324 = getelementptr inbounds i8* %107, i64 6
  %108 = load i8* %arrayidx324, align 1, !tbaa !1
  %and326 = and i8 %108, 64
  %tobool327 = icmp eq i8 %and326, 0
  br i1 %tobool327, label %lor.lhs.false328, label %if.then336

lor.lhs.false328:                                 ; preds = %lor.lhs.false320, %land.lhs.true312, %cond.end307
  %109 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings329 = getelementptr inbounds %struct.cop* %109, i64 0, i32 14
  %110 = load %struct.sv** %cop_warnings329, align 8, !tbaa !0
  %cmp330 = icmp eq %struct.sv* %110, null
  br i1 %cmp330, label %land.lhs.true332, label %if.end338

land.lhs.true332:                                 ; preds = %lor.lhs.false328
  %111 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and334 = and i8 %111, 1
  %tobool335 = icmp eq i8 %and334, 0
  br i1 %tobool335, label %if.end338, label %if.then336

if.then336:                                       ; preds = %lor.lhs.false320, %land.lhs.true332, %land.lhs.true316
  call void (i32, i8*, ...)* @Perl_warner(i32 27, i8* getelementptr inbounds ([45 x i8]* @.str35, i64 0, i64 0)) #7
  br label %if.end338

if.end338:                                        ; preds = %land.lhs.true332, %lor.lhs.false328, %if.then291, %if.then336
  %112 = load i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  %and340 = and i32 %112, 118423552
  %tobool341 = icmp eq i32 %and340, 0
  br i1 %tobool341, label %if.else347, label %if.then342

if.then342:                                       ; preds = %if.end338
  %and344 = and i32 %112, 1760624639
  %or346 = or i32 %and344, 67371008
  store i32 %or346, i32* %sv_flags87.pre-phi, align 4, !tbaa !4
  br label %if.end349

if.else347:                                       ; preds = %if.end338
  call void @Perl_sv_setpvn(%struct.sv* %37, i8* getelementptr inbounds ([1 x i8]* @.str4, i64 0, i64 0), i64 0) #7
  br label %if.end349

if.end349:                                        ; preds = %if.then287, %if.then342, %if.else347
  %sv_flags350 = getelementptr inbounds %struct.sv* %targ.0, i64 0, i32 2
  %113 = load i32* %sv_flags350, align 4, !tbaa !4
  %and351 = and i32 %113, 255
  %cmp352 = icmp ult i32 %and351, 9
  br i1 %cmp352, label %if.then354, label %if.else356

if.then354:                                       ; preds = %if.end349
  %call355 = call signext i8 @Perl_sv_upgrade(%struct.sv* %targ.0, i32 9) #7
  call void @Perl_sv_magic(%struct.sv* %targ.0, %struct.sv* null, i32 120, i8* null, i32 0) #7
  br label %if.end367

if.else356:                                       ; preds = %if.end349
  %and358 = and i32 %113, 1223753727
  store i32 %and358, i32* %sv_flags350, align 4, !tbaa !4
  %and360 = and i32 %113, 2097152
  %tobool361 = icmp eq i32 %and360, 0
  br i1 %tobool361, label %if.end367, label %land.rhs362

land.rhs362:                                      ; preds = %if.else356
  %call363 = call i32 @Perl_sv_backoff(%struct.sv* %targ.0) #7
  br label %if.end367

if.end367:                                        ; preds = %land.rhs362, %if.else356, %if.then354
  %sv_any368 = getelementptr inbounds %struct.sv* %targ.0, i64 0, i32 0
  %114 = load i8** %sv_any368, align 8, !tbaa !0
  %115 = getelementptr inbounds i8* %114, i64 80
  store i8 120, i8* %115, align 1, !tbaa !1
  %116 = load i8** %sv_any368, align 8, !tbaa !0
  %xlv_targ = getelementptr inbounds i8* %116, i64 72
  %117 = bitcast i8* %xlv_targ to %struct.sv**
  %118 = load %struct.sv** %117, align 8, !tbaa !0
  %cmp370 = icmp eq %struct.sv* %118, %37
  br i1 %cmp370, label %if.end388, label %if.then372

if.then372:                                       ; preds = %if.end367
  %tobool375 = icmp eq %struct.sv* %118, null
  br i1 %tobool375, label %if.end379, label %if.then376

if.then376:                                       ; preds = %if.then372
  call void @Perl_sv_free(%struct.sv* %118) #7
  br label %if.end379

if.end379:                                        ; preds = %if.then372, %if.then376
  store %struct.sv* %37, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool380 = icmp eq %struct.sv* %37, null
  br i1 %tobool380, label %land.end384, label %land.rhs381

land.rhs381:                                      ; preds = %if.end379
  %sv_refcnt382 = getelementptr inbounds %struct.sv* %37, i64 0, i32 1
  %119 = load i32* %sv_refcnt382, align 4, !tbaa !4
  %inc = add i32 %119, 1
  store i32 %inc, i32* %sv_refcnt382, align 4, !tbaa !4
  br label %land.end384

land.end384:                                      ; preds = %if.end379, %land.rhs381
  %120 = load i8** %sv_any368, align 8, !tbaa !0
  %xlv_targ387 = getelementptr inbounds i8* %120, i64 72
  %121 = bitcast i8* %xlv_targ387 to %struct.sv**
  store %struct.sv* %37, %struct.sv** %121, align 8, !tbaa !0
  %.pre484 = load i8** %sv_any368, align 8, !tbaa !0
  br label %if.end388

if.end388:                                        ; preds = %if.end367, %land.end384
  %122 = phi i8* [ %116, %if.end367 ], [ %.pre484, %land.end384 ]
  %conv389 = sext i32 %58 to i64
  %xlv_targoff = getelementptr inbounds i8* %122, i64 56
  %123 = bitcast i8* %xlv_targoff to i64*
  store i64 %conv389, i64* %123, align 8, !tbaa !3
  %conv391 = sext i32 %57 to i64
  %xlv_targlen = getelementptr inbounds i8* %122, i64 64
  %124 = bitcast i8* %xlv_targlen to i64*
  store i64 %conv391, i64* %124, align 8, !tbaa !3
  br label %if.end395

if.end395:                                        ; preds = %if.end281, %if.then283, %if.end388, %if.else285
  %125 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr396 = getelementptr inbounds %struct.sv** %125, i64 1
  store %struct.sv* %targ.0, %struct.sv** %incdec.ptr396, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end395, %if.end209
  %storemerge = phi %struct.sv** [ %incdec.ptr396, %if.end395 ], [ %incdec.ptr47, %if.end209 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_untaint(%struct.sv*) #1

; Function Attrs: optsize
declare i64 @Perl_sv_utf8_upgrade_flags(%struct.sv*, i32) #1

; Function Attrs: optsize
declare void @Perl_sv_pos_u2b(%struct.sv*, i32*, i32*) #1

; Function Attrs: optsize
declare void @Perl_sv_insert(%struct.sv*, i64, i64, i8*, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_vec() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 65536
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %7, i64 24
  %8 = bitcast i8* %xiv_iv to i64*
  %9 = load i64* %8, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call i64 @Perl_sv_2iv(%struct.sv* %5) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ %call, %cond.false ]
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %0, i64 -2
  %10 = load %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags2 = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %11 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %11, 65536
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %cond.false8, label %cond.true5

cond.true5:                                       ; preds = %cond.end
  %sv_any6 = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %12 = load i8** %sv_any6, align 8, !tbaa !0
  %xiv_iv7 = getelementptr inbounds i8* %12, i64 24
  %13 = bitcast i8* %xiv_iv7 to i64*
  %14 = load i64* %13, align 8, !tbaa !3
  br label %cond.end10

cond.false8:                                      ; preds = %cond.end
  %call9 = tail call i64 @Perl_sv_2iv(%struct.sv* %10) #7
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.true5
  %cond11 = phi i64 [ %14, %cond.true5 ], [ %call9, %cond.false8 ]
  %15 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %16 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %16, i64 0, i32 6
  %17 = load i8* %op_flags, align 1, !tbaa !1
  %and13 = and i8 %17, 32
  %tobool14 = icmp eq i8 %and13, 0
  br i1 %tobool14, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %cond.end10
  %op_private = getelementptr inbounds %struct.op* %16, i64 0, i32 7
  %18 = load i8* %op_private, align 1, !tbaa !1
  %and16 = and i8 %18, 8
  %tobool17 = icmp eq i8 %and16, 0
  br i1 %tobool17, label %lor.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %call18 = tail call i32 @Perl_is_lvalue_sub() #7
  %tobool19 = icmp ne i32 %call18, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end10, %land.rhs
  %19 = phi i1 [ true, %cond.end10 ], [ false, %lor.rhs ], [ %tobool19, %land.rhs ]
  %20 = load i8* @PL_tainting, align 1, !tbaa !1
  %tobool20 = icmp eq i8 %20, 0
  br i1 %tobool20, label %if.end, label %if.then

if.then:                                          ; preds = %lor.end
  tail call void @Perl_sv_untaint(%struct.sv* %4) #7
  br label %if.end

if.end:                                           ; preds = %lor.end, %if.then
  br i1 %19, label %if.then22, label %if.end56

if.then22:                                        ; preds = %if.end
  %sv_refcnt = getelementptr inbounds %struct.sv* %4, i64 0, i32 1
  %21 = load i32* %sv_refcnt, align 4, !tbaa !4
  %cmp = icmp ugt i32 %21, 1
  br i1 %cmp, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.then22
  %call25 = tail call %struct.sv* @Perl_sv_newmortal() #7
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.then22
  %targ.0 = phi %struct.sv* [ %call25, %if.then24 ], [ %4, %if.then22 ]
  %sv_flags27 = getelementptr inbounds %struct.sv* %targ.0, i64 0, i32 2
  %22 = load i32* %sv_flags27, align 4, !tbaa !4
  %and28 = and i32 %22, 255
  %cmp29 = icmp ult i32 %and28, 9
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end26
  %call32 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %targ.0, i32 9) #7
  tail call void @Perl_sv_magic(%struct.sv* %targ.0, %struct.sv* null, i32 118, i8* null, i32 0) #7
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end26
  %sv_any34 = getelementptr inbounds %struct.sv* %targ.0, i64 0, i32 0
  %23 = load i8** %sv_any34, align 8, !tbaa !0
  %24 = getelementptr inbounds i8* %23, i64 80
  store i8 118, i8* %24, align 1, !tbaa !1
  %25 = load i8** %sv_any34, align 8, !tbaa !0
  %xlv_targ = getelementptr inbounds i8* %25, i64 72
  %26 = bitcast i8* %xlv_targ to %struct.sv**
  %27 = load %struct.sv** %26, align 8, !tbaa !0
  %cmp36 = icmp eq %struct.sv* %27, %15
  br i1 %cmp36, label %if.end53, label %if.then38

if.then38:                                        ; preds = %if.end33
  %tobool41 = icmp eq %struct.sv* %27, null
  br i1 %tobool41, label %if.end45, label %if.then42

if.then42:                                        ; preds = %if.then38
  tail call void @Perl_sv_free(%struct.sv* %27) #7
  br label %if.end45

if.end45:                                         ; preds = %if.then38, %if.then42
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool46 = icmp eq %struct.sv* %15, null
  br i1 %tobool46, label %land.end50, label %land.rhs47

land.rhs47:                                       ; preds = %if.end45
  %sv_refcnt48 = getelementptr inbounds %struct.sv* %15, i64 0, i32 1
  %28 = load i32* %sv_refcnt48, align 4, !tbaa !4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %sv_refcnt48, align 4, !tbaa !4
  br label %land.end50

land.end50:                                       ; preds = %if.end45, %land.rhs47
  %29 = load i8** %sv_any34, align 8, !tbaa !0
  %xlv_targ52 = getelementptr inbounds i8* %29, i64 72
  %30 = bitcast i8* %xlv_targ52 to %struct.sv**
  store %struct.sv* %15, %struct.sv** %30, align 8, !tbaa !0
  %.pre = load i8** %sv_any34, align 8, !tbaa !0
  br label %if.end53

if.end53:                                         ; preds = %if.end33, %land.end50
  %31 = phi i8* [ %25, %if.end33 ], [ %.pre, %land.end50 ]
  %xlv_targoff = getelementptr inbounds i8* %31, i64 56
  %32 = bitcast i8* %xlv_targoff to i64*
  store i64 %cond11, i64* %32, align 8, !tbaa !3
  %xlv_targlen = getelementptr inbounds i8* %31, i64 64
  %33 = bitcast i8* %xlv_targlen to i64*
  store i64 %cond, i64* %33, align 8, !tbaa !3
  br label %if.end56

if.end56:                                         ; preds = %if.end53, %if.end
  %targ.1 = phi %struct.sv* [ %targ.0, %if.end53 ], [ %4, %if.end ]
  %conv57 = trunc i64 %cond11 to i32
  %conv58 = trunc i64 %cond to i32
  %call59 = tail call i64 @Perl_do_vecget(%struct.sv* %15, i32 %conv57, i32 %conv58) #7
  tail call void @Perl_sv_setuv(%struct.sv* %targ.1, i64 %call59) #7
  store %struct.sv* %targ.1, %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr1, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %34 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %34, i64 0, i32 0
  %35 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %35
}

; Function Attrs: optsize
declare i64 @Perl_do_vecget(%struct.sv*, i32, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_index() #0 {
entry:
  %offset = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %biglen = alloca i64, align 8
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %5, i64 0, i32 12
  %6 = load i32* %cop_arybase, align 4, !tbaa !4
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !1
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 15
  %cmp = icmp ult i32 %and, 3
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %9, 65536
  %tobool = icmp eq i32 %and3, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %10, i64 24
  %11 = bitcast i8* %xiv_iv to i64*
  %12 = load i64* %11, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call = call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %12, %cond.true ], [ %call, %cond.false ]
  %conv4136 = zext i32 %6 to i64
  %sub = sub nsw i64 %cond, %conv4136
  %conv5 = trunc i64 %sub to i32
  br label %if.end

if.end:                                           ; preds = %entry, %cond.end
  %storemerge = phi i32 [ %conv5, %cond.end ], [ 0, %entry ]
  %sp.0 = phi %struct.sv** [ %incdec.ptr, %cond.end ], [ %0, %entry ]
  store i32 %storemerge, i32* %offset, align 4, !tbaa !4
  %incdec.ptr6 = getelementptr inbounds %struct.sv** %sp.0, i64 -1
  %13 = load %struct.sv** %sp.0, align 8, !tbaa !0
  %14 = load %struct.sv** %incdec.ptr6, align 8, !tbaa !0
  %sv_flags8 = getelementptr inbounds %struct.sv* %14, i64 0, i32 2
  %15 = load i32* %sv_flags8, align 4, !tbaa !4
  %and9 = and i32 %15, 536870912
  %tobool10 = icmp eq i32 %and9, 0
  br i1 %tobool10, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private11 = getelementptr inbounds %struct.cop* %16, i64 0, i32 7
  %17 = load i8* %op_private11, align 1, !tbaa !1
  %and13 = and i8 %17, 8
  %lnot = icmp eq i8 %and13, 0
  br label %land.end

land.end:                                         ; preds = %if.end, %land.rhs
  %18 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %18 to i32
  %sv_flags15 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %19 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %19, 536870912
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %land.end.land.end24_crit_edge, label %land.end24

land.end.land.end24_crit_edge:                    ; preds = %land.end
  br i1 %18, label %if.then27, label %if.end55

land.end24:                                       ; preds = %land.end
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private19 = getelementptr inbounds %struct.cop* %20, i64 0, i32 7
  %21 = load i8* %op_private19, align 1, !tbaa !1
  %and21 = and i8 %21, 8
  %lnot23 = icmp eq i8 %and21, 0
  %xor137 = xor i1 %18, %lnot23
  br i1 %xor137, label %if.then27, label %if.end55

if.then27:                                        ; preds = %land.end.land.end24_crit_edge, %land.end24
  %22 = phi i1 [ false, %land.end.land.end24_crit_edge ], [ %lnot23, %land.end24 ]
  %cond32 = select i1 %22, %struct.sv* %14, %struct.sv* %13
  %sv_flags33 = getelementptr inbounds %struct.sv* %cond32, i64 0, i32 2
  %23 = load i32* %sv_flags33, align 4, !tbaa !4
  %and34 = and i32 %23, 262144
  %cmp35 = icmp eq i32 %and34, 0
  br i1 %cmp35, label %cond.false40, label %cond.true37

cond.true37:                                      ; preds = %if.then27
  %sv_any38 = getelementptr inbounds %struct.sv* %cond32, i64 0, i32 0
  %24 = load i8** %sv_any38, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %24, i64 8
  %25 = bitcast i8* %xpv_cur to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  store i64 %26, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %24 to i8**
  %27 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end42

cond.false40:                                     ; preds = %if.then27
  %call41 = call i8* @Perl_sv_2pv_flags(%struct.sv* %cond32, i64* %len, i32 2) #7
  %.pre = load i64* %len, align 8, !tbaa !3
  br label %cond.end42

cond.end42:                                       ; preds = %cond.false40, %cond.true37
  %28 = phi i64 [ %26, %cond.true37 ], [ %.pre, %cond.false40 ]
  %cond43 = phi i8* [ %27, %cond.true37 ], [ %call41, %cond.false40 ]
  %call44 = call %struct.sv* @Perl_newSVpvn(i8* %cond43, i64 %28) #7
  %29 = load %struct.sv** @PL_encoding, align 8, !tbaa !0
  %tobool45 = icmp eq %struct.sv* %29, null
  br i1 %tobool45, label %if.else48, label %if.then46

if.then46:                                        ; preds = %cond.end42
  %call47 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %call44, %struct.sv* %29) #7
  br label %if.end50

if.else48:                                        ; preds = %cond.end42
  %call49 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %call44, i32 2) #7
  br label %if.end50

if.end50:                                         ; preds = %if.else48, %if.then46
  %.land.ext = select i1 %22, i32 1, i32 %land.ext
  %.call44 = select i1 %22, %struct.sv* %13, %struct.sv* %call44
  %call44. = select i1 %22, %struct.sv* %call44, %struct.sv* %14
  br label %if.end55

if.end55:                                         ; preds = %land.end.land.end24_crit_edge, %if.end50, %land.end24
  %temp.0 = phi %struct.sv* [ null, %land.end24 ], [ %call44, %if.end50 ], [ null, %land.end.land.end24_crit_edge ]
  %big_utf8.0 = phi i32 [ %land.ext, %land.end24 ], [ %.land.ext, %if.end50 ], [ %land.ext, %land.end.land.end24_crit_edge ]
  %little.0 = phi %struct.sv* [ %13, %land.end24 ], [ %.call44, %if.end50 ], [ %13, %land.end.land.end24_crit_edge ]
  %big.0 = phi %struct.sv* [ %14, %land.end24 ], [ %call44., %if.end50 ], [ %14, %land.end.land.end24_crit_edge ]
  %tobool56 = icmp ne i32 %big_utf8.0, 0
  br i1 %tobool56, label %land.lhs.true, label %if.end60

land.lhs.true:                                    ; preds = %if.end55
  %30 = load i32* %offset, align 4, !tbaa !4
  %cmp57 = icmp sgt i32 %30, 0
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %land.lhs.true
  call void @Perl_sv_pos_u2b(%struct.sv* %big.0, i32* %offset, i32* null) #7
  br label %if.end60

if.end60:                                         ; preds = %land.lhs.true, %if.end55, %if.then59
  %sv_flags61 = getelementptr inbounds %struct.sv* %big.0, i64 0, i32 2
  %31 = load i32* %sv_flags61, align 4, !tbaa !4
  %and62 = and i32 %31, 262144
  %cmp63 = icmp eq i32 %and62, 0
  br i1 %cmp63, label %cond.false70, label %cond.true65

cond.true65:                                      ; preds = %if.end60
  %sv_any66 = getelementptr inbounds %struct.sv* %big.0, i64 0, i32 0
  %32 = load i8** %sv_any66, align 8, !tbaa !0
  %xpv_cur67 = getelementptr inbounds i8* %32, i64 8
  %33 = bitcast i8* %xpv_cur67 to i64*
  %34 = load i64* %33, align 8, !tbaa !3
  store i64 %34, i64* %biglen, align 8, !tbaa !3
  %xpv_pv69 = bitcast i8* %32 to i8**
  %35 = load i8** %xpv_pv69, align 8, !tbaa !0
  br label %cond.end72

cond.false70:                                     ; preds = %if.end60
  %call71 = call i8* @Perl_sv_2pv_flags(%struct.sv* %big.0, i64* %biglen, i32 2) #7
  br label %cond.end72

cond.end72:                                       ; preds = %cond.false70, %cond.true65
  %cond73 = phi i8* [ %35, %cond.true65 ], [ %call71, %cond.false70 ]
  %36 = load i32* %offset, align 4, !tbaa !4
  %cmp74 = icmp slt i32 %36, 0
  br i1 %cmp74, label %if.then76, label %if.else77

if.then76:                                        ; preds = %cond.end72
  store i32 0, i32* %offset, align 4, !tbaa !4
  %.pre143 = load i64* %biglen, align 8, !tbaa !3
  br label %if.end84

if.else77:                                        ; preds = %cond.end72
  %37 = load i64* %biglen, align 8, !tbaa !3
  %conv78 = trunc i64 %37 to i32
  %cmp79 = icmp sgt i32 %36, %conv78
  br i1 %cmp79, label %if.then81, label %if.end84

if.then81:                                        ; preds = %if.else77
  store i32 %conv78, i32* %offset, align 4, !tbaa !4
  br label %if.end84

if.end84:                                         ; preds = %if.else77, %if.then81, %if.then76
  %38 = phi i64 [ %37, %if.else77 ], [ %37, %if.then81 ], [ %.pre143, %if.then76 ]
  %39 = phi i32 [ %36, %if.else77 ], [ %conv78, %if.then81 ], [ 0, %if.then76 ]
  %idx.ext = sext i32 %39 to i64
  %add.ptr = getelementptr inbounds i8* %cond73, i64 %idx.ext
  %add.ptr85 = getelementptr inbounds i8* %cond73, i64 %38
  %call86 = call i8* @Perl_fbm_instr(i8* %add.ptr, i8* %add.ptr85, %struct.sv* %little.0, i32 0) #7
  %tobool87 = icmp eq i8* %call86, null
  br i1 %tobool87, label %if.end91.thread, label %if.end91

if.end91.thread:                                  ; preds = %if.end84
  store i32 -1, i32* %retval1, align 4, !tbaa !4
  br label %if.end97

if.end91:                                         ; preds = %if.end84
  %sub.ptr.lhs.cast = ptrtoint i8* %call86 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %cond73 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv90 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv90, i32* %retval1, align 4, !tbaa !4
  %cmp92.not = icmp slt i32 %conv90, 1
  %tobool56.not = xor i1 %tobool56, true
  %brmerge = or i1 %cmp92.not, %tobool56.not
  br i1 %brmerge, label %if.end97, label %if.then96

if.then96:                                        ; preds = %if.end91
  call void @Perl_sv_pos_b2u(%struct.sv* %big.0, i32* %retval1) #7
  br label %if.end97

if.end97:                                         ; preds = %if.end91.thread, %if.end91, %if.then96
  %tobool98 = icmp eq %struct.sv* %temp.0, null
  br i1 %tobool98, label %if.end100, label %if.then99

if.then99:                                        ; preds = %if.end97
  call void @Perl_sv_free(%struct.sv* %temp.0) #7
  br label %if.end100

if.end100:                                        ; preds = %if.end97, %if.then99
  %40 = load i32* %retval1, align 4, !tbaa !4
  %add = add nsw i32 %40, %6
  %conv101 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %conv101) #7
  %sv_flags102 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %41 = load i32* %sv_flags102, align 4, !tbaa !4
  %and103 = and i32 %41, 16384
  %tobool104 = icmp eq i32 %and103, 0
  br i1 %tobool104, label %if.end107, label %if.then105

if.then105:                                       ; preds = %if.end100
  %call106 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end107

if.end107:                                        ; preds = %if.end100, %if.then105
  store %struct.sv* %4, %struct.sv** %incdec.ptr6, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr6, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %42, i64 0, i32 0
  %43 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %43
}

; Function Attrs: optsize
declare i8* @Perl_sv_recode_to_utf8(%struct.sv*, %struct.sv*) #1

; Function Attrs: optsize
declare i8* @Perl_fbm_instr(i8*, i8*, %struct.sv*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_rindex() #0 {
entry:
  %blen = alloca i64, align 8
  %llen = alloca i64, align 8
  %offset = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %5, i64 0, i32 12
  %6 = load i32* %cop_arybase, align 4, !tbaa !4
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !1
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 15
  %cmp = icmp ugt i32 %and, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %9, 65536
  %tobool = icmp eq i32 %and3, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %10, i64 24
  %11 = bitcast i8* %xiv_iv to i64*
  %12 = load i64* %11, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call = call i64 @Perl_sv_2iv(%struct.sv* %8) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %12, %cond.true ], [ %call, %cond.false ]
  %conv4 = trunc i64 %cond to i32
  store i32 %conv4, i32* %offset, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %sp.0 = phi %struct.sv** [ %incdec.ptr, %cond.end ], [ %0, %entry ]
  %incdec.ptr5 = getelementptr inbounds %struct.sv** %sp.0, i64 -1
  %13 = load %struct.sv** %sp.0, align 8, !tbaa !0
  %14 = load %struct.sv** %incdec.ptr5, align 8, !tbaa !0
  %sv_flags7 = getelementptr inbounds %struct.sv* %14, i64 0, i32 2
  %15 = load i32* %sv_flags7, align 4, !tbaa !4
  %and8 = and i32 %15, 536870912
  %tobool9 = icmp eq i32 %and8, 0
  br i1 %tobool9, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private10 = getelementptr inbounds %struct.cop* %16, i64 0, i32 7
  %17 = load i8* %op_private10, align 1, !tbaa !1
  %and12 = and i8 %17, 8
  %lnot = icmp eq i8 %and12, 0
  br label %land.end

land.end:                                         ; preds = %if.end, %land.rhs
  %18 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %18 to i32
  %sv_flags14 = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %19 = load i32* %sv_flags14, align 4, !tbaa !4
  %and15 = and i32 %19, 536870912
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %land.end.land.end23_crit_edge, label %land.end23

land.end.land.end23_crit_edge:                    ; preds = %land.end
  br i1 %18, label %if.then26, label %if.end53

land.end23:                                       ; preds = %land.end
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private18 = getelementptr inbounds %struct.cop* %20, i64 0, i32 7
  %21 = load i8* %op_private18, align 1, !tbaa !1
  %and20 = and i8 %21, 8
  %lnot22 = icmp eq i8 %and20, 0
  %xor163 = xor i1 %18, %lnot22
  br i1 %xor163, label %if.then26, label %if.end53

if.then26:                                        ; preds = %land.end.land.end23_crit_edge, %land.end23
  %22 = phi i1 [ false, %land.end.land.end23_crit_edge ], [ %lnot22, %land.end23 ]
  %cond31 = select i1 %22, %struct.sv* %14, %struct.sv* %13
  %sv_flags32 = getelementptr inbounds %struct.sv* %cond31, i64 0, i32 2
  %23 = load i32* %sv_flags32, align 4, !tbaa !4
  %and33 = and i32 %23, 262144
  %cmp34 = icmp eq i32 %and33, 0
  br i1 %cmp34, label %cond.false39, label %cond.true36

cond.true36:                                      ; preds = %if.then26
  %sv_any37 = getelementptr inbounds %struct.sv* %cond31, i64 0, i32 0
  %24 = load i8** %sv_any37, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %24, i64 8
  %25 = bitcast i8* %xpv_cur to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  store i64 %26, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %24 to i8**
  %27 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end41

cond.false39:                                     ; preds = %if.then26
  %call40 = call i8* @Perl_sv_2pv_flags(%struct.sv* %cond31, i64* %len, i32 2) #7
  %.pre = load i64* %len, align 8, !tbaa !3
  br label %cond.end41

cond.end41:                                       ; preds = %cond.false39, %cond.true36
  %28 = phi i64 [ %26, %cond.true36 ], [ %.pre, %cond.false39 ]
  %cond42 = phi i8* [ %27, %cond.true36 ], [ %call40, %cond.false39 ]
  %call43 = call %struct.sv* @Perl_newSVpvn(i8* %cond42, i64 %28) #7
  %29 = load %struct.sv** @PL_encoding, align 8, !tbaa !0
  %tobool44 = icmp eq %struct.sv* %29, null
  br i1 %tobool44, label %if.else, label %if.then45

if.then45:                                        ; preds = %cond.end41
  %call46 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %call43, %struct.sv* %29) #7
  br label %if.end48

if.else:                                          ; preds = %cond.end41
  %call47 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %call43, i32 2) #7
  br label %if.end48

if.end48:                                         ; preds = %if.else, %if.then45
  %.land.ext = select i1 %22, i32 1, i32 %land.ext
  %.call43 = select i1 %22, %struct.sv* %13, %struct.sv* %call43
  %call43. = select i1 %22, %struct.sv* %call43, %struct.sv* %14
  br label %if.end53

if.end53:                                         ; preds = %land.end23, %land.end.land.end23_crit_edge, %if.end48
  %temp.0 = phi %struct.sv* [ %call43, %if.end48 ], [ null, %land.end.land.end23_crit_edge ], [ null, %land.end23 ]
  %big_utf8.0 = phi i32 [ %.land.ext, %if.end48 ], [ %land.ext, %land.end.land.end23_crit_edge ], [ %land.ext, %land.end23 ]
  %little.0 = phi %struct.sv* [ %.call43, %if.end48 ], [ %13, %land.end.land.end23_crit_edge ], [ %13, %land.end23 ]
  %big.0 = phi %struct.sv* [ %call43., %if.end48 ], [ %14, %land.end.land.end23_crit_edge ], [ %14, %land.end23 ]
  %sv_flags54 = getelementptr inbounds %struct.sv* %little.0, i64 0, i32 2
  %30 = load i32* %sv_flags54, align 4, !tbaa !4
  %and55 = and i32 %30, 262144
  %cmp56 = icmp eq i32 %and55, 0
  br i1 %cmp56, label %cond.false63, label %cond.true58

cond.true58:                                      ; preds = %if.end53
  %sv_any59 = getelementptr inbounds %struct.sv* %little.0, i64 0, i32 0
  %31 = load i8** %sv_any59, align 8, !tbaa !0
  %xpv_cur60 = getelementptr inbounds i8* %31, i64 8
  %32 = bitcast i8* %xpv_cur60 to i64*
  %33 = load i64* %32, align 8, !tbaa !3
  store i64 %33, i64* %llen, align 8, !tbaa !3
  %xpv_pv62 = bitcast i8* %31 to i8**
  %34 = load i8** %xpv_pv62, align 8, !tbaa !0
  br label %cond.end65

cond.false63:                                     ; preds = %if.end53
  %call64 = call i8* @Perl_sv_2pv_flags(%struct.sv* %little.0, i64* %llen, i32 2) #7
  br label %cond.end65

cond.end65:                                       ; preds = %cond.false63, %cond.true58
  %cond66 = phi i8* [ %34, %cond.true58 ], [ %call64, %cond.false63 ]
  %sv_flags67 = getelementptr inbounds %struct.sv* %big.0, i64 0, i32 2
  %35 = load i32* %sv_flags67, align 4, !tbaa !4
  %and68 = and i32 %35, 262144
  %cmp69 = icmp eq i32 %and68, 0
  br i1 %cmp69, label %cond.false76, label %cond.true71

cond.true71:                                      ; preds = %cond.end65
  %sv_any72 = getelementptr inbounds %struct.sv* %big.0, i64 0, i32 0
  %36 = load i8** %sv_any72, align 8, !tbaa !0
  %xpv_cur73 = getelementptr inbounds i8* %36, i64 8
  %37 = bitcast i8* %xpv_cur73 to i64*
  %38 = load i64* %37, align 8, !tbaa !3
  store i64 %38, i64* %blen, align 8, !tbaa !3
  %xpv_pv75 = bitcast i8* %36 to i8**
  %39 = load i8** %xpv_pv75, align 8, !tbaa !0
  br label %cond.end78

cond.false76:                                     ; preds = %cond.end65
  %call77 = call i8* @Perl_sv_2pv_flags(%struct.sv* %big.0, i64* %blen, i32 2) #7
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false76, %cond.true71
  %cond79 = phi i8* [ %39, %cond.true71 ], [ %call77, %cond.false76 ]
  %40 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private80 = getelementptr inbounds %struct.op* %40, i64 0, i32 7
  %41 = load i8* %op_private80, align 1, !tbaa !1
  %conv81 = zext i8 %41 to i32
  %and82 = and i32 %conv81, 15
  %cmp83 = icmp ult i32 %and82, 3
  br i1 %cmp83, label %if.then85, label %if.else87

if.then85:                                        ; preds = %cond.end78
  %42 = load i64* %blen, align 8, !tbaa !3
  br label %if.end95

if.else87:                                        ; preds = %cond.end78
  %43 = load i32* %offset, align 4, !tbaa !4
  %cmp88 = icmp slt i32 %43, 1
  %tobool90 = icmp eq i32 %big_utf8.0, 0
  %or.cond = or i1 %cmp88, %tobool90
  br i1 %or.cond, label %if.end92, label %if.then91

if.then91:                                        ; preds = %if.else87
  call void @Perl_sv_pos_u2b(%struct.sv* %big.0, i32* %offset, i32* null) #7
  %.pre170 = load i32* %offset, align 4, !tbaa !4
  br label %if.end92

if.end92:                                         ; preds = %if.else87, %if.then91
  %44 = phi i32 [ %.pre170, %if.then91 ], [ %43, %if.else87 ]
  %sub = sub nsw i32 %44, %6
  %conv93164 = zext i32 %sub to i64
  %45 = load i64* %llen, align 8, !tbaa !3
  %add = add i64 %conv93164, %45
  br label %if.end95

if.end95:                                         ; preds = %if.end92, %if.then85
  %storemerge.in = phi i64 [ %add, %if.end92 ], [ %42, %if.then85 ]
  %storemerge = trunc i64 %storemerge.in to i32
  store i32 %storemerge, i32* %offset, align 4, !tbaa !4
  %cmp96 = icmp slt i32 %storemerge, 0
  br i1 %cmp96, label %if.then98, label %if.else99

if.then98:                                        ; preds = %if.end95
  store i32 0, i32* %offset, align 4, !tbaa !4
  br label %if.end106

if.else99:                                        ; preds = %if.end95
  %46 = load i64* %blen, align 8, !tbaa !3
  %conv100 = trunc i64 %46 to i32
  %cmp101 = icmp sgt i32 %storemerge, %conv100
  br i1 %cmp101, label %if.then103, label %if.end106

if.then103:                                       ; preds = %if.else99
  store i32 %conv100, i32* %offset, align 4, !tbaa !4
  br label %if.end106

if.end106:                                        ; preds = %if.else99, %if.then103, %if.then98
  %47 = phi i64 [ %46, %if.then103 ], [ 0, %if.then98 ], [ %storemerge.in, %if.else99 ]
  %sext = shl i64 %47, 32
  %idx.ext = ashr exact i64 %sext, 32
  %add.ptr = getelementptr inbounds i8* %cond79, i64 %idx.ext
  %48 = load i64* %llen, align 8, !tbaa !3
  %add.ptr107 = getelementptr inbounds i8* %cond66, i64 %48
  %call108 = call i8* @Perl_rninstr(i8* %cond79, i8* %add.ptr, i8* %cond66, i8* %add.ptr107) #7
  %tobool109 = icmp eq i8* %call108, null
  br i1 %tobool109, label %if.end113.thread, label %if.end113

if.end113.thread:                                 ; preds = %if.end106
  store i32 -1, i32* %retval1, align 4, !tbaa !4
  br label %if.end119

if.end113:                                        ; preds = %if.end106
  %sub.ptr.lhs.cast = ptrtoint i8* %call108 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %cond79 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv112 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv112, i32* %retval1, align 4, !tbaa !4
  %cmp114 = icmp slt i32 %conv112, 1
  %tobool117 = icmp eq i32 %big_utf8.0, 0
  %or.cond166 = or i1 %cmp114, %tobool117
  br i1 %or.cond166, label %if.end119, label %if.then118

if.then118:                                       ; preds = %if.end113
  call void @Perl_sv_pos_b2u(%struct.sv* %big.0, i32* %retval1) #7
  br label %if.end119

if.end119:                                        ; preds = %if.end113.thread, %if.end113, %if.then118
  %tobool120 = icmp eq %struct.sv* %temp.0, null
  br i1 %tobool120, label %if.end122, label %if.then121

if.then121:                                       ; preds = %if.end119
  call void @Perl_sv_free(%struct.sv* %temp.0) #7
  br label %if.end122

if.end122:                                        ; preds = %if.end119, %if.then121
  %49 = load i32* %retval1, align 4, !tbaa !4
  %add123 = add nsw i32 %49, %6
  %conv124 = sext i32 %add123 to i64
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %conv124) #7
  %sv_flags125 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %50 = load i32* %sv_flags125, align 4, !tbaa !4
  %and126 = and i32 %50, 16384
  %tobool127 = icmp eq i32 %and126, 0
  br i1 %tobool127, label %if.end130, label %if.then128

if.then128:                                       ; preds = %if.end122
  %call129 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end130

if.end130:                                        ; preds = %if.end122, %if.then128
  store %struct.sv* %4, %struct.sv** %incdec.ptr5, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr5, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %51 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %51, i64 0, i32 0
  %52 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %52
}

; Function Attrs: optsize
declare i8* @Perl_rninstr(i8*, i8*, i8*, i8*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_sprintf() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %5 = load i64* %op_targ, align 8, !tbaa !3
  %6 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %6, i64 %5
  %7 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div441 = lshr exact i64 %sub.ptr.sub3, 3
  %conv5 = trunc i64 %sub.ptr.div441 to i32
  %add.ptr.sum = add i64 %idx.ext, 1
  %add.ptr6 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  tail call void @Perl_do_sprintf(%struct.sv* %7, i32 %conv5, %struct.sv** %add.ptr6) #7
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %8, 57344
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = tail call signext i8 @Perl_sv_tainted(%struct.sv* %7) #7
  %tobool8 = icmp eq i8 %call, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i8 1, i8* @PL_tainted, align 1, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %if.then
  %9 = load %struct.sv** %add.ptr6, align 8, !tbaa !0
  %sv_flags10 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %10 = load i32* %sv_flags10, align 4, !tbaa !4
  %and11 = and i32 %10, 536870912
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %if.end19, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %if.end
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %11, i64 0, i32 7
  %12 = load i8* %op_private, align 1, !tbaa !1
  %and15 = and i8 %12, 8
  %tobool16 = icmp eq i8 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %land.lhs.true13
  %13 = load i32* %sv_flags, align 4, !tbaa !4
  %or = or i32 %13, 536870912
  store i32 %or, i32* %sv_flags, align 4, !tbaa !4
  br label %if.end19

if.end19:                                         ; preds = %land.lhs.true13, %if.end, %if.then17
  %14 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %15 = load i32* %sv_flags, align 4, !tbaa !4
  %and23 = and i32 %15, 16384
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end19
  %call26 = tail call i32 @Perl_mg_set(%struct.sv* %7) #7
  br label %if.end27

if.end27:                                         ; preds = %if.end19, %if.then25
  %add.ptr21.sum = add i64 %idx.ext, 1
  %incdec.ptr28 = getelementptr inbounds %struct.sv** %14, i64 %add.ptr21.sum
  store %struct.sv* %7, %struct.sv** %incdec.ptr28, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr28, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %16 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %16, i64 0, i32 0
  %17 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %17
}

; Function Attrs: optsize
declare void @Perl_do_sprintf(%struct.sv*, i32, %struct.sv**) #1

; Function Attrs: optsize
declare signext i8 @Perl_sv_tainted(%struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_ord() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !3
  store i64 %9, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %7 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %len, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %10, %cond.true ], [ %call, %cond.false ]
  %11 = load %struct.sv** @PL_encoding, align 8, !tbaa !0
  %tobool = icmp eq %struct.sv* %11, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %12 = load i32* %sv_flags, align 4, !tbaa !4
  %and3 = and i32 %12, 262144
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %and7 = and i32 %12, 536870912
  %tobool8 = icmp eq i32 %and7, 0
  br i1 %tobool8, label %if.then, label %land.lhs.true9

land.lhs.true9:                                   ; preds = %land.lhs.true5
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %13, i64 0, i32 7
  %14 = load i8* %op_private, align 1, !tbaa !1
  %and10 = and i8 %14, 8
  %tobool11 = icmp eq i8 %and10, 0
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true9, %land.lhs.true5
  %call12 = call %struct.sv* @Perl_newSVsv(%struct.sv* %5) #7
  %call13 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call12) #7
  %15 = load %struct.sv** @PL_encoding, align 8, !tbaa !0
  %call14 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %call13, %struct.sv* %15) #7
  br label %if.end

if.end:                                           ; preds = %land.lhs.true9, %cond.end, %land.lhs.true, %if.then
  %argsv.0 = phi %struct.sv* [ %call13, %if.then ], [ %5, %land.lhs.true ], [ %5, %cond.end ], [ %5, %land.lhs.true9 ]
  %s.0 = phi i8* [ %call14, %if.then ], [ %cond, %land.lhs.true ], [ %cond, %cond.end ], [ %cond, %land.lhs.true9 ]
  %sv_flags15 = getelementptr inbounds %struct.sv* %argsv.0, i64 0, i32 2
  %16 = load i32* %sv_flags15, align 4, !tbaa !4
  %and16 = and i32 %16, 536870912
  %tobool17 = icmp eq i32 %and16, 0
  br i1 %tobool17, label %cond.false25, label %land.lhs.true18

land.lhs.true18:                                  ; preds = %if.end
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private19 = getelementptr inbounds %struct.cop* %17, i64 0, i32 7
  %18 = load i8* %op_private19, align 1, !tbaa !1
  %and21 = and i8 %18, 8
  %tobool22 = icmp eq i8 %and21, 0
  br i1 %tobool22, label %cond.true23, label %cond.false25

cond.true23:                                      ; preds = %land.lhs.true18
  %call24 = call i64 @Perl_utf8n_to_uvuni(i8* %s.0, i64 13, i64* null, i32 105) #7
  br label %cond.end29

cond.false25:                                     ; preds = %land.lhs.true18, %if.end
  %19 = load i8* %s.0, align 1, !tbaa !1
  %conv28 = zext i8 %19 to i64
  br label %cond.end29

cond.end29:                                       ; preds = %cond.false25, %cond.true23
  %cond30 = phi i64 [ %call24, %cond.true23 ], [ %conv28, %cond.false25 ]
  call void @Perl_sv_setuv(%struct.sv* %4, i64 %cond30) #7
  %sv_flags31 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %20 = load i32* %sv_flags31, align 4, !tbaa !4
  %and32 = and i32 %20, 16384
  %tobool33 = icmp eq i32 %and32, 0
  br i1 %tobool33, label %if.end36, label %if.then34

if.then34:                                        ; preds = %cond.end29
  %call35 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end36

if.end36:                                         ; preds = %cond.end29, %if.then34
  %21 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %21 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp37 = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp37, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %call40 = call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %sp.0 = phi %struct.sv** [ %call40, %if.then39 ], [ %incdec.ptr, %if.end36 ]
  %incdec.ptr42 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr42, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr42, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %22 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %22, i64 0, i32 0
  %23 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %23
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_chr() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 65536
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !0
  %xuv_uv = getelementptr inbounds i8* %7, i64 24
  %8 = bitcast i8* %xuv_uv to i64*
  %9 = load i64* %8, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call i64 @Perl_sv_2uv(%struct.sv* %5) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ %call, %cond.false ]
  %sv_flags1 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %10 = load i32* %sv_flags1, align 4, !tbaa !4
  %and2 = and i32 %10, 252
  %cmp = icmp eq i32 %and2, 0
  br i1 %cmp, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %cond.end
  %call3 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %4, i32 4) #7
  br label %lor.end

lor.end:                                          ; preds = %cond.end, %lor.rhs
  %cmp5 = icmp ugt i64 %cond, 255
  br i1 %cmp5, label %land.lhs.true, label %if.end119

land.lhs.true:                                    ; preds = %lor.end
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %11, i64 0, i32 7
  %12 = load i8* %op_private, align 1, !tbaa !1
  %and8 = and i8 %12, 8
  %tobool9 = icmp eq i8 %and8, 0
  br i1 %tobool9, label %if.then, label %if.end119

if.then:                                          ; preds = %land.lhs.true
  %sv_any10 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %13 = load i8** %sv_any10, align 8, !tbaa !0
  %xpv_len = getelementptr inbounds i8* %13, i64 16
  %14 = bitcast i8* %xpv_len to i64*
  %15 = load i64* %14, align 8, !tbaa !3
  %cmp11 = icmp ult i64 %cond, 128
  br i1 %cmp11, label %cond.end48, label %cond.false14

cond.false14:                                     ; preds = %if.then
  %cmp15 = icmp ult i64 %cond, 2048
  br i1 %cmp15, label %cond.end48, label %cond.false18

cond.false18:                                     ; preds = %cond.false14
  %cmp19 = icmp ult i64 %cond, 65536
  br i1 %cmp19, label %cond.end48, label %cond.false22

cond.false22:                                     ; preds = %cond.false18
  %cmp23 = icmp ult i64 %cond, 2097152
  br i1 %cmp23, label %cond.end48, label %cond.false26

cond.false26:                                     ; preds = %cond.false22
  %cmp27 = icmp ult i64 %cond, 67108864
  br i1 %cmp27, label %cond.end48, label %cond.false30

cond.false30:                                     ; preds = %cond.false26
  %cmp31 = icmp ult i64 %cond, 2147483648
  br i1 %cmp31, label %cond.end48, label %cond.false34

cond.false34:                                     ; preds = %cond.false30
  %cmp35 = icmp ult i64 %cond, 68719476736
  %phitmp267 = select i1 %cmp35, i64 8, i64 14
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false14, %cond.false22, %cond.false34, %cond.false30, %cond.false26, %cond.false18, %if.then
  %cond49 = phi i64 [ 2, %if.then ], [ 3, %cond.false14 ], [ 4, %cond.false18 ], [ 5, %cond.false22 ], [ 6, %cond.false26 ], [ %phitmp267, %cond.false34 ], [ 7, %cond.false30 ]
  %cmp51 = icmp ult i64 %15, %cond49
  br i1 %cmp51, label %cond.true53, label %cond.end98

cond.true53:                                      ; preds = %cond.end48
  br i1 %cmp11, label %cond.end91, label %cond.false57

cond.false57:                                     ; preds = %cond.true53
  %cmp58 = icmp ult i64 %cond, 2048
  br i1 %cmp58, label %cond.end91, label %cond.false61

cond.false61:                                     ; preds = %cond.false57
  %cmp62 = icmp ult i64 %cond, 65536
  br i1 %cmp62, label %cond.end91, label %cond.false65

cond.false65:                                     ; preds = %cond.false61
  %cmp66 = icmp ult i64 %cond, 2097152
  br i1 %cmp66, label %cond.end91, label %cond.false69

cond.false69:                                     ; preds = %cond.false65
  %cmp70 = icmp ult i64 %cond, 67108864
  br i1 %cmp70, label %cond.end91, label %cond.false73

cond.false73:                                     ; preds = %cond.false69
  %cmp74 = icmp ult i64 %cond, 2147483648
  br i1 %cmp74, label %cond.end91, label %cond.false77

cond.false77:                                     ; preds = %cond.false73
  %cmp78 = icmp ult i64 %cond, 68719476736
  %phitmp268 = select i1 %cmp78, i64 8, i64 14
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false57, %cond.false65, %cond.false77, %cond.false73, %cond.false69, %cond.false61, %cond.true53
  %cond92 = phi i64 [ 2, %cond.true53 ], [ 3, %cond.false57 ], [ 4, %cond.false61 ], [ 5, %cond.false65 ], [ 6, %cond.false69 ], [ %phitmp268, %cond.false77 ], [ 7, %cond.false73 ]
  %call95 = tail call i8* @Perl_sv_grow(%struct.sv* %4, i64 %cond92) #7
  %.pre = load i8** %sv_any10, align 8, !tbaa !0
  br label %cond.end98

cond.end98:                                       ; preds = %cond.end48, %cond.end91
  %16 = phi i8* [ %13, %cond.end48 ], [ %.pre, %cond.end91 ]
  %xpv_pv101 = bitcast i8* %16 to i8**
  %17 = load i8** %xpv_pv101, align 8, !tbaa !0
  %call102 = tail call i8* @Perl_uvchr_to_utf8_flags(i8* %17, i64 %cond, i64 0) #7
  %18 = load i8** %sv_any10, align 8, !tbaa !0
  %xpv_pv104 = bitcast i8* %18 to i8**
  %19 = load i8** %xpv_pv104, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint i8* %call102 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %xpv_cur = getelementptr inbounds i8* %18, i64 8
  %20 = bitcast i8* %xpv_cur to i64*
  store i64 %sub.ptr.sub, i64* %20, align 8, !tbaa !3
  store i8 0, i8* %call102, align 1, !tbaa !1
  %21 = load i32* %sv_flags1, align 4, !tbaa !4
  %and107 = and i32 %21, 1223753727
  %or110 = or i32 %and107, 604241920
  store i32 %or110, i32* %sv_flags1, align 4, !tbaa !4
  %22 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast111 = ptrtoint %struct.sv** %22 to i64
  %sub.ptr.rhs.cast112 = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub113 = sub i64 %sub.ptr.lhs.cast111, %sub.ptr.rhs.cast112
  %cmp114 = icmp slt i64 %sub.ptr.sub113, 8
  br i1 %cmp114, label %if.then116, label %if.end

if.then116:                                       ; preds = %cond.end98
  %call117 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end

if.end:                                           ; preds = %if.then116, %cond.end98
  %sp.0 = phi %struct.sv** [ %call117, %if.then116 ], [ %incdec.ptr, %cond.end98 ]
  %incdec.ptr118 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr118, align 8, !tbaa !0
  br label %return

if.end119:                                        ; preds = %land.lhs.true, %lor.end
  %sv_any120 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %23 = load i8** %sv_any120, align 8, !tbaa !0
  %xpv_len121 = getelementptr inbounds i8* %23, i64 16
  %24 = bitcast i8* %xpv_len121 to i64*
  %25 = load i64* %24, align 8, !tbaa !3
  %cmp122 = icmp ult i64 %25, 2
  br i1 %cmp122, label %cond.true124, label %cond.end129

cond.true124:                                     ; preds = %if.end119
  %call125 = tail call i8* @Perl_sv_grow(%struct.sv* %4, i64 2) #7
  %.pre269 = load i8** %sv_any120, align 8, !tbaa !0
  br label %cond.end129

cond.end129:                                      ; preds = %if.end119, %cond.true124
  %26 = phi i8* [ %23, %if.end119 ], [ %.pre269, %cond.true124 ]
  %xpv_cur132 = getelementptr inbounds i8* %26, i64 8
  %27 = bitcast i8* %xpv_cur132 to i64*
  store i64 1, i64* %27, align 8, !tbaa !3
  %xpv_pv134 = bitcast i8* %26 to i8**
  %28 = load i8** %xpv_pv134, align 8, !tbaa !0
  %conv135 = trunc i64 %cond to i8
  %incdec.ptr136 = getelementptr inbounds i8* %28, i64 1
  store i8 %conv135, i8* %28, align 1, !tbaa !1
  store i8 0, i8* %incdec.ptr136, align 1, !tbaa !1
  %29 = load i32* %sv_flags1, align 4, !tbaa !4
  %and138 = and i32 %29, 1223753727
  %or140 = or i32 %and138, 67371008
  store i32 %or140, i32* %sv_flags1, align 4, !tbaa !4
  %30 = load %struct.sv** @PL_encoding, align 8, !tbaa !0
  %tobool141 = icmp eq %struct.sv* %30, null
  br i1 %tobool141, label %if.end192, label %land.lhs.true142

land.lhs.true142:                                 ; preds = %cond.end129
  %31 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private143 = getelementptr inbounds %struct.cop* %31, i64 0, i32 7
  %32 = load i8* %op_private143, align 1, !tbaa !1
  %and145 = and i8 %32, 8
  %tobool146 = icmp eq i8 %and145, 0
  br i1 %tobool146, label %if.then147, label %if.end192

if.then147:                                       ; preds = %land.lhs.true142
  %call148 = tail call i8* @Perl_sv_recode_to_utf8(%struct.sv* %4, %struct.sv* %30) #7
  %33 = load i8** %sv_any120, align 8, !tbaa !0
  %xpv_pv150 = bitcast i8* %33 to i8**
  %34 = load i8** %xpv_pv150, align 8, !tbaa !0
  %xpv_cur152 = getelementptr inbounds i8* %33, i64 8
  %35 = bitcast i8* %xpv_cur152 to i64*
  %36 = load i64* %35, align 8, !tbaa !3
  %cmp153 = icmp eq i64 %36, 0
  br i1 %cmp153, label %if.then162, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then147
  %call157 = tail call signext i8 @Perl_is_utf8_string(i8* %34, i64 %36) #7
  %tobool158 = icmp eq i8 %call157, 0
  br i1 %tobool158, label %if.then162, label %lor.lhs.false159

lor.lhs.false159:                                 ; preds = %lor.lhs.false
  %call160 = tail call i32 @memcmp(i8* %34, i8* getelementptr inbounds ([5 x i8]* @.str36, i64 0, i64 0), i64 4) #7
  %tobool161 = icmp eq i32 %call160, 0
  br i1 %tobool161, label %if.then162, label %if.end192

if.then162:                                       ; preds = %lor.lhs.false159, %lor.lhs.false, %if.then147
  %37 = load i8** %sv_any120, align 8, !tbaa !0
  %xpv_len164 = getelementptr inbounds i8* %37, i64 16
  %38 = bitcast i8* %xpv_len164 to i64*
  %39 = load i64* %38, align 8, !tbaa !3
  %cmp165 = icmp ult i64 %39, 3
  br i1 %cmp165, label %cond.true167, label %cond.end172

cond.true167:                                     ; preds = %if.then162
  %call168 = tail call i8* @Perl_sv_grow(%struct.sv* %4, i64 3) #7
  %.pre270 = load i8** %sv_any120, align 8, !tbaa !0
  br label %cond.end172

cond.end172:                                      ; preds = %if.then162, %cond.true167
  %40 = phi i8* [ %37, %if.then162 ], [ %.pre270, %cond.true167 ]
  %xpv_pv175 = bitcast i8* %40 to i8**
  %41 = load i8** %xpv_pv175, align 8, !tbaa !0
  %xpv_cur177 = getelementptr inbounds i8* %40, i64 8
  %42 = bitcast i8* %xpv_cur177 to i64*
  store i64 2, i64* %42, align 8, !tbaa !3
  %43 = trunc i64 %cond to i32
  %conv179 = lshr i32 %43, 6
  %shr266 = and i32 %conv179, 3
  %or180 = or i32 %shr266, 192
  %conv181 = trunc i32 %or180 to i8
  %incdec.ptr182 = getelementptr inbounds i8* %41, i64 1
  store i8 %conv181, i8* %41, align 1, !tbaa !1
  %and185 = and i32 %43, 63
  %or186 = or i32 %and185, 128
  %conv187 = trunc i32 %or186 to i8
  %incdec.ptr188 = getelementptr inbounds i8* %41, i64 2
  store i8 %conv187, i8* %incdec.ptr182, align 1, !tbaa !1
  store i8 0, i8* %incdec.ptr188, align 1, !tbaa !1
  %44 = load i32* %sv_flags1, align 4, !tbaa !4
  %or190 = or i32 %44, 536870912
  store i32 %or190, i32* %sv_flags1, align 4, !tbaa !4
  br label %if.end192

if.end192:                                        ; preds = %lor.lhs.false159, %land.lhs.true142, %cond.end129, %cond.end172
  %45 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast193 = ptrtoint %struct.sv** %45 to i64
  %sub.ptr.rhs.cast194 = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub195 = sub i64 %sub.ptr.lhs.cast193, %sub.ptr.rhs.cast194
  %cmp197 = icmp slt i64 %sub.ptr.sub195, 8
  br i1 %cmp197, label %if.then199, label %if.end201

if.then199:                                       ; preds = %if.end192
  %call200 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end201

if.end201:                                        ; preds = %if.then199, %if.end192
  %sp.1 = phi %struct.sv** [ %call200, %if.then199 ], [ %incdec.ptr, %if.end192 ]
  %incdec.ptr202 = getelementptr inbounds %struct.sv** %sp.1, i64 1
  store %struct.sv* %4, %struct.sv** %incdec.ptr202, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end201, %if.end
  %storemerge = phi %struct.sv** [ %incdec.ptr202, %if.end201 ], [ %incdec.ptr118, %if.end ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare signext i8 @Perl_is_utf8_string(i8*, i64) #1

; Function Attrs: nounwind optsize readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) #4

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_crypt() #0 {
entry:
  %call = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([65 x i8]* @.str37, i64 0, i64 0)) #7
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_ucfirst() #0 {
entry:
  %slen = alloca i64, align 8
  %tmpbuf = alloca [7 x i8], align 1
  %ulen = alloca i64, align 8
  %tculen = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 8192
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @Perl_mg_get(%struct.sv* %1) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %3 = phi i32 [ %2, %entry ], [ %.pre, %if.then ]
  %and2 = and i32 %3, 536870912
  %tobool3 = icmp eq i32 %and2, 0
  br i1 %tobool3, label %if.else56, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %5, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %land.lhs.true6, label %if.else56

land.lhs.true6:                                   ; preds = %land.lhs.true
  %and8 = and i32 %3, 262144
  %cmp = icmp eq i32 %and8, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true6
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %6 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %6, i64 8
  %7 = bitcast i8* %xpv_cur to i64*
  %8 = load i64* %7, align 8, !tbaa !3
  store i64 %8, i64* %slen, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %6 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true6
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %slen, i32 0) #7
  %.pre153 = load i64* %slen, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %10 = phi i64 [ %8, %cond.true ], [ %.pre153, %cond.false ]
  %cond = phi i8* [ %9, %cond.true ], [ %call11, %cond.false ]
  %tobool12 = icmp ne i8* %cond, null
  %tobool14 = icmp ne i64 %10, 0
  %or.cond = and i1 %tobool12, %tobool14
  br i1 %or.cond, label %land.lhs.true15, label %if.else56

land.lhs.true15:                                  ; preds = %cond.end
  %11 = load i8* %cond, align 1, !tbaa !1
  %.off151 = add i8 %11, 64
  %12 = icmp ult i8 %.off151, 62
  br i1 %12, label %if.then23, label %if.else56

if.then23:                                        ; preds = %land.lhs.true15
  %call24 = call i64 @Perl_utf8_to_uvchr(i8* %cond, i64* %ulen) #7
  %arraydecay = getelementptr inbounds [7 x i8]* %tmpbuf, i64 0, i64 0
  %call25 = call i64 @Perl_to_utf8_title(i8* %cond, i8* %arraydecay, i64* %tculen) #7
  %call27 = call i64 @Perl_utf8_to_uvchr(i8* %arraydecay, i64* null) #7
  %13 = load i32* %sv_flags, align 4, !tbaa !4
  %14 = and i32 %13, 8389120
  %15 = icmp eq i32 %14, 512
  br i1 %15, label %if.else, label %if.then34

if.then34:                                        ; preds = %if.then23
  %16 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %16, i64 0, i32 3
  %17 = load i64* %op_targ, align 8, !tbaa !3
  %18 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %18, i64 %17
  %19 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %20 = load i64* %tculen, align 8, !tbaa !3
  call void @Perl_sv_setpvn(%struct.sv* %19, i8* %arraydecay, i64 %20) #7
  %21 = load i64* %slen, align 8, !tbaa !3
  %22 = load i64* %ulen, align 8, !tbaa !3
  %cmp36 = icmp ugt i64 %21, %22
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then34
  %add.ptr = getelementptr inbounds i8* %cond, i64 %22
  %sub = sub i64 %21, %22
  call void @Perl_sv_catpvn_flags(%struct.sv* %19, i8* %add.ptr, i64 %sub, i32 2) #7
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.then34
  %sv_flags40 = getelementptr inbounds %struct.sv* %19, i64 0, i32 2
  %23 = load i32* %sv_flags40, align 4, !tbaa !4
  %or = or i32 %23, 536870912
  store i32 %or, i32* %sv_flags40, align 4, !tbaa !4
  store %struct.sv* %19, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end102

if.else:                                          ; preds = %if.then23
  %and42 = and i32 %13, 10223616
  %cmp43 = icmp eq i32 %and42, 262144
  br i1 %cmp43, label %cond.true45, label %cond.false50

cond.true45:                                      ; preds = %if.else
  %sv_any46 = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %24 = load i8** %sv_any46, align 8, !tbaa !0
  %xpv_cur47 = getelementptr inbounds i8* %24, i64 8
  %25 = bitcast i8* %xpv_cur47 to i64*
  %26 = load i64* %25, align 8, !tbaa !3
  store i64 %26, i64* %slen, align 8, !tbaa !3
  %xpv_pv49 = bitcast i8* %24 to i8**
  %27 = load i8** %xpv_pv49, align 8, !tbaa !0
  br label %cond.end52

cond.false50:                                     ; preds = %if.else
  %call51 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %1, i64* %slen, i32 0) #7
  br label %cond.end52

cond.end52:                                       ; preds = %cond.false50, %cond.true45
  %cond53 = phi i8* [ %27, %cond.true45 ], [ %call51, %cond.false50 ]
  %28 = load i64* %tculen, align 8, !tbaa !3
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %cond53, i8* %arraydecay, i64 %28, i32 1, i1 false)
  br label %if.end102

if.else56:                                        ; preds = %land.lhs.true15, %cond.end, %land.lhs.true, %if.end
  %29 = load i32* %sv_flags, align 4, !tbaa !4
  %30 = and i32 %29, 8389120
  %31 = icmp eq i32 %30, 512
  br i1 %31, label %if.end70, label %if.then64

if.then64:                                        ; preds = %if.else56
  %32 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ66 = getelementptr inbounds %struct.op* %32, i64 0, i32 3
  %33 = load i64* %op_targ66, align 8, !tbaa !3
  %34 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx67 = getelementptr inbounds %struct.sv** %34, i64 %33
  %35 = load %struct.sv** %arrayidx67, align 8, !tbaa !0
  %sv_flags68 = getelementptr inbounds %struct.sv* %35, i64 0, i32 2
  %36 = load i32* %sv_flags68, align 4, !tbaa !4
  %and69 = and i32 %36, -536870913
  store i32 %and69, i32* %sv_flags68, align 4, !tbaa !4
  call void @Perl_sv_setsv_flags(%struct.sv* %35, %struct.sv* %1, i32 0) #7
  store %struct.sv* %35, %struct.sv** %0, align 8, !tbaa !0
  %.pre152 = load i32* %sv_flags68, align 4, !tbaa !4
  br label %if.end70

if.end70:                                         ; preds = %if.else56, %if.then64
  %37 = phi i32 [ %.pre152, %if.then64 ], [ %29, %if.else56 ]
  %sv.0 = phi %struct.sv* [ %35, %if.then64 ], [ %1, %if.else56 ]
  %and72 = and i32 %37, 10223616
  %cmp73 = icmp eq i32 %and72, 262144
  br i1 %cmp73, label %cond.true75, label %cond.false80

cond.true75:                                      ; preds = %if.end70
  %sv_any76 = getelementptr inbounds %struct.sv* %sv.0, i64 0, i32 0
  %38 = load i8** %sv_any76, align 8, !tbaa !0
  %xpv_cur77 = getelementptr inbounds i8* %38, i64 8
  %39 = bitcast i8* %xpv_cur77 to i64*
  %40 = load i64* %39, align 8, !tbaa !3
  store i64 %40, i64* %slen, align 8, !tbaa !3
  %xpv_pv79 = bitcast i8* %38 to i8**
  %41 = load i8** %xpv_pv79, align 8, !tbaa !0
  br label %cond.end82

cond.false80:                                     ; preds = %if.end70
  %call81 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv.0, i64* %slen, i32 0) #7
  br label %cond.end82

cond.end82:                                       ; preds = %cond.false80, %cond.true75
  %cond83 = phi i8* [ %41, %cond.true75 ], [ %call81, %cond.false80 ]
  %42 = load i8* %cond83, align 1, !tbaa !1
  %tobool84 = icmp eq i8 %42, 0
  br i1 %tobool84, label %if.end102, label %if.then85

if.then85:                                        ; preds = %cond.end82
  %.off = add i8 %42, -97
  %43 = icmp ult i8 %.off, 26
  %sub95 = add i8 %42, -32
  %sub95. = select i1 %43, i8 %sub95, i8 %42
  store i8 %sub95., i8* %cond83, align 1, !tbaa !1
  br label %if.end102

if.end102:                                        ; preds = %cond.end82, %if.then85, %if.end39, %cond.end52
  %sv.1 = phi %struct.sv* [ %sv.0, %if.then85 ], [ %1, %if.end39 ], [ %1, %cond.end52 ], [ %sv.0, %cond.end82 ]
  %sv_flags103 = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 2
  %44 = load i32* %sv_flags103, align 4, !tbaa !4
  %and104 = and i32 %44, 16384
  %tobool105 = icmp eq i32 %and104, 0
  br i1 %tobool105, label %if.end108, label %if.then106

if.then106:                                       ; preds = %if.end102
  %call107 = call i32 @Perl_mg_set(%struct.sv* %sv.1) #7
  br label %if.end108

if.end108:                                        ; preds = %if.end102, %if.then106
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %45 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %45, i64 0, i32 0
  %46 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %46
}

; Function Attrs: optsize
declare i64 @Perl_utf8_to_uvchr(i8*, i64*) #1

; Function Attrs: optsize
declare i64 @Perl_to_utf8_title(i8*, i8*, i64*) #1

; Function Attrs: optsize
declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_lcfirst() #0 {
entry:
  %slen = alloca i64, align 8
  %ulen = alloca i64, align 8
  %tmpbuf = alloca [7 x i8], align 1
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 8192
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @Perl_mg_get(%struct.sv* %1) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %3 = phi i32 [ %2, %entry ], [ %.pre, %if.then ]
  %and2 = and i32 %3, 536870912
  %tobool3 = icmp eq i32 %and2, 0
  br i1 %tobool3, label %if.else65, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %5, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %land.lhs.true6, label %if.else65

land.lhs.true6:                                   ; preds = %land.lhs.true
  %and8 = and i32 %3, 262144
  %cmp = icmp eq i32 %and8, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true6
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %6 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %6, i64 8
  %7 = bitcast i8* %xpv_cur to i64*
  %8 = load i64* %7, align 8, !tbaa !3
  store i64 %8, i64* %slen, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %6 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true6
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %slen, i32 0) #7
  %.pre160 = load i64* %slen, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %10 = phi i64 [ %8, %cond.true ], [ %.pre160, %cond.false ]
  %cond = phi i8* [ %9, %cond.true ], [ %call11, %cond.false ]
  %tobool12 = icmp ne i8* %cond, null
  %tobool14 = icmp ne i64 %10, 0
  %or.cond = and i1 %tobool12, %tobool14
  br i1 %or.cond, label %land.lhs.true15, label %if.else65

land.lhs.true15:                                  ; preds = %cond.end
  %11 = load i8* %cond, align 1, !tbaa !1
  %.off158 = add i8 %11, 64
  %12 = icmp ult i8 %.off158, 62
  br i1 %12, label %if.then23, label %if.else65

if.then23:                                        ; preds = %land.lhs.true15
  %arraydecay = getelementptr inbounds [7 x i8]* %tmpbuf, i64 0, i64 0
  %call24 = call i64 @Perl_to_utf8_lower(i8* %cond, i8* %arraydecay, i64* %ulen) #7
  %call26 = call i64 @Perl_utf8_to_uvchr(i8* %arraydecay, i64* null) #7
  %call28 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay, i64 %call26) #7
  %13 = load i32* %sv_flags, align 4, !tbaa !4
  %and30 = and i32 %13, 512
  %tobool31 = icmp eq i32 %and30, 0
  %sub.ptr.lhs.cast42.pre = ptrtoint i8* %call28 to i64
  %sub.ptr.rhs.cast43.pre = ptrtoint [7 x i8]* %tmpbuf to i64
  %sub.ptr.sub44.pre = sub i64 %sub.ptr.lhs.cast42.pre, %sub.ptr.rhs.cast43.pre
  br i1 %tobool31, label %if.then39, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then23
  %14 = load i64* %ulen, align 8, !tbaa !3
  %cmp33 = icmp eq i64 %sub.ptr.sub44.pre, %14
  br i1 %cmp33, label %lor.lhs.false35, label %if.then39

lor.lhs.false35:                                  ; preds = %lor.lhs.false
  %and37 = and i32 %13, 8388608
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %if.else, label %if.then39

if.then39:                                        ; preds = %if.then23, %lor.lhs.false35, %lor.lhs.false
  %15 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %15, i64 0, i32 3
  %16 = load i64* %op_targ, align 8, !tbaa !3
  %17 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %17, i64 %16
  %18 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  call void @Perl_sv_setpvn(%struct.sv* %18, i8* %arraydecay, i64 %sub.ptr.sub44.pre) #7
  %19 = load i64* %slen, align 8, !tbaa !3
  %20 = load i64* %ulen, align 8, !tbaa !3
  %cmp45 = icmp ugt i64 %19, %20
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then39
  %add.ptr = getelementptr inbounds i8* %cond, i64 %20
  %sub = sub i64 %19, %20
  call void @Perl_sv_catpvn_flags(%struct.sv* %18, i8* %add.ptr, i64 %sub, i32 2) #7
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %if.then39
  %sv_flags49 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %21 = load i32* %sv_flags49, align 4, !tbaa !4
  %or = or i32 %21, 536870912
  store i32 %or, i32* %sv_flags49, align 4, !tbaa !4
  store %struct.sv* %18, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end110

if.else:                                          ; preds = %lor.lhs.false35
  %and51 = and i32 %13, 10223616
  %cmp52 = icmp eq i32 %and51, 262144
  br i1 %cmp52, label %cond.true54, label %cond.false59

cond.true54:                                      ; preds = %if.else
  %sv_any55 = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %22 = load i8** %sv_any55, align 8, !tbaa !0
  %xpv_cur56 = getelementptr inbounds i8* %22, i64 8
  %23 = bitcast i8* %xpv_cur56 to i64*
  %24 = load i64* %23, align 8, !tbaa !3
  store i64 %24, i64* %slen, align 8, !tbaa !3
  %xpv_pv58 = bitcast i8* %22 to i8**
  %25 = load i8** %xpv_pv58, align 8, !tbaa !0
  br label %cond.end61

cond.false59:                                     ; preds = %if.else
  %call60 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %1, i64* %slen, i32 0) #7
  %.pre161 = load i64* %ulen, align 8, !tbaa !3
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false59, %cond.true54
  %26 = phi i64 [ %sub.ptr.sub44.pre, %cond.true54 ], [ %.pre161, %cond.false59 ]
  %cond62 = phi i8* [ %25, %cond.true54 ], [ %call60, %cond.false59 ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %cond62, i8* %arraydecay, i64 %26, i32 1, i1 false)
  br label %if.end110

if.else65:                                        ; preds = %land.lhs.true15, %cond.end, %land.lhs.true, %if.end
  %27 = load i32* %sv_flags, align 4, !tbaa !4
  %28 = and i32 %27, 8389120
  %29 = icmp eq i32 %28, 512
  br i1 %29, label %if.end79, label %if.then73

if.then73:                                        ; preds = %if.else65
  %30 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ75 = getelementptr inbounds %struct.op* %30, i64 0, i32 3
  %31 = load i64* %op_targ75, align 8, !tbaa !3
  %32 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx76 = getelementptr inbounds %struct.sv** %32, i64 %31
  %33 = load %struct.sv** %arrayidx76, align 8, !tbaa !0
  %sv_flags77 = getelementptr inbounds %struct.sv* %33, i64 0, i32 2
  %34 = load i32* %sv_flags77, align 4, !tbaa !4
  %and78 = and i32 %34, -536870913
  store i32 %and78, i32* %sv_flags77, align 4, !tbaa !4
  call void @Perl_sv_setsv_flags(%struct.sv* %33, %struct.sv* %1, i32 0) #7
  store %struct.sv* %33, %struct.sv** %0, align 8, !tbaa !0
  %.pre159 = load i32* %sv_flags77, align 4, !tbaa !4
  br label %if.end79

if.end79:                                         ; preds = %if.else65, %if.then73
  %35 = phi i32 [ %.pre159, %if.then73 ], [ %27, %if.else65 ]
  %sv.0 = phi %struct.sv* [ %33, %if.then73 ], [ %1, %if.else65 ]
  %and81 = and i32 %35, 10223616
  %cmp82 = icmp eq i32 %and81, 262144
  br i1 %cmp82, label %cond.true84, label %cond.false89

cond.true84:                                      ; preds = %if.end79
  %sv_any85 = getelementptr inbounds %struct.sv* %sv.0, i64 0, i32 0
  %36 = load i8** %sv_any85, align 8, !tbaa !0
  %xpv_cur86 = getelementptr inbounds i8* %36, i64 8
  %37 = bitcast i8* %xpv_cur86 to i64*
  %38 = load i64* %37, align 8, !tbaa !3
  store i64 %38, i64* %slen, align 8, !tbaa !3
  %xpv_pv88 = bitcast i8* %36 to i8**
  %39 = load i8** %xpv_pv88, align 8, !tbaa !0
  br label %cond.end91

cond.false89:                                     ; preds = %if.end79
  %call90 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv.0, i64* %slen, i32 0) #7
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false89, %cond.true84
  %cond92 = phi i8* [ %39, %cond.true84 ], [ %call90, %cond.false89 ]
  %40 = load i8* %cond92, align 1, !tbaa !1
  %tobool93 = icmp eq i8 %40, 0
  br i1 %tobool93, label %if.end110, label %if.then94

if.then94:                                        ; preds = %cond.end91
  %.off = add i8 %40, -65
  %41 = icmp ult i8 %.off, 26
  %add = add i8 %40, 32
  %add. = select i1 %41, i8 %add, i8 %40
  store i8 %add., i8* %cond92, align 1, !tbaa !1
  br label %if.end110

if.end110:                                        ; preds = %cond.end91, %if.then94, %if.end48, %cond.end61
  %sv.1 = phi %struct.sv* [ %sv.0, %if.then94 ], [ %1, %if.end48 ], [ %1, %cond.end61 ], [ %sv.0, %cond.end91 ]
  %sv_flags111 = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 2
  %42 = load i32* %sv_flags111, align 4, !tbaa !4
  %and112 = and i32 %42, 16384
  %tobool113 = icmp eq i32 %and112, 0
  br i1 %tobool113, label %if.end116, label %if.then114

if.then114:                                       ; preds = %if.end110
  %call115 = call i32 @Perl_mg_set(%struct.sv* %sv.1) #7
  br label %if.end116

if.end116:                                        ; preds = %if.end110, %if.then114
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %43 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %43, i64 0, i32 0
  %44 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %44
}

; Function Attrs: optsize
declare i64 @Perl_to_utf8_lower(i8*, i8*, i64*) #1

; Function Attrs: optsize
declare i8* @Perl_uvuni_to_utf8(i8*, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_uc() #0 {
entry:
  %len = alloca i64, align 8
  %ulen = alloca i64, align 8
  %tmpbuf = alloca [14 x i8], align 1
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 8192
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @Perl_mg_get(%struct.sv* %1) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %3 = phi i32 [ %2, %entry ], [ %.pre, %if.then ]
  %and2 = and i32 %3, 536870912
  %tobool3 = icmp eq i32 %and2, 0
  br i1 %tobool3, label %if.else82, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %5, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %if.then6, label %land.lhs.true.if.else82_crit_edge

land.lhs.true.if.else82_crit_edge:                ; preds = %land.lhs.true
  %.pre209 = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.else82

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %7 = load i64* %op_targ, align 8, !tbaa !3
  %8 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %8, i64 %7
  %9 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %and8 = and i32 %3, 262144
  %cmp = icmp eq i32 %and8, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then6
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur to i64*
  %12 = load i64* %11, align 8, !tbaa !3
  store i64 %12, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.then6
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %len, i32 0) #7
  %.pr = load i64* %len, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %14 = phi i64 [ %.pr, %cond.false ], [ %12, %cond.true ]
  %cond = phi i8* [ %call11, %cond.false ], [ %13, %cond.true ]
  %tobool12 = icmp eq i64 %14, 0
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %cond.end
  %sv_flags14 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %15 = load i32* %sv_flags14, align 4, !tbaa !4
  %and15 = and i32 %15, -536870913
  store i32 %and15, i32* %sv_flags14, align 4, !tbaa !4
  call void @Perl_sv_setpvn(%struct.sv* %9, i8* getelementptr inbounds ([1 x i8]* @.str4, i64 0, i64 0), i64 0) #7
  store %struct.sv* %9, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end131

if.else:                                          ; preds = %cond.end
  %add = add i64 %14, 1
  %sv_flags16 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %16 = load i32* %sv_flags16, align 4, !tbaa !4
  %and17 = and i32 %16, 252
  %cmp18 = icmp eq i32 %and17, 0
  br i1 %cmp18, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.else
  %call20 = call signext i8 @Perl_sv_upgrade(%struct.sv* %9, i32 4) #7
  br label %lor.end

lor.end:                                          ; preds = %if.else, %lor.rhs
  %sv_any23 = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %17 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_len = getelementptr inbounds i8* %17, i64 16
  %18 = bitcast i8* %xpv_len to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  %cmp24 = icmp ult i64 %19, %add
  br i1 %cmp24, label %cond.true26, label %cond.end31

cond.true26:                                      ; preds = %lor.end
  %call27 = call i8* @Perl_sv_grow(%struct.sv* %9, i64 %add) #7
  %.pre207 = load i8** %sv_any23, align 8, !tbaa !0
  br label %cond.end31

cond.end31:                                       ; preds = %lor.end, %cond.true26
  %20 = phi i8* [ %.pre207, %cond.true26 ], [ %17, %lor.end ]
  %21 = load i32* %sv_flags16, align 4, !tbaa !4
  %and34 = and i32 %21, 1223753727
  %or = or i32 %and34, 67371008
  store i32 %or, i32* %sv_flags16, align 4, !tbaa !4
  %xpv_pv37 = bitcast i8* %20 to i8**
  %22 = load i8** %xpv_pv37, align 8, !tbaa !0
  %23 = load i64* %len, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8* %cond, i64 %23
  %cmp38202 = icmp sgt i64 %23, 0
  br i1 %cmp38202, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %cond.end31
  %arraydecay = getelementptr inbounds [14 x i8]* %tmpbuf, i64 0, i64 0
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end68
  %s.0205 = phi i8* [ %cond, %while.body.lr.ph ], [ %add.ptr71, %if.end68 ]
  %d.0204 = phi i8* [ %22, %while.body.lr.ph ], [ %add.ptr70, %if.end68 ]
  %min.0203 = phi i64 [ %add, %while.body.lr.ph ], [ %min.1, %if.end68 ]
  %24 = load i8* %s.0205, align 1, !tbaa !1
  %idxprom = zext i8 %24 to i64
  %arrayidx40 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom
  %25 = load i8* %arrayidx40, align 1, !tbaa !1
  %conv41 = zext i8 %25 to i64
  %call42 = call i64 @Perl_to_utf8_upper(i8* %s.0205, i8* %arraydecay, i64* %ulen) #7
  %26 = load i64* %ulen, align 8, !tbaa !3
  %cmp43 = icmp ugt i64 %26, %conv41
  br i1 %cmp43, label %land.lhs.true45, label %if.end68

land.lhs.true45:                                  ; preds = %while.body
  %27 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_len47 = getelementptr inbounds i8* %27, i64 16
  %28 = bitcast i8* %xpv_len47 to i64*
  %29 = load i64* %28, align 8, !tbaa !3
  %sub = sub i64 %26, %conv41
  %add48 = add i64 %sub, %min.0203
  %cmp49 = icmp ult i64 %29, %add48
  br i1 %cmp49, label %if.then51, label %if.end68

if.then51:                                        ; preds = %land.lhs.true45
  %xpv_pv53 = bitcast i8* %27 to i8**
  %30 = load i8** %xpv_pv53, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint i8* %d.0204 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %30 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call59 = call i8* @Perl_sv_grow(%struct.sv* %9, i64 %add48) #7
  %31 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_pv66 = bitcast i8* %31 to i8**
  %32 = load i8** %xpv_pv66, align 8, !tbaa !0
  %add.ptr67 = getelementptr inbounds i8* %32, i64 %sub.ptr.sub
  %.pre208 = load i64* %ulen, align 8, !tbaa !3
  br label %if.end68

if.end68:                                         ; preds = %if.then51, %land.lhs.true45, %while.body
  %33 = phi i64 [ %.pre208, %if.then51 ], [ %26, %land.lhs.true45 ], [ %26, %while.body ]
  %min.1 = phi i64 [ %add48, %if.then51 ], [ %add48, %land.lhs.true45 ], [ %min.0203, %while.body ]
  %d.1 = phi i8* [ %add.ptr67, %if.then51 ], [ %d.0204, %land.lhs.true45 ], [ %d.0204, %while.body ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %d.1, i8* %arraydecay, i64 %33, i32 1, i1 false)
  %34 = load i64* %ulen, align 8, !tbaa !3
  %add.ptr70 = getelementptr inbounds i8* %d.1, i64 %34
  %add.ptr71 = getelementptr inbounds i8* %s.0205, i64 %conv41
  %cmp38 = icmp ult i8* %add.ptr71, %add.ptr
  br i1 %cmp38, label %while.body, label %while.end

while.end:                                        ; preds = %if.end68, %cond.end31
  %d.0.lcssa = phi i8* [ %22, %cond.end31 ], [ %add.ptr70, %if.end68 ]
  store i8 0, i8* %d.0.lcssa, align 1, !tbaa !1
  %35 = load i32* %sv_flags16, align 4, !tbaa !4
  %or73 = or i32 %35, 536870912
  store i32 %or73, i32* %sv_flags16, align 4, !tbaa !4
  %36 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_pv75 = bitcast i8* %36 to i8**
  %37 = load i8** %xpv_pv75, align 8, !tbaa !0
  %sub.ptr.lhs.cast76 = ptrtoint i8* %d.0.lcssa to i64
  %sub.ptr.rhs.cast77 = ptrtoint i8* %37 to i64
  %sub.ptr.sub78 = sub i64 %sub.ptr.lhs.cast76, %sub.ptr.rhs.cast77
  %xpv_cur80 = getelementptr inbounds i8* %36, i64 8
  %38 = bitcast i8* %xpv_cur80 to i64*
  store i64 %sub.ptr.sub78, i64* %38, align 8, !tbaa !3
  store %struct.sv* %9, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end131

if.else82:                                        ; preds = %land.lhs.true.if.else82_crit_edge, %if.end
  %39 = phi i32 [ %.pre209, %land.lhs.true.if.else82_crit_edge ], [ %3, %if.end ]
  %40 = and i32 %39, 8389120
  %41 = icmp eq i32 %40, 512
  br i1 %41, label %if.end95, label %if.then89

if.then89:                                        ; preds = %if.else82
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ91 = getelementptr inbounds %struct.op* %42, i64 0, i32 3
  %43 = load i64* %op_targ91, align 8, !tbaa !3
  %44 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx92 = getelementptr inbounds %struct.sv** %44, i64 %43
  %45 = load %struct.sv** %arrayidx92, align 8, !tbaa !0
  %sv_flags93 = getelementptr inbounds %struct.sv* %45, i64 0, i32 2
  %46 = load i32* %sv_flags93, align 4, !tbaa !4
  %and94 = and i32 %46, -536870913
  store i32 %and94, i32* %sv_flags93, align 4, !tbaa !4
  call void @Perl_sv_setsv_flags(%struct.sv* %45, %struct.sv* %1, i32 0) #7
  store %struct.sv* %45, %struct.sv** %0, align 8, !tbaa !0
  %.pre206 = load i32* %sv_flags93, align 4, !tbaa !4
  br label %if.end95

if.end95:                                         ; preds = %if.else82, %if.then89
  %47 = phi i32 [ %.pre206, %if.then89 ], [ %39, %if.else82 ]
  %sv.0 = phi %struct.sv* [ %45, %if.then89 ], [ %1, %if.else82 ]
  %and97 = and i32 %47, 10223616
  %cmp98 = icmp eq i32 %and97, 262144
  br i1 %cmp98, label %cond.true100, label %cond.false105

cond.true100:                                     ; preds = %if.end95
  %sv_any101 = getelementptr inbounds %struct.sv* %sv.0, i64 0, i32 0
  %48 = load i8** %sv_any101, align 8, !tbaa !0
  %xpv_cur102 = getelementptr inbounds i8* %48, i64 8
  %49 = bitcast i8* %xpv_cur102 to i64*
  %50 = load i64* %49, align 8, !tbaa !3
  store i64 %50, i64* %len, align 8, !tbaa !3
  %xpv_pv104 = bitcast i8* %48 to i8**
  %51 = load i8** %xpv_pv104, align 8, !tbaa !0
  br label %cond.end107

cond.false105:                                    ; preds = %if.end95
  %call106 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv.0, i64* %len, i32 0) #7
  %.pr199 = load i64* %len, align 8, !tbaa !3
  br label %cond.end107

cond.end107:                                      ; preds = %cond.false105, %cond.true100
  %52 = phi i64 [ %.pr199, %cond.false105 ], [ %50, %cond.true100 ]
  %cond108 = phi i8* [ %call106, %cond.false105 ], [ %51, %cond.true100 ]
  %tobool109 = icmp eq i64 %52, 0
  br i1 %tobool109, label %if.end131, label %if.then110

if.then110:                                       ; preds = %cond.end107
  %add.ptr112 = getelementptr inbounds i8* %cond108, i64 %52
  %cmp113200 = icmp sgt i64 %52, 0
  br i1 %cmp113200, label %for.body, label %if.end131

for.body:                                         ; preds = %if.then110, %for.body
  %s.1201 = phi i8* [ %incdec.ptr, %for.body ], [ %cond108, %if.then110 ]
  %53 = load i8* %s.1201, align 1, !tbaa !1
  %.off = add i8 %53, -97
  %54 = icmp ult i8 %.off, 26
  %sub124 = add i8 %53, -32
  %sub124. = select i1 %54, i8 %sub124, i8 %53
  store i8 %sub124., i8* %s.1201, align 1, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8* %s.1201, i64 1
  %cmp113 = icmp ult i8* %incdec.ptr, %add.ptr112
  br i1 %cmp113, label %for.body, label %if.end131

if.end131:                                        ; preds = %if.then110, %for.body, %cond.end107, %if.then13, %while.end
  %sv.1 = phi %struct.sv* [ %1, %while.end ], [ %1, %if.then13 ], [ %sv.0, %cond.end107 ], [ %sv.0, %for.body ], [ %sv.0, %if.then110 ]
  %sv_flags132 = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 2
  %55 = load i32* %sv_flags132, align 4, !tbaa !4
  %and133 = and i32 %55, 16384
  %tobool134 = icmp eq i32 %and133, 0
  br i1 %tobool134, label %if.end137, label %if.then135

if.then135:                                       ; preds = %if.end131
  %call136 = call i32 @Perl_mg_set(%struct.sv* %sv.1) #7
  br label %if.end137

if.end137:                                        ; preds = %if.end131, %if.then135
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %56 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %56, i64 0, i32 0
  %57 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %57
}

; Function Attrs: optsize
declare i64 @Perl_to_utf8_upper(i8*, i8*, i64*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_lc() #0 {
entry:
  %len = alloca i64, align 8
  %ulen = alloca i64, align 8
  %tmpbuf = alloca [7 x i8], align 1
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 8192
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @Perl_mg_get(%struct.sv* %1) #7
  %.pre = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %3 = phi i32 [ %2, %entry ], [ %.pre, %if.then ]
  %and2 = and i32 %3, 536870912
  %tobool3 = icmp eq i32 %and2, 0
  br i1 %tobool3, label %if.else86, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %5, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %if.then6, label %land.lhs.true.if.else86_crit_edge

land.lhs.true.if.else86_crit_edge:                ; preds = %land.lhs.true
  %.pre213 = load i32* %sv_flags, align 4, !tbaa !4
  br label %if.else86

if.then6:                                         ; preds = %land.lhs.true
  %6 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %7 = load i64* %op_targ, align 8, !tbaa !3
  %8 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %8, i64 %7
  %9 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %and8 = and i32 %3, 262144
  %cmp = icmp eq i32 %and8, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then6
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur to i64*
  %12 = load i64* %11, align 8, !tbaa !3
  store i64 %12, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %if.then6
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %len, i32 0) #7
  %.pr = load i64* %len, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %14 = phi i64 [ %.pr, %cond.false ], [ %12, %cond.true ]
  %cond = phi i8* [ %call11, %cond.false ], [ %13, %cond.true ]
  %tobool12 = icmp eq i64 %14, 0
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %cond.end
  %sv_flags14 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %15 = load i32* %sv_flags14, align 4, !tbaa !4
  %and15 = and i32 %15, -536870913
  store i32 %and15, i32* %sv_flags14, align 4, !tbaa !4
  call void @Perl_sv_setpvn(%struct.sv* %9, i8* getelementptr inbounds ([1 x i8]* @.str4, i64 0, i64 0), i64 0) #7
  store %struct.sv* %9, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end135

if.else:                                          ; preds = %cond.end
  %add = add i64 %14, 1
  %sv_flags16 = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %16 = load i32* %sv_flags16, align 4, !tbaa !4
  %and17 = and i32 %16, 252
  %cmp18 = icmp eq i32 %and17, 0
  br i1 %cmp18, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.else
  %call20 = call signext i8 @Perl_sv_upgrade(%struct.sv* %9, i32 4) #7
  br label %lor.end

lor.end:                                          ; preds = %if.else, %lor.rhs
  %sv_any23 = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %17 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_len = getelementptr inbounds i8* %17, i64 16
  %18 = bitcast i8* %xpv_len to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  %cmp24 = icmp ult i64 %19, %add
  br i1 %cmp24, label %cond.true26, label %cond.end31

cond.true26:                                      ; preds = %lor.end
  %call27 = call i8* @Perl_sv_grow(%struct.sv* %9, i64 %add) #7
  %.pre211 = load i8** %sv_any23, align 8, !tbaa !0
  br label %cond.end31

cond.end31:                                       ; preds = %lor.end, %cond.true26
  %20 = phi i8* [ %.pre211, %cond.true26 ], [ %17, %lor.end ]
  %21 = load i32* %sv_flags16, align 4, !tbaa !4
  %and34 = and i32 %21, 1223753727
  %or = or i32 %and34, 67371008
  store i32 %or, i32* %sv_flags16, align 4, !tbaa !4
  %xpv_pv37 = bitcast i8* %20 to i8**
  %22 = load i8** %xpv_pv37, align 8, !tbaa !0
  %23 = load i64* %len, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8* %cond, i64 %23
  %cmp38206 = icmp sgt i64 %23, 0
  br i1 %cmp38206, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %cond.end31
  %arraydecay = getelementptr inbounds [7 x i8]* %tmpbuf, i64 0, i64 0
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end72
  %s.0209 = phi i8* [ %cond, %while.body.lr.ph ], [ %add.ptr75, %if.end72 ]
  %d.0208 = phi i8* [ %22, %while.body.lr.ph ], [ %add.ptr74, %if.end72 ]
  %min.0207 = phi i64 [ %add, %while.body.lr.ph ], [ %min.1, %if.end72 ]
  %24 = load i8* %s.0209, align 1, !tbaa !1
  %idxprom = zext i8 %24 to i64
  %arrayidx40 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom
  %25 = load i8* %arrayidx40, align 1, !tbaa !1
  %conv41 = zext i8 %25 to i64
  %call42 = call i64 @Perl_to_utf8_lower(i8* %s.0209, i8* %arraydecay, i64* %ulen) #7
  %26 = load i64* %ulen, align 8, !tbaa !3
  %cmp47 = icmp ugt i64 %26, %conv41
  br i1 %cmp47, label %land.lhs.true49, label %if.end72

land.lhs.true49:                                  ; preds = %while.body
  %27 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_len51 = getelementptr inbounds i8* %27, i64 16
  %28 = bitcast i8* %xpv_len51 to i64*
  %29 = load i64* %28, align 8, !tbaa !3
  %sub = sub i64 %26, %conv41
  %add52 = add i64 %sub, %min.0207
  %cmp53 = icmp ult i64 %29, %add52
  br i1 %cmp53, label %if.then55, label %if.end72

if.then55:                                        ; preds = %land.lhs.true49
  %xpv_pv57 = bitcast i8* %27 to i8**
  %30 = load i8** %xpv_pv57, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint i8* %d.0208 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %30 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call63 = call i8* @Perl_sv_grow(%struct.sv* %9, i64 %add52) #7
  %31 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_pv70 = bitcast i8* %31 to i8**
  %32 = load i8** %xpv_pv70, align 8, !tbaa !0
  %add.ptr71 = getelementptr inbounds i8* %32, i64 %sub.ptr.sub
  %.pre212 = load i64* %ulen, align 8, !tbaa !3
  br label %if.end72

if.end72:                                         ; preds = %if.then55, %land.lhs.true49, %while.body
  %33 = phi i64 [ %.pre212, %if.then55 ], [ %26, %land.lhs.true49 ], [ %26, %while.body ]
  %min.1 = phi i64 [ %add52, %if.then55 ], [ %add52, %land.lhs.true49 ], [ %min.0207, %while.body ]
  %d.1 = phi i8* [ %add.ptr71, %if.then55 ], [ %d.0208, %land.lhs.true49 ], [ %d.0208, %while.body ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %d.1, i8* %arraydecay, i64 %33, i32 1, i1 false)
  %34 = load i64* %ulen, align 8, !tbaa !3
  %add.ptr74 = getelementptr inbounds i8* %d.1, i64 %34
  %add.ptr75 = getelementptr inbounds i8* %s.0209, i64 %conv41
  %cmp38 = icmp ult i8* %add.ptr75, %add.ptr
  br i1 %cmp38, label %while.body, label %while.end

while.end:                                        ; preds = %if.end72, %cond.end31
  %d.0.lcssa = phi i8* [ %22, %cond.end31 ], [ %add.ptr74, %if.end72 ]
  store i8 0, i8* %d.0.lcssa, align 1, !tbaa !1
  %35 = load i32* %sv_flags16, align 4, !tbaa !4
  %or77 = or i32 %35, 536870912
  store i32 %or77, i32* %sv_flags16, align 4, !tbaa !4
  %36 = load i8** %sv_any23, align 8, !tbaa !0
  %xpv_pv79 = bitcast i8* %36 to i8**
  %37 = load i8** %xpv_pv79, align 8, !tbaa !0
  %sub.ptr.lhs.cast80 = ptrtoint i8* %d.0.lcssa to i64
  %sub.ptr.rhs.cast81 = ptrtoint i8* %37 to i64
  %sub.ptr.sub82 = sub i64 %sub.ptr.lhs.cast80, %sub.ptr.rhs.cast81
  %xpv_cur84 = getelementptr inbounds i8* %36, i64 8
  %38 = bitcast i8* %xpv_cur84 to i64*
  store i64 %sub.ptr.sub82, i64* %38, align 8, !tbaa !3
  store %struct.sv* %9, %struct.sv** %0, align 8, !tbaa !0
  br label %if.end135

if.else86:                                        ; preds = %land.lhs.true.if.else86_crit_edge, %if.end
  %39 = phi i32 [ %.pre213, %land.lhs.true.if.else86_crit_edge ], [ %3, %if.end ]
  %40 = and i32 %39, 8389120
  %41 = icmp eq i32 %40, 512
  br i1 %41, label %if.end99, label %if.then93

if.then93:                                        ; preds = %if.else86
  %42 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ95 = getelementptr inbounds %struct.op* %42, i64 0, i32 3
  %43 = load i64* %op_targ95, align 8, !tbaa !3
  %44 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx96 = getelementptr inbounds %struct.sv** %44, i64 %43
  %45 = load %struct.sv** %arrayidx96, align 8, !tbaa !0
  %sv_flags97 = getelementptr inbounds %struct.sv* %45, i64 0, i32 2
  %46 = load i32* %sv_flags97, align 4, !tbaa !4
  %and98 = and i32 %46, -536870913
  store i32 %and98, i32* %sv_flags97, align 4, !tbaa !4
  call void @Perl_sv_setsv_flags(%struct.sv* %45, %struct.sv* %1, i32 0) #7
  store %struct.sv* %45, %struct.sv** %0, align 8, !tbaa !0
  %.pre210 = load i32* %sv_flags97, align 4, !tbaa !4
  br label %if.end99

if.end99:                                         ; preds = %if.else86, %if.then93
  %47 = phi i32 [ %.pre210, %if.then93 ], [ %39, %if.else86 ]
  %sv.0 = phi %struct.sv* [ %45, %if.then93 ], [ %1, %if.else86 ]
  %and101 = and i32 %47, 10223616
  %cmp102 = icmp eq i32 %and101, 262144
  br i1 %cmp102, label %cond.true104, label %cond.false109

cond.true104:                                     ; preds = %if.end99
  %sv_any105 = getelementptr inbounds %struct.sv* %sv.0, i64 0, i32 0
  %48 = load i8** %sv_any105, align 8, !tbaa !0
  %xpv_cur106 = getelementptr inbounds i8* %48, i64 8
  %49 = bitcast i8* %xpv_cur106 to i64*
  %50 = load i64* %49, align 8, !tbaa !3
  store i64 %50, i64* %len, align 8, !tbaa !3
  %xpv_pv108 = bitcast i8* %48 to i8**
  %51 = load i8** %xpv_pv108, align 8, !tbaa !0
  br label %cond.end111

cond.false109:                                    ; preds = %if.end99
  %call110 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %sv.0, i64* %len, i32 0) #7
  %.pr203 = load i64* %len, align 8, !tbaa !3
  br label %cond.end111

cond.end111:                                      ; preds = %cond.false109, %cond.true104
  %52 = phi i64 [ %.pr203, %cond.false109 ], [ %50, %cond.true104 ]
  %cond112 = phi i8* [ %call110, %cond.false109 ], [ %51, %cond.true104 ]
  %tobool113 = icmp eq i64 %52, 0
  br i1 %tobool113, label %if.end135, label %if.then114

if.then114:                                       ; preds = %cond.end111
  %add.ptr116 = getelementptr inbounds i8* %cond112, i64 %52
  %cmp117204 = icmp sgt i64 %52, 0
  br i1 %cmp117204, label %for.body, label %if.end135

for.body:                                         ; preds = %if.then114, %for.body
  %s.1205 = phi i8* [ %incdec.ptr, %for.body ], [ %cond112, %if.then114 ]
  %53 = load i8* %s.1205, align 1, !tbaa !1
  %.off = add i8 %53, -65
  %54 = icmp ult i8 %.off, 26
  %add128 = add i8 %53, 32
  %add128. = select i1 %54, i8 %add128, i8 %53
  store i8 %add128., i8* %s.1205, align 1, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8* %s.1205, i64 1
  %cmp117 = icmp ult i8* %incdec.ptr, %add.ptr116
  br i1 %cmp117, label %for.body, label %if.end135

if.end135:                                        ; preds = %if.then114, %for.body, %cond.end111, %if.then13, %while.end
  %sv.1 = phi %struct.sv* [ %1, %while.end ], [ %1, %if.then13 ], [ %sv.0, %cond.end111 ], [ %sv.0, %for.body ], [ %sv.0, %if.then114 ]
  %sv_flags136 = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 2
  %55 = load i32* %sv_flags136, align 4, !tbaa !4
  %and137 = and i32 %55, 16384
  %tobool138 = icmp eq i32 %and137, 0
  br i1 %tobool138, label %if.end141, label %if.then139

if.then139:                                       ; preds = %if.end135
  %call140 = call i32 @Perl_mg_set(%struct.sv* %sv.1) #7
  br label %if.end141

if.end141:                                        ; preds = %if.end135, %if.then139
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %56 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %56, i64 0, i32 0
  %57 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %57
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_quotemeta() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !3
  store i64 %9, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %7 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %len, i32 2) #7
  %.pre = load i64* %len, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %11 = phi i64 [ %9, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %10, %cond.true ], [ %call, %cond.false ]
  %sv_flags2 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %12 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %12, -536870913
  store i32 %and3, i32* %sv_flags2, align 4, !tbaa !4
  %tobool = icmp eq i64 %11, 0
  br i1 %tobool, label %if.else126, label %if.then

if.then:                                          ; preds = %cond.end
  %and5 = and i32 %12, 252
  %cmp6 = icmp ugt i32 %and5, 3
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %call7 = call signext i8 @Perl_sv_upgrade(%struct.sv* %4, i32 4) #7
  %.pre227 = load i64* %len, align 8, !tbaa !3
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %13 = phi i64 [ %.pre227, %lor.rhs ], [ %11, %if.then ]
  %sv_any9 = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %14 = load i8** %sv_any9, align 8, !tbaa !0
  %xpv_len = getelementptr inbounds i8* %14, i64 16
  %15 = bitcast i8* %xpv_len to i64*
  %16 = load i64* %15, align 8, !tbaa !3
  %mul = shl i64 %13, 1
  %add178 = or i64 %mul, 1
  %cmp10 = icmp ult i64 %16, %add178
  br i1 %cmp10, label %cond.true12, label %cond.end19

cond.true12:                                      ; preds = %lor.end
  %call15 = call i8* @Perl_sv_grow(%struct.sv* %4, i64 %add178) #7
  %.pre228 = load i8** %sv_any9, align 8, !tbaa !0
  br label %cond.end19

cond.end19:                                       ; preds = %lor.end, %cond.true12
  %17 = phi i8* [ %14, %lor.end ], [ %.pre228, %cond.true12 ]
  %xpv_pv22 = bitcast i8* %17 to i8**
  %18 = load i8** %xpv_pv22, align 8, !tbaa !0
  %19 = load i32* %sv_flags, align 4, !tbaa !4
  %and24 = and i32 %19, 536870912
  %tobool25 = icmp eq i32 %and24, 0
  br i1 %tobool25, label %while.cond80.preheader, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end19
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %20, i64 0, i32 7
  %21 = load i8* %op_private, align 1, !tbaa !1
  %and27 = and i8 %21, 8
  %tobool28 = icmp eq i8 %and27, 0
  br i1 %tobool28, label %while.condthread-pre-split.preheader, label %while.cond80.preheader

while.condthread-pre-split.preheader:             ; preds = %land.lhs.true
  %.pr212 = load i64* %len, align 8, !tbaa !3
  %tobool30201213 = icmp eq i64 %.pr212, 0
  br i1 %tobool30201213, label %while.end77, label %while.body

while.cond80.preheader:                           ; preds = %land.lhs.true, %cond.end19
  %22 = load i64* %len, align 8, !tbaa !3
  %dec81194 = add i64 %22, -1
  store i64 %dec81194, i64* %len, align 8, !tbaa !3
  %tobool82195 = icmp eq i64 %22, 0
  br i1 %tobool82195, label %if.end117, label %while.body83

while.cond40.while.condthread-pre-split.loopexit_crit_edge: ; preds = %while.body42
  %scevgep.sum = xor i64 %umax, -1
  %scevgep223 = getelementptr i8* %d.0203, i64 %scevgep.sum
  %scevgep224.sum = xor i64 %umax, -1
  %scevgep225 = getelementptr i8* %s.0202, i64 %scevgep224.sum
  %.pr.pre = load i64* %len, align 8, !tbaa !3
  br label %while.condthread-pre-split.loopexit

while.condthread-pre-split.loopexit:              ; preds = %while.cond40.while.condthread-pre-split.loopexit_crit_edge, %if.then34
  %.pr = phi i64 [ %.pr.pre, %while.cond40.while.condthread-pre-split.loopexit_crit_edge ], [ %sub, %if.then34 ]
  %d.1.lcssa = phi i8* [ %scevgep223, %while.cond40.while.condthread-pre-split.loopexit_crit_edge ], [ %d.0203, %if.then34 ]
  %s.1.lcssa = phi i8* [ %scevgep225, %while.cond40.while.condthread-pre-split.loopexit_crit_edge ], [ %s.0202, %if.then34 ]
  %tobool30201 = icmp eq i64 %.pr, 0
  br i1 %tobool30201, label %while.end77, label %while.body

while.body:                                       ; preds = %while.condthread-pre-split.loopexit, %while.condthread-pre-split.preheader, %if.end72
  %d.0203 = phi i8* [ %incdec.ptr74, %if.end72 ], [ %d.1.lcssa, %while.condthread-pre-split.loopexit ], [ %18, %while.condthread-pre-split.preheader ]
  %s.0202 = phi i8* [ %incdec.ptr73, %if.end72 ], [ %s.1.lcssa, %while.condthread-pre-split.loopexit ], [ %cond, %while.condthread-pre-split.preheader ]
  %23 = phi i64 [ %dec75, %if.end72 ], [ %.pr, %while.condthread-pre-split.loopexit ], [ %.pr212, %while.condthread-pre-split.preheader ]
  %24 = load i8* %s.0202, align 1, !tbaa !1
  %tobool33 = icmp slt i8 %24, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %while.body
  %idxprom = zext i8 %24 to i64
  %arrayidx35 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom
  %25 = load i8* %arrayidx35, align 1, !tbaa !1
  %conv36 = zext i8 %25 to i64
  %cmp37 = icmp ugt i64 %conv36, %23
  %.conv36 = select i1 %cmp37, i64 %23, i64 %conv36
  %sub = sub i64 %23, %.conv36
  store i64 %sub, i64* %len, align 8, !tbaa !3
  %tobool41205 = icmp eq i64 %.conv36, 0
  br i1 %tobool41205, label %while.condthread-pre-split.loopexit, label %while.body42.lr.ph

while.body42.lr.ph:                               ; preds = %if.then34
  %26 = xor i64 %23, -1
  %27 = xor i64 %conv36, -1
  %28 = icmp ugt i64 %26, %27
  %umax = select i1 %28, i64 %26, i64 %27
  br label %while.body42

while.body42:                                     ; preds = %while.body42.lr.ph, %while.body42
  %ulen.1208 = phi i64 [ %.conv36, %while.body42.lr.ph ], [ %dec, %while.body42 ]
  %d.1207 = phi i8* [ %d.0203, %while.body42.lr.ph ], [ %incdec.ptr43, %while.body42 ]
  %s.1206 = phi i8* [ %s.0202, %while.body42.lr.ph ], [ %incdec.ptr, %while.body42 ]
  %dec = add i64 %ulen.1208, -1
  %incdec.ptr = getelementptr inbounds i8* %s.1206, i64 1
  %29 = load i8* %s.1206, align 1, !tbaa !1
  %incdec.ptr43 = getelementptr inbounds i8* %d.1207, i64 1
  store i8 %29, i8* %d.1207, align 1, !tbaa !1
  %tobool41 = icmp eq i64 %dec, 0
  br i1 %tobool41, label %while.cond40.while.condthread-pre-split.loopexit_crit_edge, label %while.body42

if.else:                                          ; preds = %while.body
  %.off188 = add i8 %24, -65
  %30 = icmp ult i8 %.off188, 26
  %.off189 = add i8 %24, -97
  %31 = icmp ult i8 %.off189, 26
  %or.cond = or i1 %30, %31
  br i1 %or.cond, label %if.end72, label %lor.lhs.false58

lor.lhs.false58:                                  ; preds = %if.else
  %.off190 = add i8 %24, -48
  %32 = icmp ult i8 %.off190, 10
  %cmp68 = icmp eq i8 %24, 95
  %or.cond184 = or i1 %32, %cmp68
  br i1 %or.cond184, label %if.end72, label %if.then70

if.then70:                                        ; preds = %lor.lhs.false58
  %incdec.ptr71 = getelementptr inbounds i8* %d.0203, i64 1
  store i8 92, i8* %d.0203, align 1, !tbaa !1
  %.pre230 = load i8* %s.0202, align 1, !tbaa !1
  br label %if.end72

if.end72:                                         ; preds = %lor.lhs.false58, %if.else, %if.then70
  %33 = phi i8 [ %.pre230, %if.then70 ], [ %24, %if.else ], [ %24, %lor.lhs.false58 ]
  %d.2 = phi i8* [ %incdec.ptr71, %if.then70 ], [ %d.0203, %if.else ], [ %d.0203, %lor.lhs.false58 ]
  %incdec.ptr73 = getelementptr inbounds i8* %s.0202, i64 1
  %incdec.ptr74 = getelementptr inbounds i8* %d.2, i64 1
  store i8 %33, i8* %d.2, align 1, !tbaa !1
  %34 = load i64* %len, align 8, !tbaa !3
  %dec75 = add i64 %34, -1
  store i64 %dec75, i64* %len, align 8, !tbaa !3
  %tobool30 = icmp eq i64 %dec75, 0
  br i1 %tobool30, label %while.end77, label %while.body

while.end77:                                      ; preds = %while.condthread-pre-split.preheader, %while.condthread-pre-split.loopexit, %if.end72
  %d.0.lcssa = phi i8* [ %incdec.ptr74, %if.end72 ], [ %18, %while.condthread-pre-split.preheader ], [ %d.1.lcssa, %while.condthread-pre-split.loopexit ]
  %35 = load i32* %sv_flags2, align 4, !tbaa !4
  %or = or i32 %35, 536870912
  store i32 %or, i32* %sv_flags2, align 4, !tbaa !4
  br label %if.end117

while.body83:                                     ; preds = %while.cond80.preheader, %if.end113
  %d.3197 = phi i8* [ %incdec.ptr115, %if.end113 ], [ %18, %while.cond80.preheader ]
  %s.2196 = phi i8* [ %incdec.ptr114, %if.end113 ], [ %cond, %while.cond80.preheader ]
  %36 = load i8* %s.2196, align 1, !tbaa !1
  %.off = add i8 %36, -65
  %37 = icmp ult i8 %.off, 26
  %.off186 = add i8 %36, -97
  %38 = icmp ult i8 %.off186, 26
  %or.cond193 = or i1 %37, %38
  br i1 %or.cond193, label %if.end113, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %while.body83
  %.off187 = add i8 %36, -48
  %39 = icmp ult i8 %.off187, 10
  %cmp109 = icmp eq i8 %36, 95
  %or.cond185 = or i1 %39, %cmp109
  br i1 %or.cond185, label %if.end113, label %if.then111

if.then111:                                       ; preds = %lor.lhs.false99
  %incdec.ptr112 = getelementptr inbounds i8* %d.3197, i64 1
  store i8 92, i8* %d.3197, align 1, !tbaa !1
  %.pre231 = load i8* %s.2196, align 1, !tbaa !1
  br label %if.end113

if.end113:                                        ; preds = %lor.lhs.false99, %while.body83, %if.then111
  %40 = phi i8 [ %.pre231, %if.then111 ], [ %36, %while.body83 ], [ %36, %lor.lhs.false99 ]
  %d.4 = phi i8* [ %incdec.ptr112, %if.then111 ], [ %d.3197, %while.body83 ], [ %d.3197, %lor.lhs.false99 ]
  %incdec.ptr114 = getelementptr inbounds i8* %s.2196, i64 1
  %incdec.ptr115 = getelementptr inbounds i8* %d.4, i64 1
  store i8 %40, i8* %d.4, align 1, !tbaa !1
  %41 = load i64* %len, align 8, !tbaa !3
  %dec81 = add i64 %41, -1
  store i64 %dec81, i64* %len, align 8, !tbaa !3
  %tobool82 = icmp eq i64 %41, 0
  br i1 %tobool82, label %if.end117, label %while.body83

if.end117:                                        ; preds = %while.cond80.preheader, %if.end113, %while.end77
  %d.5 = phi i8* [ %d.0.lcssa, %while.end77 ], [ %18, %while.cond80.preheader ], [ %incdec.ptr115, %if.end113 ]
  store i8 0, i8* %d.5, align 1, !tbaa !1
  %42 = load i8** %sv_any9, align 8, !tbaa !0
  %xpv_pv119 = bitcast i8* %42 to i8**
  %43 = load i8** %xpv_pv119, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint i8* %d.5 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %xpv_cur121 = getelementptr inbounds i8* %42, i64 8
  %44 = bitcast i8* %xpv_cur121 to i64*
  store i64 %sub.ptr.sub, i64* %44, align 8, !tbaa !3
  %45 = load i32* %sv_flags2, align 4, !tbaa !4
  %and123 = and i32 %45, 1760624639
  %or125 = or i32 %and123, 67371008
  store i32 %or125, i32* %sv_flags2, align 4, !tbaa !4
  br label %if.end127

if.else126:                                       ; preds = %cond.end
  call void @Perl_sv_setpvn(%struct.sv* %4, i8* %cond, i64 0) #7
  %.pre226 = load i32* %sv_flags2, align 4, !tbaa !4
  br label %if.end127

if.end127:                                        ; preds = %if.else126, %if.end117
  %46 = phi i32 [ %.pre226, %if.else126 ], [ %or125, %if.end117 ]
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  %and129 = and i32 %46, 16384
  %tobool130 = icmp eq i32 %and129, 0
  br i1 %tobool130, label %if.end133, label %if.then131

if.then131:                                       ; preds = %if.end127
  %call132 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end133

if.end133:                                        ; preds = %if.end127, %if.then131
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %47 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %47, i64 0, i32 0
  %48 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %48
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_aslice() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %0, i64 -1
  %4 = load %struct.sv** %0, align 8, !tbaa !0
  %5 = bitcast %struct.sv* %4 to %struct.av*
  %6 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %6, i64 0, i32 6
  %7 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %7, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %8 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %8, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %lor.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %call = tail call i32 @Perl_is_lvalue_sub() #7
  %tobool6 = icmp ne i32 %call, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry, %land.rhs
  %9 = phi i1 [ true, %entry ], [ false, %lor.rhs ], [ %tobool6, %land.rhs ]
  %lor.ext = zext i1 %9 to i32
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %10, i64 0, i32 12
  %11 = load i32* %cop_arybase, align 4, !tbaa !4
  %12 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %13 = load i32* %12, align 4, !tbaa !4
  %and7 = and i32 %13, 255
  %cmp = icmp eq i32 %and7, 10
  br i1 %cmp, label %if.then, label %if.end73

if.then:                                          ; preds = %lor.end
  br i1 %9, label %land.lhs.true, label %while.cond.preheader

land.lhs.true:                                    ; preds = %if.then
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private10 = getelementptr inbounds %struct.op* %14, i64 0, i32 7
  %15 = load i8* %op_private10, align 1, !tbaa !1
  %tobool13 = icmp slt i8 %15, 0
  br i1 %tobool13, label %if.then14, label %while.cond.preheader

if.then14:                                        ; preds = %land.lhs.true
  %add.ptr.sum = add i64 %idx.ext, 1
  %add.ptr15 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %cmp16141 = icmp ugt %struct.sv** %add.ptr15, %incdec.ptr1
  br i1 %cmp16141, label %for.end, label %for.body

for.body:                                         ; preds = %if.then14, %cond.end
  %max.0143 = phi i32 [ %conv22.max.0, %cond.end ], [ -1, %if.then14 ]
  %svp.0142 = phi %struct.sv** [ %incdec.ptr26, %cond.end ], [ %add.ptr15, %if.then14 ]
  %16 = load %struct.sv** %svp.0142, align 8, !tbaa !0
  store %struct.sv* %16, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags18 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags18, align 4, !tbaa !4
  %and19 = and i32 %17, 65536
  %tobool20 = icmp eq i32 %and19, 0
  br i1 %tobool20, label %cond.false, label %cond.true

cond.true:                                        ; preds = %for.body
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %18, i64 24
  %19 = bitcast i8* %xiv_iv to i64*
  %20 = load i64* %19, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %call21 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %20, %cond.true ], [ %call21, %cond.false ]
  %conv22 = trunc i64 %cond to i32
  %cmp23 = icmp sgt i32 %conv22, %max.0143
  %conv22.max.0 = select i1 %cmp23, i32 %conv22, i32 %max.0143
  %incdec.ptr26 = getelementptr inbounds %struct.sv** %svp.0142, i64 1
  %cmp16 = icmp ugt %struct.sv** %incdec.ptr26, %incdec.ptr1
  br i1 %cmp16, label %for.end, label %for.body

for.end:                                          ; preds = %cond.end, %if.then14
  %max.0.lcssa = phi i32 [ -1, %if.then14 ], [ %conv22.max.0, %cond.end ]
  %conv27 = sext i32 %max.0.lcssa to i64
  %sv_any28 = bitcast %struct.sv* %4 to %struct.xpvav**
  %21 = load %struct.xpvav** %sv_any28, align 8, !tbaa !0
  %xav_max = getelementptr inbounds %struct.xpvav* %21, i64 0, i32 2
  %22 = load i64* %xav_max, align 8, !tbaa !3
  %cmp29 = icmp sgt i64 %conv27, %22
  br i1 %cmp29, label %if.then31, label %while.cond.preheader

if.then31:                                        ; preds = %for.end
  tail call void @Perl_av_extend(%struct.av* %5, i32 %max.0.lcssa) #7
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %for.end, %if.then31, %land.lhs.true, %if.then
  %add.ptr.sum144 = add i64 %idx.ext, 1
  %incdec.ptr34138 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum144
  %cmp35139 = icmp ugt %struct.sv** %incdec.ptr34138, %incdec.ptr1
  br i1 %cmp35139, label %if.end73, label %while.body

while.body:                                       ; preds = %while.cond.preheader, %cond.end71
  %incdec.ptr34140 = phi %struct.sv** [ %incdec.ptr34, %cond.end71 ], [ %incdec.ptr34138, %while.cond.preheader ]
  %23 = load %struct.sv** %incdec.ptr34140, align 8, !tbaa !0
  store %struct.sv* %23, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags37 = getelementptr inbounds %struct.sv* %23, i64 0, i32 2
  %24 = load i32* %sv_flags37, align 4, !tbaa !4
  %and38 = and i32 %24, 65536
  %tobool39 = icmp eq i32 %and38, 0
  br i1 %tobool39, label %cond.false43, label %cond.true40

cond.true40:                                      ; preds = %while.body
  %sv_any41 = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %25 = load i8** %sv_any41, align 8, !tbaa !0
  %xiv_iv42 = getelementptr inbounds i8* %25, i64 24
  %26 = bitcast i8* %xiv_iv42 to i64*
  %27 = load i64* %26, align 8, !tbaa !3
  br label %cond.end45

cond.false43:                                     ; preds = %while.body
  %call44 = tail call i64 @Perl_sv_2iv(%struct.sv* %23) #7
  br label %cond.end45

cond.end45:                                       ; preds = %cond.false43, %cond.true40
  %cond46 = phi i64 [ %27, %cond.true40 ], [ %call44, %cond.false43 ]
  %conv47 = trunc i64 %cond46 to i32
  %cmp48 = icmp sgt i32 %conv47, 0
  %sub = select i1 %cmp48, i32 %11, i32 0
  %sub.conv47 = sub nsw i32 %conv47, %sub
  %call52 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %5, i32 %sub.conv47, i32 %lor.ext) #7
  br i1 %9, label %if.then54, label %if.end67

if.then54:                                        ; preds = %cond.end45
  %tobool55 = icmp eq %struct.sv** %call52, null
  br i1 %tobool55, label %if.then58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then54
  %28 = load %struct.sv** %call52, align 8, !tbaa !0
  %cmp56 = icmp eq %struct.sv* %28, @PL_sv_undef
  br i1 %cmp56, label %if.then58, label %if.end60

if.then58:                                        ; preds = %if.then54, %lor.lhs.false
  %call59 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_aelem, i64 0, i64 0), i32 %sub.conv47) #7
  br label %return

if.end60:                                         ; preds = %lor.lhs.false
  %29 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private61 = getelementptr inbounds %struct.op* %29, i64 0, i32 7
  %30 = load i8* %op_private61, align 1, !tbaa !1
  %tobool64 = icmp slt i8 %30, 0
  br i1 %tobool64, label %if.then65, label %if.end67

if.then65:                                        ; preds = %if.end60
  tail call void @Perl_save_aelem(%struct.av* %5, i32 %sub.conv47, %struct.sv** %call52) #7
  br label %if.end67

if.end67:                                         ; preds = %if.end60, %if.then65, %cond.end45
  %tobool68 = icmp eq %struct.sv** %call52, null
  br i1 %tobool68, label %cond.end71, label %cond.true69

cond.true69:                                      ; preds = %if.end67
  %31 = load %struct.sv** %call52, align 8, !tbaa !0
  br label %cond.end71

cond.end71:                                       ; preds = %if.end67, %cond.true69
  %cond72 = phi %struct.sv* [ %31, %cond.true69 ], [ @PL_sv_undef, %if.end67 ]
  store %struct.sv* %cond72, %struct.sv** %incdec.ptr34140, align 8, !tbaa !0
  %incdec.ptr34 = getelementptr inbounds %struct.sv** %incdec.ptr34140, i64 1
  %cmp35 = icmp ugt %struct.sv** %incdec.ptr34, %incdec.ptr1
  br i1 %cmp35, label %if.end73, label %while.body

if.end73:                                         ; preds = %while.cond.preheader, %cond.end71, %lor.end
  %32 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags74 = getelementptr inbounds %struct.op* %32, i64 0, i32 6
  %33 = load i8* %op_flags74, align 1, !tbaa !1
  %conv75 = zext i8 %33 to i32
  %and76 = and i32 %conv75, 3
  %tobool77 = icmp eq i32 %and76, 0
  br i1 %tobool77, label %cond.false85, label %cond.true78

cond.true78:                                      ; preds = %if.end73
  %cmp82 = icmp eq i32 %and76, 3
  %cond84 = zext i1 %cmp82 to i32
  br label %cond.end87

cond.false85:                                     ; preds = %if.end73
  %call86 = tail call i32 @Perl_dowantarray() #7
  br label %cond.end87

cond.end87:                                       ; preds = %cond.false85, %cond.true78
  %cond88 = phi i32 [ %cond84, %cond.true78 ], [ %call86, %cond.false85 ]
  %cmp89 = icmp eq i32 %cond88, 1
  br i1 %cmp89, label %if.end103, label %if.then91

if.then91:                                        ; preds = %cond.end87
  %34 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr93 = getelementptr inbounds %struct.sv** %34, i64 %idx.ext
  %cmp96 = icmp ugt %struct.sv** %incdec.ptr1, %add.ptr93
  br i1 %cmp96, label %cond.true98, label %cond.end100

cond.true98:                                      ; preds = %if.then91
  %35 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  br label %cond.end100

cond.end100:                                      ; preds = %if.then91, %cond.true98
  %cond101 = phi %struct.sv* [ %35, %cond.true98 ], [ @PL_sv_undef, %if.then91 ]
  %add.ptr93.sum = add i64 %idx.ext, 1
  %incdec.ptr102 = getelementptr inbounds %struct.sv** %34, i64 %add.ptr93.sum
  store %struct.sv* %cond101, %struct.sv** %incdec.ptr102, align 8, !tbaa !0
  br label %if.end103

if.end103:                                        ; preds = %cond.end87, %cond.end100
  %sp.0 = phi %struct.sv** [ %incdec.ptr102, %cond.end100 ], [ %incdec.ptr1, %cond.end87 ]
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %36 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %36, i64 0, i32 0
  %37 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end103, %if.then58
  %retval.0 = phi %struct.op* [ %call59, %if.then58 ], [ %37, %if.end103 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_av_extend(%struct.av*, i32) #1

; Function Attrs: optsize
declare void @Perl_save_aelem(%struct.av*, i32, %struct.sv**) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_each() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %2 = bitcast %struct.sv* %1 to %struct.hv*
  %3 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %3, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %cond.end19, label %cond.false

cond.false:                                       ; preds = %entry
  %cmp6 = icmp eq i32 %and, 2
  br i1 %cmp6, label %cond.end19, label %cond.false9

cond.false9:                                      ; preds = %cond.false
  %cmp13 = icmp eq i32 %and, 3
  br i1 %cmp13, label %cond.end19, label %cond.false16

cond.false16:                                     ; preds = %cond.false9
  %call = tail call i32 @Perl_block_gimme() #7
  br label %cond.end19

cond.end19:                                       ; preds = %cond.false, %cond.false9, %cond.false16, %entry
  %cond20 = phi i32 [ 128, %entry ], [ 0, %cond.false ], [ %call, %cond.false16 ], [ 1, %cond.false9 ]
  %5 = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %6 = load i32* %5, align 4, !tbaa !4
  %and21 = and i32 %6, 255
  %cmp22 = icmp eq i32 %and21, 11
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  br i1 %cmp22, label %cond.true24, label %cond.false26

cond.true24:                                      ; preds = %cond.end19
  %call25 = tail call %struct.he* @Perl_hv_iternext(%struct.hv* %2) #7
  br label %cond.end28

cond.false26:                                     ; preds = %cond.end19
  %7 = bitcast %struct.sv* %1 to %struct.av*
  %call27 = tail call %struct.he* @Perl_avhv_iternext(%struct.av* %7) #7
  br label %cond.end28

cond.end28:                                       ; preds = %cond.false26, %cond.true24
  %cond29 = phi %struct.he* [ %call25, %cond.true24 ], [ %call27, %cond.false26 ]
  %8 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %9 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %9 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp30 = icmp slt i64 %sub.ptr.sub, 16
  br i1 %cmp30, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end28
  %call32 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %8, %struct.sv** %8, i32 2) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end28
  %sp.0 = phi %struct.sv** [ %call32, %if.then ], [ %8, %cond.end28 ]
  %tobool33 = icmp eq %struct.he* %cond29, null
  br i1 %tobool33, label %if.else, label %if.then34

if.then34:                                        ; preds = %if.end
  %call35 = tail call %struct.sv* @Perl_hv_iterkeysv(%struct.he* %cond29) #7
  %incdec.ptr36 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call35, %struct.sv** %incdec.ptr36, align 8, !tbaa !0
  %cmp37 = icmp eq i32 %cond20, 1
  br i1 %cmp37, label %if.then39, label %return

if.then39:                                        ; preds = %if.then34
  store %struct.sv** %incdec.ptr36, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  br i1 %cmp22, label %cond.true41, label %cond.false43

cond.true41:                                      ; preds = %if.then39
  %call42 = tail call %struct.sv* @Perl_hv_iterval(%struct.hv* %2, %struct.he* %cond29) #7
  br label %cond.end45

cond.false43:                                     ; preds = %if.then39
  %10 = bitcast %struct.sv* %1 to %struct.av*
  %call44 = tail call %struct.sv* @Perl_avhv_iterval(%struct.av* %10, %struct.he* %cond29) #7
  br label %cond.end45

cond.end45:                                       ; preds = %cond.false43, %cond.true41
  %cond46 = phi %struct.sv* [ %call42, %cond.true41 ], [ %call44, %cond.false43 ]
  %11 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr47 = getelementptr inbounds %struct.sv** %11, i64 1
  store %struct.sv* %cond46, %struct.sv** %incdec.ptr47, align 8, !tbaa !0
  br label %return

if.else:                                          ; preds = %if.end
  %cmp49 = icmp eq i32 %cond20, 0
  br i1 %cmp49, label %if.then51, label %return

if.then51:                                        ; preds = %if.else
  %incdec.ptr52 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr52, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %cond.end45, %if.then34, %if.else, %if.then51
  %storemerge = phi %struct.sv** [ %incdec.ptr52, %if.then51 ], [ %incdec.ptr47, %cond.end45 ], [ %incdec.ptr36, %if.then34 ], [ %sp.0, %if.else ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.he* @Perl_hv_iternext(%struct.hv*) #1

; Function Attrs: optsize
declare %struct.he* @Perl_avhv_iternext(%struct.av*) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_hv_iterkeysv(%struct.he*) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_hv_iterval(%struct.hv*, %struct.he*) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_avhv_iterval(%struct.av*, %struct.he*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_values() #0 {
entry:
  %call = tail call %struct.op* @Perl_do_kv() #7
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_keys() #0 {
entry:
  %call = tail call %struct.op* @Perl_do_kv() #7
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_delete() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %cond.end18, label %cond.false

cond.false:                                       ; preds = %entry
  %cmp5 = icmp eq i32 %and, 2
  br i1 %cmp5, label %cond.end18, label %cond.false8

cond.false8:                                      ; preds = %cond.false
  %cmp12 = icmp eq i32 %and, 3
  br i1 %cmp12, label %cond.end18, label %cond.false15

cond.false15:                                     ; preds = %cond.false8
  %call = tail call i32 @Perl_block_gimme() #7
  %.pre = load %struct.op** @PL_op, align 8, !tbaa !0
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false, %cond.false8, %cond.false15, %entry
  %3 = phi %struct.op* [ %1, %entry ], [ %1, %cond.false ], [ %.pre, %cond.false15 ], [ %1, %cond.false8 ]
  %cond19 = phi i32 [ 128, %entry ], [ 0, %cond.false ], [ %call, %cond.false15 ], [ 1, %cond.false8 ]
  %cmp20 = icmp eq i32 %cond19, 128
  %cond22 = select i1 %cmp20, i32 2, i32 0
  %op_private = getelementptr inbounds %struct.op* %3, i64 0, i32 7
  %4 = load i8* %op_private, align 1, !tbaa !1
  %and24 = and i8 %4, 64
  %tobool = icmp eq i8 %and24, 0
  br i1 %tobool, label %if.else105, label %if.then

if.then:                                          ; preds = %cond.end18
  %5 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %6 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %6, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %7 = load i32* %6, align 4, !tbaa !4
  %idx.ext = sext i32 %7 to i64
  %incdec.ptr26 = getelementptr inbounds %struct.sv** %0, i64 -1
  %8 = load %struct.sv** %0, align 8, !tbaa !0
  %9 = bitcast %struct.sv* %8 to %struct.hv*
  %10 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %11 = load i32* %10, align 4, !tbaa !4
  %and27 = and i32 %11, 255
  switch i32 %and27, label %if.else82 [
    i32 11, label %while.cond.preheader
    i32 10, label %if.then42
  ]

while.cond.preheader:                             ; preds = %if.then
  %add.ptr.sum215 = add i64 %idx.ext, 1
  %incdec.ptr31203 = getelementptr inbounds %struct.sv** %5, i64 %add.ptr.sum215
  %cmp32204 = icmp ugt %struct.sv** %incdec.ptr31203, %incdec.ptr26
  br i1 %cmp32204, label %if.end85, label %while.body

while.body:                                       ; preds = %while.cond.preheader, %while.body
  %incdec.ptr31205 = phi %struct.sv** [ %incdec.ptr31, %while.body ], [ %incdec.ptr31203, %while.cond.preheader ]
  %12 = load %struct.sv** %incdec.ptr31205, align 8, !tbaa !0
  %call34 = tail call %struct.sv* @Perl_hv_delete_ent(%struct.hv* %9, %struct.sv* %12, i32 %cond22, i32 0) #7
  %tobool35 = icmp ne %struct.sv* %call34, null
  %cond39 = select i1 %tobool35, %struct.sv* %call34, %struct.sv* @PL_sv_undef
  store %struct.sv* %cond39, %struct.sv** %incdec.ptr31205, align 8, !tbaa !0
  %incdec.ptr31 = getelementptr inbounds %struct.sv** %incdec.ptr31205, i64 1
  %cmp32 = icmp ugt %struct.sv** %incdec.ptr31, %incdec.ptr26
  br i1 %cmp32, label %if.end85, label %while.body

if.then42:                                        ; preds = %if.then
  %op_flags43 = getelementptr inbounds %struct.op* %3, i64 0, i32 6
  %13 = load i8* %op_flags43, align 1, !tbaa !1
  %tobool46 = icmp slt i8 %13, 0
  %add.ptr.sum214 = add i64 %idx.ext, 1
  %incdec.ptr49207 = getelementptr inbounds %struct.sv** %5, i64 %add.ptr.sum214
  %cmp50208 = icmp ugt %struct.sv** %incdec.ptr49207, %incdec.ptr26
  br i1 %tobool46, label %while.cond48.preheader, label %while.cond70.preheader

while.cond70.preheader:                           ; preds = %if.then42
  br i1 %cmp50208, label %if.end85, label %while.body74.lr.ph

while.body74.lr.ph:                               ; preds = %while.cond70.preheader
  %14 = bitcast %struct.sv* %8 to %struct.av*
  br label %while.body74

while.cond48.preheader:                           ; preds = %if.then42
  br i1 %cmp50208, label %if.end85, label %while.body52.lr.ph

while.body52.lr.ph:                               ; preds = %while.cond48.preheader
  %15 = bitcast %struct.sv* %8 to %struct.av*
  br label %while.body52

while.body52:                                     ; preds = %while.body52.lr.ph, %cond.end59
  %incdec.ptr49209 = phi %struct.sv** [ %incdec.ptr49207, %while.body52.lr.ph ], [ %incdec.ptr49, %cond.end59 ]
  %16 = load %struct.sv** %incdec.ptr49209, align 8, !tbaa !0
  %sv_flags53 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags53, align 4, !tbaa !4
  %and54 = and i32 %17, 65536
  %tobool55 = icmp eq i32 %and54, 0
  br i1 %tobool55, label %cond.false57, label %cond.true56

cond.true56:                                      ; preds = %while.body52
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %18, i64 24
  %19 = bitcast i8* %xiv_iv to i64*
  %20 = load i64* %19, align 8, !tbaa !3
  br label %cond.end59

cond.false57:                                     ; preds = %while.body52
  %call58 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  br label %cond.end59

cond.end59:                                       ; preds = %cond.false57, %cond.true56
  %cond60 = phi i64 [ %20, %cond.true56 ], [ %call58, %cond.false57 ]
  %conv61 = trunc i64 %cond60 to i32
  %call62 = tail call %struct.sv* @Perl_av_delete(%struct.av* %15, i32 %conv61, i32 %cond22) #7
  %tobool63 = icmp ne %struct.sv* %call62, null
  %cond67 = select i1 %tobool63, %struct.sv* %call62, %struct.sv* @PL_sv_undef
  store %struct.sv* %cond67, %struct.sv** %incdec.ptr49209, align 8, !tbaa !0
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %incdec.ptr49209, i64 1
  %cmp50 = icmp ugt %struct.sv** %incdec.ptr49, %incdec.ptr26
  br i1 %cmp50, label %if.end85, label %while.body52

while.body74:                                     ; preds = %while.body74.lr.ph, %while.body74
  %incdec.ptr71213 = phi %struct.sv** [ %incdec.ptr49207, %while.body74.lr.ph ], [ %incdec.ptr71, %while.body74 ]
  %21 = load %struct.sv** %incdec.ptr71213, align 8, !tbaa !0
  %call75 = tail call %struct.sv* @Perl_avhv_delete_ent(%struct.av* %14, %struct.sv* %21, i32 %cond22, i32 0) #7
  %tobool76 = icmp ne %struct.sv* %call75, null
  %cond80 = select i1 %tobool76, %struct.sv* %call75, %struct.sv* @PL_sv_undef
  store %struct.sv* %cond80, %struct.sv** %incdec.ptr71213, align 8, !tbaa !0
  %incdec.ptr71 = getelementptr inbounds %struct.sv** %incdec.ptr71213, i64 1
  %cmp72 = icmp ugt %struct.sv** %incdec.ptr71, %incdec.ptr26
  br i1 %cmp72, label %if.end85, label %while.body74

if.else82:                                        ; preds = %if.then
  %call83 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str38, i64 0, i64 0)) #7
  br label %return

if.end85:                                         ; preds = %while.cond70.preheader, %while.body74, %while.cond48.preheader, %cond.end59, %while.cond.preheader, %while.body
  br i1 %cmp20, label %if.then87, label %if.else90

if.then87:                                        ; preds = %if.end85
  %22 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr89 = getelementptr inbounds %struct.sv** %22, i64 %idx.ext
  br label %if.end151

if.else90:                                        ; preds = %if.end85
  %cmp91 = icmp eq i32 %cond19, 0
  br i1 %cmp91, label %if.then93, label %if.end151

if.then93:                                        ; preds = %if.else90
  %23 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr95 = getelementptr inbounds %struct.sv** %23, i64 %idx.ext
  %cmp96 = icmp ugt %struct.sv** %incdec.ptr26, %add.ptr95
  br i1 %cmp96, label %if.then98, label %if.else100

if.then98:                                        ; preds = %if.then93
  %24 = load %struct.sv** %incdec.ptr26, align 8, !tbaa !0
  %add.ptr95.sum201 = add i64 %idx.ext, 1
  %incdec.ptr99 = getelementptr inbounds %struct.sv** %23, i64 %add.ptr95.sum201
  store %struct.sv* %24, %struct.sv** %incdec.ptr99, align 8, !tbaa !0
  br label %if.end151

if.else100:                                       ; preds = %if.then93
  %add.ptr95.sum = add i64 %idx.ext, 1
  %incdec.ptr101 = getelementptr inbounds %struct.sv** %23, i64 %add.ptr95.sum
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr101, align 8, !tbaa !0
  br label %if.end151

if.else105:                                       ; preds = %cond.end18
  %incdec.ptr106 = getelementptr inbounds %struct.sv** %0, i64 -1
  %25 = load %struct.sv** %0, align 8, !tbaa !0
  %incdec.ptr107 = getelementptr inbounds %struct.sv** %0, i64 -2
  %26 = load %struct.sv** %incdec.ptr106, align 8, !tbaa !0
  %27 = getelementptr inbounds %struct.sv* %26, i64 0, i32 2
  %28 = load i32* %27, align 4, !tbaa !4
  %and109 = and i32 %28, 255
  switch i32 %and109, label %if.else140 [
    i32 11, label %if.then112
    i32 10, label %if.then119
  ]

if.then112:                                       ; preds = %if.else105
  %29 = bitcast %struct.sv* %26 to %struct.hv*
  %call113 = tail call %struct.sv* @Perl_hv_delete_ent(%struct.hv* %29, %struct.sv* %25, i32 %cond22, i32 0) #7
  br label %if.end143

if.then119:                                       ; preds = %if.else105
  %op_flags120 = getelementptr inbounds %struct.op* %3, i64 0, i32 6
  %30 = load i8* %op_flags120, align 1, !tbaa !1
  %tobool123 = icmp slt i8 %30, 0
  %31 = bitcast %struct.sv* %26 to %struct.av*
  br i1 %tobool123, label %if.then124, label %if.else137

if.then124:                                       ; preds = %if.then119
  %sv_flags125 = getelementptr inbounds %struct.sv* %25, i64 0, i32 2
  %32 = load i32* %sv_flags125, align 4, !tbaa !4
  %and126 = and i32 %32, 65536
  %tobool127 = icmp eq i32 %and126, 0
  br i1 %tobool127, label %cond.false131, label %cond.true128

cond.true128:                                     ; preds = %if.then124
  %sv_any129 = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %33 = load i8** %sv_any129, align 8, !tbaa !0
  %xiv_iv130 = getelementptr inbounds i8* %33, i64 24
  %34 = bitcast i8* %xiv_iv130 to i64*
  %35 = load i64* %34, align 8, !tbaa !3
  br label %cond.end133

cond.false131:                                    ; preds = %if.then124
  %call132 = tail call i64 @Perl_sv_2iv(%struct.sv* %25) #7
  br label %cond.end133

cond.end133:                                      ; preds = %cond.false131, %cond.true128
  %cond134 = phi i64 [ %35, %cond.true128 ], [ %call132, %cond.false131 ]
  %conv135 = trunc i64 %cond134 to i32
  %call136 = tail call %struct.sv* @Perl_av_delete(%struct.av* %31, i32 %conv135, i32 %cond22) #7
  br label %if.end143

if.else137:                                       ; preds = %if.then119
  %call138 = tail call %struct.sv* @Perl_avhv_delete_ent(%struct.av* %31, %struct.sv* %25, i32 %cond22, i32 0) #7
  br label %if.end143

if.else140:                                       ; preds = %if.else105
  %call141 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str38, i64 0, i64 0)) #7
  br label %return

if.end143:                                        ; preds = %if.else137, %cond.end133, %if.then112
  %sv.0 = phi %struct.sv* [ %call113, %if.then112 ], [ %call136, %cond.end133 ], [ %call138, %if.else137 ]
  br i1 %cmp20, label %if.end151, label %if.then148

if.then148:                                       ; preds = %if.end143
  %tobool144 = icmp eq %struct.sv* %sv.0, null
  %PL_sv_undef.sv.0 = select i1 %tobool144, %struct.sv* @PL_sv_undef, %struct.sv* %sv.0
  store %struct.sv* %PL_sv_undef.sv.0, %struct.sv** %incdec.ptr106, align 8, !tbaa !0
  br label %if.end151

if.end151:                                        ; preds = %if.end143, %if.else90, %if.then98, %if.else100, %if.then148, %if.then87
  %sp.0 = phi %struct.sv** [ %add.ptr89, %if.then87 ], [ %incdec.ptr106, %if.then148 ], [ %incdec.ptr99, %if.then98 ], [ %incdec.ptr101, %if.else100 ], [ %incdec.ptr26, %if.else90 ], [ %incdec.ptr107, %if.end143 ]
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %36 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %36, i64 0, i32 0
  %37 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end151, %if.else140, %if.else82
  %retval.0 = phi %struct.op* [ %37, %if.end151 ], [ %call83, %if.else82 ], [ %call141, %if.else140 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_hv_delete_ent(%struct.hv*, %struct.sv*, i32, i32) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_av_delete(%struct.av*, i32, i32) #1

; Function Attrs: optsize
declare %struct.sv* @Perl_avhv_delete_ent(%struct.av*, %struct.sv*, i32, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_exists() #0 {
entry:
  %hv = alloca %struct.hv*, align 8
  %gv = alloca %struct.gv*, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %2 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  %3 = load %struct.sv** %0, align 8, !tbaa !0
  br i1 %tobool, label %if.end19, label %if.then

if.then:                                          ; preds = %entry
  %call = call %struct.cv* @Perl_sv_2cv(%struct.sv* %3, %struct.hv** %hv, %struct.gv** %gv, i32 0) #7
  %tobool1 = icmp eq %struct.cv* %call, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load %struct.gv** %gv, align 8, !tbaa !0
  %tobool4 = icmp eq %struct.gv* %6, null
  br i1 %tobool4, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %sv_flags = getelementptr inbounds %struct.gv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !4
  %and5 = and i32 %7, 255
  %cmp = icmp eq i32 %and5, 13
  br i1 %cmp, label %land.lhs.true7, label %if.end16

land.lhs.true7:                                   ; preds = %land.lhs.true
  %sv_any = getelementptr inbounds %struct.gv* %6, i64 0, i32 0
  %8 = load %struct.xpvgv** %sv_any, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %8, i64 0, i32 7
  %9 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_cv = getelementptr inbounds %struct.gp* %9, i64 0, i32 7
  %10 = load %struct.cv** %gp_cv, align 8, !tbaa !0
  %tobool8 = icmp eq %struct.cv* %10, null
  br i1 %tobool8, label %if.end16, label %land.lhs.true9

land.lhs.true9:                                   ; preds = %land.lhs.true7
  %gp_cvgen = getelementptr inbounds %struct.gp* %9, i64 0, i32 8
  %11 = load i32* %gp_cvgen, align 4, !tbaa !4
  %tobool12 = icmp eq i32 %11, 0
  br i1 %tobool12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true9
  store %struct.sv* @PL_sv_yes, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %12 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next15 = getelementptr inbounds %struct.op* %12, i64 0, i32 0
  %13 = load %struct.op** %op_next15, align 8, !tbaa !0
  br label %return

if.end16:                                         ; preds = %land.lhs.true9, %land.lhs.true7, %if.end, %land.lhs.true
  store %struct.sv* @PL_sv_no, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next18 = getelementptr inbounds %struct.op* %14, i64 0, i32 0
  %15 = load %struct.op** %op_next18, align 8, !tbaa !0
  br label %return

if.end19:                                         ; preds = %entry
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %16 = load %struct.sv** %incdec.ptr, align 8, !tbaa !0
  %17 = bitcast %struct.sv* %16 to %struct.hv*
  store %struct.hv* %17, %struct.hv** %hv, align 8, !tbaa !0
  %18 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %19 = load i32* %18, align 4, !tbaa !4
  %and23 = and i32 %19, 255
  switch i32 %and23, label %if.else62 [
    i32 11, label %if.then26
    i32 10, label %if.then37
  ]

if.then26:                                        ; preds = %if.end19
  %call27 = call signext i8 @Perl_hv_exists_ent(%struct.hv* %17, %struct.sv* %3, i32 0) #7
  %tobool28 = icmp eq i8 %call27, 0
  br i1 %tobool28, label %if.end65, label %if.then29

if.then29:                                        ; preds = %if.then26
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %20 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next31 = getelementptr inbounds %struct.op* %20, i64 0, i32 0
  %21 = load %struct.op** %op_next31, align 8, !tbaa !0
  br label %return

if.then37:                                        ; preds = %if.end19
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %22 = load i8* %op_flags, align 1, !tbaa !1
  %tobool40 = icmp slt i8 %22, 0
  %23 = bitcast %struct.sv* %16 to %struct.av*
  br i1 %tobool40, label %if.then41, label %if.else54

if.then41:                                        ; preds = %if.then37
  %sv_flags42 = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %24 = load i32* %sv_flags42, align 4, !tbaa !4
  %and43 = and i32 %24, 65536
  %tobool44 = icmp eq i32 %and43, 0
  br i1 %tobool44, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then41
  %sv_any45 = getelementptr inbounds %struct.sv* %3, i64 0, i32 0
  %25 = load i8** %sv_any45, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %25, i64 24
  %26 = bitcast i8* %xiv_iv to i64*
  %27 = load i64* %26, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then41
  %call46 = call i64 @Perl_sv_2iv(%struct.sv* %3) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call46, %cond.false ]
  %conv47 = trunc i64 %cond to i32
  %call48 = call signext i8 @Perl_av_exists(%struct.av* %23, i32 %conv47) #7
  %tobool49 = icmp eq i8 %call48, 0
  br i1 %tobool49, label %if.end65, label %if.then50

if.then50:                                        ; preds = %cond.end
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %28 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next52 = getelementptr inbounds %struct.op* %28, i64 0, i32 0
  %29 = load %struct.op** %op_next52, align 8, !tbaa !0
  br label %return

if.else54:                                        ; preds = %if.then37
  %call55 = call signext i8 @Perl_avhv_exists_ent(%struct.av* %23, %struct.sv* %3, i32 0) #7
  %tobool56 = icmp eq i8 %call55, 0
  br i1 %tobool56, label %if.end65, label %if.then57

if.then57:                                        ; preds = %if.else54
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %30 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next59 = getelementptr inbounds %struct.op* %30, i64 0, i32 0
  %31 = load %struct.op** %op_next59, align 8, !tbaa !0
  br label %return

if.else62:                                        ; preds = %if.end19
  %call63 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([21 x i8]* @.str38, i64 0, i64 0)) #7
  br label %return

if.end65:                                         ; preds = %if.then26, %cond.end, %if.else54
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %32 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next67 = getelementptr inbounds %struct.op* %32, i64 0, i32 0
  %33 = load %struct.op** %op_next67, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end65, %if.else62, %if.then57, %if.then50, %if.then29, %if.end16, %if.then13, %if.then2
  %retval.0 = phi %struct.op* [ %5, %if.then2 ], [ %15, %if.end16 ], [ %13, %if.then13 ], [ %21, %if.then29 ], [ %33, %if.end65 ], [ %29, %if.then50 ], [ %31, %if.then57 ], [ %call63, %if.else62 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare signext i8 @Perl_hv_exists_ent(%struct.hv*, %struct.sv*, i32) #1

; Function Attrs: optsize
declare signext i8 @Perl_av_exists(%struct.av*, i32) #1

; Function Attrs: optsize
declare signext i8 @Perl_avhv_exists_ent(%struct.av*, %struct.sv*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_hslice() #0 {
entry:
  %n_a = alloca i64, align 8
  %keylen = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %0, i64 -1
  %4 = load %struct.sv** %0, align 8, !tbaa !0
  %5 = bitcast %struct.sv* %4 to %struct.hv*
  %6 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %6, i64 0, i32 6
  %7 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %7, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %8 = load i8* %op_private, align 1, !tbaa !1
  %and4 = and i8 %8, 8
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %lor.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %call = call i32 @Perl_is_lvalue_sub() #7
  %tobool6 = icmp ne i32 %call, 0
  %.pre = load %struct.op** @PL_op, align 8, !tbaa !0
  br label %lor.end

lor.end:                                          ; preds = %entry, %lor.rhs, %land.rhs
  %9 = phi %struct.op* [ %6, %lor.rhs ], [ %.pre, %land.rhs ], [ %6, %entry ]
  %10 = phi i1 [ false, %lor.rhs ], [ %tobool6, %land.rhs ], [ true, %entry ]
  %lor.ext = zext i1 %10 to i32
  %11 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %12 = load i32* %11, align 4, !tbaa !4
  %and7 = and i32 %12, 255
  %cmp = icmp eq i32 %and7, 11
  %op_private9 = getelementptr inbounds %struct.op* %9, i64 0, i32 7
  %13 = load i8* %op_private9, align 1, !tbaa !1
  %tobool14 = icmp slt i8 %13, 0
  br i1 %tobool14, label %if.then, label %if.end43

if.then:                                          ; preds = %lor.end
  %call15 = call %struct.magic* @Perl_mg_find(%struct.sv* %4, i32 69) #7
  %tobool16 = icmp eq %struct.magic* %call15, null
  br i1 %tobool16, label %lor.rhs17, label %if.end

lor.rhs17:                                        ; preds = %if.then
  %call18 = call %struct.magic* @Perl_mg_find(%struct.sv* %4, i32 80) #7
  %tobool19 = icmp eq %struct.magic* %call18, null
  br i1 %tobool19, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.rhs17
  %mg_obj = getelementptr inbounds %struct.magic* %call18, i64 0, i32 5
  %14 = load %struct.sv** %mg_obj, align 8, !tbaa !0
  %tobool20 = icmp eq %struct.sv* %14, null
  br i1 %tobool20, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %call22 = call %struct.sv* @Perl_newRV(%struct.sv* %4) #7
  %call23 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call22) #7
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true, %cond.false
  %cond24 = phi %struct.sv* [ %call23, %cond.false ], [ %14, %land.lhs.true ]
  %sv_any = getelementptr inbounds %struct.sv* %cond24, i64 0, i32 0
  %15 = load i8** %sv_any, align 8, !tbaa !0
  %xrv_rv = bitcast i8* %15 to %struct.sv**
  %16 = load %struct.sv** %xrv_rv, align 8, !tbaa !0
  %sv_any25 = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %17 = load i8** %sv_any25, align 8, !tbaa !0
  %xmg_stash = getelementptr inbounds i8* %17, i64 48
  %18 = bitcast i8* %xmg_stash to %struct.hv**
  %19 = load %struct.hv** %18, align 8, !tbaa !0
  %tobool26 = icmp eq %struct.hv* %19, null
  br i1 %tobool26, label %if.end, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %cond.end
  %call28 = call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %19, i8* getelementptr inbounds ([7 x i8]* @.str39, i64 0, i64 0), i32 1) #7
  %tobool29 = icmp eq %struct.gv* %call28, null
  br i1 %tobool29, label %if.end, label %land.rhs30

land.rhs30:                                       ; preds = %land.lhs.true27
  %call31 = call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %19, i8* getelementptr inbounds ([7 x i8]* @.str40, i64 0, i64 0), i32 1) #7
  %tobool32 = icmp ne %struct.gv* %call31, null
  br label %if.end

if.end:                                           ; preds = %land.rhs30, %if.then, %lor.rhs17, %cond.end, %land.lhs.true27
  %20 = phi i1 [ true, %if.then ], [ false, %land.lhs.true27 ], [ false, %cond.end ], [ false, %lor.rhs17 ], [ %tobool32, %land.rhs30 ]
  %conv36 = zext i1 %20 to i8
  br i1 %cmp, label %while.cond.preheader, label %if.then41

if.then41:                                        ; preds = %if.end
  %call42 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([35 x i8]* @.str41, i64 0, i64 0)) #7
  br label %return

if.end43:                                         ; preds = %lor.end
  br i1 %cmp, label %while.cond.preheader, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end43
  %21 = load i32* %11, align 4, !tbaa !4
  %and46 = and i32 %21, 255
  %cmp47 = icmp eq i32 %and46, 10
  br i1 %cmp47, label %while.cond.preheader, label %if.end134

while.cond.preheader:                             ; preds = %if.end, %lor.lhs.false, %if.end43
  %other_magic.0214224 = phi i8 [ 0, %lor.lhs.false ], [ 0, %if.end43 ], [ %conv36, %if.end ]
  %add.ptr.sum = add i64 %idx.ext, 1
  %incdec.ptr50219 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %cmp51220 = icmp ugt %struct.sv** %incdec.ptr50219, %incdec.ptr1
  br i1 %cmp51220, label %if.end134, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %tobool59 = icmp eq i8 %other_magic.0214224, 0
  %22 = bitcast %struct.sv* %4 to %struct.av*
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %cond.end132
  %incdec.ptr50221 = phi %struct.sv** [ %incdec.ptr50219, %while.body.lr.ph ], [ %incdec.ptr50, %cond.end132 ]
  %23 = load %struct.sv** %incdec.ptr50221, align 8, !tbaa !0
  br i1 %tobool14, label %if.then54, label %if.end74

if.then54:                                        ; preds = %while.body
  %24 = load i32* %11, align 4, !tbaa !4
  %and56 = and i32 %24, 32768
  %tobool57 = icmp ne i32 %and56, 0
  %or.cond211 = and i1 %tobool57, %tobool59
  br i1 %or.cond211, label %if.end74, label %cond.false61

cond.false61:                                     ; preds = %if.then54
  br i1 %cmp, label %if.end74.thread, label %if.end74.thread217

if.end74.thread:                                  ; preds = %cond.false61
  %call64 = call signext i8 @Perl_hv_exists_ent(%struct.hv* %5, %struct.sv* %23, i32 0) #7
  br label %if.then76

if.end74.thread217:                               ; preds = %cond.false61
  %call67 = call signext i8 @Perl_avhv_exists_ent(%struct.av* %22, %struct.sv* %23, i32 0) #7
  br label %if.else

if.end74:                                         ; preds = %if.then54, %while.body
  %preeminent.0 = phi i8 [ 0, %while.body ], [ 1, %if.then54 ]
  br i1 %cmp, label %if.then76, label %if.else

if.then76:                                        ; preds = %if.end74.thread, %if.end74
  %preeminent.0216 = phi i8 [ %call64, %if.end74.thread ], [ %preeminent.0, %if.end74 ]
  %call77 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %5, %struct.sv* %23, i32 %lor.ext, i32 0) #7
  %tobool78 = icmp eq %struct.he* %call77, null
  %hent_val = getelementptr inbounds %struct.he* %call77, i64 0, i32 2
  %.hent_val = select i1 %tobool78, %struct.sv** null, %struct.sv** %hent_val
  br label %if.end84

if.else:                                          ; preds = %if.end74.thread217, %if.end74
  %preeminent.0218 = phi i8 [ %call67, %if.end74.thread217 ], [ %preeminent.0, %if.end74 ]
  %call83 = call %struct.sv** @Perl_avhv_fetch_ent(%struct.av* %22, %struct.sv* %23, i32 %lor.ext, i32 0) #7
  br label %if.end84

if.end84:                                         ; preds = %if.else, %if.then76
  %preeminent.0215 = phi i8 [ %preeminent.0216, %if.then76 ], [ %preeminent.0218, %if.else ]
  %svp.0 = phi %struct.sv** [ %.hent_val, %if.then76 ], [ %call83, %if.else ]
  br i1 %10, label %if.then86, label %if.end128

if.then86:                                        ; preds = %if.end84
  %tobool87 = icmp eq %struct.sv** %svp.0, null
  br i1 %tobool87, label %if.then91, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %if.then86
  %25 = load %struct.sv** %svp.0, align 8, !tbaa !0
  %cmp89 = icmp eq %struct.sv* %25, @PL_sv_undef
  br i1 %cmp89, label %if.then91, label %if.end104

if.then91:                                        ; preds = %if.then86, %lor.lhs.false88
  %sv_flags92 = getelementptr inbounds %struct.sv* %23, i64 0, i32 2
  %26 = load i32* %sv_flags92, align 4, !tbaa !4
  %and93 = and i32 %26, 262144
  %cmp94 = icmp eq i32 %and93, 0
  br i1 %cmp94, label %cond.false99, label %cond.true96

cond.true96:                                      ; preds = %if.then91
  %sv_any97 = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %27 = load i8** %sv_any97, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %27, i64 8
  %28 = bitcast i8* %xpv_cur to i64*
  %29 = load i64* %28, align 8, !tbaa !3
  store i64 %29, i64* %n_a, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %27 to i8**
  %30 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end101

cond.false99:                                     ; preds = %if.then91
  %call100 = call i8* @Perl_sv_2pv_flags(%struct.sv* %23, i64* %n_a, i32 2) #7
  br label %cond.end101

cond.end101:                                      ; preds = %cond.false99, %cond.true96
  %cond102 = phi i8* [ %30, %cond.true96 ], [ %call100, %cond.false99 ]
  %call103 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_helem, i64 0, i64 0), i8* %cond102) #7
  br label %return

if.end104:                                        ; preds = %lor.lhs.false88
  br i1 %tobool14, label %if.then106, label %if.end128

if.then106:                                       ; preds = %if.end104
  %tobool107 = icmp eq i8 %preeminent.0215, 0
  br i1 %tobool107, label %if.else109, label %if.then108

if.then108:                                       ; preds = %if.then106
  call void @Perl_save_helem(%struct.hv* %5, %struct.sv* %23, %struct.sv** %svp.0) #7
  br label %if.end128

if.else109:                                       ; preds = %if.then106
  %sv_flags110 = getelementptr inbounds %struct.sv* %23, i64 0, i32 2
  %31 = load i32* %sv_flags110, align 4, !tbaa !4
  %and111 = and i32 %31, 262144
  %cmp112 = icmp eq i32 %and111, 0
  br i1 %cmp112, label %cond.false119, label %cond.true114

cond.true114:                                     ; preds = %if.else109
  %sv_any115 = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %32 = load i8** %sv_any115, align 8, !tbaa !0
  %xpv_cur116 = getelementptr inbounds i8* %32, i64 8
  %33 = bitcast i8* %xpv_cur116 to i64*
  %34 = load i64* %33, align 8, !tbaa !3
  store i64 %34, i64* %keylen, align 8, !tbaa !3
  %xpv_pv118 = bitcast i8* %32 to i8**
  %35 = load i8** %xpv_pv118, align 8, !tbaa !0
  br label %cond.end121

cond.false119:                                    ; preds = %if.else109
  %call120 = call i8* @Perl_sv_2pv_flags(%struct.sv* %23, i64* %keylen, i32 2) #7
  %.pre223 = load i64* %keylen, align 8, !tbaa !3
  br label %cond.end121

cond.end121:                                      ; preds = %cond.false119, %cond.true114
  %36 = phi i64 [ %34, %cond.true114 ], [ %.pre223, %cond.false119 ]
  %cond122 = phi i8* [ %35, %cond.true114 ], [ %call120, %cond.false119 ]
  %conv123 = trunc i64 %36 to i32
  %call124 = call i8* @Perl_savepvn(i8* %cond122, i32 %conv123) #7
  %37 = load i64* %keylen, align 8, !tbaa !3
  %conv125 = trunc i64 %37 to i32
  call void @Perl_save_delete(%struct.hv* %5, i8* %call124, i32 %conv125) #7
  br label %if.end128

if.end128:                                        ; preds = %if.end104, %cond.end121, %if.then108, %if.end84
  %tobool129 = icmp eq %struct.sv** %svp.0, null
  br i1 %tobool129, label %cond.end132, label %cond.true130

cond.true130:                                     ; preds = %if.end128
  %38 = load %struct.sv** %svp.0, align 8, !tbaa !0
  br label %cond.end132

cond.end132:                                      ; preds = %if.end128, %cond.true130
  %cond133 = phi %struct.sv* [ %38, %cond.true130 ], [ @PL_sv_undef, %if.end128 ]
  store %struct.sv* %cond133, %struct.sv** %incdec.ptr50221, align 8, !tbaa !0
  %incdec.ptr50 = getelementptr inbounds %struct.sv** %incdec.ptr50221, i64 1
  %cmp51 = icmp ugt %struct.sv** %incdec.ptr50, %incdec.ptr1
  br i1 %cmp51, label %if.end134, label %while.body

if.end134:                                        ; preds = %while.cond.preheader, %cond.end132, %lor.lhs.false
  %39 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags135 = getelementptr inbounds %struct.op* %39, i64 0, i32 6
  %40 = load i8* %op_flags135, align 1, !tbaa !1
  %conv136 = zext i8 %40 to i32
  %and137 = and i32 %conv136, 3
  %tobool138 = icmp eq i32 %and137, 0
  br i1 %tobool138, label %cond.false146, label %cond.true139

cond.true139:                                     ; preds = %if.end134
  %cmp143 = icmp eq i32 %and137, 3
  %cond145 = zext i1 %cmp143 to i32
  br label %cond.end148

cond.false146:                                    ; preds = %if.end134
  %call147 = call i32 @Perl_dowantarray() #7
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false146, %cond.true139
  %cond149 = phi i32 [ %cond145, %cond.true139 ], [ %call147, %cond.false146 ]
  %cmp150 = icmp eq i32 %cond149, 1
  br i1 %cmp150, label %if.end164, label %if.then152

if.then152:                                       ; preds = %cond.end148
  %41 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr154 = getelementptr inbounds %struct.sv** %41, i64 %idx.ext
  %cmp157 = icmp ugt %struct.sv** %incdec.ptr1, %add.ptr154
  br i1 %cmp157, label %cond.true159, label %cond.end161

cond.true159:                                     ; preds = %if.then152
  %42 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  br label %cond.end161

cond.end161:                                      ; preds = %if.then152, %cond.true159
  %cond162 = phi %struct.sv* [ %42, %cond.true159 ], [ @PL_sv_undef, %if.then152 ]
  %add.ptr154.sum = add i64 %idx.ext, 1
  %incdec.ptr163 = getelementptr inbounds %struct.sv** %41, i64 %add.ptr154.sum
  store %struct.sv* %cond162, %struct.sv** %incdec.ptr163, align 8, !tbaa !0
  br label %if.end164

if.end164:                                        ; preds = %cond.end148, %cond.end161
  %sp.0 = phi %struct.sv** [ %incdec.ptr163, %cond.end161 ], [ %incdec.ptr1, %cond.end148 ]
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %43 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %43, i64 0, i32 0
  %44 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end164, %cond.end101, %if.then41
  %retval.0 = phi %struct.op* [ %call103, %cond.end101 ], [ %44, %if.end164 ], [ %call42, %if.then41 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv*, i8*, i32) #1

; Function Attrs: optsize
declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i32, i32) #1

; Function Attrs: optsize
declare %struct.sv** @Perl_avhv_fetch_ent(%struct.av*, %struct.sv*, i32, i32) #1

; Function Attrs: optsize
declare void @Perl_save_helem(%struct.hv*, %struct.sv*, %struct.sv**) #1

; Function Attrs: optsize
declare void @Perl_save_delete(%struct.hv*, i8*, i32) #1

; Function Attrs: optsize
declare i8* @Perl_savepvn(i8*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_list() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %cmp = icmp eq i32 %and, 3
  %cond = zext i1 %cmp to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call i32 @Perl_dowantarray() #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond5 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp6 = icmp eq i32 %cond5, 1
  br i1 %cmp6, label %if.end12, label %if.then

if.then:                                          ; preds = %cond.end
  %add.ptr.sum = add i64 %idx.ext, 1
  %incdec.ptr8 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %cmp9 = icmp ugt %struct.sv** %incdec.ptr8, %0
  br i1 %cmp9, label %if.end, label %if.then11

if.then11:                                        ; preds = %if.then
  %6 = load %struct.sv** %0, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then11
  %storemerge = phi %struct.sv* [ %6, %if.then11 ], [ @PL_sv_undef, %if.then ]
  store %struct.sv* %storemerge, %struct.sv** %incdec.ptr8, align 8, !tbaa !0
  br label %if.end12

if.end12:                                         ; preds = %cond.end, %if.end
  %sp.0 = phi %struct.sv** [ %incdec.ptr8, %if.end ], [ %0, %cond.end ]
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  %8 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %8
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_lslice() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %incdec.ptr1 = getelementptr inbounds i32* %2, i64 -2
  store i32* %incdec.ptr1, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %4 = load i32* %incdec.ptr, align 4, !tbaa !4
  %idx.ext2 = sext i32 %4 to i64
  %add.ptr3.sum = add i64 %idx.ext2, 1
  %add.ptr4 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr3.sum
  %add.ptr.sum = add i64 %idx.ext, 1
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %5, i64 0, i32 12
  %6 = load i32* %cop_arybase, align 4, !tbaa !4
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %7, i64 0, i32 6
  %8 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 32
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div114 = lshr exact i64 %sub.ptr.sub, 3
  %conv6 = trunc i64 %sub.ptr.div114 to i32
  %and9 = and i32 %conv, 3
  %tobool = icmp eq i32 %and9, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %cmp = icmp eq i32 %and9, 3
  %cond = zext i1 %cmp to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = tail call i32 @Perl_dowantarray() #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond14 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp15 = icmp eq i32 %cond14, 1
  br i1 %cmp15, label %if.end35, label %if.then

if.then:                                          ; preds = %cond.end
  %9 = load %struct.sv** %add.ptr, align 8, !tbaa !0
  store %struct.sv* %9, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %9, i64 0, i32 2
  %10 = load i32* %sv_flags, align 4, !tbaa !4
  %and17 = and i32 %10, 65536
  %tobool18 = icmp eq i32 %and17, 0
  br i1 %tobool18, label %cond.false20, label %cond.true19

cond.true19:                                      ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %11, i64 24
  %12 = bitcast i8* %xiv_iv to i64*
  %13 = load i64* %12, align 8, !tbaa !3
  br label %cond.end22

cond.false20:                                     ; preds = %if.then
  %call21 = tail call i64 @Perl_sv_2iv(%struct.sv* %9) #7
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false20, %cond.true19
  %cond23 = phi i64 [ %13, %cond.true19 ], [ %call21, %cond.false20 ]
  %conv24 = trunc i64 %cond23 to i32
  %cmp25 = icmp slt i32 %conv24, 0
  %14 = sub i32 0, %6
  %ix.0.p = select i1 %cmp25, i32 %conv6, i32 %14
  %ix.0 = add i32 %ix.0.p, %conv24
  %cmp28 = icmp sgt i32 %ix.0, -1
  %cmp30 = icmp slt i32 %ix.0, %conv6
  %or.cond = and i1 %cmp28, %cmp30
  br i1 %or.cond, label %if.else33, label %if.end34

if.else33:                                        ; preds = %cond.end22
  %idxprom = sext i32 %ix.0 to i64
  %add.ptr5.sum115 = add i64 %idxprom, %add.ptr.sum
  %arrayidx = getelementptr inbounds %struct.sv** %1, i64 %add.ptr5.sum115
  %15 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  br label %if.end34

if.end34:                                         ; preds = %cond.end22, %if.else33
  %storemerge = phi %struct.sv* [ %15, %if.else33 ], [ @PL_sv_undef, %cond.end22 ]
  store %struct.sv* %storemerge, %struct.sv** %add.ptr4, align 8, !tbaa !0
  store %struct.sv** %add.ptr4, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %16 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %16, i64 0, i32 0
  br label %return

if.end35:                                         ; preds = %cond.end
  %cmp36 = icmp eq i32 %conv6, 0
  br i1 %cmp36, label %if.then38, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end35
  %cmp42118 = icmp sgt i64 %add.ptr3.sum, %idx.ext
  br i1 %cmp42118, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %17 = sub i32 0, %6
  br label %for.body

if.then38:                                        ; preds = %if.end35
  %add.ptr39 = getelementptr inbounds %struct.sv** %1, i64 %idx.ext2
  store %struct.sv** %add.ptr39, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %18 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next40 = getelementptr inbounds %struct.op* %18, i64 0, i32 0
  br label %return

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %lelem.0120 = phi %struct.sv** [ %add.ptr4, %for.body.lr.ph ], [ %incdec.ptr75, %for.inc ]
  %is_something_there.0119 = phi i32 [ %and, %for.body.lr.ph ], [ %is_something_there.1, %for.inc ]
  %19 = load %struct.sv** %lelem.0120, align 8, !tbaa !0
  store %struct.sv* %19, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags44 = getelementptr inbounds %struct.sv* %19, i64 0, i32 2
  %20 = load i32* %sv_flags44, align 4, !tbaa !4
  %and45 = and i32 %20, 65536
  %tobool46 = icmp eq i32 %and45, 0
  br i1 %tobool46, label %cond.false50, label %cond.true47

cond.true47:                                      ; preds = %for.body
  %sv_any48 = getelementptr inbounds %struct.sv* %19, i64 0, i32 0
  %21 = load i8** %sv_any48, align 8, !tbaa !0
  %xiv_iv49 = getelementptr inbounds i8* %21, i64 24
  %22 = bitcast i8* %xiv_iv49 to i64*
  %23 = load i64* %22, align 8, !tbaa !3
  br label %cond.end52

cond.false50:                                     ; preds = %for.body
  %call51 = tail call i64 @Perl_sv_2iv(%struct.sv* %19) #7
  br label %cond.end52

cond.end52:                                       ; preds = %cond.false50, %cond.true47
  %cond53 = phi i64 [ %23, %cond.true47 ], [ %call51, %cond.false50 ]
  %conv54 = trunc i64 %cond53 to i32
  %cmp55 = icmp slt i32 %conv54, 0
  %ix.1.p = select i1 %cmp55, i32 %conv6, i32 %17
  %ix.1 = add i32 %ix.1.p, %conv54
  %cmp62 = icmp sgt i32 %ix.1, -1
  %cmp65 = icmp slt i32 %ix.1, %conv6
  %or.cond116 = and i1 %cmp62, %cmp65
  br i1 %or.cond116, label %if.else68, label %for.inc

if.else68:                                        ; preds = %cond.end52
  %idxprom69 = sext i32 %ix.1 to i64
  %add.ptr5.sum = add i64 %idxprom69, %add.ptr.sum
  %arrayidx70 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr5.sum
  %24 = load %struct.sv** %arrayidx70, align 8, !tbaa !0
  %tobool71 = icmp eq %struct.sv* %24, null
  %PL_sv_undef. = select i1 %tobool71, %struct.sv* @PL_sv_undef, %struct.sv* %24
  br label %for.inc

for.inc:                                          ; preds = %cond.end52, %if.else68
  %storemerge117 = phi %struct.sv* [ %PL_sv_undef., %if.else68 ], [ @PL_sv_undef, %cond.end52 ]
  %is_something_there.1 = phi i32 [ 1, %if.else68 ], [ %is_something_there.0119, %cond.end52 ]
  store %struct.sv* %storemerge117, %struct.sv** %lelem.0120, align 8, !tbaa !0
  %incdec.ptr75 = getelementptr inbounds %struct.sv** %lelem.0120, i64 1
  %cmp42 = icmp ugt %struct.sv** %incdec.ptr75, %add.ptr
  br i1 %cmp42, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %for.cond.preheader
  %is_something_there.0.lcssa = phi i32 [ %and, %for.cond.preheader ], [ %is_something_there.1, %for.inc ]
  %tobool76 = icmp eq i32 %is_something_there.0.lcssa, 0
  br i1 %tobool76, label %if.else78, label %if.end80

if.else78:                                        ; preds = %for.end
  %add.ptr79 = getelementptr inbounds %struct.sv** %1, i64 %idx.ext2
  br label %if.end80

if.end80:                                         ; preds = %for.end, %if.else78
  %sp.0 = phi %struct.sv** [ %add.ptr79, %if.else78 ], [ %add.ptr, %for.end ]
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %25 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next81 = getelementptr inbounds %struct.op* %25, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end80, %if.then38, %if.end34
  %retval.0.in = phi %struct.op** [ %op_next, %if.end34 ], [ %op_next40, %if.then38 ], [ %op_next81, %if.end80 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_anonlist() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.lhs.cast
  %sub.ptr.div425 = lshr exact i64 %sub.ptr.sub3, 3
  %conv5 = trunc i64 %sub.ptr.div425 to i32
  %add.ptr.sum = add i64 %idx.ext, 1
  %add.ptr6 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %call = tail call %struct.av* @Perl_av_make(i32 %conv5, %struct.sv** %add.ptr6) #7
  %4 = bitcast %struct.av* %call to %struct.sv*
  %call7 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %4) #7
  %5 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr9 = getelementptr inbounds %struct.sv** %5, i64 %idx.ext
  %6 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast10 = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.rhs.cast11 = ptrtoint %struct.sv** %add.ptr9 to i64
  %sub.ptr.sub12 = sub i64 %sub.ptr.lhs.cast10, %sub.ptr.rhs.cast11
  %cmp = icmp slt i64 %sub.ptr.sub12, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call15 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr9, %struct.sv** %add.ptr9, i32 1) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sp.0 = phi %struct.sv** [ %call15, %if.then ], [ %add.ptr9, %entry ]
  %incdec.ptr16 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call7, %struct.sv** %incdec.ptr16, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr16, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %7 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %7, i64 0, i32 0
  %8 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %8
}

; Function Attrs: optsize
declare %struct.av* @Perl_av_make(i32, %struct.sv**) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_anonhash() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %call = tail call %struct.hv* @Perl_newHV() #7
  %4 = bitcast %struct.hv* %call to %struct.sv*
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %4) #7
  %5 = bitcast %struct.sv* %call1 to %struct.hv*
  %cmp56 = icmp ult %struct.sv** %add.ptr, %0
  br i1 %cmp56, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %if.end28
  %mark.057 = phi %struct.sv** [ %mark.1, %if.end28 ], [ %add.ptr, %entry ]
  %incdec.ptr3 = getelementptr inbounds %struct.sv** %mark.057, i64 1
  %6 = load %struct.sv** %incdec.ptr3, align 8, !tbaa !0
  %call4 = tail call %struct.sv* @Perl_newSV(i64 0) #7
  %cmp5 = icmp ult %struct.sv** %incdec.ptr3, %0
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %incdec.ptr7 = getelementptr inbounds %struct.sv** %mark.057, i64 2
  %7 = load %struct.sv** %incdec.ptr7, align 8, !tbaa !0
  tail call void @Perl_sv_setsv_flags(%struct.sv* %call4, %struct.sv* %7, i32 2) #7
  br label %if.end28

if.else:                                          ; preds = %while.body
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp8 = icmp eq %struct.sv* %9, null
  br i1 %cmp8, label %lor.lhs.false19, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings10 = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings10, align 8, !tbaa !0
  %cmp11 = icmp eq %struct.sv* %11, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp11, label %lor.lhs.false19, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings14 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings14, align 8, !tbaa !0
  %cmp15 = icmp eq %struct.sv* %13, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp15, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true13
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings17 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings17, align 8, !tbaa !0
  %sv_any = getelementptr inbounds %struct.sv* %15, i64 0, i32 0
  %16 = load i8** %sv_any, align 8, !tbaa !0
  %xpv_pv = bitcast i8* %16 to i8**
  %17 = load i8** %xpv_pv, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds i8* %17, i64 3
  %18 = load i8* %arrayidx, align 1, !tbaa !1
  %and = and i8 %18, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false19, label %if.then27

lor.lhs.false19:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.else
  %19 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings20 = getelementptr inbounds %struct.cop* %19, i64 0, i32 14
  %20 = load %struct.sv** %cop_warnings20, align 8, !tbaa !0
  %cmp21 = icmp eq %struct.sv* %20, null
  br i1 %cmp21, label %land.lhs.true23, label %if.end28

land.lhs.true23:                                  ; preds = %lor.lhs.false19
  %21 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and25 = and i8 %21, 1
  %tobool26 = icmp eq i8 %and25, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %lor.lhs.false, %land.lhs.true23, %land.lhs.true13
  tail call void (i32, i8*, ...)* @Perl_warner(i32 12, i8* getelementptr inbounds ([41 x i8]* @.str42, i64 0, i64 0)) #7
  br label %if.end28

if.end28:                                         ; preds = %land.lhs.true23, %lor.lhs.false19, %if.then27, %if.then
  %mark.1 = phi %struct.sv** [ %incdec.ptr7, %if.then ], [ %incdec.ptr3, %if.then27 ], [ %incdec.ptr3, %land.lhs.true23 ], [ %incdec.ptr3, %lor.lhs.false19 ]
  %call29 = tail call %struct.he* @Perl_hv_store_ent(%struct.hv* %5, %struct.sv* %6, %struct.sv* %call4, i32 0) #7
  %cmp = icmp ult %struct.sv** %mark.1, %0
  br i1 %cmp, label %while.body, label %while.end

while.end:                                        ; preds = %if.end28, %entry
  %22 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr31 = getelementptr inbounds %struct.sv** %22, i64 %idx.ext
  %23 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast32 = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.rhs.cast33 = ptrtoint %struct.sv** %add.ptr31 to i64
  %sub.ptr.sub34 = sub i64 %sub.ptr.lhs.cast32, %sub.ptr.rhs.cast33
  %cmp36 = icmp slt i64 %sub.ptr.sub34, 8
  br i1 %cmp36, label %if.then38, label %if.end40

if.then38:                                        ; preds = %while.end
  %call39 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %add.ptr31, %struct.sv** %add.ptr31, i32 1) #7
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %while.end
  %sp.0 = phi %struct.sv** [ %call39, %if.then38 ], [ %add.ptr31, %while.end ]
  %incdec.ptr41 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call1, %struct.sv** %incdec.ptr41, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr41, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %24 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %24, i64 0, i32 0
  %25 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %25
}

; Function Attrs: optsize
declare %struct.hv* @Perl_newHV() #1

; Function Attrs: optsize
declare %struct.he* @Perl_hv_store_ent(%struct.hv*, %struct.sv*, %struct.sv*, i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_splice() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %add.ptr.sum = add i64 %idx.ext, 1
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %4 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %5 = bitcast %struct.sv* %4 to %struct.av*
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %6, 32768
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end48, label %cond.end

cond.end:                                         ; preds = %entry
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %4, i32 80) #7
  %tobool2 = icmp eq %struct.magic* %call, null
  br i1 %tobool2, label %if.end48, label %if.then

if.then:                                          ; preds = %cond.end
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %7 = load %struct.sv** %mg_obj, align 8, !tbaa !0
  %tobool3 = icmp eq %struct.sv* %7, null
  br i1 %tobool3, label %cond.false6, label %cond.end9

cond.false6:                                      ; preds = %if.then
  %call7 = tail call %struct.sv* @Perl_newRV(%struct.sv* %4) #7
  %call8 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7) #7
  br label %cond.end9

cond.end9:                                        ; preds = %if.then, %cond.false6
  %cond10 = phi %struct.sv* [ %call8, %cond.false6 ], [ %7, %if.then ]
  store %struct.sv* %cond10, %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %8 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr12 = getelementptr inbounds i32* %8, i64 1
  store i32* %incdec.ptr12, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %9 = load i32** @PL_markstack_max, align 8, !tbaa !0
  %cmp = icmp eq i32* %incdec.ptr12, %9
  br i1 %cmp, label %if.then14, label %if.end

if.then14:                                        ; preds = %cond.end9
  tail call void @Perl_markstack_grow() #7
  %.pre809 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then14, %cond.end9
  %10 = phi i32* [ %.pre809, %if.then14 ], [ %incdec.ptr12, %cond.end9 ]
  %11 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.rhs.cast16 = ptrtoint %struct.sv** %11 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast16
  %sub.ptr.div18771 = lshr exact i64 %sub.ptr.sub17, 3
  %conv19 = trunc i64 %sub.ptr.div18771 to i32
  store i32 %conv19, i32* %10, align 4, !tbaa !4
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  tail call void @Perl_push_scope() #7
  %12 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %12, i64 0, i32 6
  %13 = load i8* %op_flags, align 1, !tbaa !1
  %conv20 = zext i8 %13 to i32
  %and21 = and i32 %conv20, 3
  %cmp22 = icmp eq i32 %and21, 1
  br i1 %cmp22, label %cond.end45, label %cond.false25

cond.false25:                                     ; preds = %if.end
  %cmp29 = icmp eq i32 %and21, 2
  br i1 %cmp29, label %cond.end45, label %cond.false32

cond.false32:                                     ; preds = %cond.false25
  %cmp36 = icmp eq i32 %and21, 3
  br i1 %cmp36, label %cond.end45, label %cond.false39

cond.false39:                                     ; preds = %cond.false32
  %call40 = tail call i32 @Perl_block_gimme() #7
  br label %cond.end45

cond.end45:                                       ; preds = %cond.false25, %cond.false32, %cond.false39, %if.end
  %cond46 = phi i32 [ 128, %if.end ], [ 0, %cond.false25 ], [ %call40, %cond.false39 ], [ 1, %cond.false32 ]
  %call47 = tail call i32 @Perl_call_method(i8* getelementptr inbounds ([7 x i8]* @.str43, i64 0, i64 0), i32 %cond46) #7
  tail call void @Perl_pop_scope() #7
  %14 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %14, i64 0, i32 0
  %15 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.end48:                                         ; preds = %entry, %cond.end
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %0, i64 1
  %incdec.ptr1.sum = add i64 %idx.ext, 2
  %incdec.ptr50 = getelementptr inbounds %struct.sv** %1, i64 %incdec.ptr1.sum
  %cmp51 = icmp ult %struct.sv** %incdec.ptr50, %incdec.ptr49
  br i1 %cmp51, label %if.then53, label %if.else113

if.then53:                                        ; preds = %if.end48
  %16 = load %struct.sv** %incdec.ptr50, align 8, !tbaa !0
  store %struct.sv* %16, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags54 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags54, align 4, !tbaa !4
  %and55 = and i32 %17, 65536
  %tobool56 = icmp eq i32 %and55, 0
  br i1 %tobool56, label %cond.false58, label %cond.true57

cond.true57:                                      ; preds = %if.then53
  %sv_any = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %18, i64 24
  %19 = bitcast i8* %xiv_iv to i64*
  %20 = load i64* %19, align 8, !tbaa !3
  br label %cond.end60

cond.false58:                                     ; preds = %if.then53
  %call59 = tail call i64 @Perl_sv_2iv(%struct.sv* %16) #7
  br label %cond.end60

cond.end60:                                       ; preds = %cond.false58, %cond.true57
  %cond61 = phi i64 [ %20, %cond.true57 ], [ %call59, %cond.false58 ]
  %conv62 = trunc i64 %cond61 to i32
  %cmp63 = icmp slt i32 %conv62, 0
  br i1 %cmp63, label %if.then65, label %if.else

if.then65:                                        ; preds = %cond.end60
  %sv_any66 = bitcast %struct.sv* %4 to %struct.xpvav**
  %21 = load %struct.xpvav** %sv_any66, align 8, !tbaa !0
  %xav_fill = getelementptr inbounds %struct.xpvav* %21, i64 0, i32 1
  %22 = load i64* %xav_fill, align 8, !tbaa !3
  %add = add i64 %cond61, 1
  %add68 = add i64 %add, %22
  %conv69 = trunc i64 %add68 to i32
  br label %if.end70

if.else:                                          ; preds = %cond.end60
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %23, i64 0, i32 12
  %24 = load i32* %cop_arybase, align 4, !tbaa !4
  %sub = sub nsw i32 %conv62, %24
  br label %if.end70

if.end70:                                         ; preds = %if.else, %if.then65
  %offset.0 = phi i32 [ %conv69, %if.then65 ], [ %sub, %if.else ]
  %cmp71 = icmp slt i32 %offset.0, 0
  br i1 %cmp71, label %if.then73, label %if.end75

if.then73:                                        ; preds = %if.end70
  %call74 = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([0 x i8]* @PL_no_aelem, i64 0, i64 0), i32 %conv62) #7
  br label %return

if.end75:                                         ; preds = %if.end70
  %incdec.ptr50.sum = add i64 %idx.ext, 3
  %incdec.ptr76 = getelementptr inbounds %struct.sv** %1, i64 %incdec.ptr50.sum
  %cmp77 = icmp ult %struct.sv** %incdec.ptr76, %incdec.ptr49
  br i1 %cmp77, label %if.then79, label %if.else108

if.then79:                                        ; preds = %if.end75
  %incdec.ptr76.sum = add i64 %idx.ext, 4
  %incdec.ptr80 = getelementptr inbounds %struct.sv** %1, i64 %incdec.ptr76.sum
  %25 = load %struct.sv** %incdec.ptr76, align 8, !tbaa !0
  store %struct.sv* %25, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags81 = getelementptr inbounds %struct.sv* %25, i64 0, i32 2
  %26 = load i32* %sv_flags81, align 4, !tbaa !4
  %and82 = and i32 %26, 65536
  %tobool83 = icmp eq i32 %and82, 0
  br i1 %tobool83, label %cond.false87, label %cond.true84

cond.true84:                                      ; preds = %if.then79
  %sv_any85 = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %27 = load i8** %sv_any85, align 8, !tbaa !0
  %xiv_iv86 = getelementptr inbounds i8* %27, i64 24
  %28 = bitcast i8* %xiv_iv86 to i64*
  %29 = load i64* %28, align 8, !tbaa !3
  br label %cond.end89

cond.false87:                                     ; preds = %if.then79
  %call88 = tail call i64 @Perl_sv_2iv(%struct.sv* %25) #7
  br label %cond.end89

cond.end89:                                       ; preds = %cond.false87, %cond.true84
  %cond90 = phi i64 [ %29, %cond.true84 ], [ %call88, %cond.false87 ]
  %conv91 = trunc i64 %cond90 to i32
  %cmp92 = icmp slt i32 %conv91, 0
  %sv_any95 = bitcast %struct.sv* %4 to %struct.xpvav**
  %30 = load %struct.xpvav** %sv_any95, align 8, !tbaa !0
  br i1 %cmp92, label %if.then94, label %if.end118

if.then94:                                        ; preds = %cond.end89
  %xav_fill96 = getelementptr inbounds %struct.xpvav* %30, i64 0, i32 1
  %31 = load i64* %xav_fill96, align 8, !tbaa !3
  %conv97767 = zext i32 %offset.0 to i64
  %sub98 = sub i64 1, %conv97767
  %add99 = add i64 %sub98, %cond90
  %add101 = add i64 %add99, %31
  %conv102 = trunc i64 %add101 to i32
  %cmp103 = icmp slt i32 %conv102, 0
  %.conv102 = select i1 %cmp103, i32 0, i32 %conv102
  br label %if.end118

if.else108:                                       ; preds = %if.end75
  %sv_any109 = bitcast %struct.sv* %4 to %struct.xpvav**
  %32 = load %struct.xpvav** %sv_any109, align 8, !tbaa !0
  %xav_max = getelementptr inbounds %struct.xpvav* %32, i64 0, i32 2
  %33 = load i64* %xav_max, align 8, !tbaa !3
  %add110 = add nsw i64 %33, 1
  %conv111 = trunc i64 %add110 to i32
  br label %if.end118

if.else113:                                       ; preds = %if.end48
  %sv_any114 = bitcast %struct.sv* %4 to %struct.xpvav**
  %34 = load %struct.xpvav** %sv_any114, align 8, !tbaa !0
  %xav_max115 = getelementptr inbounds %struct.xpvav* %34, i64 0, i32 2
  %35 = load i64* %xav_max115, align 8, !tbaa !3
  %add116 = add nsw i64 %35, 1
  %conv117 = trunc i64 %add116 to i32
  br label %if.end118

if.end118:                                        ; preds = %cond.end89, %if.else108, %if.then94, %if.else113
  %36 = phi %struct.xpvav* [ %30, %if.then94 ], [ %32, %if.else108 ], [ %34, %if.else113 ], [ %30, %cond.end89 ]
  %offset.1 = phi i32 [ %offset.0, %if.then94 ], [ %offset.0, %if.else108 ], [ 0, %if.else113 ], [ %offset.0, %cond.end89 ]
  %length.0 = phi i32 [ %.conv102, %if.then94 ], [ %conv111, %if.else108 ], [ %conv117, %if.else113 ], [ %conv91, %cond.end89 ]
  %mark.0 = phi %struct.sv** [ %incdec.ptr80, %if.then94 ], [ %incdec.ptr76, %if.else108 ], [ %incdec.ptr50, %if.else113 ], [ %incdec.ptr80, %cond.end89 ]
  %conv119 = sext i32 %offset.1 to i64
  %sv_any120 = bitcast %struct.sv* %4 to %struct.xpvav**
  %xav_fill121 = getelementptr inbounds %struct.xpvav* %36, i64 0, i32 1
  %37 = load i64* %xav_fill121, align 8, !tbaa !3
  %add122 = add nsw i64 %37, 1
  %cmp123 = icmp sgt i64 %conv119, %add122
  br i1 %cmp123, label %if.then125, label %if.end154

if.then125:                                       ; preds = %if.end118
  %38 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings = getelementptr inbounds %struct.cop* %38, i64 0, i32 14
  %39 = load %struct.sv** %cop_warnings, align 8, !tbaa !0
  %cmp126 = icmp eq %struct.sv* %39, null
  br i1 %cmp126, label %lor.lhs.false140, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then125
  %40 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings128 = getelementptr inbounds %struct.cop* %40, i64 0, i32 14
  %41 = load %struct.sv** %cop_warnings128, align 8, !tbaa !0
  %cmp129 = icmp eq %struct.sv* %41, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp129, label %lor.lhs.false140, label %land.lhs.true131

land.lhs.true131:                                 ; preds = %land.lhs.true
  %42 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings132 = getelementptr inbounds %struct.cop* %42, i64 0, i32 14
  %43 = load %struct.sv** %cop_warnings132, align 8, !tbaa !0
  %cmp133 = icmp eq %struct.sv* %43, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp133, label %if.then148, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true131
  %44 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings135 = getelementptr inbounds %struct.cop* %44, i64 0, i32 14
  %45 = load %struct.sv** %cop_warnings135, align 8, !tbaa !0
  %sv_any136 = getelementptr inbounds %struct.sv* %45, i64 0, i32 0
  %46 = load i8** %sv_any136, align 8, !tbaa !0
  %xpv_pv = bitcast i8* %46 to i8**
  %47 = load i8** %xpv_pv, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds i8* %47, i64 3
  %48 = load i8* %arrayidx, align 1, !tbaa !1
  %and138 = and i8 %48, 1
  %tobool139 = icmp eq i8 %and138, 0
  br i1 %tobool139, label %lor.lhs.false140, label %if.then148

lor.lhs.false140:                                 ; preds = %lor.lhs.false, %land.lhs.true, %if.then125
  %49 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_warnings141 = getelementptr inbounds %struct.cop* %49, i64 0, i32 14
  %50 = load %struct.sv** %cop_warnings141, align 8, !tbaa !0
  %cmp142 = icmp eq %struct.sv* %50, null
  br i1 %cmp142, label %land.lhs.true144, label %if.end149

land.lhs.true144:                                 ; preds = %lor.lhs.false140
  %51 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and146 = and i8 %51, 1
  %tobool147 = icmp eq i8 %and146, 0
  br i1 %tobool147, label %if.end149, label %if.then148

if.then148:                                       ; preds = %lor.lhs.false, %land.lhs.true144, %land.lhs.true131
  tail call void (i32, i8*, ...)* @Perl_warner(i32 12, i8* getelementptr inbounds ([34 x i8]* @.str44, i64 0, i64 0)) #7
  br label %if.end149

if.end149:                                        ; preds = %land.lhs.true144, %if.then148, %lor.lhs.false140
  %52 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_fill151 = getelementptr inbounds %struct.xpvav* %52, i64 0, i32 1
  %53 = load i64* %xav_fill151, align 8, !tbaa !3
  %add152 = add nsw i64 %53, 1
  %conv153 = trunc i64 %add152 to i32
  br label %if.end154

if.end154:                                        ; preds = %if.end149, %if.end118
  %54 = phi i64 [ %53, %if.end149 ], [ %37, %if.end118 ]
  %55 = phi %struct.xpvav* [ %52, %if.end149 ], [ %36, %if.end118 ]
  %offset.2 = phi i32 [ %conv153, %if.end149 ], [ %offset.1, %if.end118 ]
  %add157 = add nsw i64 %54, 1
  %add158 = add nsw i32 %offset.2, %length.0
  %conv159756 = zext i32 %add158 to i64
  %sub160 = sub i64 %add157, %conv159756
  %conv161 = trunc i64 %sub160 to i32
  %cmp162 = icmp slt i32 %conv161, 0
  br i1 %cmp162, label %if.then164, label %if.end170

if.then164:                                       ; preds = %if.end154
  %add165 = add nsw i32 %conv161, %length.0
  %xav_alloc = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 7
  %56 = load %struct.sv*** %xav_alloc, align 8, !tbaa !0
  %tobool167 = icmp eq %struct.sv** %56, null
  br i1 %tobool167, label %if.then168, label %if.end170

if.then168:                                       ; preds = %if.then164
  tail call void @Perl_av_extend(%struct.av* %5, i32 0) #7
  br label %if.end170

if.end170:                                        ; preds = %if.then164, %if.then168, %if.end154
  %length.1 = phi i32 [ %add165, %if.then164 ], [ %add165, %if.then168 ], [ %length.0, %if.end154 ]
  %after.0 = phi i32 [ 0, %if.then164 ], [ 0, %if.then168 ], [ %conv161, %if.end154 ]
  %sub.ptr.lhs.cast171 = ptrtoint %struct.sv** %incdec.ptr49 to i64
  %sub.ptr.rhs.cast172 = ptrtoint %struct.sv** %mark.0 to i64
  %sub.ptr.sub173 = sub i64 %sub.ptr.lhs.cast171, %sub.ptr.rhs.cast172
  %sub.ptr.div174757 = lshr exact i64 %sub.ptr.sub173, 3
  %conv175 = trunc i64 %sub.ptr.div174757 to i32
  %sub176 = sub nsw i32 %conv175, %length.1
  %tobool177 = icmp ne i32 %conv175, 0
  br i1 %tobool177, label %land.lhs.true178, label %for.end

land.lhs.true178:                                 ; preds = %if.end170
  %57 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_flags = getelementptr inbounds %struct.xpvav* %57, i64 0, i32 9
  %58 = load i8* %xav_flags, align 1, !tbaa !1
  %59 = and i8 %58, 3
  %60 = icmp eq i8 %59, 2
  br i1 %60, label %if.then189, label %for.body

if.then189:                                       ; preds = %land.lhs.true178
  tail call void @Perl_av_reify(%struct.av* %5) #7
  br label %for.body

for.body:                                         ; preds = %if.then189, %land.lhs.true178, %for.body
  %dst.0798 = phi %struct.sv** [ %incdec.ptr193, %for.body ], [ %mark.0, %land.lhs.true178 ], [ %mark.0, %if.then189 ]
  %i.0797 = phi i32 [ %dec, %for.body ], [ %conv175, %land.lhs.true178 ], [ %conv175, %if.then189 ]
  %61 = load %struct.sv** %dst.0798, align 8, !tbaa !0
  %call192 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %61) #7
  %incdec.ptr193 = getelementptr inbounds %struct.sv** %dst.0798, i64 1
  store %struct.sv* %call192, %struct.sv** %dst.0798, align 8, !tbaa !0
  %dec = add nsw i32 %i.0797, -1
  %tobool191 = icmp eq i32 %dec, 0
  br i1 %tobool191, label %for.end, label %for.body

for.end:                                          ; preds = %if.end170, %for.body
  %cmp194 = icmp slt i32 %sub176, 0
  br i1 %cmp194, label %if.then196, label %if.else372

if.then196:                                       ; preds = %for.end
  br i1 %tobool177, label %if.then198, label %if.end203

if.then198:                                       ; preds = %if.then196
  %sext763 = shl i64 %sub.ptr.sub173, 29
  %mul = ashr exact i64 %sext763, 29
  %call200 = tail call i8* @Perl_safesysmalloc(i64 %mul) #7
  %62 = bitcast %struct.sv** %mark.0 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call200, i8* %62, i64 %mul, i32 1, i1 false)
  br label %if.end203

if.end203:                                        ; preds = %if.then196, %if.then198
  %tmparyval.0 = phi i8* [ %call200, %if.then198 ], [ null, %if.then196 ]
  %63 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr205.sum = add i64 %idx.ext, 1
  %add.ptr206 = getelementptr inbounds %struct.sv** %63, i64 %add.ptr205.sum
  %64 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags207 = getelementptr inbounds %struct.op* %64, i64 0, i32 6
  %65 = load i8* %op_flags207, align 1, !tbaa !1
  %conv208 = zext i8 %65 to i32
  %and209 = and i32 %conv208, 3
  %tobool210 = icmp eq i32 %and209, 0
  br i1 %tobool210, label %cond.false218, label %cond.true211

cond.true211:                                     ; preds = %if.end203
  %cmp215 = icmp eq i32 %and209, 3
  %cond217 = zext i1 %cmp215 to i32
  br label %cond.end220

cond.false218:                                    ; preds = %if.end203
  %call219 = tail call i32 @Perl_dowantarray() #7
  br label %cond.end220

cond.end220:                                      ; preds = %cond.false218, %cond.true211
  %cond221 = phi i32 [ %cond217, %cond.true211 ], [ %call219, %cond.false218 ]
  %cmp222 = icmp eq i32 %cond221, 1
  br i1 %cmp222, label %if.then224, label %if.else270

if.then224:                                       ; preds = %cond.end220
  %66 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast225 = ptrtoint %struct.sv** %66 to i64
  %sub.ptr.rhs.cast226 = ptrtoint %struct.sv** %add.ptr206 to i64
  %sub.ptr.sub227 = sub i64 %sub.ptr.lhs.cast225, %sub.ptr.rhs.cast226
  %sub.ptr.div228 = ashr exact i64 %sub.ptr.sub227, 3
  %conv229 = sext i32 %length.1 to i64
  %cmp230 = icmp slt i64 %sub.ptr.div228, %conv229
  br i1 %cmp230, label %if.then232, label %if.end241

if.then232:                                       ; preds = %if.then224
  %67 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.rhs.cast234 = ptrtoint %struct.sv** %67 to i64
  %sub.ptr.sub235 = sub i64 %sub.ptr.rhs.cast226, %sub.ptr.rhs.cast234
  %call238 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr49, %struct.sv** %add.ptr206, i32 %length.1) #7
  %68 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %69 = shl i64 %sub.ptr.sub235, 29
  %idx.ext239 = ashr i64 %69, 32
  %add.ptr240 = getelementptr inbounds %struct.sv** %68, i64 %idx.ext239
  br label %if.end241

if.end241:                                        ; preds = %if.then224, %if.then232
  %mark.1 = phi %struct.sv** [ %add.ptr240, %if.then232 ], [ %add.ptr206, %if.then224 ]
  %70 = bitcast %struct.sv** %mark.1 to i8*
  %71 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array = getelementptr inbounds %struct.xpvav* %71, i64 0, i32 0
  %72 = load i8** %xav_array, align 8, !tbaa !0
  %73 = bitcast i8* %72 to %struct.sv**
  %idx.ext243 = sext i32 %offset.2 to i64
  %add.ptr244 = getelementptr inbounds %struct.sv** %73, i64 %idx.ext243
  %74 = bitcast %struct.sv** %add.ptr244 to i8*
  %mul246 = shl nsw i64 %conv229, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %70, i8* %74, i64 %mul246, i32 1, i1 false)
  %75 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_flags248 = getelementptr inbounds %struct.xpvav* %75, i64 0, i32 9
  %76 = load i8* %xav_flags248, align 1, !tbaa !1
  %and250 = and i8 %76, 1
  %tobool251 = icmp eq i8 %and250, 0
  br i1 %tobool251, label %if.end266, label %if.then252

if.then252:                                       ; preds = %if.end241
  %77 = load i32* @PL_tmps_ix, align 4, !tbaa !4
  %add253 = add nsw i32 %77, %length.1
  %78 = load i32* @PL_tmps_max, align 4, !tbaa !4
  %cmp254 = icmp slt i32 %add253, %78
  br i1 %cmp254, label %for.cond258.preheader, label %if.then256

if.then256:                                       ; preds = %if.then252
  tail call void @Perl_tmps_grow(i32 %length.1) #7
  br label %for.cond258.preheader

for.cond258.preheader:                            ; preds = %if.then252, %if.then256
  %tobool259779 = icmp eq i32 %length.1, 0
  br i1 %tobool259779, label %if.end266, label %for.body260

for.body260:                                      ; preds = %for.cond258.preheader, %for.body260
  %dst.1781 = phi %struct.sv** [ %incdec.ptr262, %for.body260 ], [ %mark.1, %for.cond258.preheader ]
  %i.1780 = phi i32 [ %dec264, %for.body260 ], [ %length.1, %for.cond258.preheader ]
  %79 = load %struct.sv** %dst.1781, align 8, !tbaa !0
  %call261 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %79) #7
  %incdec.ptr262 = getelementptr inbounds %struct.sv** %dst.1781, i64 1
  %dec264 = add nsw i32 %i.1780, -1
  %tobool259 = icmp eq i32 %dec264, 0
  br i1 %tobool259, label %if.end266, label %for.body260

if.end266:                                        ; preds = %for.cond258.preheader, %for.body260, %if.end241
  %sub267 = add nsw i32 %length.1, -1
  %idx.ext268 = sext i32 %sub267 to i64
  %add.ptr269 = getelementptr inbounds %struct.sv** %mark.1, i64 %idx.ext268
  br label %if.end297

if.else270:                                       ; preds = %cond.end220
  %add271 = add i32 %offset.2, -1
  %sub272 = add i32 %add271, %length.1
  %idxprom = sext i32 %sub272 to i64
  %80 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array274 = getelementptr inbounds %struct.xpvav* %80, i64 0, i32 0
  %81 = load i8** %xav_array274, align 8, !tbaa !0
  %82 = bitcast i8* %81 to %struct.sv**
  %arrayidx275 = getelementptr inbounds %struct.sv** %82, i64 %idxprom
  %83 = load %struct.sv** %arrayidx275, align 8, !tbaa !0
  store %struct.sv* %83, %struct.sv** %add.ptr206, align 8, !tbaa !0
  %84 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_flags277 = getelementptr inbounds %struct.xpvav* %84, i64 0, i32 9
  %85 = load i8* %xav_flags277, align 1, !tbaa !1
  %and279 = and i8 %85, 1
  %tobool280 = icmp eq i8 %and279, 0
  br i1 %tobool280, label %if.end297, label %if.then281

if.then281:                                       ; preds = %if.else270
  %call282 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %83) #7
  %i.2782 = add nsw i32 %length.1, -1
  %cmp289783 = icmp sgt i32 %i.2782, 0
  br i1 %cmp289783, label %for.body291.lr.ph, label %if.end297

for.body291.lr.ph:                                ; preds = %if.then281
  %86 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array286 = getelementptr inbounds %struct.xpvav* %86, i64 0, i32 0
  %87 = load i8** %xav_array286, align 8, !tbaa !0
  %88 = bitcast i8* %87 to %struct.sv**
  %idxprom284 = sext i32 %offset.2 to i64
  %arrayidx287 = getelementptr inbounds %struct.sv** %88, i64 %idxprom284
  br label %for.body291

for.body291:                                      ; preds = %for.body291.lr.ph, %for.body291
  %i.2785 = phi i32 [ %i.2782, %for.body291.lr.ph ], [ %i.2, %for.body291 ]
  %dst.2784 = phi %struct.sv** [ %arrayidx287, %for.body291.lr.ph ], [ %incdec.ptr292, %for.body291 ]
  %incdec.ptr292 = getelementptr inbounds %struct.sv** %dst.2784, i64 1
  %89 = load %struct.sv** %dst.2784, align 8, !tbaa !0
  tail call void @Perl_sv_free(%struct.sv* %89) #7
  %i.2 = add nsw i32 %i.2785, -1
  %cmp289 = icmp sgt i32 %i.2, 0
  br i1 %cmp289, label %for.body291, label %if.end297

if.end297:                                        ; preds = %if.then281, %for.body291, %if.else270, %if.end266
  %mark.2 = phi %struct.sv** [ %add.ptr269, %if.end266 ], [ %add.ptr206, %if.else270 ], [ %add.ptr206, %for.body291 ], [ %add.ptr206, %if.then281 ]
  %conv298 = sext i32 %sub176 to i64
  %90 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_fill300 = getelementptr inbounds %struct.xpvav* %90, i64 0, i32 1
  %91 = load i64* %xav_fill300, align 8, !tbaa !3
  %add301 = add nsw i64 %91, %conv298
  store i64 %add301, i64* %xav_fill300, align 8, !tbaa !3
  %cmp302 = icmp slt i32 %offset.2, %after.0
  br i1 %cmp302, label %if.then304, label %if.else337

if.then304:                                       ; preds = %if.end297
  %tobool305 = icmp eq i32 %offset.2, 0
  br i1 %tobool305, label %if.end323, label %if.then306

if.then306:                                       ; preds = %if.then304
  %sub307 = add nsw i32 %offset.2, -1
  %idxprom308 = sext i32 %sub307 to i64
  %xav_array310 = getelementptr inbounds %struct.xpvav* %90, i64 0, i32 0
  %92 = load i8** %xav_array310, align 8, !tbaa !0
  %93 = bitcast i8* %92 to %struct.sv**
  %cmp315775 = icmp sgt i32 %offset.2, 0
  br i1 %cmp315775, label %for.body317.lr.ph, label %if.end323

for.body317.lr.ph:                                ; preds = %if.then306
  %arrayidx311.sum = sub i64 %idxprom308, %conv298
  %add.ptr313 = getelementptr inbounds %struct.sv** %93, i64 %arrayidx311.sum
  %arrayidx311 = getelementptr inbounds %struct.sv** %93, i64 %idxprom308
  br label %for.body317

for.body317:                                      ; preds = %for.body317.lr.ph, %for.body317
  %src.0778 = phi %struct.sv** [ %arrayidx311, %for.body317.lr.ph ], [ %incdec.ptr318, %for.body317 ]
  %dst.3777 = phi %struct.sv** [ %add.ptr313, %for.body317.lr.ph ], [ %incdec.ptr319, %for.body317 ]
  %i.3776 = phi i32 [ %offset.2, %for.body317.lr.ph ], [ %dec321, %for.body317 ]
  %incdec.ptr318 = getelementptr inbounds %struct.sv** %src.0778, i64 -1
  %94 = load %struct.sv** %src.0778, align 8, !tbaa !0
  %incdec.ptr319 = getelementptr inbounds %struct.sv** %dst.3777, i64 -1
  store %struct.sv* %94, %struct.sv** %dst.3777, align 8, !tbaa !0
  %dec321 = add nsw i32 %i.3776, -1
  %cmp315 = icmp sgt i32 %dec321, 0
  br i1 %cmp315, label %for.body317, label %for.cond314.if.end323.loopexit_crit_edge

for.cond314.if.end323.loopexit_crit_edge:         ; preds = %for.body317
  %.pre.pre = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  br label %if.end323

if.end323:                                        ; preds = %if.then306, %for.cond314.if.end323.loopexit_crit_edge, %if.then304
  %95 = phi %struct.xpvav* [ %90, %if.then304 ], [ %.pre.pre, %for.cond314.if.end323.loopexit_crit_edge ], [ %90, %if.then306 ]
  %xav_array325 = getelementptr inbounds %struct.xpvav* %95, i64 0, i32 0
  %96 = load i8** %xav_array325, align 8, !tbaa !0
  %97 = bitcast i8* %96 to %struct.sv**
  %idx.neg329 = sub i64 0, %conv298
  %add.ptr330 = getelementptr inbounds %struct.sv** %97, i64 %idx.neg329
  %98 = bitcast %struct.sv** %add.ptr330 to i8*
  store i8* %98, i8** %xav_array325, align 8, !tbaa !0
  %99 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_max335 = getelementptr inbounds %struct.xpvav* %99, i64 0, i32 2
  %100 = load i64* %xav_max335, align 8, !tbaa !3
  %add336 = add nsw i64 %100, %conv298
  store i64 %add336, i64* %xav_max335, align 8, !tbaa !3
  br label %if.end357

if.else337:                                       ; preds = %if.end297
  %tobool338 = icmp eq i32 %after.0, 0
  br i1 %tobool338, label %if.end350, label %if.then339

if.then339:                                       ; preds = %if.else337
  %xav_array341 = getelementptr inbounds %struct.xpvav* %90, i64 0, i32 0
  %101 = load i8** %xav_array341, align 8, !tbaa !0
  %102 = bitcast i8* %101 to %struct.sv**
  %idx.ext342 = sext i32 %offset.2 to i64
  %idx.ext344 = sext i32 %length.1 to i64
  %add.ptr343.sum = add i64 %idx.ext344, %idx.ext342
  %add.ptr345 = getelementptr inbounds %struct.sv** %102, i64 %add.ptr343.sum
  %add.ptr345.sum = add i64 %add.ptr343.sum, %conv298
  %add.ptr347 = getelementptr inbounds %struct.sv** %102, i64 %add.ptr345.sum
  %103 = bitcast %struct.sv** %add.ptr347 to i8*
  %104 = bitcast %struct.sv** %add.ptr345 to i8*
  %conv348 = sext i32 %after.0 to i64
  %mul349 = shl nsw i64 %conv348, 3
  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %103, i8* %104, i64 %mul349, i32 1, i1 false)
  %.pre803 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_fill352.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre803, i64 0, i32 1
  %.pre804 = load i64* %xav_fill352.phi.trans.insert, align 8, !tbaa !3
  br label %if.end350

if.end350:                                        ; preds = %if.else337, %if.then339
  %105 = phi i64 [ %add301, %if.else337 ], [ %.pre804, %if.then339 ]
  %106 = phi %struct.xpvav* [ %90, %if.else337 ], [ %.pre803, %if.then339 ]
  %add353 = add nsw i64 %105, 1
  %xav_array355 = getelementptr inbounds %struct.xpvav* %106, i64 0, i32 0
  %107 = load i8** %xav_array355, align 8, !tbaa !0
  %108 = bitcast i8* %107 to %struct.sv**
  %arrayidx356 = getelementptr inbounds %struct.sv** %108, i64 %add353
  br label %if.end357

if.end357:                                        ; preds = %if.end350, %if.end323
  %dst.4 = phi %struct.sv** [ %97, %if.end323 ], [ %arrayidx356, %if.end350 ]
  %tobool359773 = icmp eq i32 %conv175, %length.1
  br i1 %tobool359773, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end357
  %109 = sub i32 %length.1, %conv175
  %110 = sext i32 %109 to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %indvars.iv = phi i64 [ %110, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ]
  %indvars.iv.next = add i64 %indvars.iv, -1
  %arrayidx362 = getelementptr inbounds %struct.sv** %dst.4, i64 %indvars.iv.next
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx362, align 8, !tbaa !0
  %111 = trunc i64 %indvars.iv.next to i32
  %tobool359 = icmp eq i32 %111, 0
  br i1 %tobool359, label %while.end, label %while.body

while.end:                                        ; preds = %while.body, %if.end357
  br i1 %tobool177, label %if.then364, label %if.end552

if.then364:                                       ; preds = %while.end
  %112 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array366 = getelementptr inbounds %struct.xpvav* %112, i64 0, i32 0
  %113 = load i8** %xav_array366, align 8, !tbaa !0
  %114 = bitcast i8* %113 to %struct.sv**
  %idx.ext367 = sext i32 %offset.2 to i64
  %add.ptr368 = getelementptr inbounds %struct.sv** %114, i64 %idx.ext367
  %115 = bitcast %struct.sv** %add.ptr368 to i8*
  %sext760 = shl i64 %sub.ptr.sub173, 29
  %mul370 = ashr exact i64 %sext760, 29
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %115, i8* %tmparyval.0, i64 %mul370, i32 1, i1 false)
  tail call void @Perl_safesysfree(i8* %tmparyval.0) #7
  br label %if.end552

if.else372:                                       ; preds = %for.end
  %tobool373 = icmp ne i32 %length.1, 0
  br i1 %tobool373, label %if.then374, label %if.end384

if.then374:                                       ; preds = %if.else372
  %conv375 = sext i32 %length.1 to i64
  %mul376 = shl nsw i64 %conv375, 3
  %call377 = tail call i8* @Perl_safesysmalloc(i64 %mul376) #7
  %116 = bitcast i8* %call377 to %struct.sv**
  %117 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array379 = getelementptr inbounds %struct.xpvav* %117, i64 0, i32 0
  %118 = load i8** %xav_array379, align 8, !tbaa !0
  %119 = bitcast i8* %118 to %struct.sv**
  %idx.ext380 = sext i32 %offset.2 to i64
  %add.ptr381 = getelementptr inbounds %struct.sv** %119, i64 %idx.ext380
  %120 = bitcast %struct.sv** %add.ptr381 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call377, i8* %120, i64 %mul376, i32 1, i1 false)
  br label %if.end384

if.end384:                                        ; preds = %if.then374, %if.else372
  %tmparyval.1 = phi %struct.sv** [ %116, %if.then374 ], [ null, %if.else372 ]
  %cmp385 = icmp sgt i32 %sub176, 0
  br i1 %cmp385, label %if.then387, label %if.end468

if.then387:                                       ; preds = %if.end384
  %cmp388 = icmp slt i32 %offset.2, %after.0
  br i1 %cmp388, label %land.lhs.true390, label %if.then387.if.else428_crit_edge

if.then387.if.else428_crit_edge:                  ; preds = %if.then387
  %.pre811 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %conv431.pre = sext i32 %sub176 to i64
  br label %if.else428

land.lhs.true390:                                 ; preds = %if.then387
  %conv391 = sext i32 %sub176 to i64
  %121 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array393 = getelementptr inbounds %struct.xpvav* %121, i64 0, i32 0
  %122 = load i8** %xav_array393, align 8, !tbaa !0
  %123 = bitcast i8* %122 to %struct.sv**
  %xav_alloc395 = getelementptr inbounds %struct.xpvav* %121, i64 0, i32 7
  %124 = load %struct.sv*** %xav_alloc395, align 8, !tbaa !0
  %sub.ptr.lhs.cast396 = ptrtoint i8* %122 to i64
  %sub.ptr.rhs.cast397 = ptrtoint %struct.sv** %124 to i64
  %sub.ptr.sub398 = sub i64 %sub.ptr.lhs.cast396, %sub.ptr.rhs.cast397
  %sub.ptr.div399 = ashr exact i64 %sub.ptr.sub398, 3
  %cmp400 = icmp sgt i64 %conv391, %sub.ptr.div399
  br i1 %cmp400, label %if.else428, label %if.then402

if.then402:                                       ; preds = %land.lhs.true390
  %tobool403 = icmp eq i32 %offset.2, 0
  %idx.neg416.pre = sub i64 0, %conv391
  br i1 %tobool403, label %if.end412, label %if.then404

if.then404:                                       ; preds = %if.then402
  %add.ptr409 = getelementptr inbounds %struct.sv** %123, i64 %idx.neg416.pre
  %125 = bitcast %struct.sv** %add.ptr409 to i8*
  %conv410 = sext i32 %offset.2 to i64
  %mul411 = shl nsw i64 %conv410, 3
  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %125, i8* %122, i64 %mul411, i32 1, i1 false)
  %.pre805 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array414.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre805, i64 0, i32 0
  %.pre806 = load i8** %xav_array414.phi.trans.insert, align 8, !tbaa !0
  br label %if.end412

if.end412:                                        ; preds = %if.then402, %if.then404
  %126 = phi i8* [ %.pre806, %if.then404 ], [ %122, %if.then402 ]
  %127 = phi %struct.xpvav* [ %.pre805, %if.then404 ], [ %121, %if.then402 ]
  %xav_array414 = getelementptr inbounds %struct.xpvav* %127, i64 0, i32 0
  %128 = bitcast i8* %126 to %struct.sv**
  %add.ptr417 = getelementptr inbounds %struct.sv** %128, i64 %idx.neg416.pre
  %129 = bitcast %struct.sv** %add.ptr417 to i8*
  store i8* %129, i8** %xav_array414, align 8, !tbaa !0
  %130 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_max422 = getelementptr inbounds %struct.xpvav* %130, i64 0, i32 2
  %131 = load i64* %xav_max422, align 8, !tbaa !3
  %add423 = add nsw i64 %131, %conv391
  store i64 %add423, i64* %xav_max422, align 8, !tbaa !3
  %xav_fill426 = getelementptr inbounds %struct.xpvav* %130, i64 0, i32 1
  %132 = load i64* %xav_fill426, align 8, !tbaa !3
  %add427 = add nsw i64 %132, %conv391
  store i64 %add427, i64* %xav_fill426, align 8, !tbaa !3
  br label %if.end468

if.else428:                                       ; preds = %if.then387.if.else428_crit_edge, %land.lhs.true390
  %conv431.pre-phi = phi i64 [ %conv431.pre, %if.then387.if.else428_crit_edge ], [ %conv391, %land.lhs.true390 ]
  %133 = phi %struct.xpvav* [ %.pre811, %if.then387.if.else428_crit_edge ], [ %121, %land.lhs.true390 ]
  %xav_fill430 = getelementptr inbounds %struct.xpvav* %133, i64 0, i32 1
  %134 = load i64* %xav_fill430, align 8, !tbaa !3
  %add432 = add nsw i64 %134, %conv431.pre-phi
  %xav_max434 = getelementptr inbounds %struct.xpvav* %133, i64 0, i32 2
  %135 = load i64* %xav_max434, align 8, !tbaa !3
  %cmp435 = icmp slt i64 %add432, %135
  br i1 %cmp435, label %if.end443, label %if.then437

if.then437:                                       ; preds = %if.else428
  %conv442 = trunc i64 %add432 to i32
  tail call void @Perl_av_extend(%struct.av* %5, i32 %conv442) #7
  %.pre807 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_fill446.phi.trans.insert = getelementptr inbounds %struct.xpvav* %.pre807, i64 0, i32 1
  %.pre808 = load i64* %xav_fill446.phi.trans.insert, align 8, !tbaa !3
  br label %if.end443

if.end443:                                        ; preds = %if.else428, %if.then437
  %136 = phi i64 [ %134, %if.else428 ], [ %.pre808, %if.then437 ]
  %137 = phi %struct.xpvav* [ %133, %if.else428 ], [ %.pre807, %if.then437 ]
  %xav_fill446 = getelementptr inbounds %struct.xpvav* %137, i64 0, i32 1
  %add447 = add nsw i64 %136, %conv431.pre-phi
  store i64 %add447, i64* %xav_fill446, align 8, !tbaa !3
  %tobool448 = icmp eq i32 %after.0, 0
  br i1 %tobool448, label %if.end468, label %for.body460.lr.ph

for.body460.lr.ph:                                ; preds = %if.end443
  %xav_array451 = getelementptr inbounds %struct.xpvav* %137, i64 0, i32 0
  %138 = load i8** %xav_array451, align 8, !tbaa !0
  %139 = bitcast i8* %138 to %struct.sv**
  %add.ptr457 = getelementptr inbounds %struct.sv** %139, i64 %136
  %add.ptr454 = getelementptr inbounds %struct.sv** %139, i64 %add447
  br label %for.body460

for.body460:                                      ; preds = %for.body460.lr.ph, %for.body460
  %src.1795 = phi %struct.sv** [ %add.ptr457, %for.body460.lr.ph ], [ %incdec.ptr461, %for.body460 ]
  %dst.5794 = phi %struct.sv** [ %add.ptr454, %for.body460.lr.ph ], [ %incdec.ptr462, %for.body460 ]
  %i.5793 = phi i32 [ %after.0, %for.body460.lr.ph ], [ %dec464, %for.body460 ]
  %incdec.ptr461 = getelementptr inbounds %struct.sv** %src.1795, i64 -1
  %140 = load %struct.sv** %src.1795, align 8, !tbaa !0
  %incdec.ptr462 = getelementptr inbounds %struct.sv** %dst.5794, i64 -1
  store %struct.sv* %140, %struct.sv** %dst.5794, align 8, !tbaa !0
  %dec464 = add nsw i32 %i.5793, -1
  %tobool459 = icmp eq i32 %dec464, 0
  br i1 %tobool459, label %if.end468, label %for.body460

if.end468:                                        ; preds = %for.body460, %if.end443, %if.end412, %if.end384
  br i1 %tobool177, label %if.then470, label %if.end477

if.then470:                                       ; preds = %if.end468
  %141 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_array472 = getelementptr inbounds %struct.xpvav* %141, i64 0, i32 0
  %142 = load i8** %xav_array472, align 8, !tbaa !0
  %143 = bitcast i8* %142 to %struct.sv**
  %idx.ext473 = sext i32 %offset.2 to i64
  %add.ptr474 = getelementptr inbounds %struct.sv** %143, i64 %idx.ext473
  %144 = bitcast %struct.sv** %add.ptr474 to i8*
  %145 = bitcast %struct.sv** %mark.0 to i8*
  %sext758 = shl i64 %sub.ptr.sub173, 29
  %mul476 = ashr exact i64 %sext758, 29
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %144, i8* %145, i64 %mul476, i32 1, i1 false)
  br label %if.end477

if.end477:                                        ; preds = %if.end468, %if.then470
  %146 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %add.ptr479.sum = add i64 %idx.ext, 1
  %add.ptr480 = getelementptr inbounds %struct.sv** %146, i64 %add.ptr479.sum
  %147 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags481 = getelementptr inbounds %struct.op* %147, i64 0, i32 6
  %148 = load i8* %op_flags481, align 1, !tbaa !1
  %conv482 = zext i8 %148 to i32
  %and483 = and i32 %conv482, 3
  %tobool484 = icmp eq i32 %and483, 0
  br i1 %tobool484, label %cond.false492, label %cond.true485

cond.true485:                                     ; preds = %if.end477
  %cmp489 = icmp eq i32 %and483, 3
  %cond491 = zext i1 %cmp489 to i32
  br label %cond.end494

cond.false492:                                    ; preds = %if.end477
  %call493 = tail call i32 @Perl_dowantarray() #7
  br label %cond.end494

cond.end494:                                      ; preds = %cond.false492, %cond.true485
  %cond495 = phi i32 [ %cond491, %cond.true485 ], [ %call493, %cond.false492 ]
  %cmp496 = icmp eq i32 %cond495, 1
  br i1 %cmp496, label %if.then498, label %if.else527

if.then498:                                       ; preds = %cond.end494
  br i1 %tobool373, label %if.then500, label %if.end523

if.then500:                                       ; preds = %if.then498
  %149 = bitcast %struct.sv** %add.ptr480 to i8*
  %150 = bitcast %struct.sv** %tmparyval.1 to i8*
  %conv501 = sext i32 %length.1 to i64
  %mul502 = shl nsw i64 %conv501, 3
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %149, i8* %150, i64 %mul502, i32 1, i1 false)
  %151 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_flags504 = getelementptr inbounds %struct.xpvav* %151, i64 0, i32 9
  %152 = load i8* %xav_flags504, align 1, !tbaa !1
  %and506 = and i8 %152, 1
  %tobool507 = icmp eq i8 %and506, 0
  br i1 %tobool507, label %if.end522, label %if.then508

if.then508:                                       ; preds = %if.then500
  %153 = load i32* @PL_tmps_ix, align 4, !tbaa !4
  %add509 = add nsw i32 %153, %length.1
  %154 = load i32* @PL_tmps_max, align 4, !tbaa !4
  %cmp510 = icmp slt i32 %add509, %154
  br i1 %cmp510, label %for.body516, label %if.then512

if.then512:                                       ; preds = %if.then508
  tail call void @Perl_tmps_grow(i32 %length.1) #7
  br label %for.body516

for.body516:                                      ; preds = %if.then508, %if.then512, %for.body516
  %dst.6788 = phi %struct.sv** [ %incdec.ptr518, %for.body516 ], [ %add.ptr480, %if.then512 ], [ %add.ptr480, %if.then508 ]
  %i.6787 = phi i32 [ %dec520, %for.body516 ], [ %length.1, %if.then512 ], [ %length.1, %if.then508 ]
  %155 = load %struct.sv** %dst.6788, align 8, !tbaa !0
  %call517 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %155) #7
  %incdec.ptr518 = getelementptr inbounds %struct.sv** %dst.6788, i64 1
  %dec520 = add nsw i32 %i.6787, -1
  %tobool515 = icmp eq i32 %dec520, 0
  br i1 %tobool515, label %if.end522, label %for.body516

if.end522:                                        ; preds = %for.body516, %if.then500
  tail call void @Perl_safesysfree(i8* %150) #7
  br label %if.end523

if.end523:                                        ; preds = %if.end522, %if.then498
  %sub524 = add nsw i32 %length.1, -1
  %idx.ext525 = sext i32 %sub524 to i64
  %add.ptr480.sum = add i64 %idx.ext525, %add.ptr479.sum
  %add.ptr526 = getelementptr inbounds %struct.sv** %146, i64 %add.ptr480.sum
  br label %if.end552

if.else527:                                       ; preds = %cond.end494
  %dec528 = add nsw i32 %length.1, -1
  br i1 %tobool373, label %if.then530, label %if.else549

if.then530:                                       ; preds = %if.else527
  %idxprom531 = sext i32 %dec528 to i64
  %arrayidx532 = getelementptr inbounds %struct.sv** %tmparyval.1, i64 %idxprom531
  %156 = load %struct.sv** %arrayidx532, align 8, !tbaa !0
  store %struct.sv* %156, %struct.sv** %add.ptr480, align 8, !tbaa !0
  %157 = load %struct.xpvav** %sv_any120, align 8, !tbaa !0
  %xav_flags534 = getelementptr inbounds %struct.xpvav* %157, i64 0, i32 9
  %158 = load i8* %xav_flags534, align 1, !tbaa !1
  %and536 = and i8 %158, 1
  %tobool537 = icmp eq i8 %and536, 0
  br i1 %tobool537, label %if.end548, label %if.then538

if.then538:                                       ; preds = %if.then530
  %call539 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %156) #7
  %cmp542790 = icmp sgt i32 %dec528, 0
  br i1 %cmp542790, label %while.body544.lr.ph, label %if.end548

while.body544.lr.ph:                              ; preds = %if.then538
  %dec541789 = add nsw i32 %length.1, -2
  %159 = sext i32 %dec541789 to i64
  br label %while.body544

while.body544:                                    ; preds = %while.body544.lr.ph, %while.body544
  %indvars.iv799 = phi i64 [ %159, %while.body544.lr.ph ], [ %indvars.iv.next800, %while.body544 ]
  %arrayidx546 = getelementptr inbounds %struct.sv** %tmparyval.1, i64 %indvars.iv799
  %160 = load %struct.sv** %arrayidx546, align 8, !tbaa !0
  tail call void @Perl_sv_free(%struct.sv* %160) #7
  %161 = trunc i64 %indvars.iv799 to i32
  %cmp542 = icmp sgt i32 %161, 0
  %indvars.iv.next800 = add i64 %indvars.iv799, -1
  br i1 %cmp542, label %while.body544, label %if.end548

if.end548:                                        ; preds = %if.then538, %while.body544, %if.then530
  %162 = bitcast %struct.sv** %tmparyval.1 to i8*
  tail call void @Perl_safesysfree(i8* %162) #7
  br label %if.end552

if.else549:                                       ; preds = %if.else527
  store %struct.sv* @PL_sv_undef, %struct.sv** %add.ptr480, align 8, !tbaa !0
  br label %if.end552

if.end552:                                        ; preds = %while.end, %if.end523, %if.else549, %if.end548, %if.then364
  %mark.3 = phi %struct.sv** [ %mark.2, %if.then364 ], [ %add.ptr526, %if.end523 ], [ %add.ptr480, %if.end548 ], [ %add.ptr480, %if.else549 ], [ %mark.2, %while.end ]
  store %struct.sv** %mark.3, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %163 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next553 = getelementptr inbounds %struct.op* %163, i64 0, i32 0
  %164 = load %struct.op** %op_next553, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end552, %if.then73, %cond.end45
  %retval.0 = phi %struct.op* [ %15, %cond.end45 ], [ %call74, %if.then73 ], [ %164, %if.end552 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_markstack_grow() #1

; Function Attrs: optsize
declare void @Perl_push_scope() #1

; Function Attrs: optsize
declare i32 @Perl_call_method(i8*, i32) #1

; Function Attrs: optsize
declare void @Perl_pop_scope() #1

; Function Attrs: optsize
declare void @Perl_av_reify(%struct.av*) #1

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) #3

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_push() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %5 = load i64* %op_targ, align 8, !tbaa !3
  %6 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %6, i64 %5
  %7 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %add.ptr.sum = add i64 %idx.ext, 1
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %8 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %9 = bitcast %struct.sv* %8 to %struct.av*
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %10 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %10, 32768
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %cond.end

cond.end:                                         ; preds = %entry
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %8, i32 80) #7
  %tobool2 = icmp eq %struct.magic* %call, null
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %cond.end
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %11 = load %struct.sv** %mg_obj, align 8, !tbaa !0
  %tobool3 = icmp eq %struct.sv* %11, null
  br i1 %tobool3, label %cond.false6, label %cond.end9

cond.false6:                                      ; preds = %if.then
  %call7 = tail call %struct.sv* @Perl_newRV(%struct.sv* %8) #7
  %call8 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7) #7
  br label %cond.end9

cond.end9:                                        ; preds = %if.then, %cond.false6
  %cond10 = phi %struct.sv* [ %call8, %cond.false6 ], [ %11, %if.then ]
  store %struct.sv* %cond10, %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %12 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr12 = getelementptr inbounds i32* %12, i64 1
  store i32* %incdec.ptr12, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %13 = load i32** @PL_markstack_max, align 8, !tbaa !0
  %cmp = icmp eq i32* %incdec.ptr12, %13
  br i1 %cmp, label %if.then14, label %if.end

if.then14:                                        ; preds = %cond.end9
  tail call void @Perl_markstack_grow() #7
  %.pre = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then14, %cond.end9
  %14 = phi i32* [ %.pre, %if.then14 ], [ %incdec.ptr12, %cond.end9 ]
  %15 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.rhs.cast16 = ptrtoint %struct.sv** %15 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast16
  %sub.ptr.div1871 = lshr exact i64 %sub.ptr.sub17, 3
  %conv19 = trunc i64 %sub.ptr.div1871 to i32
  store i32 %conv19, i32* %14, align 4, !tbaa !4
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  tail call void @Perl_push_scope() #7
  %call20 = tail call i32 @Perl_call_method(i8* getelementptr inbounds ([5 x i8]* @.str45, i64 0, i64 0), i32 2) #7
  tail call void @Perl_pop_scope() #7
  br label %if.end29

if.else:                                          ; preds = %entry, %cond.end
  %incdec.ptr1.sum = add i64 %idx.ext, 2
  %incdec.ptr21 = getelementptr inbounds %struct.sv** %1, i64 %incdec.ptr1.sum
  %cmp2273 = icmp ugt %struct.sv** %incdec.ptr21, %0
  br i1 %cmp2273, label %if.end29, label %for.body

for.body:                                         ; preds = %if.else, %if.end27
  %mark.074 = phi %struct.sv** [ %incdec.ptr28, %if.end27 ], [ %incdec.ptr21, %if.else ]
  %call24 = tail call %struct.sv* @Perl_newSV(i64 0) #7
  %16 = load %struct.sv** %mark.074, align 8, !tbaa !0
  %tobool25 = icmp eq %struct.sv* %16, null
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %for.body
  tail call void @Perl_sv_setsv_flags(%struct.sv* %call24, %struct.sv* %16, i32 2) #7
  br label %if.end27

if.end27:                                         ; preds = %for.body, %if.then26
  tail call void @Perl_av_push(%struct.av* %9, %struct.sv* %call24) #7
  %incdec.ptr28 = getelementptr inbounds %struct.sv** %mark.074, i64 1
  %cmp22 = icmp ugt %struct.sv** %incdec.ptr28, %0
  br i1 %cmp22, label %if.end29, label %for.body

if.end29:                                         ; preds = %if.else, %if.end27, %if.end
  %17 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %18 = load i32* %sv_flags, align 4, !tbaa !4
  %and33 = and i32 %18, 32768
  %tobool34 = icmp eq i32 %and33, 0
  br i1 %tobool34, label %cond.false38, label %cond.true35

cond.true35:                                      ; preds = %if.end29
  %call36 = tail call i32 @Perl_mg_size(%struct.sv* %8) #7
  %conv37 = sext i32 %call36 to i64
  br label %cond.end39

cond.false38:                                     ; preds = %if.end29
  %sv_any = bitcast %struct.sv* %8 to %struct.xpvav**
  %19 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_fill = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 1
  %20 = load i64* %xav_fill, align 8, !tbaa !3
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true35
  %cond40 = phi i64 [ %conv37, %cond.true35 ], [ %20, %cond.false38 ]
  %add = add nsw i64 %cond40, 1
  tail call void @Perl_sv_setiv(%struct.sv* %7, i64 %add) #7
  %sv_flags41 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %21 = load i32* %sv_flags41, align 4, !tbaa !4
  %and42 = and i32 %21, 16384
  %tobool43 = icmp eq i32 %and42, 0
  br i1 %tobool43, label %if.end46, label %if.then44

if.then44:                                        ; preds = %cond.end39
  %call45 = tail call i32 @Perl_mg_set(%struct.sv* %7) #7
  br label %if.end46

if.end46:                                         ; preds = %cond.end39, %if.then44
  %add.ptr31.sum = add i64 %idx.ext, 1
  %incdec.ptr47 = getelementptr inbounds %struct.sv** %17, i64 %add.ptr31.sum
  store %struct.sv* %7, %struct.sv** %incdec.ptr47, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr47, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %22 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %22, i64 0, i32 0
  %23 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %23
}

; Function Attrs: optsize
declare void @Perl_av_push(%struct.av*, %struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_pop() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %2 = bitcast %struct.sv* %1 to %struct.av*
  %call = tail call %struct.sv* @Perl_av_pop(%struct.av* %2) #7
  %sv_any = bitcast %struct.sv* %1 to %struct.xpvav**
  %3 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_flags = getelementptr inbounds %struct.xpvav* %3, i64 0, i32 9
  %4 = load i8* %xav_flags, align 1, !tbaa !1
  %and = and i8 %4, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  store %struct.sv* %call, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %5 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %5, i64 0, i32 0
  %6 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %6
}

; Function Attrs: optsize
declare %struct.sv* @Perl_av_pop(%struct.av*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_shift() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %2 = bitcast %struct.sv* %1 to %struct.av*
  %call = tail call %struct.sv* @Perl_av_shift(%struct.av* %2) #7
  %3 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %incdec.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp slt i64 %sub.ptr.sub, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %incdec.ptr, %struct.sv** %incdec.ptr, i32 1) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sp.0 = phi %struct.sv** [ %call1, %if.then ], [ %incdec.ptr, %entry ]
  %tobool = icmp eq %struct.sv* %call, null
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %incdec.ptr3 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr3, align 8, !tbaa !0
  br label %return

if.end4:                                          ; preds = %if.end
  %sv_any = bitcast %struct.sv* %1 to %struct.xpvav**
  %4 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_flags = getelementptr inbounds %struct.xpvav* %4, i64 0, i32 9
  %5 = load i8* %xav_flags, align 1, !tbaa !1
  %and = and i8 %5, 1
  %tobool5 = icmp eq i8 %and, 0
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  %call7 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #7
  br label %if.end8

if.end8:                                          ; preds = %if.end4, %if.then6
  %incdec.ptr9 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call, %struct.sv** %incdec.ptr9, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end8, %if.then2
  %storemerge = phi %struct.sv** [ %incdec.ptr9, %if.end8 ], [ %incdec.ptr3, %if.then2 ]
  store %struct.sv** %storemerge, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %.pn = load %struct.op** @PL_op, align 8
  %retval.0.in = getelementptr inbounds %struct.op* %.pn, i64 0, i32 0
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_av_shift(%struct.av*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_unshift() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %5 = load i64* %op_targ, align 8, !tbaa !3
  %6 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %6, i64 %5
  %7 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %add.ptr.sum = add i64 %idx.ext, 1
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %8 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %9 = bitcast %struct.sv* %8 to %struct.av*
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %10 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %10, 32768
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %cond.end

cond.end:                                         ; preds = %entry
  %call = tail call %struct.magic* @Perl_mg_find(%struct.sv* %8, i32 80) #7
  %tobool2 = icmp eq %struct.magic* %call, null
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %cond.end
  %mg_obj = getelementptr inbounds %struct.magic* %call, i64 0, i32 5
  %11 = load %struct.sv** %mg_obj, align 8, !tbaa !0
  %tobool3 = icmp eq %struct.sv* %11, null
  br i1 %tobool3, label %cond.false6, label %cond.end9

cond.false6:                                      ; preds = %if.then
  %call7 = tail call %struct.sv* @Perl_newRV(%struct.sv* %8) #7
  %call8 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7) #7
  br label %cond.end9

cond.end9:                                        ; preds = %if.then, %cond.false6
  %cond10 = phi %struct.sv* [ %call8, %cond.false6 ], [ %11, %if.then ]
  store %struct.sv* %cond10, %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %12 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr12 = getelementptr inbounds i32* %12, i64 1
  store i32* %incdec.ptr12, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %13 = load i32** @PL_markstack_max, align 8, !tbaa !0
  %cmp = icmp eq i32* %incdec.ptr12, %13
  br i1 %cmp, label %if.then14, label %if.end

if.then14:                                        ; preds = %cond.end9
  tail call void @Perl_markstack_grow() #7
  %.pre = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then14, %cond.end9
  %14 = phi i32* [ %.pre, %if.then14 ], [ %incdec.ptr12, %cond.end9 ]
  %15 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.rhs.cast16 = ptrtoint %struct.sv** %15 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast16
  %sub.ptr.div1872 = lshr exact i64 %sub.ptr.sub17, 3
  %conv19 = trunc i64 %sub.ptr.div1872 to i32
  store i32 %conv19, i32* %14, align 4, !tbaa !4
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  tail call void @Perl_push_scope() #7
  %call20 = tail call i32 @Perl_call_method(i8* getelementptr inbounds ([8 x i8]* @.str46, i64 0, i64 0), i32 2) #7
  tail call void @Perl_pop_scope() #7
  br label %if.end31

if.else:                                          ; preds = %entry, %cond.end
  %sub.ptr.lhs.cast21 = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast22 = ptrtoint %struct.sv** %incdec.ptr1 to i64
  %sub.ptr.sub23 = sub i64 %sub.ptr.lhs.cast21, %sub.ptr.rhs.cast22
  %sub.ptr.div2471 = lshr exact i64 %sub.ptr.sub23, 3
  %conv25 = trunc i64 %sub.ptr.div2471 to i32
  tail call void @Perl_av_unshift(%struct.av* %9, i32 %conv25) #7
  %cmp2674 = icmp ult %struct.sv** %incdec.ptr1, %0
  br i1 %cmp2674, label %while.body, label %if.end31

while.body:                                       ; preds = %if.else, %while.body
  %i.076 = phi i32 [ %inc, %while.body ], [ 0, %if.else ]
  %mark.075 = phi %struct.sv** [ %incdec.ptr28, %while.body ], [ %incdec.ptr1, %if.else ]
  %incdec.ptr28 = getelementptr inbounds %struct.sv** %mark.075, i64 1
  %16 = load %struct.sv** %incdec.ptr28, align 8, !tbaa !0
  %call29 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %16) #7
  %inc = add nsw i32 %i.076, 1
  %call30 = tail call %struct.sv** @Perl_av_store(%struct.av* %9, i32 %i.076, %struct.sv* %call29) #7
  %cmp26 = icmp ult %struct.sv** %incdec.ptr28, %0
  br i1 %cmp26, label %while.body, label %if.end31

if.end31:                                         ; preds = %if.else, %while.body, %if.end
  %17 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %18 = load i32* %sv_flags, align 4, !tbaa !4
  %and35 = and i32 %18, 32768
  %tobool36 = icmp eq i32 %and35, 0
  br i1 %tobool36, label %cond.false40, label %cond.true37

cond.true37:                                      ; preds = %if.end31
  %call38 = tail call i32 @Perl_mg_size(%struct.sv* %8) #7
  %conv39 = sext i32 %call38 to i64
  br label %cond.end41

cond.false40:                                     ; preds = %if.end31
  %sv_any = bitcast %struct.sv* %8 to %struct.xpvav**
  %19 = load %struct.xpvav** %sv_any, align 8, !tbaa !0
  %xav_fill = getelementptr inbounds %struct.xpvav* %19, i64 0, i32 1
  %20 = load i64* %xav_fill, align 8, !tbaa !3
  br label %cond.end41

cond.end41:                                       ; preds = %cond.false40, %cond.true37
  %cond42 = phi i64 [ %conv39, %cond.true37 ], [ %20, %cond.false40 ]
  %add = add nsw i64 %cond42, 1
  tail call void @Perl_sv_setiv(%struct.sv* %7, i64 %add) #7
  %sv_flags43 = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %21 = load i32* %sv_flags43, align 4, !tbaa !4
  %and44 = and i32 %21, 16384
  %tobool45 = icmp eq i32 %and44, 0
  br i1 %tobool45, label %if.end48, label %if.then46

if.then46:                                        ; preds = %cond.end41
  %call47 = tail call i32 @Perl_mg_set(%struct.sv* %7) #7
  br label %if.end48

if.end48:                                         ; preds = %cond.end41, %if.then46
  %add.ptr33.sum = add i64 %idx.ext, 1
  %incdec.ptr49 = getelementptr inbounds %struct.sv** %17, i64 %add.ptr33.sum
  store %struct.sv* %7, %struct.sv** %incdec.ptr49, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr49, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %22 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %22, i64 0, i32 0
  %23 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %23
}

; Function Attrs: optsize
declare void @Perl_av_unshift(%struct.av*, i32) #1

; Function Attrs: optsize
declare %struct.sv** @Perl_av_store(%struct.av*, i32, %struct.sv*) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_reverse() #0 {
entry:
  %len = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %3 = load i32* %2, align 4, !tbaa !4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %1, i64 %idx.ext
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %cmp = icmp eq i32 %and, 3
  %cond = zext i1 %cmp to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i32 @Perl_dowantarray() #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond6 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp7 = icmp eq i32 %cond6, 1
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %add.ptr.sum162 = add i64 %idx.ext, 1
  %incdec.ptr9 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum162
  %cmp10163 = icmp ult %struct.sv** %incdec.ptr9, %0
  br i1 %cmp10163, label %while.body, label %if.end114

while.body:                                       ; preds = %if.then, %while.body
  %sp.0165 = phi %struct.sv** [ %incdec.ptr13, %while.body ], [ %0, %if.then ]
  %mark.0164 = phi %struct.sv** [ %incdec.ptr12, %while.body ], [ %incdec.ptr9, %if.then ]
  %6 = load %struct.sv** %mark.0164, align 8, !tbaa !0
  %7 = load %struct.sv** %sp.0165, align 8, !tbaa !0
  %incdec.ptr12 = getelementptr inbounds %struct.sv** %mark.0164, i64 1
  store %struct.sv* %7, %struct.sv** %mark.0164, align 8, !tbaa !0
  %incdec.ptr13 = getelementptr inbounds %struct.sv** %sp.0165, i64 -1
  store %struct.sv* %6, %struct.sv** %sp.0165, align 8, !tbaa !0
  %cmp10 = icmp ult %struct.sv** %incdec.ptr12, %incdec.ptr13
  br i1 %cmp10, label %while.body, label %if.end114

if.else:                                          ; preds = %cond.end
  %8 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %8, i64 0, i32 3
  %9 = load i64* %op_targ, align 8, !tbaa !3
  %10 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %10, i64 %9
  %11 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %12 = load i32* %sv_flags, align 4, !tbaa !4
  %and20 = and i32 %12, -536870913
  store i32 %and20, i32* %sv_flags, align 4, !tbaa !4
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %add.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp21 = icmp sgt i64 %sub.ptr.sub, 8
  br i1 %cmp21, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.else
  call void @Perl_do_join(%struct.sv* %11, %struct.sv* @PL_sv_no, %struct.sv** %add.ptr, %struct.sv** %0) #7
  br label %if.end

if.else24:                                        ; preds = %if.else
  %cmp25 = icmp ugt %struct.sv** %0, %add.ptr
  br i1 %cmp25, label %cond.end29, label %cond.false28

cond.false28:                                     ; preds = %if.else24
  %13 = load %struct.gv** @PL_defgv, align 8, !tbaa !0
  %sv_any = getelementptr inbounds %struct.gv* %13, i64 0, i32 0
  %14 = load %struct.xpvgv** %sv_any, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %14, i64 0, i32 7
  %15 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_sv = getelementptr inbounds %struct.gp* %15, i64 0, i32 0
  br label %cond.end29

cond.end29:                                       ; preds = %if.else24, %cond.false28
  %cond30.in = phi %struct.sv** [ %gp_sv, %cond.false28 ], [ %0, %if.else24 ]
  %cond30 = load %struct.sv** %cond30.in, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %11, %struct.sv* %cond30, i32 2) #7
  br label %if.end

if.end:                                           ; preds = %cond.end29, %if.then23
  %16 = load i32* %sv_flags, align 4, !tbaa !4
  %and32 = and i32 %16, 10223616
  %cmp33 = icmp eq i32 %and32, 262144
  br i1 %cmp33, label %cond.true35, label %cond.false38

cond.true35:                                      ; preds = %if.end
  %sv_any36 = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %17 = load i8** %sv_any36, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %17, i64 8
  %18 = bitcast i8* %xpv_cur to i64*
  %19 = load i64* %18, align 8, !tbaa !3
  store i64 %19, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %17 to i8**
  %20 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end40

cond.false38:                                     ; preds = %if.end
  %call39 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %11, i64* %len, i32 2) #7
  %.pr = load i64* %len, align 8, !tbaa !3
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false38, %cond.true35
  %21 = phi i64 [ %.pr, %cond.false38 ], [ %19, %cond.true35 ]
  %cond41 = phi i8* [ %call39, %cond.false38 ], [ %20, %cond.true35 ]
  %cmp42 = icmp ugt i64 %21, 1
  %22 = load i32* %sv_flags, align 4, !tbaa !4
  br i1 %cmp42, label %if.then44, label %if.end106

if.then44:                                        ; preds = %cond.end40
  %and46 = and i32 %22, 536870912
  %tobool47 = icmp eq i32 %and46, 0
  br i1 %tobool47, label %if.end89, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then44
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %23, i64 0, i32 7
  %24 = load i8* %op_private, align 1, !tbaa !1
  %and49 = and i8 %24, 8
  %tobool50 = icmp eq i8 %and49, 0
  br i1 %tobool50, label %if.then51, label %if.end89

if.then51:                                        ; preds = %land.lhs.true
  %sv_any53 = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %25 = load i8** %sv_any53, align 8, !tbaa !0
  %xpv_pv54 = bitcast i8* %25 to i8**
  %26 = load i8** %xpv_pv54, align 8, !tbaa !0
  %add.ptr56 = getelementptr inbounds i8* %26, i64 %21
  %cmp58172 = icmp sgt i64 %21, 0
  br i1 %cmp58172, label %while.body60, label %while.end86

while.body60:                                     ; preds = %if.then51, %while.cond57.backedge
  %s.0173 = phi i8* [ %s.0.be, %while.cond57.backedge ], [ %26, %if.then51 ]
  %27 = load i8* %s.0173, align 1, !tbaa !1
  %cmp62 = icmp sgt i8 %27, -1
  br i1 %cmp62, label %if.then64, label %if.else66

if.then64:                                        ; preds = %while.body60
  %incdec.ptr65 = getelementptr inbounds i8* %s.0173, i64 1
  br label %while.cond57.backedge

while.cond57.backedge:                            ; preds = %if.end70, %while.body79, %if.then64
  %s.0.be = phi i8* [ %incdec.ptr65, %if.then64 ], [ %add.ptr74, %while.body79 ], [ %add.ptr74, %if.end70 ]
  %cmp58 = icmp ult i8* %s.0.be, %add.ptr56
  br i1 %cmp58, label %while.body60, label %while.end86

if.else66:                                        ; preds = %while.body60
  %call67 = call i64 @Perl_utf8_to_uvchr(i8* %s.0173, i64* null) #7
  %tobool68 = icmp eq i64 %call67, 0
  br i1 %tobool68, label %while.end86, label %if.end70

if.end70:                                         ; preds = %if.else66
  %28 = load i8* %s.0173, align 1, !tbaa !1
  %idxprom = zext i8 %28 to i64
  %arrayidx71 = getelementptr inbounds [0 x i8]* @PL_utf8skip, i64 0, i64 %idxprom
  %29 = load i8* %arrayidx71, align 1, !tbaa !1
  %idx.ext73 = zext i8 %29 to i64
  %add.ptr74 = getelementptr inbounds i8* %s.0173, i64 %idx.ext73
  %add.ptr74.sum = add i64 %idx.ext73, -1
  %cmp77169 = icmp sgt i64 %add.ptr74.sum, 0
  br i1 %cmp77169, label %while.body79.lr.ph, label %while.cond57.backedge

while.body79.lr.ph:                               ; preds = %if.end70
  %add.ptr75 = getelementptr inbounds i8* %s.0173, i64 %add.ptr74.sum
  br label %while.body79

while.body79:                                     ; preds = %while.body79.while.body79_crit_edge, %while.body79.lr.ph
  %30 = phi i8 [ %28, %while.body79.lr.ph ], [ %.pre, %while.body79.while.body79_crit_edge ]
  %down.0171 = phi i8* [ %add.ptr75, %while.body79.lr.ph ], [ %incdec.ptr83, %while.body79.while.body79_crit_edge ]
  %up.0170 = phi i8* [ %s.0173, %while.body79.lr.ph ], [ %incdec.ptr81, %while.body79.while.body79_crit_edge ]
  %31 = load i8* %down.0171, align 1, !tbaa !1
  %incdec.ptr81 = getelementptr inbounds i8* %up.0170, i64 1
  store i8 %31, i8* %up.0170, align 1, !tbaa !1
  %incdec.ptr83 = getelementptr inbounds i8* %down.0171, i64 -1
  store i8 %30, i8* %down.0171, align 1, !tbaa !1
  %cmp77 = icmp ugt i8* %incdec.ptr83, %incdec.ptr81
  br i1 %cmp77, label %while.body79.while.body79_crit_edge, label %while.cond57.backedge

while.body79.while.body79_crit_edge:              ; preds = %while.body79
  %.pre = load i8* %incdec.ptr81, align 1, !tbaa !1
  br label %while.body79

while.end86:                                      ; preds = %while.cond57.backedge, %if.else66, %if.then51
  %32 = load i8** %sv_any53, align 8, !tbaa !0
  %xpv_pv88 = bitcast i8* %32 to i8**
  %33 = load i8** %xpv_pv88, align 8, !tbaa !0
  br label %if.end89

if.end89:                                         ; preds = %land.lhs.true, %if.then44, %while.end86
  %up.1 = phi i8* [ %33, %while.end86 ], [ %cond41, %if.then44 ], [ %cond41, %land.lhs.true ]
  %sv_any90 = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %34 = load i8** %sv_any90, align 8, !tbaa !0
  %xpv_pv91 = bitcast i8* %34 to i8**
  %35 = load i8** %xpv_pv91, align 8, !tbaa !0
  %36 = load i64* %len, align 8, !tbaa !3
  %add.ptr92.sum = add i64 %36, -1
  %add.ptr93 = getelementptr inbounds i8* %35, i64 %add.ptr92.sum
  %cmp95166 = icmp ugt i8* %add.ptr93, %up.1
  br i1 %cmp95166, label %while.body97, label %while.end102

while.body97:                                     ; preds = %if.end89, %while.body97
  %down.1168 = phi i8* [ %incdec.ptr101, %while.body97 ], [ %add.ptr93, %if.end89 ]
  %up.2167 = phi i8* [ %incdec.ptr99, %while.body97 ], [ %up.1, %if.end89 ]
  %37 = load i8* %up.2167, align 1, !tbaa !1
  %38 = load i8* %down.1168, align 1, !tbaa !1
  %incdec.ptr99 = getelementptr inbounds i8* %up.2167, i64 1
  store i8 %38, i8* %up.2167, align 1, !tbaa !1
  %incdec.ptr101 = getelementptr inbounds i8* %down.1168, i64 -1
  store i8 %37, i8* %down.1168, align 1, !tbaa !1
  %cmp95 = icmp ugt i8* %incdec.ptr101, %incdec.ptr99
  br i1 %cmp95, label %while.body97, label %while.end102

while.end102:                                     ; preds = %while.body97, %if.end89
  %39 = load i32* %sv_flags, align 4, !tbaa !4
  %and104 = and i32 %39, 1760624639
  %or = or i32 %and104, 67371008
  store i32 %or, i32* %sv_flags, align 4, !tbaa !4
  br label %if.end106

if.end106:                                        ; preds = %cond.end40, %while.end102
  %40 = phi i32 [ %or, %while.end102 ], [ %22, %cond.end40 ]
  %add.ptr.sum = add i64 %idx.ext, 1
  %add.ptr107 = getelementptr inbounds %struct.sv** %1, i64 %add.ptr.sum
  %and109 = and i32 %40, 16384
  %tobool110 = icmp eq i32 %and109, 0
  br i1 %tobool110, label %if.end113, label %if.then111

if.then111:                                       ; preds = %if.end106
  %call112 = call i32 @Perl_mg_set(%struct.sv* %11) #7
  br label %if.end113

if.end113:                                        ; preds = %if.end106, %if.then111
  store %struct.sv* %11, %struct.sv** %add.ptr107, align 8, !tbaa !0
  br label %if.end114

if.end114:                                        ; preds = %if.then, %while.body, %if.end113
  %sp.1 = phi %struct.sv** [ %add.ptr107, %if.end113 ], [ %0, %while.body ], [ %0, %if.then ]
  store %struct.sv** %sp.1, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %41 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %41, i64 0, i32 0
  %42 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %42
}

; Function Attrs: optsize
declare void @Perl_do_join(%struct.sv*, %struct.sv*, %struct.sv**, %struct.sv**) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_split() #0 {
entry:
  %len = alloca i64, align 8
  %n_a = alloca i64, align 8
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %incdec.ptr = getelementptr inbounds %struct.sv** %0, i64 -1
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %2, 65536
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !0
  %xiv_iv = getelementptr inbounds i8* %3, i64 24
  %4 = bitcast i8* %xiv_iv to i64*
  %5 = load i64* %4, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @Perl_sv_2iv(%struct.sv* %1) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %call, %cond.false ]
  %incdec.ptr1 = getelementptr inbounds %struct.sv** %0, i64 -2
  %6 = load %struct.sv** %incdec.ptr, align 8, !tbaa !0
  %sv_flags2 = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags2, align 4, !tbaa !4
  %and3 = and i32 %7, 262144
  %cmp = icmp eq i32 %and3, 0
  br i1 %cmp, label %cond.false7, label %cond.true4

cond.true4:                                       ; preds = %cond.end
  %sv_any5 = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any5, align 8, !tbaa !0
  %xpv_cur = getelementptr inbounds i8* %8, i64 8
  %9 = bitcast i8* %xpv_cur to i64*
  %10 = load i64* %9, align 8, !tbaa !3
  store i64 %10, i64* %len, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %8 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !0
  br label %cond.end9

cond.false7:                                      ; preds = %cond.end
  %call8 = call i8* @Perl_sv_2pv_flags(%struct.sv* %6, i64* %len, i32 2) #7
  %.pre = load i32* %sv_flags2, align 4, !tbaa !4
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true4
  %12 = phi i32 [ %7, %cond.true4 ], [ %.pre, %cond.false7 ]
  %cond10 = phi i8* [ %11, %cond.true4 ], [ %call8, %cond.false7 ]
  %and12 = and i32 %12, 536870912
  %tobool13 = icmp eq i32 %and12, 0
  br i1 %tobool13, label %land.end.thread, label %land.end

land.end.thread:                                  ; preds = %cond.end9
  %13 = load i64* %len, align 8, !tbaa !3
  %add.ptr1241 = getelementptr inbounds i8* %cond10, i64 %13
  br label %cond.end22

land.end:                                         ; preds = %cond.end9
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private = getelementptr inbounds %struct.cop* %14, i64 0, i32 7
  %15 = load i8* %op_private, align 1, !tbaa !1
  %and14 = and i8 %15, 8
  %lnot = icmp eq i8 %and14, 0
  %16 = load i64* %len, align 8, !tbaa !3
  %add.ptr = getelementptr inbounds i8* %cond10, i64 %16
  br i1 %lnot, label %cond.true19, label %cond.end22

cond.true19:                                      ; preds = %land.end
  %call20 = call i64 @Perl_utf8_length(i8* %cond10, i8* %add.ptr) #7
  br label %cond.end22

cond.end22:                                       ; preds = %land.end.thread, %land.end, %cond.true19
  %add.ptr1242 = phi i8* [ %add.ptr, %cond.true19 ], [ %add.ptr, %land.end ], [ %add.ptr1241, %land.end.thread ]
  %17 = phi i1 [ true, %cond.true19 ], [ false, %land.end ], [ false, %land.end.thread ]
  %cond23 = phi i64 [ %call20, %cond.true19 ], [ %16, %land.end ], [ %13, %land.end.thread ]
  %add = add i64 %cond23, 10
  %conv24 = trunc i64 %add to i32
  %conv25 = trunc i64 %cond to i32
  %18 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %18, i64 0, i32 6
  %19 = load i8* %op_flags, align 1, !tbaa !1
  %conv26 = zext i8 %19 to i32
  %and27 = and i32 %conv26, 3
  %cmp28 = icmp eq i32 %and27, 1
  br i1 %cmp28, label %cond.end51, label %cond.false31

cond.false31:                                     ; preds = %cond.end22
  %cmp35 = icmp eq i32 %and27, 2
  br i1 %cmp35, label %cond.end51, label %cond.false38

cond.false38:                                     ; preds = %cond.false31
  %cmp42 = icmp eq i32 %and27, 3
  br i1 %cmp42, label %cond.end51, label %cond.false45

cond.false45:                                     ; preds = %cond.false38
  %call46 = call i32 @Perl_block_gimme() #7
  br label %cond.end51

cond.end51:                                       ; preds = %cond.false31, %cond.false38, %cond.false45, %cond.end22
  %cond52 = phi i32 [ 128, %cond.end22 ], [ 0, %cond.false31 ], [ %call46, %cond.false45 ], [ 1, %cond.false38 ]
  %20 = load i32* @PL_savestack_ix, align 4, !tbaa !4
  %incdec.ptr53 = getelementptr inbounds %struct.sv** %0, i64 -3
  %21 = load %struct.sv** %incdec.ptr1, align 8, !tbaa !0
  %tobool54 = icmp eq %struct.sv* %21, null
  %tobool55 = icmp eq i8* %cond10, null
  %or.cond = or i1 %tobool54, %tobool55
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end51
  %call56 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([16 x i8]* @.str47, i64 0, i64 0)) #7
  br label %return

if.end:                                           ; preds = %cond.end51
  %op_pmregexp = getelementptr inbounds %struct.sv* %21, i64 5
  %22 = bitcast %struct.sv* %op_pmregexp to %struct.regexp**
  %23 = load %struct.regexp** %22, align 8, !tbaa !0
  %24 = getelementptr inbounds %struct.sv* %21, i64 5, i32 1
  %25 = load i32* %24, align 4, !tbaa !4
  %and57 = and i32 %25, 2048
  %tobool58 = icmp eq i32 %and57, 0
  %and60 = and i32 %25, 48
  %tobool61 = icmp eq i32 %and60, 0
  %or.cond1231 = or i1 %tobool58, %tobool61
  br i1 %or.cond1231, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.end
  store i8 1, i8* @PL_tainted, align 1, !tbaa !1
  br label %if.end63

if.end63:                                         ; preds = %if.end, %if.then62
  %reganch = getelementptr inbounds %struct.regexp* %23, i64 0, i32 15
  %26 = load i32* %reganch, align 4, !tbaa !4
  %or = or i32 %26, 268435456
  %and69 = and i32 %26, -268435457
  %storemerge1230 = select i1 %17, i32 %or, i32 %and69
  %storemerge = zext i1 %17 to i8
  store i32 %storemerge1230, i32* %reganch, align 4, !tbaa !4
  store i8 %storemerge, i8* @PL_reg_match_utf8, align 1, !tbaa !1
  %op_pmreplroot = getelementptr inbounds %struct.sv* %21, i64 3, i32 1
  %27 = bitcast i32* %op_pmreplroot to %struct.op**
  %28 = load %struct.op** %27, align 8, !tbaa !0
  %tobool72 = icmp eq %struct.op* %28, null
  br i1 %tobool72, label %if.else, label %if.then73

if.then73:                                        ; preds = %if.end63
  %sv_any75 = bitcast %struct.op* %28 to %struct.xpvgv**
  %29 = load %struct.xpvgv** %sv_any75, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %29, i64 0, i32 7
  %30 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_av = getelementptr inbounds %struct.gp* %30, i64 0, i32 4
  %31 = load %struct.av** %gp_av, align 8, !tbaa !0
  %tobool76 = icmp eq %struct.av* %31, null
  br i1 %tobool76, label %cond.false82, label %land.lhs.true112

cond.false82:                                     ; preds = %if.then73
  %32 = bitcast %struct.op* %28 to %struct.gv*
  %call84 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %32) #7
  br label %if.end110

if.else:                                          ; preds = %if.end63
  %cmp90 = icmp eq i32 %cond52, 1
  br i1 %cmp90, label %if.end207, label %if.then92

if.then92:                                        ; preds = %if.else
  %33 = load %struct.gv** @PL_defgv, align 8, !tbaa !0
  %sv_any93 = getelementptr inbounds %struct.gv* %33, i64 0, i32 0
  %34 = load %struct.xpvgv** %sv_any93, align 8, !tbaa !0
  %xgv_gp94 = getelementptr inbounds %struct.xpvgv* %34, i64 0, i32 7
  %35 = load %struct.gp** %xgv_gp94, align 8, !tbaa !0
  %gp_av95 = getelementptr inbounds %struct.gp* %35, i64 0, i32 4
  %36 = load %struct.av** %gp_av95, align 8, !tbaa !0
  %tobool96 = icmp eq %struct.av* %36, null
  br i1 %tobool96, label %cond.false101, label %land.lhs.true112

cond.false101:                                    ; preds = %if.then92
  %call102 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %33) #7
  br label %if.end110

if.end110:                                        ; preds = %cond.false101, %cond.false82
  %call84.pn = phi %struct.gv* [ %call84, %cond.false82 ], [ %call102, %cond.false101 ]
  %.pn1252.in = getelementptr inbounds %struct.gv* %call84.pn, i64 0, i32 0
  %.pn1252 = load %struct.xpvgv** %.pn1252.in, align 8
  %.pn.in = getelementptr inbounds %struct.xpvgv* %.pn1252, i64 0, i32 7
  %.pn = load %struct.gp** %.pn.in, align 8
  %ary.0.in = getelementptr inbounds %struct.gp* %.pn, i64 0, i32 4
  %ary.0 = load %struct.av** %ary.0.in, align 8
  %tobool111 = icmp eq %struct.av* %ary.0, null
  br i1 %tobool111, label %if.end207, label %land.lhs.true112

land.lhs.true112:                                 ; preds = %if.then92, %if.then73, %if.end110
  %ary.01244 = phi %struct.av* [ %ary.0, %if.end110 ], [ %31, %if.then73 ], [ %36, %if.then92 ]
  %cmp113 = icmp eq i32 %cond52, 1
  br i1 %cmp113, label %lor.lhs.false115, label %if.then119

lor.lhs.false115:                                 ; preds = %land.lhs.true112
  %37 = load i32* %24, align 4, !tbaa !4
  %and117 = and i32 %37, 2
  %tobool118 = icmp eq i32 %and117, 0
  br i1 %tobool118, label %if.end207, label %if.then119

if.then119:                                       ; preds = %lor.lhs.false115, %land.lhs.true112
  store %struct.sv** %incdec.ptr53, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  call void @Perl_av_extend(%struct.av* %ary.01244, i32 0) #7
  call void @Perl_av_clear(%struct.av* %ary.01244) #7
  %38 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %39 = bitcast %struct.av* %ary.01244 to %struct.sv*
  %40 = getelementptr inbounds %struct.av* %ary.01244, i64 0, i32 2
  %41 = load i32* %40, align 4, !tbaa !4
  %and121 = and i32 %41, 32768
  %tobool122 = icmp eq i32 %and121, 0
  br i1 %tobool122, label %if.else157, label %cond.end126

cond.end126:                                      ; preds = %if.then119
  %call124 = call %struct.magic* @Perl_mg_find(%struct.sv* %39, i32 80) #7
  %tobool128 = icmp eq %struct.magic* %call124, null
  br i1 %tobool128, label %if.else157, label %if.then129

if.then129:                                       ; preds = %cond.end126
  %42 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  %incdec.ptr130 = getelementptr inbounds i32* %42, i64 1
  store i32* %incdec.ptr130, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %43 = load i32** @PL_markstack_max, align 8, !tbaa !0
  %cmp131 = icmp eq i32* %incdec.ptr130, %43
  br i1 %cmp131, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.then129
  call void @Perl_markstack_grow() #7
  %.pre1379 = load i32** @PL_markstack_ptr, align 8, !tbaa !0
  br label %if.end134

if.end134:                                        ; preds = %if.then133, %if.then129
  %44 = phi i32* [ %.pre1379, %if.then133 ], [ %incdec.ptr130, %if.then129 ]
  %45 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.lhs.cast135 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.rhs.cast136 = ptrtoint %struct.sv** %45 to i64
  %sub.ptr.sub137 = sub i64 %sub.ptr.lhs.cast135, %sub.ptr.rhs.cast136
  %sub.ptr.div1229 = lshr exact i64 %sub.ptr.sub137, 3
  %conv138 = trunc i64 %sub.ptr.div1229 to i32
  store i32 %conv138, i32* %44, align 4, !tbaa !4
  %46 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast139 = ptrtoint %struct.sv** %46 to i64
  %sub.ptr.sub141 = sub i64 %sub.ptr.lhs.cast139, %sub.ptr.lhs.cast135
  %cmp143 = icmp slt i64 %sub.ptr.sub141, 8
  br i1 %cmp143, label %if.then145, label %if.end147

if.then145:                                       ; preds = %if.end134
  %call146 = call %struct.sv** @Perl_stack_grow(%struct.sv** %38, %struct.sv** %38, i32 1) #7
  br label %if.end147

if.end147:                                        ; preds = %if.then145, %if.end134
  %sp.0 = phi %struct.sv** [ %call146, %if.then145 ], [ %38, %if.end134 ]
  %mg_obj = getelementptr inbounds %struct.magic* %call124, i64 0, i32 5
  %47 = load %struct.sv** %mg_obj, align 8, !tbaa !0
  %tobool148 = icmp eq %struct.sv* %47, null
  br i1 %tobool148, label %cond.false151, label %cond.end154

cond.false151:                                    ; preds = %if.end147
  %call152 = call %struct.sv* @Perl_newRV(%struct.sv* %39) #7
  %call153 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call152) #7
  br label %cond.end154

cond.end154:                                      ; preds = %if.end147, %cond.false151
  %cond155 = phi %struct.sv* [ %call153, %cond.false151 ], [ %47, %if.end147 ]
  %incdec.ptr156 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %cond155, %struct.sv** %incdec.ptr156, align 8, !tbaa !0
  br label %if.end207

if.else157:                                       ; preds = %if.then119, %cond.end126
  %sv_any158 = getelementptr inbounds %struct.av* %ary.01244, i64 0, i32 0
  %48 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  %xav_flags = getelementptr inbounds %struct.xpvav* %48, i64 0, i32 9
  %49 = load i8* %xav_flags, align 1, !tbaa !1
  %and160 = and i8 %49, 1
  %tobool161 = icmp eq i8 %and160, 0
  br i1 %tobool161, label %if.then162, label %if.end178

if.then162:                                       ; preds = %if.else157
  %or166 = or i8 %49, 1
  store i8 %or166, i8* %xav_flags, align 1, !tbaa !1
  %50 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  %xav_flags169 = getelementptr inbounds %struct.xpvav* %50, i64 0, i32 9
  %51 = load i8* %xav_flags169, align 1, !tbaa !1
  %and171 = and i8 %51, -3
  store i8 %and171, i8* %xav_flags169, align 1, !tbaa !1
  %52 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  %xav_fill = getelementptr inbounds %struct.xpvav* %52, i64 0, i32 1
  %53 = load i64* %xav_fill, align 8, !tbaa !3
  %conv174 = trunc i64 %53 to i32
  %cmp1751339 = icmp sgt i32 %conv174, -1
  br i1 %cmp1751339, label %for.body.lr.ph, label %if.end178

for.body.lr.ph:                                   ; preds = %if.then162
  %sext1382 = shl i64 %53, 32
  %54 = ashr exact i64 %sext1382, 32
  br label %for.body

for.body:                                         ; preds = %for.body.for.body_crit_edge, %for.body.lr.ph
  %55 = phi %struct.xpvav* [ %52, %for.body.lr.ph ], [ %.pre1381, %for.body.for.body_crit_edge ]
  %indvars.iv1373 = phi i64 [ %54, %for.body.lr.ph ], [ %indvars.iv.next1374, %for.body.for.body_crit_edge ]
  %xav_array = getelementptr inbounds %struct.xpvav* %55, i64 0, i32 0
  %56 = load i8** %xav_array, align 8, !tbaa !0
  %57 = bitcast i8* %56 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv** %57, i64 %indvars.iv1373
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8, !tbaa !0
  %58 = trunc i64 %indvars.iv1373 to i32
  %cmp175 = icmp sgt i32 %58, 0
  br i1 %cmp175, label %for.body.for.body_crit_edge, label %if.end178

for.body.for.body_crit_edge:                      ; preds = %for.body
  %indvars.iv.next1374 = add i64 %indvars.iv1373, -1
  %.pre1381 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  br label %for.body

if.end178:                                        ; preds = %if.then162, %for.body, %if.else157
  %59 = load i32* @PL_savestack_ix, align 4, !tbaa !4
  %add179 = add nsw i32 %59, 3
  %60 = load i32* @PL_savestack_max, align 4, !tbaa !4
  %cmp180 = icmp sgt i32 %add179, %60
  br i1 %cmp180, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.end178
  call void @Perl_savestack_grow() #7
  %.pre1378 = load i32* @PL_savestack_ix, align 4, !tbaa !4
  br label %if.end183

if.end183:                                        ; preds = %if.then182, %if.end178
  %61 = phi i32 [ %.pre1378, %if.then182 ], [ %59, %if.end178 ]
  %62 = load %struct.av** @PL_curstack, align 8, !tbaa !0
  %63 = bitcast %struct.av* %62 to i8*
  %inc = add nsw i32 %61, 1
  %idxprom184 = sext i32 %61 to i64
  %64 = load %union.any** @PL_savestack, align 8, !tbaa !0
  %any_ptr = getelementptr inbounds %union.any* %64, i64 %idxprom184, i32 0
  store i8* %63, i8** %any_ptr, align 8, !tbaa !0
  %65 = bitcast %struct.av* %ary.01244 to i8*
  %inc186 = add nsw i32 %61, 2
  %idxprom187 = sext i32 %inc to i64
  %66 = load %union.any** @PL_savestack, align 8, !tbaa !0
  %any_ptr189 = getelementptr inbounds %union.any* %66, i64 %idxprom187, i32 0
  store i8* %65, i8** %any_ptr189, align 8, !tbaa !0
  %inc190 = add nsw i32 %61, 3
  store i32 %inc190, i32* @PL_savestack_ix, align 4, !tbaa !4
  %idxprom191 = sext i32 %inc186 to i64
  %67 = load %union.any** @PL_savestack, align 8, !tbaa !0
  %arrayidx192 = getelementptr inbounds %union.any* %67, i64 %idxprom191
  %any_i32 = bitcast %union.any* %arrayidx192 to i32*
  store i32 40, i32* %any_i32, align 4, !tbaa !4
  %68 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.lhs.cast193 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.rhs.cast194 = ptrtoint %struct.sv** %68 to i64
  %sub.ptr.sub195 = sub i64 %sub.ptr.lhs.cast193, %sub.ptr.rhs.cast194
  %sub.ptr.div196 = ashr exact i64 %sub.ptr.sub195, 3
  %69 = load %struct.av** @PL_curstack, align 8, !tbaa !0
  %sv_any197 = getelementptr inbounds %struct.av* %69, i64 0, i32 0
  %70 = load %struct.xpvav** %sv_any197, align 8, !tbaa !0
  %xav_fill198 = getelementptr inbounds %struct.xpvav* %70, i64 0, i32 1
  store i64 %sub.ptr.div196, i64* %xav_fill198, align 8, !tbaa !3
  %71 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  %xav_array200 = getelementptr inbounds %struct.xpvav* %71, i64 0, i32 0
  %72 = load i8** %xav_array200, align 8, !tbaa !0
  %73 = bitcast i8* %72 to %struct.sv**
  store %struct.sv** %73, %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %74 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  %xav_max = getelementptr inbounds %struct.xpvav* %74, i64 0, i32 2
  %75 = load i64* %xav_max, align 8, !tbaa !3
  %add.ptr202 = getelementptr inbounds %struct.sv** %73, i64 %75
  store %struct.sv** %add.ptr202, %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %76 = load %struct.xpvav** %sv_any158, align 8, !tbaa !0
  %xav_fill204 = getelementptr inbounds %struct.xpvav* %76, i64 0, i32 1
  %77 = load i64* %xav_fill204, align 8, !tbaa !3
  %add.ptr205 = getelementptr inbounds %struct.sv** %73, i64 %77
  store %struct.sv** %add.ptr205, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  store %struct.av* %ary.01244, %struct.av** @PL_curstack, align 8, !tbaa !0
  %78 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !0
  %si_stack = getelementptr inbounds %struct.stackinfo* %78, i64 0, i32 0
  store %struct.av* %ary.01244, %struct.av** %si_stack, align 8, !tbaa !0
  br label %if.end207

if.end207:                                        ; preds = %if.end110, %if.else, %lor.lhs.false115, %cond.end154, %if.end183
  %ary.01245 = phi %struct.av* [ %ary.01244, %cond.end154 ], [ %ary.01244, %if.end183 ], [ %ary.01244, %lor.lhs.false115 ], [ null, %if.else ], [ null, %if.end110 ]
  %realarray.0 = phi i32 [ 1, %cond.end154 ], [ 1, %if.end183 ], [ 0, %lor.lhs.false115 ], [ 0, %if.else ], [ 0, %if.end110 ]
  %make_mortal.0 = phi i32 [ 1, %cond.end154 ], [ 0, %if.end183 ], [ 1, %lor.lhs.false115 ], [ 1, %if.else ], [ 1, %if.end110 ]
  %mg.0 = phi %struct.magic* [ %call124, %cond.end154 ], [ null, %if.end183 ], [ null, %lor.lhs.false115 ], [ null, %if.else ], [ null, %if.end110 ]
  %sp.1 = phi %struct.sv** [ %incdec.ptr156, %cond.end154 ], [ %add.ptr205, %if.end183 ], [ %incdec.ptr53, %lor.lhs.false115 ], [ %incdec.ptr53, %if.else ], [ %incdec.ptr53, %if.end110 ]
  %79 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.lhs.cast208 = ptrtoint %struct.sv** %sp.1 to i64
  %sub.ptr.rhs.cast209 = ptrtoint %struct.sv** %79 to i64
  %sub.ptr.sub210 = sub i64 %sub.ptr.lhs.cast208, %sub.ptr.rhs.cast209
  %80 = load i32* %24, align 4, !tbaa !4
  %and214 = and i32 %80, 16
  %tobool215 = icmp eq i32 %and214, 0
  br i1 %tobool215, label %if.end260, label %if.then216

if.then216:                                       ; preds = %if.end207
  %and218 = and i32 %80, 2048
  %tobool219 = icmp eq i32 %and218, 0
  br i1 %tobool219, label %while.cond237, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then216
  %81 = load i8* %cond10, align 1, !tbaa !1
  %cmp22312281336 = icmp sgt i8 %81, -1
  br i1 %cmp22312281336, label %land.rhs225, label %if.end260.loopexit1335

while.cond:                                       ; preds = %land.rhs225
  %82 = load i8* %incdec.ptr235, align 1, !tbaa !1
  %cmp2231228 = icmp sgt i8 %82, -1
  br i1 %cmp2231228, label %land.rhs225, label %if.end260.loopexit1335

land.rhs225:                                      ; preds = %while.cond.preheader, %while.cond
  %83 = phi i8 [ %82, %while.cond ], [ %81, %while.cond.preheader ]
  %s.01337 = phi i8* [ %incdec.ptr235, %while.cond ], [ %cond10, %while.cond.preheader ]
  %idxprom227 = sext i8 %83 to i64
  %call228 = call i16** @__ctype_b_loc() #7
  %84 = load i16** %call228, align 8, !tbaa !0
  %arrayidx229 = getelementptr inbounds i16* %84, i64 %idxprom227
  %85 = load i16* %arrayidx229, align 2, !tbaa !5
  %and231 = and i16 %85, 8192
  %tobool232 = icmp eq i16 %and231, 0
  %incdec.ptr235 = getelementptr inbounds i8* %s.01337, i64 1
  br i1 %tobool232, label %if.end260.loopexit1335, label %while.cond

while.cond237:                                    ; preds = %if.then216, %while.body256
  %s.1 = phi i8* [ %incdec.ptr257, %while.body256 ], [ %cond10, %if.then216 ]
  %86 = load i8* %s.1, align 1, !tbaa !1
  switch i8 %86, label %if.end260 [
    i8 32, label %while.body256
    i8 9, label %while.body256
    i8 10, label %while.body256
    i8 13, label %while.body256
    i8 12, label %while.body256
  ]

while.body256:                                    ; preds = %while.cond237, %while.cond237, %while.cond237, %while.cond237, %while.cond237
  %incdec.ptr257 = getelementptr inbounds i8* %s.1, i64 1
  br label %while.cond237

if.end260.loopexit1335:                           ; preds = %while.cond, %land.rhs225, %while.cond.preheader
  %s.0.lcssa = phi i8* [ %cond10, %while.cond.preheader ], [ %s.01337, %land.rhs225 ], [ %incdec.ptr235, %while.cond ]
  %.pre1375 = load i32* %24, align 4, !tbaa !4
  br label %if.end260

if.end260:                                        ; preds = %while.cond237, %if.end260.loopexit1335, %if.end207
  %87 = phi i32 [ %80, %if.end207 ], [ %.pre1375, %if.end260.loopexit1335 ], [ %80, %while.cond237 ]
  %s.2 = phi i8* [ %cond10, %if.end207 ], [ %s.0.lcssa, %if.end260.loopexit1335 ], [ %s.1, %while.cond237 ]
  %and262 = and i32 %87, 12288
  %tobool263 = icmp eq i32 %and262, 0
  br i1 %tobool263, label %if.end267, label %if.then264

if.then264:                                       ; preds = %if.end260
  call void @Perl_save_int(i32* @PL_multiline) #7
  %88 = load i32* %24, align 4, !tbaa !4
  %and266 = and i32 %88, 4096
  store i32 %and266, i32* @PL_multiline, align 4, !tbaa !4
  br label %if.end267

if.end267:                                        ; preds = %if.end260, %if.then264
  %tobool268 = icmp eq i64 %cond, 0
  br i1 %tobool268, label %if.then269, label %if.end272

if.then269:                                       ; preds = %if.end267
  %add270 = shl i64 %add, 32
  %sext = add i64 %add270, 8589934592
  %conv271 = ashr exact i64 %sext, 32
  br label %if.end272

if.end272:                                        ; preds = %if.end267, %if.then269
  %limit.0 = phi i64 [ %conv271, %if.then269 ], [ %cond, %if.end267 ]
  %89 = load i32* %24, align 4, !tbaa !4
  %and274 = and i32 %89, 32
  %tobool275 = icmp eq i32 %and274, 0
  br i1 %tobool275, label %if.else414, label %while.cond277.preheader

while.cond277.preheader:                          ; preds = %if.end272
  %dec2781328 = add nsw i64 %limit.0, -1
  %tobool2791329 = icmp eq i64 %dec2781328, 0
  br i1 %tobool2791329, label %if.end747, label %while.cond281.preheader.lr.ph

while.cond281.preheader.lr.ph:                    ; preds = %while.cond277.preheader
  %tobool341 = icmp eq i32 %make_mortal.0, 0
  br label %while.cond281.preheader

while.cond277.loopexit:                           ; preds = %while.cond361.backedge, %cond.true368, %cond.false383, %land.rhs373, %if.end358
  %s.4.lcssa = phi i8* [ %s.41317, %if.end358 ], [ %s.41319, %land.rhs373 ], [ %s.41319, %cond.false383 ], [ %s.41319, %cond.true368 ], [ %s.4, %while.cond361.backedge ]
  %dec278 = add nsw i64 %dec2781332, -1
  %tobool279 = icmp eq i64 %dec278, 0
  br i1 %tobool279, label %if.end747, label %while.cond281.preheader

while.cond281.preheader:                          ; preds = %while.cond281.preheader.lr.ph, %while.cond277.loopexit
  %dec2781332 = phi i64 [ %dec2781328, %while.cond281.preheader.lr.ph ], [ %dec278, %while.cond277.loopexit ]
  %sp.21331 = phi %struct.sv** [ %sp.1, %while.cond281.preheader.lr.ph ], [ %incdec.ptr359, %while.cond277.loopexit ]
  %s.31330 = phi i8* [ %s.2, %while.cond281.preheader.lr.ph ], [ %s.4.lcssa, %while.cond277.loopexit ]
  %cmp2821313 = icmp ult i8* %s.31330, %add.ptr1242
  br i1 %cmp2821313, label %land.rhs284, label %if.end747

land.rhs284:                                      ; preds = %while.body330, %while.cond281.preheader
  %m.01314 = phi i8* [ %s.31330, %while.cond281.preheader ], [ %incdec.ptr331, %while.body330 ]
  %90 = load i32* %24, align 4, !tbaa !4
  %and286 = and i32 %90, 2048
  %tobool287 = icmp eq i32 %and286, 0
  %91 = load i8* %m.01314, align 1, !tbaa !1
  br i1 %tobool287, label %cond.false303, label %cond.true288

cond.true288:                                     ; preds = %land.rhs284
  %cmp2911227 = icmp sgt i8 %91, -1
  br i1 %cmp2911227, label %land.rhs293, label %while.body330

land.rhs293:                                      ; preds = %cond.true288
  %idxprom295 = sext i8 %91 to i64
  %call296 = call i16** @__ctype_b_loc() #7
  %92 = load i16** %call296, align 8, !tbaa !0
  %arrayidx297 = getelementptr inbounds i16* %92, i64 %idxprom295
  %93 = load i16* %arrayidx297, align 2, !tbaa !5
  %and299 = and i16 %93, 8192
  %tobool300 = icmp eq i16 %and299, 0
  br i1 %tobool300, label %while.body330, label %if.end336

cond.false303:                                    ; preds = %land.rhs284
  %switch.tableidx = add i8 %91, -9
  %94 = icmp ult i8 %switch.tableidx, 24
  br i1 %94, label %cond.end324, label %while.body330

cond.end324:                                      ; preds = %cond.false303
  %switch.cast = zext i8 %switch.tableidx to i24
  %switch.downshift = lshr i24 -8388581, %switch.cast
  %95 = and i24 %switch.downshift, 1
  %switch.masked = icmp eq i24 %95, 0
  br i1 %switch.masked, label %while.body330, label %if.end336

while.body330:                                    ; preds = %cond.end324, %land.rhs293, %cond.false303, %cond.true288
  %incdec.ptr331 = getelementptr inbounds i8* %m.01314, i64 1
  %cmp282 = icmp ult i8* %incdec.ptr331, %add.ptr1242
  br i1 %cmp282, label %land.rhs284, label %if.end747

if.end336:                                        ; preds = %cond.end324, %land.rhs293
  %sub.ptr.lhs.cast337 = ptrtoint i8* %m.01314 to i64
  %sub.ptr.rhs.cast338 = ptrtoint i8* %s.31330 to i64
  %sub.ptr.sub339 = sub i64 %sub.ptr.lhs.cast337, %sub.ptr.rhs.cast338
  %call340 = call %struct.sv* @Perl_newSVpvn(i8* %s.31330, i64 %sub.ptr.sub339) #7
  br i1 %tobool341, label %if.end344, label %if.then342

if.then342:                                       ; preds = %if.end336
  %call343 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call340) #7
  br label %if.end344

if.end344:                                        ; preds = %if.end336, %if.then342
  br i1 %17, label %if.then346, label %if.end349

if.then346:                                       ; preds = %if.end344
  %sv_flags347 = getelementptr inbounds %struct.sv* %call340, i64 0, i32 2
  %96 = load i32* %sv_flags347, align 4, !tbaa !4
  %or348 = or i32 %96, 536870912
  store i32 %or348, i32* %sv_flags347, align 4, !tbaa !4
  br label %if.end349

if.end349:                                        ; preds = %if.then346, %if.end344
  %97 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast350 = ptrtoint %struct.sv** %97 to i64
  %sub.ptr.rhs.cast351 = ptrtoint %struct.sv** %sp.21331 to i64
  %sub.ptr.sub352 = sub i64 %sub.ptr.lhs.cast350, %sub.ptr.rhs.cast351
  %cmp354 = icmp slt i64 %sub.ptr.sub352, 8
  br i1 %cmp354, label %if.then356, label %if.end358

if.then356:                                       ; preds = %if.end349
  %call357 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.21331, %struct.sv** %sp.21331, i32 1) #7
  br label %if.end358

if.end358:                                        ; preds = %if.then356, %if.end349
  %sp.3 = phi %struct.sv** [ %call357, %if.then356 ], [ %sp.21331, %if.end349 ]
  %incdec.ptr359 = getelementptr inbounds %struct.sv** %sp.3, i64 1
  store %struct.sv* %call340, %struct.sv** %incdec.ptr359, align 8, !tbaa !0
  %s.41317 = getelementptr inbounds i8* %m.01314, i64 1
  %cmp3621318 = icmp ult i8* %s.41317, %add.ptr1242
  br i1 %cmp3621318, label %land.rhs364, label %while.cond277.loopexit

land.rhs364:                                      ; preds = %while.cond361.backedge, %if.end358
  %s.41319 = phi i8* [ %s.41317, %if.end358 ], [ %s.4, %while.cond361.backedge ]
  %98 = load i32* %24, align 4, !tbaa !4
  %and366 = and i32 %98, 2048
  %tobool367 = icmp eq i32 %and366, 0
  %99 = load i8* %s.41319, align 1, !tbaa !1
  br i1 %tobool367, label %cond.false383, label %cond.true368

cond.true368:                                     ; preds = %land.rhs364
  %cmp3711226 = icmp sgt i8 %99, -1
  br i1 %cmp3711226, label %land.rhs373, label %while.cond277.loopexit

land.rhs373:                                      ; preds = %cond.true368
  %idxprom375 = sext i8 %99 to i64
  %call376 = call i16** @__ctype_b_loc() #7
  %100 = load i16** %call376, align 8, !tbaa !0
  %arrayidx377 = getelementptr inbounds i16* %100, i64 %idxprom375
  %101 = load i16* %arrayidx377, align 2, !tbaa !5
  %and379 = and i16 %101, 8192
  %tobool380 = icmp eq i16 %and379, 0
  br i1 %tobool380, label %while.cond277.loopexit, label %while.cond361.backedge

cond.false383:                                    ; preds = %land.rhs364
  switch i8 %99, label %while.cond277.loopexit [
    i8 32, label %while.cond361.backedge
    i8 9, label %while.cond361.backedge
    i8 10, label %while.cond361.backedge
    i8 13, label %while.cond361.backedge
    i8 12, label %while.cond361.backedge
  ]

while.cond361.backedge:                           ; preds = %cond.false383, %cond.false383, %cond.false383, %cond.false383, %cond.false383, %land.rhs373
  %s.4 = getelementptr inbounds i8* %s.41319, i64 1
  %cmp362 = icmp ult i8* %s.4, %add.ptr1242
  br i1 %cmp362, label %land.rhs364, label %while.cond277.loopexit

if.else414:                                       ; preds = %if.end272
  %precomp = getelementptr inbounds %struct.regexp* %23, i64 0, i32 4
  %102 = load i8** %precomp, align 8, !tbaa !0
  %103 = load i8* %102, align 1, !tbaa !1
  %cmp417 = icmp eq i8 %103, 94
  br i1 %cmp417, label %land.lhs.true419, label %if.else472

land.lhs.true419:                                 ; preds = %if.else414
  %arrayidx421 = getelementptr inbounds i8* %102, i64 1
  %104 = load i8* %arrayidx421, align 1, !tbaa !1
  %cmp423 = icmp eq i8 %104, 0
  br i1 %cmp423, label %while.cond426.preheader, label %if.else472

while.cond426.preheader:                          ; preds = %land.lhs.true419
  %dec4271264 = add nsw i64 %limit.0, -1
  %tobool4281265 = icmp eq i64 %dec4271264, 0
  br i1 %tobool4281265, label %if.end747, label %for.cond430.preheader.lr.ph

for.cond430.preheader.lr.ph:                      ; preds = %while.cond426.preheader
  %tobool452 = icmp eq i32 %make_mortal.0, 0
  br label %for.cond430.preheader

for.cond430.preheader:                            ; preds = %for.cond430.preheader.lr.ph, %if.end469
  %dec4271268 = phi i64 [ %dec4271264, %for.cond430.preheader.lr.ph ], [ %dec427, %if.end469 ]
  %sp.41267 = phi %struct.sv** [ %sp.1, %for.cond430.preheader.lr.ph ], [ %incdec.ptr470, %if.end469 ]
  %s.51266 = phi i8* [ %s.2, %for.cond430.preheader.lr.ph ], [ %incdec.ptr443, %if.end469 ]
  %cmp4311261 = icmp ult i8* %s.51266, %add.ptr1242
  br i1 %cmp4311261, label %land.rhs433, label %for.end442

for.cond430:                                      ; preds = %land.rhs433
  %cmp431 = icmp ult i8* %incdec.ptr441, %add.ptr1242
  br i1 %cmp431, label %land.rhs433, label %for.end442

land.rhs433:                                      ; preds = %for.cond430, %for.cond430.preheader
  %m.11262 = phi i8* [ %s.51266, %for.cond430.preheader ], [ %incdec.ptr441, %for.cond430 ]
  %105 = load i8* %m.11262, align 1, !tbaa !1
  %cmp435 = icmp eq i8 %105, 10
  %incdec.ptr441 = getelementptr inbounds i8* %m.11262, i64 1
  br i1 %cmp435, label %for.end442, label %for.cond430

for.end442:                                       ; preds = %for.cond430, %land.rhs433, %for.cond430.preheader
  %m.1.lcssa = phi i8* [ %s.51266, %for.cond430.preheader ], [ %m.11262, %land.rhs433 ], [ %incdec.ptr441, %for.cond430 ]
  %incdec.ptr443 = getelementptr inbounds i8* %m.1.lcssa, i64 1
  %cmp444 = icmp ult i8* %incdec.ptr443, %add.ptr1242
  br i1 %cmp444, label %if.end447, label %if.end747

if.end447:                                        ; preds = %for.end442
  %sub.ptr.lhs.cast448 = ptrtoint i8* %incdec.ptr443 to i64
  %sub.ptr.rhs.cast449 = ptrtoint i8* %s.51266 to i64
  %sub.ptr.sub450 = sub i64 %sub.ptr.lhs.cast448, %sub.ptr.rhs.cast449
  %call451 = call %struct.sv* @Perl_newSVpvn(i8* %s.51266, i64 %sub.ptr.sub450) #7
  br i1 %tobool452, label %if.end455, label %if.then453

if.then453:                                       ; preds = %if.end447
  %call454 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call451) #7
  br label %if.end455

if.end455:                                        ; preds = %if.end447, %if.then453
  br i1 %17, label %if.then457, label %if.end460

if.then457:                                       ; preds = %if.end455
  %sv_flags458 = getelementptr inbounds %struct.sv* %call451, i64 0, i32 2
  %106 = load i32* %sv_flags458, align 4, !tbaa !4
  %or459 = or i32 %106, 536870912
  store i32 %or459, i32* %sv_flags458, align 4, !tbaa !4
  br label %if.end460

if.end460:                                        ; preds = %if.then457, %if.end455
  %107 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast461 = ptrtoint %struct.sv** %107 to i64
  %sub.ptr.rhs.cast462 = ptrtoint %struct.sv** %sp.41267 to i64
  %sub.ptr.sub463 = sub i64 %sub.ptr.lhs.cast461, %sub.ptr.rhs.cast462
  %cmp465 = icmp slt i64 %sub.ptr.sub463, 8
  br i1 %cmp465, label %if.then467, label %if.end469

if.then467:                                       ; preds = %if.end460
  %call468 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.41267, %struct.sv** %sp.41267, i32 1) #7
  br label %if.end469

if.end469:                                        ; preds = %if.then467, %if.end460
  %sp.5 = phi %struct.sv** [ %call468, %if.then467 ], [ %sp.41267, %if.end460 ]
  %incdec.ptr470 = getelementptr inbounds %struct.sv** %sp.5, i64 1
  store %struct.sv* %call451, %struct.sv** %incdec.ptr470, align 8, !tbaa !0
  %dec427 = add nsw i64 %dec4271268, -1
  %tobool428 = icmp eq i64 %dec427, 0
  br i1 %tobool428, label %if.end747, label %for.cond430.preheader

if.else472:                                       ; preds = %land.lhs.true419, %if.else414
  %108 = load i32* %reganch, align 4, !tbaa !4
  %109 = and i32 %108, 65536
  %110 = icmp ne i32 %109, 0
  %cmp478tmp = xor i1 %17, %110
  %and482 = and i32 %108, 3145728
  %tobool483 = icmp eq i32 %and482, 0
  %or.cond1235 = or i1 %cmp478tmp, %tobool483
  %nparens622.phi.trans.insert = getelementptr inbounds %struct.regexp* %23, i64 0, i32 12
  %.pre1380 = load i32* %nparens622.phi.trans.insert, align 4, !tbaa !4
  %or.cond1235.not = xor i1 %or.cond1235, true
  %tobool485 = icmp eq i32 %.pre1380, 0
  %or.cond1385 = and i1 %tobool485, %or.cond1235.not
  br i1 %or.cond1385, label %land.lhs.true486, label %if.else621

land.lhs.true486:                                 ; preds = %if.else472
  %111 = and i32 %108, 271
  %112 = icmp eq i32 %111, 256
  br i1 %112, label %if.then494, label %if.else621

if.then494:                                       ; preds = %land.lhs.true486
  %113 = load %struct.sv* (%struct.regexp*)** @PL_regint_string, align 8, !tbaa !0
  %call497 = call %struct.sv* %113(%struct.regexp* %23) #7
  %minlen = getelementptr inbounds %struct.regexp* %23, i64 0, i32 10
  %114 = load i32* %minlen, align 4, !tbaa !4
  %conv498 = sext i32 %114 to i64
  store i64 %conv498, i64* %len, align 8, !tbaa !3
  %cmp499 = icmp eq i32 %114, 1
  br i1 %cmp499, label %land.lhs.true501, label %while.cond575.preheader

land.lhs.true501:                                 ; preds = %if.then494
  %and496 = and i32 %108, 134217728
  %115 = load i32* %reganch, align 4, !tbaa !4
  %and503 = and i32 %115, 65536
  %116 = or i32 %and503, %and496
  %117 = icmp eq i32 %116, 0
  br i1 %117, label %if.then507, label %while.cond575.preheader

while.cond575.preheader:                          ; preds = %if.then494, %land.lhs.true501
  %cmp5761304 = icmp ult i8* %s.2, %add.ptr1242
  br i1 %cmp5761304, label %land.lhs.true578.lr.ph, label %if.end747

land.lhs.true578.lr.ph:                           ; preds = %while.cond575.preheader
  %tobool593 = icmp eq i32 %make_mortal.0, 0
  br label %land.lhs.true578

if.then507:                                       ; preds = %land.lhs.true501
  %sv_flags508 = getelementptr inbounds %struct.sv* %call497, i64 0, i32 2
  %118 = load i32* %sv_flags508, align 4, !tbaa !4
  %and509 = and i32 %118, 262144
  %cmp510 = icmp eq i32 %and509, 0
  br i1 %cmp510, label %cond.false517, label %cond.true512

cond.true512:                                     ; preds = %if.then507
  %sv_any513 = getelementptr inbounds %struct.sv* %call497, i64 0, i32 0
  %119 = load i8** %sv_any513, align 8, !tbaa !0
  %xpv_cur514 = getelementptr inbounds i8* %119, i64 8
  %120 = bitcast i8* %xpv_cur514 to i64*
  %121 = load i64* %120, align 8, !tbaa !3
  store i64 %121, i64* %n_a, align 8, !tbaa !3
  %xpv_pv516 = bitcast i8* %119 to i8**
  %122 = load i8** %xpv_pv516, align 8, !tbaa !0
  br label %cond.end519

cond.false517:                                    ; preds = %if.then507
  %call518 = call i8* @Perl_sv_2pv_flags(%struct.sv* %call497, i64* %n_a, i32 2) #7
  br label %cond.end519

cond.end519:                                      ; preds = %cond.false517, %cond.true512
  %cond520 = phi i8* [ %122, %cond.true512 ], [ %call518, %cond.false517 ]
  %123 = load i8* %cond520, align 1, !tbaa !1
  %dec5221296 = add nsw i64 %limit.0, -1
  %tobool5231297 = icmp eq i64 %dec5221296, 0
  br i1 %tobool5231297, label %if.end747, label %for.cond525.preheader.lr.ph

for.cond525.preheader.lr.ph:                      ; preds = %cond.end519
  %tobool547 = icmp eq i32 %make_mortal.0, 0
  br label %for.cond525.preheader

for.cond525.preheader:                            ; preds = %for.cond525.preheader.lr.ph, %while.cond521.backedge
  %dec5221300 = phi i64 [ %dec5221296, %for.cond525.preheader.lr.ph ], [ %dec522, %while.cond521.backedge ]
  %sp.61299 = phi %struct.sv** [ %sp.1, %for.cond525.preheader.lr.ph ], [ %incdec.ptr565, %while.cond521.backedge ]
  %s.61298 = phi i8* [ %s.2, %for.cond525.preheader.lr.ph ], [ %s.6.be, %while.cond521.backedge ]
  %cmp5261287 = icmp ult i8* %s.61298, %add.ptr1242
  br i1 %cmp5261287, label %land.rhs528, label %if.end747

for.cond525:                                      ; preds = %land.rhs528
  %cmp526 = icmp ult i8* %incdec.ptr537, %add.ptr1242
  br i1 %cmp526, label %land.rhs528, label %if.end747

land.rhs528:                                      ; preds = %for.cond525.preheader, %for.cond525
  %m.21288 = phi i8* [ %incdec.ptr537, %for.cond525 ], [ %s.61298, %for.cond525.preheader ]
  %124 = load i8* %m.21288, align 1, !tbaa !1
  %cmp531 = icmp eq i8 %124, %123
  %incdec.ptr537 = getelementptr inbounds i8* %m.21288, i64 1
  br i1 %cmp531, label %if.end542, label %for.cond525

if.end542:                                        ; preds = %land.rhs528
  %sub.ptr.lhs.cast543 = ptrtoint i8* %m.21288 to i64
  %sub.ptr.rhs.cast544 = ptrtoint i8* %s.61298 to i64
  %sub.ptr.sub545 = sub i64 %sub.ptr.lhs.cast543, %sub.ptr.rhs.cast544
  %call546 = call %struct.sv* @Perl_newSVpvn(i8* %s.61298, i64 %sub.ptr.sub545) #7
  br i1 %tobool547, label %if.end550, label %if.then548

if.then548:                                       ; preds = %if.end542
  %call549 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call546) #7
  br label %if.end550

if.end550:                                        ; preds = %if.end542, %if.then548
  br i1 %17, label %if.then552, label %if.end555

if.then552:                                       ; preds = %if.end550
  %sv_flags553 = getelementptr inbounds %struct.sv* %call546, i64 0, i32 2
  %125 = load i32* %sv_flags553, align 4, !tbaa !4
  %or554 = or i32 %125, 536870912
  store i32 %or554, i32* %sv_flags553, align 4, !tbaa !4
  br label %if.end555

if.end555:                                        ; preds = %if.then552, %if.end550
  %126 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast556 = ptrtoint %struct.sv** %126 to i64
  %sub.ptr.rhs.cast557 = ptrtoint %struct.sv** %sp.61299 to i64
  %sub.ptr.sub558 = sub i64 %sub.ptr.lhs.cast556, %sub.ptr.rhs.cast557
  %cmp560 = icmp slt i64 %sub.ptr.sub558, 8
  br i1 %cmp560, label %if.then562, label %if.end564

if.then562:                                       ; preds = %if.end555
  %call563 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.61299, %struct.sv** %sp.61299, i32 1) #7
  br label %if.end564

if.end564:                                        ; preds = %if.then562, %if.end555
  %sp.7 = phi %struct.sv** [ %call563, %if.then562 ], [ %sp.61299, %if.end555 ]
  %incdec.ptr565 = getelementptr inbounds %struct.sv** %sp.7, i64 1
  store %struct.sv* %call546, %struct.sv** %incdec.ptr565, align 8, !tbaa !0
  %127 = load i64* %len, align 8, !tbaa !3
  br i1 %17, label %if.then567, label %if.else570

if.then567:                                       ; preds = %if.end564
  %conv568 = trunc i64 %127 to i32
  %call569 = call i8* @Perl_utf8_hop(i8* %m.21288, i32 %conv568) #7
  br label %while.cond521.backedge

if.else570:                                       ; preds = %if.end564
  %add.ptr571 = getelementptr inbounds i8* %m.21288, i64 %127
  br label %while.cond521.backedge

while.cond521.backedge:                           ; preds = %if.else570, %if.then567
  %s.6.be = phi i8* [ %call569, %if.then567 ], [ %add.ptr571, %if.else570 ]
  %dec522 = add nsw i64 %dec5221300, -1
  %tobool523 = icmp eq i64 %dec522, 0
  br i1 %tobool523, label %if.end747, label %for.cond525.preheader

land.lhs.true578:                                 ; preds = %land.lhs.true578.lr.ph, %while.cond575.backedge
  %sp.81307 = phi %struct.sv** [ %sp.1, %land.lhs.true578.lr.ph ], [ %incdec.ptr611, %while.cond575.backedge ]
  %limit.41306 = phi i64 [ %limit.0, %land.lhs.true578.lr.ph ], [ %dec579, %while.cond575.backedge ]
  %s.71305 = phi i8* [ %s.2, %land.lhs.true578.lr.ph ], [ %s.7.be, %while.cond575.backedge ]
  %dec579 = add nsw i64 %limit.41306, -1
  %tobool580 = icmp eq i64 %dec579, 0
  br i1 %tobool580, label %if.end747, label %land.rhs581

land.rhs581:                                      ; preds = %land.lhs.true578
  %128 = load i32* @PL_multiline, align 4, !tbaa !4
  %tobool582 = icmp ne i32 %128, 0
  %cond583 = zext i1 %tobool582 to i32
  %call584 = call i8* @Perl_fbm_instr(i8* %s.71305, i8* %add.ptr1242, %struct.sv* %call497, i32 %cond583) #7
  %tobool585 = icmp eq i8* %call584, null
  br i1 %tobool585, label %if.end747, label %while.body588

while.body588:                                    ; preds = %land.rhs581
  %sub.ptr.lhs.cast589 = ptrtoint i8* %call584 to i64
  %sub.ptr.rhs.cast590 = ptrtoint i8* %s.71305 to i64
  %sub.ptr.sub591 = sub i64 %sub.ptr.lhs.cast589, %sub.ptr.rhs.cast590
  %call592 = call %struct.sv* @Perl_newSVpvn(i8* %s.71305, i64 %sub.ptr.sub591) #7
  br i1 %tobool593, label %if.end596, label %if.then594

if.then594:                                       ; preds = %while.body588
  %call595 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call592) #7
  br label %if.end596

if.end596:                                        ; preds = %while.body588, %if.then594
  br i1 %17, label %if.then598, label %if.end601

if.then598:                                       ; preds = %if.end596
  %sv_flags599 = getelementptr inbounds %struct.sv* %call592, i64 0, i32 2
  %129 = load i32* %sv_flags599, align 4, !tbaa !4
  %or600 = or i32 %129, 536870912
  store i32 %or600, i32* %sv_flags599, align 4, !tbaa !4
  br label %if.end601

if.end601:                                        ; preds = %if.then598, %if.end596
  %130 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast602 = ptrtoint %struct.sv** %130 to i64
  %sub.ptr.rhs.cast603 = ptrtoint %struct.sv** %sp.81307 to i64
  %sub.ptr.sub604 = sub i64 %sub.ptr.lhs.cast602, %sub.ptr.rhs.cast603
  %cmp606 = icmp slt i64 %sub.ptr.sub604, 8
  br i1 %cmp606, label %if.then608, label %if.end610

if.then608:                                       ; preds = %if.end601
  %call609 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.81307, %struct.sv** %sp.81307, i32 1) #7
  br label %if.end610

if.end610:                                        ; preds = %if.then608, %if.end601
  %sp.9 = phi %struct.sv** [ %call609, %if.then608 ], [ %sp.81307, %if.end601 ]
  %incdec.ptr611 = getelementptr inbounds %struct.sv** %sp.9, i64 1
  store %struct.sv* %call592, %struct.sv** %incdec.ptr611, align 8, !tbaa !0
  %131 = load i64* %len, align 8, !tbaa !3
  br i1 %17, label %if.then613, label %if.else616

if.then613:                                       ; preds = %if.end610
  %conv614 = trunc i64 %131 to i32
  %call615 = call i8* @Perl_utf8_hop(i8* %call584, i32 %conv614) #7
  br label %while.cond575.backedge

if.else616:                                       ; preds = %if.end610
  %add.ptr617 = getelementptr inbounds i8* %call584, i64 %131
  br label %while.cond575.backedge

while.cond575.backedge:                           ; preds = %if.else616, %if.then613
  %s.7.be = phi i8* [ %call615, %if.then613 ], [ %add.ptr617, %if.else616 ]
  %cmp576 = icmp ult i8* %s.7.be, %add.ptr1242
  br i1 %cmp576, label %land.lhs.true578, label %if.end747

if.else621:                                       ; preds = %if.else472, %land.lhs.true486
  %132 = phi i32 [ 0, %land.lhs.true486 ], [ %.pre1380, %if.else472 ]
  %nparens622 = getelementptr inbounds %struct.regexp* %23, i64 0, i32 12
  %conv623 = zext i32 %132 to i64
  %mul = mul i64 %conv623, %cond23
  %add625 = add i64 %mul, %add
  %conv626 = trunc i64 %add625 to i32
  %cmp6281276 = icmp ult i8* %s.2, %add.ptr1242
  br i1 %cmp6281276, label %land.rhs630.lr.ph, label %if.end747

land.rhs630.lr.ph:                                ; preds = %if.else621
  %startp = getelementptr inbounds %struct.regexp* %23, i64 0, i32 0
  %tobool669 = icmp ne i32 %make_mortal.0, 0
  %endp740 = getelementptr inbounds %struct.regexp* %23, i64 0, i32 1
  %subbeg = getelementptr inbounds %struct.regexp* %23, i64 0, i32 6
  br label %land.rhs630

land.rhs630:                                      ; preds = %land.rhs630.lr.ph, %if.end739
  %sp.101281 = phi %struct.sv** [ %sp.1, %land.rhs630.lr.ph ], [ %sp.14, %if.end739 ]
  %limit.51280 = phi i64 [ %limit.0, %land.rhs630.lr.ph ], [ %dec631, %if.end739 ]
  %s.81279 = phi i8* [ %s.2, %land.rhs630.lr.ph ], [ %add.ptr743, %if.end739 ]
  %strend.01278 = phi i8* [ %add.ptr1242, %land.rhs630.lr.ph ], [ %strend.1, %if.end739 ]
  %orig.01277 = phi i8* [ %cond10, %land.rhs630.lr.ph ], [ %orig.1, %if.end739 ]
  %dec631 = add nsw i64 %limit.51280, -1
  %tobool632 = icmp eq i64 %dec631, 0
  br i1 %tobool632, label %if.end747, label %while.body635

while.body635:                                    ; preds = %land.rhs630
  store %struct.sv** %sp.101281, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %133 = load i32 (%struct.regexp*, i8*, i8*, i8*, i32, %struct.sv*, i8*, i32)** @PL_regexecp, align 8, !tbaa !0
  %call636 = call i32 %133(%struct.regexp* %23, i8* %s.81279, i8* %strend.01278, i8* %orig.01277, i32 1, %struct.sv* %6, i8* null, i32 0) #7
  %134 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %cmp637 = icmp eq i32 %call636, 0
  br i1 %cmp637, label %if.end747, label %if.end640

if.end640:                                        ; preds = %while.body635
  %135 = load i32* %reganch, align 4, !tbaa !4
  %and642 = and i32 %135, 524288
  %tobool643 = icmp eq i32 %and642, 0
  br i1 %tobool643, label %if.end645, label %if.then644

if.then644:                                       ; preds = %if.end640
  store i8 1, i8* @PL_tainted, align 1, !tbaa !1
  %.pre1376 = load i32* %reganch, align 4, !tbaa !4
  br label %if.end645

if.end645:                                        ; preds = %if.end640, %if.then644
  %136 = phi i32 [ %135, %if.end640 ], [ %.pre1376, %if.then644 ]
  %and647 = and i32 %136, 262144
  %tobool648 = icmp eq i32 %and647, 0
  br i1 %tobool648, label %if.end662, label %land.lhs.true649

land.lhs.true649:                                 ; preds = %if.end645
  %137 = load i8** %subbeg, align 8, !tbaa !0
  %cmp650 = icmp eq i8* %137, %orig.01277
  br i1 %cmp650, label %if.end662, label %if.then652

if.then652:                                       ; preds = %land.lhs.true649
  %sub.ptr.lhs.cast654 = ptrtoint i8* %s.81279 to i64
  %sub.ptr.rhs.cast655 = ptrtoint i8* %orig.01277 to i64
  %sub.ptr.sub656 = sub i64 %sub.ptr.lhs.cast654, %sub.ptr.rhs.cast655
  %add.ptr657 = getelementptr inbounds i8* %137, i64 %sub.ptr.sub656
  %sub.ptr.lhs.cast658 = ptrtoint i8* %strend.01278 to i64
  %sub.ptr.sub660 = sub i64 %sub.ptr.lhs.cast658, %sub.ptr.lhs.cast654
  %add.ptr657.sum = add i64 %sub.ptr.sub660, %sub.ptr.sub656
  %add.ptr661 = getelementptr inbounds i8* %137, i64 %add.ptr657.sum
  br label %if.end662

if.end662:                                        ; preds = %land.lhs.true649, %if.end645, %if.then652
  %orig.1 = phi i8* [ %137, %if.then652 ], [ %orig.01277, %land.lhs.true649 ], [ %orig.01277, %if.end645 ]
  %strend.1 = phi i8* [ %add.ptr661, %if.then652 ], [ %strend.01278, %land.lhs.true649 ], [ %strend.01278, %if.end645 ]
  %s.9 = phi i8* [ %add.ptr657, %if.then652 ], [ %s.81279, %land.lhs.true649 ], [ %s.81279, %if.end645 ]
  %138 = load i32** %startp, align 8, !tbaa !0
  %139 = load i32* %138, align 4, !tbaa !4
  %idx.ext = sext i32 %139 to i64
  %add.ptr664 = getelementptr inbounds i8* %orig.1, i64 %idx.ext
  %sub.ptr.lhs.cast665 = ptrtoint i8* %add.ptr664 to i64
  %sub.ptr.rhs.cast666 = ptrtoint i8* %s.9 to i64
  %sub.ptr.sub667 = sub i64 %sub.ptr.lhs.cast665, %sub.ptr.rhs.cast666
  %call668 = call %struct.sv* @Perl_newSVpvn(i8* %s.9, i64 %sub.ptr.sub667) #7
  br i1 %tobool669, label %if.then670, label %if.end672

if.then670:                                       ; preds = %if.end662
  %call671 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call668) #7
  br label %if.end672

if.end672:                                        ; preds = %if.then670, %if.end662
  br i1 %17, label %if.then674, label %if.end677

if.then674:                                       ; preds = %if.end672
  %sv_flags675 = getelementptr inbounds %struct.sv* %call668, i64 0, i32 2
  %140 = load i32* %sv_flags675, align 4, !tbaa !4
  %or676 = or i32 %140, 536870912
  store i32 %or676, i32* %sv_flags675, align 4, !tbaa !4
  br label %if.end677

if.end677:                                        ; preds = %if.then674, %if.end672
  %141 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast678 = ptrtoint %struct.sv** %141 to i64
  %sub.ptr.rhs.cast679 = ptrtoint %struct.sv** %134 to i64
  %sub.ptr.sub680 = sub i64 %sub.ptr.lhs.cast678, %sub.ptr.rhs.cast679
  %cmp682 = icmp slt i64 %sub.ptr.sub680, 8
  br i1 %cmp682, label %if.then684, label %if.end686

if.then684:                                       ; preds = %if.end677
  %call685 = call %struct.sv** @Perl_stack_grow(%struct.sv** %134, %struct.sv** %134, i32 1) #7
  br label %if.end686

if.end686:                                        ; preds = %if.then684, %if.end677
  %sp.11 = phi %struct.sv** [ %call685, %if.then684 ], [ %134, %if.end677 ]
  %incdec.ptr687 = getelementptr inbounds %struct.sv** %sp.11, i64 1
  store %struct.sv* %call668, %struct.sv** %incdec.ptr687, align 8, !tbaa !0
  %142 = load i32* %nparens622, align 4, !tbaa !4
  %cmp6931271 = icmp slt i32 %142, 1
  br i1 %cmp6931271, label %if.end739, label %for.body695

for.body695:                                      ; preds = %if.end686, %if.end734
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end734 ], [ 1, %if.end686 ]
  %sp.121273 = phi %struct.sv** [ %incdec.ptr735, %if.end734 ], [ %incdec.ptr687, %if.end686 ]
  %143 = load i32** %startp, align 8, !tbaa !0
  %arrayidx698 = getelementptr inbounds i32* %143, i64 %indvars.iv
  %144 = load i32* %arrayidx698, align 4, !tbaa !4
  %idx.ext699 = sext i32 %144 to i64
  %145 = load i32** %endp740, align 8, !tbaa !0
  %arrayidx702 = getelementptr inbounds i32* %145, i64 %indvars.iv
  %146 = load i32* %arrayidx702, align 4, !tbaa !4
  %147 = or i32 %146, %144
  %148 = icmp sgt i32 %147, -1
  br i1 %148, label %if.then710, label %if.end716

if.then710:                                       ; preds = %for.body695
  %idx.ext703 = sext i32 %146 to i64
  %add.ptr700 = getelementptr inbounds i8* %orig.1, i64 %idx.ext699
  %149 = sub i64 %idx.ext703, %idx.ext699
  %call714 = call %struct.sv* @Perl_newSVpvn(i8* %add.ptr700, i64 %149) #7
  br label %if.end716

if.end716:                                        ; preds = %for.body695, %if.then710
  %dstr.0 = phi %struct.sv* [ %call714, %if.then710 ], [ @PL_sv_undef, %for.body695 ]
  br i1 %tobool669, label %if.then718, label %if.end720

if.then718:                                       ; preds = %if.end716
  %call719 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %dstr.0) #7
  br label %if.end720

if.end720:                                        ; preds = %if.then718, %if.end716
  br i1 %17, label %if.then722, label %if.end725

if.then722:                                       ; preds = %if.end720
  %sv_flags723 = getelementptr inbounds %struct.sv* %dstr.0, i64 0, i32 2
  %150 = load i32* %sv_flags723, align 4, !tbaa !4
  %or724 = or i32 %150, 536870912
  store i32 %or724, i32* %sv_flags723, align 4, !tbaa !4
  br label %if.end725

if.end725:                                        ; preds = %if.then722, %if.end720
  %151 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast726 = ptrtoint %struct.sv** %151 to i64
  %sub.ptr.rhs.cast727 = ptrtoint %struct.sv** %sp.121273 to i64
  %sub.ptr.sub728 = sub i64 %sub.ptr.lhs.cast726, %sub.ptr.rhs.cast727
  %cmp730 = icmp slt i64 %sub.ptr.sub728, 8
  br i1 %cmp730, label %if.then732, label %if.end734

if.then732:                                       ; preds = %if.end725
  %call733 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.121273, %struct.sv** %sp.121273, i32 1) #7
  br label %if.end734

if.end734:                                        ; preds = %if.end725, %if.then732
  %sp.13 = phi %struct.sv** [ %call733, %if.then732 ], [ %sp.121273, %if.end725 ]
  %incdec.ptr735 = getelementptr inbounds %struct.sv** %sp.13, i64 1
  store %struct.sv* %dstr.0, %struct.sv** %incdec.ptr735, align 8, !tbaa !0
  %indvars.iv.next = add i64 %indvars.iv, 1
  %152 = load i32* %nparens622, align 4, !tbaa !4
  %153 = trunc i64 %indvars.iv to i32
  %cmp693 = icmp slt i32 %153, %152
  br i1 %cmp693, label %for.body695, label %if.end739

if.end739:                                        ; preds = %if.end734, %if.end686
  %sp.14 = phi %struct.sv** [ %incdec.ptr687, %if.end686 ], [ %incdec.ptr735, %if.end734 ]
  %154 = load i32** %endp740, align 8, !tbaa !0
  %155 = load i32* %154, align 4, !tbaa !4
  %idx.ext742 = sext i32 %155 to i64
  %add.ptr743 = getelementptr inbounds i8* %orig.1, i64 %idx.ext742
  %cmp628 = icmp ult i8* %add.ptr743, %strend.1
  br i1 %cmp628, label %land.rhs630, label %if.end747

if.end747:                                        ; preds = %while.cond277.preheader, %while.cond277.loopexit, %while.body330, %while.cond281.preheader, %while.cond575.preheader, %land.rhs581, %land.lhs.true578, %while.cond575.backedge, %cond.end519, %while.cond521.backedge, %for.cond525, %for.cond525.preheader, %if.else621, %land.rhs630, %while.body635, %if.end739, %while.cond426.preheader, %for.end442, %if.end469
  %maxiters.0 = phi i32 [ %conv24, %if.end469 ], [ %conv24, %for.end442 ], [ %conv24, %while.cond426.preheader ], [ %conv626, %if.end739 ], [ %conv626, %while.body635 ], [ %conv626, %land.rhs630 ], [ %conv626, %if.else621 ], [ %conv24, %for.cond525.preheader ], [ %conv24, %for.cond525 ], [ %conv24, %while.cond521.backedge ], [ %conv24, %cond.end519 ], [ %conv24, %while.cond575.backedge ], [ %conv24, %land.lhs.true578 ], [ %conv24, %land.rhs581 ], [ %conv24, %while.cond575.preheader ], [ %conv24, %while.cond281.preheader ], [ %conv24, %while.body330 ], [ %conv24, %while.cond277.loopexit ], [ %conv24, %while.cond277.preheader ]
  %strend.2 = phi i8* [ %add.ptr1242, %if.end469 ], [ %add.ptr1242, %for.end442 ], [ %add.ptr1242, %while.cond426.preheader ], [ %strend.1, %if.end739 ], [ %strend.01278, %while.body635 ], [ %strend.01278, %land.rhs630 ], [ %add.ptr1242, %if.else621 ], [ %add.ptr1242, %for.cond525.preheader ], [ %add.ptr1242, %for.cond525 ], [ %add.ptr1242, %while.cond521.backedge ], [ %add.ptr1242, %cond.end519 ], [ %add.ptr1242, %while.cond575.backedge ], [ %add.ptr1242, %land.lhs.true578 ], [ %add.ptr1242, %land.rhs581 ], [ %add.ptr1242, %while.cond575.preheader ], [ %add.ptr1242, %while.cond281.preheader ], [ %add.ptr1242, %while.body330 ], [ %add.ptr1242, %while.cond277.loopexit ], [ %add.ptr1242, %while.cond277.preheader ]
  %s.10 = phi i8* [ %incdec.ptr443, %if.end469 ], [ %s.51266, %for.end442 ], [ %s.2, %while.cond426.preheader ], [ %add.ptr743, %if.end739 ], [ %s.81279, %while.body635 ], [ %s.81279, %land.rhs630 ], [ %s.2, %if.else621 ], [ %s.61298, %for.cond525.preheader ], [ %s.61298, %for.cond525 ], [ %s.6.be, %while.cond521.backedge ], [ %s.2, %cond.end519 ], [ %s.7.be, %while.cond575.backedge ], [ %s.71305, %land.lhs.true578 ], [ %s.71305, %land.rhs581 ], [ %s.2, %while.cond575.preheader ], [ %s.31330, %while.cond281.preheader ], [ %s.31330, %while.body330 ], [ %s.4.lcssa, %while.cond277.loopexit ], [ %s.2, %while.cond277.preheader ]
  %sp.15 = phi %struct.sv** [ %incdec.ptr470, %if.end469 ], [ %sp.41267, %for.end442 ], [ %sp.1, %while.cond426.preheader ], [ %sp.14, %if.end739 ], [ %134, %while.body635 ], [ %sp.101281, %land.rhs630 ], [ %sp.1, %if.else621 ], [ %sp.61299, %for.cond525.preheader ], [ %sp.61299, %for.cond525 ], [ %incdec.ptr565, %while.cond521.backedge ], [ %sp.1, %cond.end519 ], [ %incdec.ptr611, %while.cond575.backedge ], [ %sp.81307, %land.lhs.true578 ], [ %sp.81307, %land.rhs581 ], [ %sp.1, %while.cond575.preheader ], [ %sp.21331, %while.cond281.preheader ], [ %sp.21331, %while.body330 ], [ %incdec.ptr359, %while.cond277.loopexit ], [ %sp.1, %while.cond277.preheader ]
  %156 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.lhs.cast748 = ptrtoint %struct.sv** %sp.15 to i64
  %sub.ptr.rhs.cast749 = ptrtoint %struct.sv** %156 to i64
  %sub.ptr.sub750 = sub i64 %sub.ptr.lhs.cast748, %sub.ptr.rhs.cast749
  %sub.ptr.div7511224 = lshr exact i64 %sub.ptr.sub750, 3
  %157 = lshr i64 %sub.ptr.sub210, 3
  %sub = sub nsw i64 %sub.ptr.div7511224, %157
  %conv753 = trunc i64 %sub to i32
  %cmp754 = icmp sgt i32 %conv753, %maxiters.0
  br i1 %cmp754, label %if.then756, label %if.end758

if.then756:                                       ; preds = %if.end747
  %call757 = call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([11 x i8]* @.str48, i64 0, i64 0)) #7
  br label %return

if.end758:                                        ; preds = %if.end747
  %cmp759 = icmp ult i8* %s.10, %strend.2
  br i1 %cmp759, label %if.then765, label %lor.lhs.false761

lor.lhs.false761:                                 ; preds = %if.end758
  %tobool762 = icmp eq i32 %conv753, 0
  %tobool764 = icmp eq i32 %conv25, 0
  %or.cond1239 = or i1 %tobool762, %tobool764
  br i1 %or.cond1239, label %if.else790, label %if.then765

if.then765:                                       ; preds = %lor.lhs.false761, %if.end758
  %sub.ptr.lhs.cast766 = ptrtoint i8* %strend.2 to i64
  %sub.ptr.rhs.cast767 = ptrtoint i8* %s.10 to i64
  %sub.ptr.sub768 = sub i64 %sub.ptr.lhs.cast766, %sub.ptr.rhs.cast767
  %call769 = call %struct.sv* @Perl_newSVpvn(i8* %s.10, i64 %sub.ptr.sub768) #7
  %tobool770 = icmp eq i32 %make_mortal.0, 0
  br i1 %tobool770, label %if.end773, label %if.then771

if.then771:                                       ; preds = %if.then765
  %call772 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call769) #7
  br label %if.end773

if.end773:                                        ; preds = %if.then765, %if.then771
  br i1 %17, label %if.then775, label %if.end778

if.then775:                                       ; preds = %if.end773
  %sv_flags776 = getelementptr inbounds %struct.sv* %call769, i64 0, i32 2
  %158 = load i32* %sv_flags776, align 4, !tbaa !4
  %or777 = or i32 %158, 536870912
  store i32 %or777, i32* %sv_flags776, align 4, !tbaa !4
  br label %if.end778

if.end778:                                        ; preds = %if.then775, %if.end773
  %159 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast779 = ptrtoint %struct.sv** %159 to i64
  %sub.ptr.sub781 = sub i64 %sub.ptr.lhs.cast779, %sub.ptr.lhs.cast748
  %cmp783 = icmp slt i64 %sub.ptr.sub781, 8
  br i1 %cmp783, label %if.then785, label %if.end787

if.then785:                                       ; preds = %if.end778
  %call786 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.15, %struct.sv** %sp.15, i32 1) #7
  br label %if.end787

if.end787:                                        ; preds = %if.then785, %if.end778
  %sp.16 = phi %struct.sv** [ %call786, %if.then785 ], [ %sp.15, %if.end778 ]
  %incdec.ptr788 = getelementptr inbounds %struct.sv** %sp.16, i64 1
  store %struct.sv* %call769, %struct.sv** %incdec.ptr788, align 8, !tbaa !0
  %inc789 = add nsw i32 %conv753, 1
  br label %if.end821

if.else790:                                       ; preds = %lor.lhs.false761
  %cmp7941256 = icmp sgt i32 %conv753, 0
  %or.cond1387 = and i1 %tobool764, %cmp7941256
  br i1 %or.cond1387, label %land.rhs796.lr.ph, label %if.end821

land.rhs796.lr.ph:                                ; preds = %if.else790
  %tobool813 = icmp eq i32 %make_mortal.0, 0
  br label %land.rhs796

land.rhs796:                                      ; preds = %if.end816, %land.rhs796.lr.ph
  %sp.171258 = phi %struct.sv** [ %sp.15, %land.rhs796.lr.ph ], [ %incdec.ptr818, %if.end816 ]
  %iters.01257 = phi i32 [ %conv753, %land.rhs796.lr.ph ], [ %dec817, %if.end816 ]
  %160 = load %struct.sv** %sp.171258, align 8, !tbaa !0
  %tobool797 = icmp eq %struct.sv* %160, null
  br i1 %tobool797, label %if.end816, label %lor.lhs.false798

lor.lhs.false798:                                 ; preds = %land.rhs796
  %sv_any799 = getelementptr inbounds %struct.sv* %160, i64 0, i32 0
  %161 = load i8** %sv_any799, align 8, !tbaa !0
  %tobool800 = icmp eq i8* %161, null
  br i1 %tobool800, label %while.body810, label %lor.rhs801

lor.rhs801:                                       ; preds = %lor.lhs.false798
  %xpv_cur803 = getelementptr inbounds i8* %161, i64 8
  %162 = bitcast i8* %xpv_cur803 to i64*
  %163 = load i64* %162, align 8, !tbaa !3
  %cmp804 = icmp eq i64 %163, 0
  br i1 %cmp804, label %while.body810, label %if.end821

while.body810:                                    ; preds = %lor.lhs.false798, %lor.rhs801
  br i1 %tobool813, label %if.then814, label %if.end816

if.then814:                                       ; preds = %while.body810
  %call815 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %160) #7
  br label %if.end816

if.end816:                                        ; preds = %land.rhs796, %while.body810, %if.then814
  %dec817 = add nsw i32 %iters.01257, -1
  %incdec.ptr818 = getelementptr inbounds %struct.sv** %sp.171258, i64 -1
  store %struct.sv* @PL_sv_undef, %struct.sv** %sp.171258, align 8, !tbaa !0
  %cmp794 = icmp sgt i32 %dec817, 0
  br i1 %cmp794, label %land.rhs796, label %if.end821

if.end821:                                        ; preds = %lor.rhs801, %if.end816, %if.else790, %if.end787
  %iters.1 = phi i32 [ %inc789, %if.end787 ], [ %conv753, %if.else790 ], [ %iters.01257, %lor.rhs801 ], [ %dec817, %if.end816 ]
  %sp.18 = phi %struct.sv** [ %incdec.ptr788, %if.end787 ], [ %sp.15, %if.else790 ], [ %sp.171258, %lor.rhs801 ], [ %incdec.ptr818, %if.end816 ]
  store %struct.sv** %sp.18, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %164 = load i32* @PL_savestack_ix, align 4, !tbaa !4
  %cmp822 = icmp sgt i32 %164, %20
  br i1 %cmp822, label %if.then824, label %if.end825

if.then824:                                       ; preds = %if.end821
  call void @Perl_leave_scope(i32 %20) #7
  %.pre1377 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  br label %if.end825

if.end825:                                        ; preds = %if.then824, %if.end821
  %165 = phi %struct.sv** [ %.pre1377, %if.then824 ], [ %sp.18, %if.end821 ]
  %tobool826 = icmp eq i32 %realarray.0, 0
  br i1 %tobool826, label %if.else889, label %if.then827

if.then827:                                       ; preds = %if.end825
  %tobool828 = icmp eq %struct.magic* %mg.0, null
  br i1 %tobool828, label %if.then829, label %if.else857

if.then829:                                       ; preds = %if.then827
  %sv_flags830 = getelementptr inbounds %struct.av* %ary.01245, i64 0, i32 2
  %166 = load i32* %sv_flags830, align 4, !tbaa !4
  %and831 = and i32 %166, 16384
  %tobool832 = icmp eq i32 %and831, 0
  br i1 %tobool832, label %if.end835, label %if.then833

if.then833:                                       ; preds = %if.then829
  store %struct.sv** %165, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %167 = bitcast %struct.av* %ary.01245 to %struct.sv*
  %call834 = call i32 @Perl_mg_set(%struct.sv* %167) #7
  %168 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  br label %if.end835

if.end835:                                        ; preds = %if.then829, %if.then833
  %sp.19 = phi %struct.sv** [ %168, %if.then833 ], [ %165, %if.then829 ]
  %cmp836 = icmp eq i32 %cond52, 1
  br i1 %cmp836, label %if.then838, label %if.end895

if.then838:                                       ; preds = %if.end835
  %169 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast839 = ptrtoint %struct.sv** %169 to i64
  %sub.ptr.rhs.cast840 = ptrtoint %struct.sv** %sp.19 to i64
  %sub.ptr.sub841 = sub i64 %sub.ptr.lhs.cast839, %sub.ptr.rhs.cast840
  %sub.ptr.div842 = ashr exact i64 %sub.ptr.sub841, 3
  %conv843 = sext i32 %iters.1 to i64
  %cmp844 = icmp slt i64 %sub.ptr.div842, %conv843
  br i1 %cmp844, label %if.then846, label %if.end848

if.then846:                                       ; preds = %if.then838
  %call847 = call %struct.sv** @Perl_stack_grow(%struct.sv** %sp.19, %struct.sv** %sp.19, i32 %iters.1) #7
  br label %if.end848

if.end848:                                        ; preds = %if.then846, %if.then838
  %sp.20 = phi %struct.sv** [ %call847, %if.then846 ], [ %sp.19, %if.then838 ]
  %add.ptr849 = getelementptr inbounds %struct.sv** %sp.20, i64 1
  %170 = bitcast %struct.sv** %add.ptr849 to i8*
  %sv_any850 = getelementptr inbounds %struct.av* %ary.01245, i64 0, i32 0
  %171 = load %struct.xpvav** %sv_any850, align 8, !tbaa !0
  %xav_array851 = getelementptr inbounds %struct.xpvav* %171, i64 0, i32 0
  %172 = load i8** %xav_array851, align 8, !tbaa !0
  %mul853 = shl nsw i64 %conv843, 3
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %170, i8* %172, i64 %mul853, i32 1, i1 false)
  %add.ptr855 = getelementptr inbounds %struct.sv** %sp.20, i64 %conv843
  store %struct.sv** %add.ptr855, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %173 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %173, i64 0, i32 0
  %174 = load %struct.op** %op_next, align 8, !tbaa !0
  br label %return

if.else857:                                       ; preds = %if.then827
  store %struct.sv** %165, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  call void @Perl_push_scope() #7
  %call858 = call i32 @Perl_call_method(i8* getelementptr inbounds ([5 x i8]* @.str45, i64 0, i64 0), i32 2) #7
  call void @Perl_pop_scope() #7
  %175 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %cmp859 = icmp eq i32 %cond52, 1
  br i1 %cmp859, label %if.then861, label %if.end895

if.then861:                                       ; preds = %if.else857
  %176 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast862 = ptrtoint %struct.sv** %176 to i64
  %sub.ptr.rhs.cast863 = ptrtoint %struct.sv** %175 to i64
  %sub.ptr.sub864 = sub i64 %sub.ptr.lhs.cast862, %sub.ptr.rhs.cast863
  %sub.ptr.div865 = ashr exact i64 %sub.ptr.sub864, 3
  %conv866 = sext i32 %iters.1 to i64
  %cmp867 = icmp slt i64 %sub.ptr.div865, %conv866
  br i1 %cmp867, label %if.then869, label %for.cond872.preheader

if.then869:                                       ; preds = %if.then861
  %call870 = call %struct.sv** @Perl_stack_grow(%struct.sv** %175, %struct.sv** %175, i32 %iters.1) #7
  br label %for.cond872.preheader

for.cond872.preheader:                            ; preds = %if.then869, %if.then861
  %sp.22.ph = phi %struct.sv** [ %175, %if.then861 ], [ %call870, %if.then869 ]
  %cmp8731253 = icmp sgt i32 %iters.1, 0
  br i1 %cmp8731253, label %for.body875.lr.ph, label %for.end885

for.body875.lr.ph:                                ; preds = %for.cond872.preheader
  %177 = add i32 %iters.1, -1
  %178 = zext i32 %177 to i64
  %179 = add i64 %178, 1
  br label %for.body875

for.body875:                                      ; preds = %cond.end880, %for.body875.lr.ph
  %sp.221255 = phi %struct.sv** [ %sp.22.ph, %for.body875.lr.ph ], [ %incdec.ptr882, %cond.end880 ]
  %i.21254 = phi i32 [ 0, %for.body875.lr.ph ], [ %inc884, %cond.end880 ]
  %call876 = call %struct.sv** @Perl_av_fetch(%struct.av* %ary.01245, i32 %i.21254, i32 0) #7
  %tobool877 = icmp eq %struct.sv** %call876, null
  br i1 %tobool877, label %cond.end880, label %cond.true878

cond.true878:                                     ; preds = %for.body875
  %180 = load %struct.sv** %call876, align 8, !tbaa !0
  br label %cond.end880

cond.end880:                                      ; preds = %for.body875, %cond.true878
  %cond881 = phi %struct.sv* [ %180, %cond.true878 ], [ @PL_sv_undef, %for.body875 ]
  %incdec.ptr882 = getelementptr inbounds %struct.sv** %sp.221255, i64 1
  store %struct.sv* %cond881, %struct.sv** %incdec.ptr882, align 8, !tbaa !0
  %inc884 = add nsw i32 %i.21254, 1
  %exitcond = icmp eq i32 %inc884, %iters.1
  br i1 %exitcond, label %for.cond872.for.end885_crit_edge, label %for.body875

for.cond872.for.end885_crit_edge:                 ; preds = %cond.end880
  %scevgep = getelementptr %struct.sv** %sp.22.ph, i64 %179
  br label %for.end885

for.end885:                                       ; preds = %for.cond872.for.end885_crit_edge, %for.cond872.preheader
  %sp.22.lcssa = phi %struct.sv** [ %scevgep, %for.cond872.for.end885_crit_edge ], [ %sp.22.ph, %for.cond872.preheader ]
  store %struct.sv** %sp.22.lcssa, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %181 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next886 = getelementptr inbounds %struct.op* %181, i64 0, i32 0
  %182 = load %struct.op** %op_next886, align 8, !tbaa !0
  br label %return

if.else889:                                       ; preds = %if.end825
  %cmp890 = icmp eq i32 %cond52, 1
  br i1 %cmp890, label %if.then892, label %if.end895

if.then892:                                       ; preds = %if.else889
  store %struct.sv** %165, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %183 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next893 = getelementptr inbounds %struct.op* %183, i64 0, i32 0
  %184 = load %struct.op** %op_next893, align 8, !tbaa !0
  br label %return

if.end895:                                        ; preds = %if.else889, %if.else857, %if.end835
  %sp.23 = phi %struct.sv** [ %sp.19, %if.end835 ], [ %175, %if.else857 ], [ %165, %if.else889 ]
  %185 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %185, i64 0, i32 3
  %186 = load i64* %op_targ, align 8, !tbaa !3
  %187 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx896 = getelementptr inbounds %struct.sv** %187, i64 %186
  %188 = load %struct.sv** %arrayidx896, align 8, !tbaa !0
  %conv897 = sext i32 %iters.1 to i64
  call void @Perl_sv_setiv(%struct.sv* %188, i64 %conv897) #7
  %sv_flags898 = getelementptr inbounds %struct.sv* %188, i64 0, i32 2
  %189 = load i32* %sv_flags898, align 4, !tbaa !4
  %and899 = and i32 %189, 16384
  %tobool900 = icmp eq i32 %and899, 0
  br i1 %tobool900, label %if.end903, label %if.then901

if.then901:                                       ; preds = %if.end895
  %call902 = call i32 @Perl_mg_set(%struct.sv* %188) #7
  br label %if.end903

if.end903:                                        ; preds = %if.end895, %if.then901
  %incdec.ptr904 = getelementptr inbounds %struct.sv** %sp.23, i64 1
  store %struct.sv* %188, %struct.sv** %incdec.ptr904, align 8, !tbaa !0
  store %struct.sv** %incdec.ptr904, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %190 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next905 = getelementptr inbounds %struct.op* %190, i64 0, i32 0
  %191 = load %struct.op** %op_next905, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %if.end903, %if.then892, %for.end885, %if.end848, %if.then756, %if.then
  %retval.0 = phi %struct.op* [ %call757, %if.then756 ], [ %182, %for.end885 ], [ %191, %if.end903 ], [ %174, %if.end848 ], [ %184, %if.then892 ], [ %call56, %if.then ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare i64 @Perl_utf8_length(i8*, i8*) #1

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_AVadd(%struct.gv*) #1

; Function Attrs: optsize
declare void @Perl_av_clear(%struct.av*) #1

; Function Attrs: optsize
declare void @Perl_savestack_grow() #1

; Function Attrs: optsize
declare i16** @__ctype_b_loc() #1

; Function Attrs: optsize
declare void @Perl_save_int(i32*) #1

; Function Attrs: optsize
declare i8* @Perl_utf8_hop(i8*, i32) #1

; Function Attrs: optsize
declare void @Perl_leave_scope(i32) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_lock() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.sv** %0, align 8, !tbaa !0
  %2 = load void (%struct.sv*)** @PL_lockhook, align 8, !tbaa !0
  tail call void %2(%struct.sv* %1) #7
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %3 = load i32* %sv_flags, align 4, !tbaa !4
  %and = and i32 %3, 255
  %and.off = add i32 %and, -10
  %switch = icmp ult i32 %and.off, 3
  br i1 %switch, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call fastcc %struct.sv* @S_refto(%struct.sv* %1) #8
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %retsv.0 = phi %struct.sv* [ %call, %if.then ], [ %1, %entry ]
  store %struct.sv* %retsv.0, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %4 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !0
  ret %struct.op* %5
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pp_threadsv() #0 {
entry:
  %call = tail call %struct.op* (i8*, ...)* @Perl_die(i8* getelementptr inbounds ([53 x i8]* @.str49, i64 0, i64 0)) #7
  ret %struct.op* %call
}

; Function Attrs: optsize
declare void @Perl_vivify_defelem(%struct.sv*) #1

; Function Attrs: nounwind readnone
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64, i64) #6

attributes #0 = { nounwind optsize uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { optsize "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind optsize readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }
attributes #4 = { nounwind optsize readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind optsize readnone "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone }
attributes #7 = { nounwind optsize }
attributes #8 = { optsize }
attributes #9 = { nounwind optsize readnone }

!0 = metadata !{metadata !"any pointer", metadata !1}
!1 = metadata !{metadata !"omnipotent char", metadata !2}
!2 = metadata !{metadata !"Simple C/C++ TBAA"}
!3 = metadata !{metadata !"long", metadata !1}
!4 = metadata !{metadata !"int", metadata !1}
!5 = metadata !{metadata !"short", metadata !1}
!6 = metadata !{metadata !"double", metadata !1}
