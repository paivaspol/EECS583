define void @calc_cgcm(%struct.__sFILE* nocapture readnone %log, i32 %cg0, i32 %cg1, %struct.t_block* nocapture readonly %cgs, [3 x float]* nocapture readonly %pos, [3 x float]* nocapture %cg_cm) #4 {
  %cg = alloca [3 x float], align 4
  %1 = getelementptr inbounds %struct.t_block* %cgs, i64 0, i32 4
  %2 = load i32** %1, align 8, !tbaa !18
  %3 = getelementptr inbounds %struct.t_block* %cgs, i64 0, i32 2
  %4 = load i32** %3, align 8, !tbaa !20
  %5 = icmp slt i32 %cg0, %cg1
  br i1 %5, label %.lr.ph5, label %._crit_edge

.lr.ph5:                                          ; preds = %0
  %6 = getelementptr inbounds [3 x float]* %cg, i64 0, i64 0
  %7 = getelementptr inbounds [3 x float]* %cg, i64 0, i64 1
  %8 = getelementptr inbounds [3 x float]* %cg, i64 0, i64 2
  %9 = sext i32 %cg0 to i64
  %10 = add i32 %cg1, -1
  %.phi.trans.insert = getelementptr inbounds i32* %4, i64 %9
  %.pre = load i32* %.phi.trans.insert, align 4, !tbaa !17
  br label %11

; <label>:11                                      ; preds = %.backedge, %.lr.ph5
  %12 = phi i32 [ %.pre, %.lr.ph5 ], [ %14, %.backedge ]
  %indvars.iv12 = phi i64 [ %9, %.lr.ph5 ], [ %indvars.iv.next13, %.backedge ]
  %indvars.iv.next13 = add nsw i64 %indvars.iv12, 1
  %13 = getelementptr inbounds i32* %4, i64 %indvars.iv.next13
  %14 = load i32* %13, align 4, !tbaa !17
  %15 = sub nsw i32 %14, %12
  %16 = icmp eq i32 %15, 1
  br i1 %16, label %17, label %37

; <label>:17                                      ; preds = %11
  %18 = sext i32 %12 to i64
  %19 = getelementptr inbounds i32* %2, i64 %18
  %20 = load i32* %19, align 4, !tbaa !17
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds [3 x float]* %pos, i64 %21, i64 0
  %23 = getelementptr inbounds [3 x float]* %cg_cm, i64 %indvars.iv12, i64 0
  %24 = bitcast float* %22 to i32*
  %25 = load i32* %24, align 4, !tbaa !14
  %26 = bitcast float* %23 to i32*
  store i32 %25, i32* %26, align 4, !tbaa !14
  %27 = getelementptr inbounds [3 x float]* %pos, i64 %21, i64 1
  %28 = bitcast float* %27 to i32*
  %29 = load i32* %28, align 4, !tbaa !14
  %30 = getelementptr inbounds [3 x float]* %cg_cm, i64 %indvars.iv12, i64 1
  %31 = bitcast float* %30 to i32*
  store i32 %29, i32* %31, align 4, !tbaa !14
  %32 = getelementptr inbounds [3 x float]* %pos, i64 %21, i64 2
  %33 = bitcast float* %32 to i32*
  %34 = load i32* %33, align 4, !tbaa !14
  %35 = getelementptr inbounds [3 x float]* %cg_cm, i64 %indvars.iv12, i64 2
  %36 = bitcast float* %35 to i32*
  store i32 %34, i32* %36, align 4, !tbaa !14
  br label %.backedge

.backedge:                                        ; preds = %.preheader, %17
  %lftr.wideiv14 = trunc i64 %indvars.iv12 to i32
  %exitcond15 = icmp eq i32 %lftr.wideiv14, %10
  br i1 %exitcond15, label %._crit_edge, label %11

; <label>:37                                      ; preds = %11
  %38 = sitofp i32 %15 to double
  %39 = fdiv double 1.000000e+00, %38
  %40 = fptrunc double %39 to float
  store float 0.000000e+00, float* %6, align 4, !tbaa !14
  store float 0.000000e+00, float* %7, align 4, !tbaa !14
  store float 0.000000e+00, float* %8, align 4, !tbaa !14
  %41 = icmp sgt i32 %14, %12
  br i1 %41, label %.lr.ph, label %.preheader

.lr.ph:                                           ; preds = %37
  %42 = sext i32 %12 to i64
  %43 = add i32 %14, -1
  br label %44

; <label>:44                                      ; preds = %54, %.lr.ph
  %indvars.iv6 = phi i64 [ %42, %.lr.ph ], [ %indvars.iv.next7, %54 ]
  %45 = getelementptr inbounds i32* %2, i64 %indvars.iv6
  %46 = load i32* %45, align 4, !tbaa !17
  %47 = sext i32 %46 to i64
  br label %48

; <label>:48                                      ; preds = %48, %44
  %indvars.iv = phi i64 [ 0, %44 ], [ %indvars.iv.next, %48 ]
  %49 = getelementptr inbounds [3 x float]* %pos, i64 %47, i64 %indvars.iv
  %50 = load float* %49, align 4, !tbaa !14
  %51 = getelementptr inbounds [3 x float]* %cg, i64 0, i64 %indvars.iv
  %52 = load float* %51, align 4, !tbaa !14
  %53 = fadd float %50, %52
  store float %53, float* %51, align 4, !tbaa !14
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 3
  br i1 %exitcond, label %54, label %48

; <label>:54                                      ; preds = %48
  %indvars.iv.next7 = add nsw i64 %indvars.iv6, 1
  %lftr.wideiv = trunc i64 %indvars.iv6 to i32
  %exitcond8 = icmp eq i32 %lftr.wideiv, %43
  br i1 %exitcond8, label %.preheader, label %44

.preheader:                                       ; preds = %37, %54, %.preheader
  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %.preheader ], [ 0, %54 ], [ 0, %37 ]
  %55 = getelementptr inbounds [3 x float]* %cg, i64 0, i64 %indvars.iv9
  %56 = load float* %55, align 4, !tbaa !14
  %57 = fmul float %40, %56
  %58 = getelementptr inbounds [3 x float]* %cg_cm, i64 %indvars.iv12, i64 %indvars.iv9
  store float %57, float* %58, align 4, !tbaa !14
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
  %exitcond11 = icmp eq i64 %indvars.iv.next10, 3
  br i1 %exitcond11, label %.backedge, label %.preheader

._crit_edge:                                      ; preds = %.backedge, %0
  ret void
}
