define float @pdihs(i32 %nbonds, i32* nocapture readonly %forceatoms, %union.t_iparams* nocapture readonly %forceparams, [3 x float]* nocapture readonly %x, [3 x float]* nocapture %f, %struct.t_forcerec* nocapture readonly %fr, %struct.t_graph* nocapture readonly %g, [3 x float]* nocapture readnone %box, float %lambda, float* nocapture %dvdlambda, %struct.t_mdatoms* nocapture readnone %md, i32 %ngrp, float* nocapture readnone %egnb, float* nocapture readnone %egcoul, %struct.t_fcdata* nocapture readnone %fcd) #3 {
  %r_ij = alloca [3 x float], align 4
  %r_kj = alloca [3 x float], align 4
  %r_kl = alloca [3 x float], align 4
  %m = alloca [3 x float], align 4
  %n = alloca [3 x float], align 4
  %cos_phi = alloca float, align 4
  %sign = alloca float, align 4
  %1 = icmp sgt i32 %nbonds, 0
  br i1 %1, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %2 = getelementptr inbounds [3 x float]* %r_ij, i64 0, i64 0
  %3 = getelementptr inbounds [3 x float]* %r_kj, i64 0, i64 0
  %4 = getelementptr inbounds [3 x float]* %r_kl, i64 0, i64 0
  %5 = getelementptr inbounds [3 x float]* %m, i64 0, i64 0
  %6 = getelementptr inbounds [3 x float]* %n, i64 0, i64 0
  %7 = fsub float 1.000000e+00, %lambda
  %8 = sext i32 %nbonds to i64
  br label %9

; <label>:9                                       ; preds = %.lr.ph, %9
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %9 ]
  %vtot.02 = phi float [ 0.000000e+00, %.lr.ph ], [ %75, %9 ]
  %10 = add nuw nsw i64 %indvars.iv, 1
  %11 = getelementptr inbounds i32* %forceatoms, i64 %indvars.iv
  %12 = load i32* %11, align 4, !tbaa !36
  %13 = add nuw nsw i64 %indvars.iv, 2
  %14 = getelementptr inbounds i32* %forceatoms, i64 %10
  %15 = load i32* %14, align 4, !tbaa !36
  %16 = add nuw nsw i64 %indvars.iv, 3
  %17 = getelementptr inbounds i32* %forceatoms, i64 %13
  %18 = load i32* %17, align 4, !tbaa !36
  %19 = add nuw nsw i64 %indvars.iv, 4
  %20 = getelementptr inbounds i32* %forceatoms, i64 %16
  %21 = load i32* %20, align 4, !tbaa !36
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 5
  %22 = getelementptr inbounds i32* %forceatoms, i64 %19
  %23 = load i32* %22, align 4, !tbaa !36
  %24 = sext i32 %15 to i64
  %25 = getelementptr inbounds [3 x float]* %x, i64 %24, i64 0
  %26 = sext i32 %18 to i64
  %27 = getelementptr inbounds [3 x float]* %x, i64 %26, i64 0
  %28 = sext i32 %21 to i64
  %29 = getelementptr inbounds [3 x float]* %x, i64 %28, i64 0
  %30 = sext i32 %23 to i64
  %31 = getelementptr inbounds [3 x float]* %x, i64 %30, i64 0
  %32 = call float @dih_angle([3 x float]* undef, float* %25, float* %27, float* %29, float* %31, float* %2, float* %3, float* %4, float* %5, float* %6, float* %cos_phi, float* %sign) #11
  %33 = sext i32 %12 to i64
  %34 = getelementptr inbounds %union.t_iparams* %forceparams, i64 %33, i32 0, i32 1
  %35 = load float* %34, align 4, !tbaa !59
  %36 = getelementptr inbounds %union.t_iparams* %forceparams, i64 %33, i32 0, i32 4
  %37 = load float* %36, align 4, !tbaa !61
  %38 = getelementptr inbounds %union.t_iparams* %forceparams, i64 %33, i32 0, i32 0
  %39 = load float* %38, align 4, !tbaa !62
  %40 = getelementptr inbounds %union.t_iparams* %forceparams, i64 %33, i32 0, i32 3
  %41 = load float* %40, align 4, !tbaa !63
  %42 = getelementptr inbounds %union.t_iparams* %forceparams, i64 %33, i32 0, i32 2
  %43 = bitcast float* %42 to i32*
  %44 = load i32* %43, align 4, !tbaa !64
  %45 = fmul float %7, %39
  %46 = fmul float %41, %lambda
  %47 = fadd float %45, %46
  %48 = fpext float %47 to double
  %49 = fmul double %48, 0x3F91DF46A2529D39
  %50 = fptrunc double %49 to float
  %51 = fmul float %7, %35
  %52 = fmul float %37, %lambda
  %53 = fadd float %51, %52
  %54 = sitofp i32 %44 to float
  %55 = fmul float %32, %54
  %56 = fsub float %55, %50
  %57 = fpext float %56 to double
  %58 = tail call double @sin(double %57) #10
  %59 = fptrunc double %58 to float
  %60 = fmul float %53, %54
  %61 = fmul float %60, %59
  %62 = fsub float -0.000000e+00, %61
  %63 = tail call double @cos(double %57) #10
  %64 = fadd double %63, 1.000000e+00
  %65 = fptrunc double %64 to float
  %66 = fmul float %53, %65
  %67 = fsub float %37, %35
  %68 = fmul float %67, %65
  %69 = fsub float %39, %41
  %70 = fmul float %53, %69
  %71 = fmul float %70, %59
  %72 = fsub float %68, %71
  %73 = load float* %dvdlambda, align 4, !tbaa !14
  %74 = fadd float %73, %72
  store float %74, float* %dvdlambda, align 4, !tbaa !14
  %75 = fadd float %vtot.02, %66
  call void @do_dih_fup(i32 %15, i32 %18, i32 %21, i32 %23, float %62, float* %2, float* %3, float* %4, float* %5, float* %6, [3 x float]* %f, %struct.t_forcerec* %fr, %struct.t_graph* %g, [3 x float]* undef) #11
  %76 = icmp slt i64 %indvars.iv.next, %8
  br i1 %76, label %9, label %._crit_edge

._crit_edge:                                      ; preds = %9, %0
  %vtot.0.lcssa = phi float [ 0.000000e+00, %0 ], [ %75, %9 ]
  ret float %vtot.0.lcssa
}
