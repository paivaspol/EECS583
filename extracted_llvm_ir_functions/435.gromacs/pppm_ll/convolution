define void @convolution(%struct.__sFILE* nocapture readnone %fp, i32 %bVerbose, %struct.t_fftgrid* %grid, float*** nocapture readonly %ghat, %struct.t_commrec* nocapture readonly %cr) #1 {
  %nx = alloca i32, align 4
  %ny = alloca i32, align 4
  %nz = alloca i32, align 4
  %la2 = alloca i32, align 4
  %la12 = alloca i32, align 4
  %ptr = alloca %struct.t_fft_c*, align 8
  %1 = bitcast %struct.t_fft_c** %ptr to float**
  call void @unpack_fftgrid(%struct.t_fftgrid* %grid, i32* %nx, i32* %ny, i32* %nz, i32* %la2, i32* %la12, i32 0, float** %1) #6
  %2 = getelementptr inbounds %struct.t_fftgrid* %grid, i64 0, i32 10
  %3 = load i32* %2, align 4, !tbaa !14
  %4 = call i8* @save_calloc(i8* getelementptr inbounds ([6 x i8]* @.str3, i64 0, i64 0), i8* getelementptr inbounds ([64 x i8]* @.str4, i64 0, i64 0), i32 373, i32 %3, i32 4) #6
  %5 = bitcast i8* %4 to i32*
  %6 = getelementptr inbounds %struct.t_commrec* %cr, i64 0, i32 1
  %7 = load i32* %6, align 4, !tbaa !15
  %8 = icmp sgt i32 %7, 1
  br i1 %8, label %.loopexit, label %9

; <label>:9                                       ; preds = %0
  %10 = getelementptr inbounds %struct.t_commrec* %cr, i64 0, i32 5
  %11 = load i32* %10, align 4, !tbaa !17
  %12 = icmp sgt i32 %11, 1
  br i1 %12, label %.loopexit, label %.preheader2

.preheader2:                                      ; preds = %9
  %13 = load i32* %nx, align 4, !tbaa !6
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %.preheader1.lr.ph, label %.loopexit

.preheader1.lr.ph:                                ; preds = %.preheader2
  %15 = load %struct.t_fft_c** %ptr, align 8, !tbaa !8
  %.pre = load i32* %ny, align 4, !tbaa !6
  br label %.preheader1

.preheader1:                                      ; preds = %.preheader1.lr.ph, %57
  %16 = phi i32 [ %13, %.preheader1.lr.ph ], [ %58, %57 ]
  %17 = phi i32 [ %.pre, %.preheader1.lr.ph ], [ %59, %57 ]
  %indvars.iv11 = phi i64 [ 0, %.preheader1.lr.ph ], [ %indvars.iv.next12, %57 ]
  %18 = icmp sgt i32 %17, 0
  br i1 %18, label %.preheader.lr.ph, label %57

.preheader.lr.ph:                                 ; preds = %.preheader1
  %19 = getelementptr inbounds float*** %ghat, i64 %indvars.iv11
  %.pre13 = load i32* %nz, align 4, !tbaa !6
  br label %.preheader

.preheader:                                       ; preds = %.preheader.lr.ph, %52
  %20 = phi i32 [ %17, %.preheader.lr.ph ], [ %53, %52 ]
  %21 = phi i32 [ %.pre13, %.preheader.lr.ph ], [ %54, %52 ]
  %indvars.iv9 = phi i64 [ 0, %.preheader.lr.ph ], [ %indvars.iv.next10, %52 ]
  %22 = icmp sgt i32 %21, -2
  br i1 %22, label %.lr.ph, label %52

.lr.ph:                                           ; preds = %.preheader
  %23 = load float*** %19, align 8, !tbaa !8
  %24 = getelementptr inbounds float** %23, i64 %indvars.iv9
  %25 = load float** %24, align 8, !tbaa !8
  br label %26

; <label>:26                                      ; preds = %.lr.ph, %26
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %26 ]
  %27 = getelementptr inbounds float* %25, i64 %indvars.iv
  %28 = load float* %27, align 4, !tbaa !2
  %29 = load i32* %la12, align 4, !tbaa !6
  %30 = trunc i64 %indvars.iv11 to i32
  %31 = mul nsw i32 %29, %30
  %32 = load i32* %la2, align 4, !tbaa !6
  %33 = trunc i64 %indvars.iv9 to i32
  %34 = mul nsw i32 %32, %33
  %35 = trunc i64 %indvars.iv to i32
  %36 = add i32 %31, %35
  %37 = add i32 %36, %34
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds %struct.t_fft_c* %15, i64 %38, i32 0
  %40 = load float* %39, align 4, !tbaa !18
  %41 = fmul float %28, %40
  store float %41, float* %39, align 4, !tbaa !18
  %42 = getelementptr inbounds %struct.t_fft_c* %15, i64 %38, i32 1
  %43 = load float* %42, align 4, !tbaa !20
  %44 = fmul float %28, %43
  store float %44, float* %42, align 4, !tbaa !20
  %45 = getelementptr inbounds i32* %5, i64 %38
  %46 = load i32* %45, align 4, !tbaa !6
  %47 = add nsw i32 %46, 1
  store i32 %47, i32* %45, align 4, !tbaa !6
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  %48 = load i32* %nz, align 4, !tbaa !6
  %49 = sdiv i32 %48, 2
  %50 = sext i32 %49 to i64
  %51 = icmp slt i64 %indvars.iv, %50
  br i1 %51, label %26, label %._crit_edge

._crit_edge:                                      ; preds = %26
  %.pre14 = load i32* %ny, align 4, !tbaa !6
  br label %52

; <label>:52                                      ; preds = %._crit_edge, %.preheader
  %53 = phi i32 [ %.pre14, %._crit_edge ], [ %20, %.preheader ]
  %54 = phi i32 [ %48, %._crit_edge ], [ %21, %.preheader ]
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
  %55 = sext i32 %53 to i64
  %56 = icmp slt i64 %indvars.iv.next10, %55
  br i1 %56, label %.preheader, label %._crit_edge6

._crit_edge6:                                     ; preds = %52
  %.pre15 = load i32* %nx, align 4, !tbaa !6
  br label %57

; <label>:57                                      ; preds = %._crit_edge6, %.preheader1
  %58 = phi i32 [ %.pre15, %._crit_edge6 ], [ %16, %.preheader1 ]
  %59 = phi i32 [ %53, %._crit_edge6 ], [ %17, %.preheader1 ]
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  %60 = sext i32 %58 to i64
  %61 = icmp slt i64 %indvars.iv.next12, %60
  br i1 %61, label %.preheader1, label %.loopexit

.loopexit:                                        ; preds = %57, %.preheader2, %0, %9
  call void @save_free(i8* getelementptr inbounds ([6 x i8]* @.str3, i64 0, i64 0), i8* getelementptr inbounds ([64 x i8]* @.str4, i64 0, i64 0), i32 427, i8* %4) #6
  ret void
}
