define void @convolution(%struct._IO_FILE* nocapture %fp, i32 %bVerbose, %struct.t_fftgrid* %grid, float*** nocapture %ghat, %struct.t_commrec* nocapture %cr) #0 {
entry:
  %nx = alloca i32, align 4
  %ny = alloca i32, align 4
  %nz = alloca i32, align 4
  %la2 = alloca i32, align 4
  %la12 = alloca i32, align 4
  %ptr = alloca %struct.t_fft_c*, align 8
  %0 = bitcast %struct.t_fft_c** %ptr to float**
  call void @unpack_fftgrid(%struct.t_fftgrid* %grid, i32* %nx, i32* %ny, i32* %nz, i32* %la2, i32* %la12, i32 0, float** %0) #4
  %nptr = getelementptr inbounds %struct.t_fftgrid* %grid, i64 0, i32 10
  %1 = load i32* %nptr, align 4, !tbaa !3
  %call = call i8* @save_calloc(i8* getelementptr inbounds ([6 x i8]* @.str3, i64 0, i64 0), i8* getelementptr inbounds ([52 x i8]* @.str4, i64 0, i64 0), i32 373, i32 %1, i32 4) #4
  %2 = bitcast i8* %call to i32*
  %nnodes = getelementptr inbounds %struct.t_commrec* %cr, i64 0, i32 1
  %3 = load i32* %nnodes, align 4, !tbaa !3
  %cmp = icmp sgt i32 %3, 1
  br i1 %cmp, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %nthreads = getelementptr inbounds %struct.t_commrec* %cr, i64 0, i32 5
  %4 = load i32* %nthreads, align 4, !tbaa !3
  %cmp1 = icmp sgt i32 %4, 1
  br i1 %cmp1, label %if.end, label %for.cond.preheader

for.cond.preheader:                               ; preds = %lor.lhs.false
  %5 = load i32* %nx, align 4, !tbaa !3
  %cmp253 = icmp sgt i32 %5, 0
  br i1 %cmp253, label %for.cond3.preheader.lr.ph, label %if.end

for.cond3.preheader.lr.ph:                        ; preds = %for.cond.preheader
  %6 = load %struct.t_fft_c** %ptr, align 8, !tbaa !4
  %.pre = load i32* %ny, align 4, !tbaa !3
  br label %for.cond3.preheader

for.cond3.preheader:                              ; preds = %for.cond3.preheader.lr.ph, %for.inc28
  %7 = phi i32 [ %5, %for.cond3.preheader.lr.ph ], [ %26, %for.inc28 ]
  %8 = phi i32 [ %.pre, %for.cond3.preheader.lr.ph ], [ %27, %for.inc28 ]
  %indvars.iv58 = phi i64 [ 0, %for.cond3.preheader.lr.ph ], [ %indvars.iv.next59, %for.inc28 ]
  %cmp450 = icmp sgt i32 %8, 0
  br i1 %cmp450, label %for.cond6.preheader.lr.ph, label %for.inc28

for.cond6.preheader.lr.ph:                        ; preds = %for.cond3.preheader
  %arrayidx = getelementptr inbounds float*** %ghat, i64 %indvars.iv58
  %.pre61 = load i32* %nz, align 4, !tbaa !3
  br label %for.cond6.preheader

for.cond6.preheader:                              ; preds = %for.cond6.preheader.lr.ph, %for.inc25
  %9 = phi i32 [ %8, %for.cond6.preheader.lr.ph ], [ %23, %for.inc25 ]
  %10 = phi i32 [ %.pre61, %for.cond6.preheader.lr.ph ], [ %24, %for.inc25 ]
  %indvars.iv56 = phi i64 [ 0, %for.cond6.preheader.lr.ph ], [ %indvars.iv.next57, %for.inc25 ]
  %cmp748 = icmp sgt i32 %10, -2
  br i1 %cmp748, label %for.body8.lr.ph, label %for.inc25

for.body8.lr.ph:                                  ; preds = %for.cond6.preheader
  %11 = load float*** %arrayidx, align 8, !tbaa !4
  %arrayidx11 = getelementptr inbounds float** %11, i64 %indvars.iv56
  %12 = load float** %arrayidx11, align 8, !tbaa !4
  br label %for.body8

for.body8:                                        ; preds = %for.body8.lr.ph, %for.body8
  %indvars.iv = phi i64 [ 0, %for.body8.lr.ph ], [ %indvars.iv.next, %for.body8 ]
  %arrayidx12 = getelementptr inbounds float* %12, i64 %indvars.iv
  %13 = load float* %arrayidx12, align 4, !tbaa !0
  %14 = load i32* %la12, align 4, !tbaa !3
  %15 = trunc i64 %indvars.iv58 to i32
  %mul = mul nsw i32 %14, %15
  %16 = load i32* %la2, align 4, !tbaa !3
  %17 = trunc i64 %indvars.iv56 to i32
  %mul13 = mul nsw i32 %16, %17
  %18 = trunc i64 %indvars.iv to i32
  %add14 = add i32 %mul, %18
  %add15 = add i32 %add14, %mul13
  %idxprom16 = sext i32 %add15 to i64
  %re = getelementptr inbounds %struct.t_fft_c* %6, i64 %idxprom16, i32 0
  %19 = load float* %re, align 4, !tbaa !0
  %mul18 = fmul float %13, %19
  store float %mul18, float* %re, align 4, !tbaa !0
  %im = getelementptr inbounds %struct.t_fft_c* %6, i64 %idxprom16, i32 1
  %20 = load float* %im, align 4, !tbaa !0
  %mul21 = fmul float %13, %20
  store float %mul21, float* %im, align 4, !tbaa !0
  %arrayidx23 = getelementptr inbounds i32* %2, i64 %idxprom16
  %21 = load i32* %arrayidx23, align 4, !tbaa !3
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %arrayidx23, align 4, !tbaa !3
  %indvars.iv.next = add i64 %indvars.iv, 1
  %22 = load i32* %nz, align 4, !tbaa !3
  %div = sdiv i32 %22, 2
  %cmp7 = icmp slt i32 %18, %div
  br i1 %cmp7, label %for.body8, label %for.cond6.for.inc25_crit_edge

for.cond6.for.inc25_crit_edge:                    ; preds = %for.body8
  %.pre62 = load i32* %ny, align 4, !tbaa !3
  br label %for.inc25

for.inc25:                                        ; preds = %for.cond6.for.inc25_crit_edge, %for.cond6.preheader
  %23 = phi i32 [ %.pre62, %for.cond6.for.inc25_crit_edge ], [ %9, %for.cond6.preheader ]
  %24 = phi i32 [ %22, %for.cond6.for.inc25_crit_edge ], [ %10, %for.cond6.preheader ]
  %indvars.iv.next57 = add i64 %indvars.iv56, 1
  %25 = trunc i64 %indvars.iv.next57 to i32
  %cmp4 = icmp slt i32 %25, %23
  br i1 %cmp4, label %for.cond6.preheader, label %for.cond3.for.inc28_crit_edge

for.cond3.for.inc28_crit_edge:                    ; preds = %for.inc25
  %.pre60 = load i32* %nx, align 4, !tbaa !3
  br label %for.inc28

for.inc28:                                        ; preds = %for.cond3.for.inc28_crit_edge, %for.cond3.preheader
  %26 = phi i32 [ %.pre60, %for.cond3.for.inc28_crit_edge ], [ %7, %for.cond3.preheader ]
  %27 = phi i32 [ %23, %for.cond3.for.inc28_crit_edge ], [ %8, %for.cond3.preheader ]
  %indvars.iv.next59 = add i64 %indvars.iv58, 1
  %28 = trunc i64 %indvars.iv.next59 to i32
  %cmp2 = icmp slt i32 %28, %26
  br i1 %cmp2, label %for.cond3.preheader, label %if.end

if.end:                                           ; preds = %for.cond.preheader, %for.inc28, %entry, %lor.lhs.false
  call void @save_free(i8* getelementptr inbounds ([6 x i8]* @.str3, i64 0, i64 0), i8* getelementptr inbounds ([52 x i8]* @.str4, i64 0, i64 0), i32 427, i8* %call) #4
  ret void
}
