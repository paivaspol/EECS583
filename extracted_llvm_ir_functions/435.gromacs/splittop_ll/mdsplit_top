define void @mdsplit_top(%struct.__sFILE* nocapture readnone %log, %struct.t_topology* nocapture %top, %struct.t_commrec* nocapture readonly %cr, %struct.t_nsborder* nocapture readonly %nsb, i32* nocapture %bParallelDummies, %struct.t_comm_dummies* nocapture %dummycomm) #3 {
  %1 = getelementptr inbounds %struct.t_commrec* %cr, i64 0, i32 1
  %2 = load i32* %1, align 4, !tbaa !25
  %3 = icmp slt i32 %2, 2
  br i1 %3, label %split_idef.exit, label %4

; <label>:4                                       ; preds = %0
  %5 = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1
  %6 = tail call i32 @setup_parallel_dummies(%struct.t_idef* %5, %struct.t_commrec* %cr, %struct.t_nsborder* %nsb, %struct.t_comm_dummies* %dummycomm) #5
  store i32 %6, i32* %bParallelDummies, align 4, !tbaa !14
  %7 = getelementptr inbounds %struct.t_commrec* %cr, i64 0, i32 0
  br label %8

; <label>:8                                       ; preds = %split_ilist.exit.i, %4
  %indvars.iv.i = phi i64 [ 0, %4 ], [ %indvars.iv.next.i, %split_ilist.exit.i ]
  %9 = load i32* %7, align 4, !tbaa !23
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %16, label %11

; <label>:11                                      ; preds = %8
  %12 = add nsw i32 %9, -1
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1, i32 5, i64 %indvars.iv.i, i32 1, i64 %13
  %15 = load i32* %14, align 4, !tbaa !14
  br label %16

; <label>:16                                      ; preds = %11, %8
  %start.0.i.i = phi i32 [ %15, %11 ], [ 0, %8 ]
  %17 = sext i32 %9 to i64
  %18 = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1, i32 5, i64 %indvars.iv.i, i32 1, i64 %17
  %19 = load i32* %18, align 4, !tbaa !14
  %20 = sub nsw i32 %19, %start.0.i.i
  %21 = icmp slt i32 %20, 0
  br i1 %21, label %.thread.i.i, label %23

.thread.i.i:                                      ; preds = %16
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([113 x i8]* @.str7, i64 0, i64 0), i32 %20, i32 %9) #4
  %22 = tail call i8* @save_calloc(i8* getelementptr inbounds ([3 x i8]* @.str8, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8]* @.str1, i64 0, i64 0), i32 222, i32 %20, i32 4) #4
  br label %._crit_edge6.i.i

; <label>:23                                      ; preds = %16
  %24 = tail call i8* @save_calloc(i8* getelementptr inbounds ([3 x i8]* @.str8, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8]* @.str1, i64 0, i64 0), i32 222, i32 %20, i32 4) #4
  %25 = bitcast i8* %24 to i32*
  %26 = icmp sgt i32 %20, 0
  br i1 %26, label %.lr.ph.i.i, label %._crit_edge6.i.i

._crit_edge6.i.i:                                 ; preds = %23, %.thread.i.i
  %27 = phi i8* [ %22, %.thread.i.i ], [ %24, %23 ]
  %.phi.trans.insert.i.i = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1, i32 5, i64 %indvars.iv.i, i32 2
  %.phi.trans.insert7.i.i = bitcast i32** %.phi.trans.insert.i.i to i8**
  %.pre.i.i = load i8** %.phi.trans.insert7.i.i, align 8, !tbaa !21
  br label %overflow.checked

.lr.ph.i.i:                                       ; preds = %23
  %28 = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1, i32 5, i64 %indvars.iv.i, i32 2
  %29 = load i32** %28, align 8, !tbaa !21
  %30 = sext i32 %start.0.i.i to i64
  %31 = add i32 %19, -1
  %32 = sub i32 %31, %start.0.i.i
  br label %33

; <label>:33                                      ; preds = %33, %.lr.ph.i.i
  %indvars.iv3.i.i = phi i64 [ 0, %.lr.ph.i.i ], [ %indvars.iv.next4.i.i, %33 ]
  %34 = add nsw i64 %indvars.iv3.i.i, %30
  %35 = getelementptr inbounds i32* %29, i64 %34
  %36 = load i32* %35, align 4, !tbaa !14
  %37 = getelementptr inbounds i32* %25, i64 %indvars.iv3.i.i
  store i32 %36, i32* %37, align 4, !tbaa !14
  %indvars.iv.next4.i.i = add nuw nsw i64 %indvars.iv3.i.i, 1
  %lftr.wideiv = trunc i64 %indvars.iv3.i.i to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %32
  br i1 %exitcond, label %._crit_edge.i.i, label %33

._crit_edge.i.i:                                  ; preds = %33
  %38 = bitcast i32* %29 to i8*
  %.pre8.i.i = bitcast i32** %28 to i8**
  br label %overflow.checked

overflow.checked:                                 ; preds = %._crit_edge.i.i, %._crit_edge6.i.i
  %39 = phi i8* [ %27, %._crit_edge6.i.i ], [ %24, %._crit_edge.i.i ]
  %.pre-phi9.i.i = phi i8** [ %.phi.trans.insert7.i.i, %._crit_edge6.i.i ], [ %.pre8.i.i, %._crit_edge.i.i ]
  %40 = phi i8* [ %.pre.i.i, %._crit_edge6.i.i ], [ %38, %._crit_edge.i.i ]
  tail call void @save_free(i8* getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), i8* getelementptr inbounds ([68 x i8]* @.str1, i64 0, i64 0), i32 227, i8* %40) #4
  store i8* %39, i8** %.pre-phi9.i.i, align 8, !tbaa !21
  %broadcast.splatinsert1 = insertelement <4 x i32> undef, i32 %20, i32 0
  %broadcast.splat2 = shufflevector <4 x i32> %broadcast.splatinsert1, <4 x i32> undef, <4 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %overflow.checked
  %index = phi i64 [ 0, %overflow.checked ], [ %index.next, %vector.body ]
  %41 = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1, i32 5, i64 %indvars.iv.i, i32 1, i64 %index
  %42 = bitcast i32* %41 to <4 x i32>*
  store <4 x i32> %broadcast.splat2, <4 x i32>* %42, align 4, !tbaa !14
  %index.next = add i64 %index, 4
  %43 = icmp eq i64 %index.next, 256
  br i1 %43, label %split_ilist.exit.i, label %vector.body, !llvm.loop !26

split_ilist.exit.i:                               ; preds = %vector.body
  %44 = getelementptr inbounds %struct.t_topology* %top, i64 0, i32 1, i32 5, i64 %indvars.iv.i, i32 0
  store i32 %20, i32* %44, align 4, !tbaa !19
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond2.i = icmp eq i64 %indvars.iv.next.i, 44
  br i1 %exitcond2.i, label %split_idef.exit, label %8

split_idef.exit:                                  ; preds = %split_ilist.exit.i, %0
  ret void
}
