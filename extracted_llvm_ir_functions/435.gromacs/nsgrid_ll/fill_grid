define void @fill_grid(%struct.__sFILE* nocapture readnone %log, i32 %bDD, i32* nocapture readonly %cg_index, %struct.t_grid* nocapture readonly %grid, [3 x float]* nocapture readonly %box, i32 %ncg, i32 %cg0, i32 %cg1, [3 x float]* nocapture readonly %cg_cm) #4 {
  %1 = getelementptr inbounds %struct.t_grid* %grid, i64 0, i32 8
  %2 = load i32** %1, align 8, !tbaa !28
  %3 = bitcast i32* %2 to i8*
  %4 = getelementptr inbounds %struct.t_grid* %grid, i64 0, i32 1
  %5 = load i32* %4, align 4, !tbaa !21
  %6 = getelementptr inbounds %struct.t_grid* %grid, i64 0, i32 2
  %7 = load i32* %6, align 4, !tbaa !22
  %8 = getelementptr inbounds %struct.t_grid* %grid, i64 0, i32 3
  %9 = load i32* %8, align 4, !tbaa !23
  %10 = sitofp i32 %5 to float
  %11 = getelementptr inbounds [3 x float]* %box, i64 0, i64 0
  %12 = load float* %11, align 4, !tbaa !14
  %13 = fpext float %12 to double
  %14 = fcmp olt double %13, 1.200000e-38
  br i1 %14, label %15, label %_divide.exit

; <label>:15                                      ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([35 x i8]* @.str33, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str1, i64 0, i64 0), i32 282) #8
  br label %_divide.exit

_divide.exit:                                     ; preds = %0, %15
  %16 = fdiv float %10, %12
  %17 = sitofp i32 %7 to float
  %18 = getelementptr inbounds [3 x float]* %box, i64 1, i64 1
  %19 = load float* %18, align 4, !tbaa !14
  %20 = fpext float %19 to double
  %21 = fcmp olt double %20, 1.200000e-38
  br i1 %21, label %22, label %_divide.exit2

; <label>:22                                      ; preds = %_divide.exit
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([35 x i8]* @.str33, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str1, i64 0, i64 0), i32 283) #8
  br label %_divide.exit2

_divide.exit2:                                    ; preds = %_divide.exit, %22
  %23 = fdiv float %17, %19
  %24 = sitofp i32 %9 to float
  %25 = getelementptr inbounds [3 x float]* %box, i64 2, i64 2
  %26 = load float* %25, align 4, !tbaa !14
  %27 = fpext float %26 to double
  %28 = fcmp olt double %27, 1.200000e-38
  br i1 %28, label %29, label %_divide.exit3

; <label>:29                                      ; preds = %_divide.exit2
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([35 x i8]* @.str33, i64 0, i64 0), i8* getelementptr inbounds ([66 x i8]* @.str1, i64 0, i64 0), i32 284) #8
  br label %_divide.exit3

_divide.exit3:                                    ; preds = %_divide.exit2, %29
  %30 = fdiv float %24, %26
  %31 = icmp sgt i32 %cg0, 0
  br i1 %31, label %.lr.ph10, label %36

.lr.ph10:                                         ; preds = %_divide.exit3
  %32 = add i32 %cg0, -1
  %33 = zext i32 %32 to i64
  %34 = shl nuw nsw i64 %33, 2
  %35 = add nuw nsw i64 %34, 4
  call void @llvm.memset.p0i8.i64(i8* %3, i8 -1, i64 %35, i32 4, i1 false)
  br label %36

; <label>:36                                      ; preds = %.lr.ph10, %_divide.exit3
  %37 = load %struct.__sFILE** @debug, align 8, !tbaa !32
  %38 = icmp eq %struct.__sFILE* %37, null
  br i1 %38, label %.preheader5, label %39

; <label>:39                                      ; preds = %36
  %40 = tail call i32 (%struct.__sFILE*, i8*, ...)* @fprintf(%struct.__sFILE* %37, i8* getelementptr inbounds ([39 x i8]* @.str13, i64 0, i64 0), i32 %cg0, i32 %cg1, i32 %ncg) #8
  br label %.preheader5

.preheader5:                                      ; preds = %36, %39
  %41 = icmp slt i32 %cg0, %cg1
  br i1 %41, label %.lr.ph8, label %.preheader

.lr.ph8:                                          ; preds = %.preheader5
  %42 = add nsw i32 %5, -1
  %43 = add nsw i32 %7, -1
  %44 = add nsw i32 %9, -1
  %45 = sext i32 %cg0 to i64
  %46 = add i32 %cg1, -1
  br label %54

.preheader:                                       ; preds = %54, %.preheader5
  %i.1.lcssa = phi i32 [ %cg0, %.preheader5 ], [ %cg1, %54 ]
  %47 = icmp slt i32 %i.1.lcssa, %ncg
  br i1 %47, label %.lr.ph, label %76

.lr.ph:                                           ; preds = %.preheader
  %48 = sext i32 %i.1.lcssa to i64
  %49 = add i32 %ncg, -1
  %scevgep = getelementptr i32* %2, i64 %48
  %scevgep12 = bitcast i32* %scevgep to i8*
  %50 = sub i32 %49, %i.1.lcssa
  %51 = zext i32 %50 to i64
  %52 = shl nuw nsw i64 %51, 2
  %53 = add nuw nsw i64 %52, 4
  call void @llvm.memset.p0i8.i64(i8* %scevgep12, i8 -1, i64 %53, i32 4, i1 false)
  br label %76

; <label>:54                                      ; preds = %54, %.lr.ph8
  %indvars.iv = phi i64 [ %45, %.lr.ph8 ], [ %indvars.iv.next, %54 ]
  %55 = getelementptr inbounds i32* %cg_index, i64 %indvars.iv
  %56 = load i32* %55, align 4, !tbaa !18
  %57 = sext i32 %56 to i64
  %58 = getelementptr inbounds [3 x float]* %cg_cm, i64 %57, i64 0
  %59 = load float* %58, align 4, !tbaa !14
  %60 = fmul float %16, %59
  %61 = fptosi float %60 to i32
  %62 = getelementptr inbounds [3 x float]* %cg_cm, i64 %57, i64 1
  %63 = load float* %62, align 4, !tbaa !14
  %64 = fmul float %23, %63
  %65 = fptosi float %64 to i32
  %66 = getelementptr inbounds [3 x float]* %cg_cm, i64 %57, i64 2
  %67 = load float* %66, align 4, !tbaa !14
  %68 = fmul float %30, %67
  %69 = fptosi float %68 to i32
  %70 = icmp slt i32 %61, %5
  %. = select i1 %70, i32 %61, i32 %42
  %71 = icmp slt i32 %65, %7
  %iy.0 = select i1 %71, i32 %65, i32 %43
  %72 = icmp slt i32 %69, %9
  %.1 = select i1 %72, i32 %69, i32 %44
  %73 = mul i32 %., %7
  %tmp = add i32 %iy.0, %73
  %tmp4 = mul i32 %tmp, %9
  %74 = add i32 %tmp4, %.1
  %75 = getelementptr inbounds i32* %2, i64 %indvars.iv
  store i32 %74, i32* %75, align 4, !tbaa !18
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %46
  br i1 %exitcond, label %.preheader, label %54

; <label>:76                                      ; preds = %.lr.ph, %.preheader
  ret void
}
