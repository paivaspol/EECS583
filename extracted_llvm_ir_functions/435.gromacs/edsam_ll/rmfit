define void @rmfit(i32 %ned, [3 x float]* nocapture %x, [3 x float]* nocapture readonly %transvec, [3 x float]* nocapture readonly %rotmat) #4 {
  %r_inv = alloca [3 x [3 x float]], align 16
  %xdum = alloca [3 x float], align 4
  %xdum11 = bitcast [3 x float]* %xdum to i8*
  %1 = bitcast [3 x [3 x float]]* %r_inv to i8*
  call void @llvm.lifetime.start(i64 36, i8* %1) #6
  %2 = getelementptr inbounds [3 x float]* %rotmat, i64 0, i64 0
  %3 = load float* %2, align 4, !tbaa !2
  %4 = getelementptr inbounds [3 x float]* %rotmat, i64 1, i64 1
  %5 = load float* %4, align 4, !tbaa !2
  %6 = getelementptr inbounds [3 x float]* %rotmat, i64 2, i64 2
  %7 = load float* %6, align 4, !tbaa !2
  %8 = fmul float %5, %7
  %9 = getelementptr inbounds [3 x float]* %rotmat, i64 2, i64 1
  %10 = load float* %9, align 4, !tbaa !2
  %11 = getelementptr inbounds [3 x float]* %rotmat, i64 1, i64 2
  %12 = load float* %11, align 4, !tbaa !2
  %13 = fmul float %10, %12
  %14 = fsub float %8, %13
  %15 = fmul float %3, %14
  %16 = getelementptr inbounds [3 x float]* %rotmat, i64 1, i64 0
  %17 = load float* %16, align 4, !tbaa !2
  %18 = getelementptr inbounds [3 x float]* %rotmat, i64 0, i64 1
  %19 = load float* %18, align 4, !tbaa !2
  %20 = fmul float %7, %19
  %21 = getelementptr inbounds [3 x float]* %rotmat, i64 0, i64 2
  %22 = load float* %21, align 4, !tbaa !2
  %23 = fmul float %10, %22
  %24 = fsub float %20, %23
  %25 = fmul float %17, %24
  %26 = fsub float %15, %25
  %27 = getelementptr inbounds [3 x float]* %rotmat, i64 2, i64 0
  %28 = load float* %27, align 4, !tbaa !2
  %29 = fmul float %12, %19
  %30 = fmul float %5, %22
  %31 = fsub float %29, %30
  %32 = fmul float %28, %31
  %33 = fadd float %32, %26
  %34 = fdiv float 1.000000e+00, %33
  %fabsf.i = tail call float @fabsf(float %34) #8
  %35 = fcmp ole float %fabsf.i, 0x3C32725DE0000000
  %36 = fcmp oge float %fabsf.i, 0x43ABC16D60000000
  %or.cond.i = or i1 %35, %36
  br i1 %or.cond.i, label %37, label %m_inv.exit

; <label>:37                                      ; preds = %0
  %38 = fpext float %34 to double
  %39 = fdiv double 1.000000e+00, %38
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([17 x i8]* @.str68, i64 0, i64 0), double %39) #11
  %.pre.i = load float* %4, align 4, !tbaa !2
  %.pre2.i = load float* %6, align 4, !tbaa !2
  %.pre3.i = load float* %9, align 4, !tbaa !2
  %.pre4.i = load float* %11, align 4, !tbaa !2
  %.pre = load float* %18, align 4, !tbaa !2
  %.pre25 = load float* %21, align 4, !tbaa !2
  %.pre26 = load float* %16, align 4, !tbaa !2
  %.pre27 = load float* %27, align 4, !tbaa !2
  %.pre28 = load float* %2, align 4, !tbaa !2
  br label %m_inv.exit

m_inv.exit:                                       ; preds = %0, %37
  %40 = phi float [ %3, %0 ], [ %.pre28, %37 ]
  %41 = phi float [ %28, %0 ], [ %.pre27, %37 ]
  %42 = phi float [ %17, %0 ], [ %.pre26, %37 ]
  %43 = phi float [ %22, %0 ], [ %.pre25, %37 ]
  %44 = phi float [ %19, %0 ], [ %.pre, %37 ]
  %45 = phi float [ %12, %0 ], [ %.pre4.i, %37 ]
  %46 = phi float [ %10, %0 ], [ %.pre3.i, %37 ]
  %47 = phi float [ %7, %0 ], [ %.pre2.i, %37 ]
  %48 = phi float [ %5, %0 ], [ %.pre.i, %37 ]
  %49 = fmul float %47, %48
  %50 = fmul float %45, %46
  %51 = fsub float %49, %50
  %52 = fsub float -0.000000e+00, %34
  %53 = fmul float %44, %47
  %54 = fmul float %46, %43
  %55 = fsub float %53, %54
  %56 = fmul float %44, %45
  %57 = fmul float %48, %43
  %58 = fsub float %56, %57
  %59 = fmul float %42, %47
  %60 = fmul float %41, %45
  %61 = fsub float %59, %60
  %62 = insertelement <4 x float> undef, float %34, i32 0
  %63 = insertelement <4 x float> %62, float %55, i32 1
  %64 = insertelement <4 x float> %63, float %34, i32 2
  %65 = insertelement <4 x float> %64, float %61, i32 3
  %66 = insertelement <4 x float> undef, float %51, i32 0
  %67 = insertelement <4 x float> %66, float %52, i32 1
  %68 = insertelement <4 x float> %67, float %58, i32 2
  %69 = insertelement <4 x float> %68, float %52, i32 3
  %70 = fmul <4 x float> %65, %69
  %71 = bitcast [3 x [3 x float]]* %r_inv to <4 x float>*
  store <4 x float> %70, <4 x float>* %71, align 16, !tbaa !2
  %72 = fmul float %40, %47
  %73 = fmul float %41, %43
  %74 = fsub float %72, %73
  %75 = getelementptr inbounds [3 x [3 x float]]* %r_inv, i64 0, i64 1, i64 1
  %76 = fmul float %40, %45
  %77 = fmul float %42, %43
  %78 = fsub float %76, %77
  %79 = fmul float %42, %46
  %80 = fmul float %41, %48
  %81 = fsub float %79, %80
  %82 = fmul float %40, %46
  %83 = fmul float %41, %44
  %84 = fsub float %82, %83
  %85 = insertelement <4 x float> %62, float %78, i32 1
  %86 = insertelement <4 x float> %85, float %34, i32 2
  %87 = insertelement <4 x float> %86, float %84, i32 3
  %88 = insertelement <4 x float> undef, float %74, i32 0
  %89 = insertelement <4 x float> %88, float %52, i32 1
  %90 = insertelement <4 x float> %89, float %81, i32 2
  %91 = insertelement <4 x float> %90, float %52, i32 3
  %92 = fmul <4 x float> %87, %91
  %93 = bitcast float* %75 to <4 x float>*
  store <4 x float> %92, <4 x float>* %93, align 4, !tbaa !2
  %94 = fmul float %40, %48
  %95 = fmul float %42, %44
  %96 = fsub float %94, %95
  %97 = fmul float %34, %96
  %98 = getelementptr inbounds [3 x [3 x float]]* %r_inv, i64 0, i64 2, i64 2
  store float %97, float* %98, align 8, !tbaa !2
  %99 = icmp sgt i32 %ned, 0
  br i1 %99, label %.preheader2.lr.ph, label %._crit_edge

.preheader2.lr.ph:                                ; preds = %m_inv.exit
  %100 = add i32 %ned, -1
  br label %.preheader2

.preheader2:                                      ; preds = %113, %.preheader2.lr.ph
  %indvars.iv21 = phi i64 [ 0, %.preheader2.lr.ph ], [ %indvars.iv.next22, %113 ]
  %scevgep = getelementptr [3 x float]* %x, i64 %indvars.iv21, i64 0
  %scevgep12 = bitcast float* %scevgep to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %xdum11, i8* %scevgep12, i64 12, i32 4, i1 false)
  br label %102

.preheader:                                       ; preds = %113
  br i1 %99, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %101 = add i32 %ned, -1
  br label %114

; <label>:102                                     ; preds = %112, %.preheader2
  %indvars.iv16 = phi i64 [ 0, %.preheader2 ], [ %indvars.iv.next17, %112 ]
  %103 = getelementptr inbounds [3 x float]* %x, i64 %indvars.iv21, i64 %indvars.iv16
  store float 0.000000e+00, float* %103, align 4, !tbaa !2
  br label %104

; <label>:104                                     ; preds = %104, %102
  %indvars.iv13 = phi i64 [ 0, %102 ], [ %indvars.iv.next14, %104 ]
  %105 = phi float [ 0.000000e+00, %102 ], [ %111, %104 ]
  %106 = getelementptr inbounds [3 x [3 x float]]* %r_inv, i64 0, i64 %indvars.iv13, i64 %indvars.iv16
  %107 = load float* %106, align 4, !tbaa !2
  %108 = getelementptr inbounds [3 x float]* %xdum, i64 0, i64 %indvars.iv13
  %109 = load float* %108, align 4, !tbaa !2
  %110 = fmul float %107, %109
  %111 = fadd float %105, %110
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %exitcond15 = icmp eq i64 %indvars.iv.next14, 3
  br i1 %exitcond15, label %112, label %104

; <label>:112                                     ; preds = %104
  store float %111, float* %103, align 4, !tbaa !2
  %indvars.iv.next17 = add nuw nsw i64 %indvars.iv16, 1
  %exitcond18 = icmp eq i64 %indvars.iv.next17, 3
  br i1 %exitcond18, label %113, label %102

; <label>:113                                     ; preds = %112
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %lftr.wideiv23 = trunc i64 %indvars.iv21 to i32
  %exitcond24 = icmp eq i32 %lftr.wideiv23, %100
  br i1 %exitcond24, label %.preheader, label %.preheader2

; <label>:114                                     ; preds = %114, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %114 ]
  %115 = getelementptr inbounds [3 x float]* %x, i64 %indvars.iv, i64 0
  %116 = getelementptr inbounds [3 x float]* %transvec, i64 %indvars.iv, i64 0
  %117 = load float* %115, align 4, !tbaa !2
  %118 = load float* %116, align 4, !tbaa !2
  %119 = fsub float %117, %118
  %120 = getelementptr inbounds [3 x float]* %x, i64 %indvars.iv, i64 1
  %121 = load float* %120, align 4, !tbaa !2
  %122 = getelementptr inbounds [3 x float]* %transvec, i64 %indvars.iv, i64 1
  %123 = load float* %122, align 4, !tbaa !2
  %124 = fsub float %121, %123
  %125 = getelementptr inbounds [3 x float]* %x, i64 %indvars.iv, i64 2
  %126 = load float* %125, align 4, !tbaa !2
  %127 = getelementptr inbounds [3 x float]* %transvec, i64 %indvars.iv, i64 2
  %128 = load float* %127, align 4, !tbaa !2
  %129 = fsub float %126, %128
  store float %119, float* %115, align 4, !tbaa !2
  store float %124, float* %120, align 4, !tbaa !2
  store float %129, float* %125, align 4, !tbaa !2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %101
  br i1 %exitcond, label %._crit_edge, label %114

._crit_edge:                                      ; preds = %114, %m_inv.exit, %.preheader
  call void @llvm.lifetime.end(i64 36, i8* %1) #6
  ret void
}
