define internal fastcc i32 @check_convergence(%struct.t_pull* nocapture %pull) #0 {
entry:
  %dr = alloca [3 x float], align 4
  %tolerance = getelementptr inbounds %struct.t_pull* %pull, i64 0, i32 14
  %0 = load float* %tolerance, align 4, !tbaa !4
  %n = getelementptr inbounds %struct.t_pull* %pull, i64 0, i32 1, i32 0
  %1 = load i32* %n, align 4, !tbaa !3
  %cmp50 = icmp sgt i32 %1, 0
  br i1 %cmp50, label %for.body.lr.ph, label %for.end26

for.body.lr.ph:                                   ; preds = %entry
  %x_unc = getelementptr inbounds %struct.t_pull* %pull, i64 0, i32 2, i32 9
  %x_unc3 = getelementptr inbounds %struct.t_pull* %pull, i64 0, i32 1, i32 9
  %xtarget = getelementptr inbounds %struct.t_pull* %pull, i64 0, i32 1, i32 16
  %arraydecay12 = getelementptr inbounds [3 x float]* %dr, i64 0, i64 0
  %arrayidx9.i47 = getelementptr inbounds [3 x float]* %dr, i64 0, i64 1
  %arrayidx10.i48 = getelementptr inbounds [3 x float]* %dr, i64 0, i64 2
  br label %for.body

for.body:                                         ; preds = %land.end, %for.body.lr.ph
  %2 = phi i32 [ %1, %for.body.lr.ph ], [ %20, %land.end ]
  %indvars.iv53 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next54, %land.end ]
  %bTest.051 = phi i32 [ 1, %for.body.lr.ph ], [ %land.ext, %land.end ]
  %3 = load [3 x float]** %x_unc, align 8, !tbaa !0
  %arraydecay = getelementptr inbounds [3 x float]* %3, i64 0, i64 0
  %4 = load [3 x float]** %x_unc3, align 8, !tbaa !0
  %arraydecay5 = getelementptr inbounds [3 x float]* %4, i64 %indvars.iv53, i64 0
  %5 = load float* %arraydecay, align 4, !tbaa !4
  %6 = load float* %arraydecay5, align 4, !tbaa !4
  %sub.i = fsub float %5, %6
  %arrayidx2.i = getelementptr inbounds [3 x float]* %3, i64 0, i64 1
  %7 = load float* %arrayidx2.i, align 4, !tbaa !4
  %arrayidx3.i = getelementptr inbounds [3 x float]* %4, i64 %indvars.iv53, i64 1
  %8 = load float* %arrayidx3.i, align 4, !tbaa !4
  %sub4.i = fsub float %7, %8
  %arrayidx5.i = getelementptr inbounds [3 x float]* %3, i64 0, i64 2
  %9 = load float* %arrayidx5.i, align 4, !tbaa !4
  %arrayidx6.i = getelementptr inbounds [3 x float]* %4, i64 %indvars.iv53, i64 2
  %10 = load float* %arrayidx6.i, align 4, !tbaa !4
  %sub7.i = fsub float %9, %10
  %11 = load [3 x float]** %xtarget, align 8, !tbaa !0
  %arraydecay10 = getelementptr inbounds [3 x float]* %11, i64 %indvars.iv53, i64 0
  %12 = load float* %arraydecay10, align 4, !tbaa !4
  %add.i42 = fadd float %sub.i, %12
  %arrayidx2.i43 = getelementptr inbounds [3 x float]* %11, i64 %indvars.iv53, i64 1
  %13 = load float* %arrayidx2.i43, align 4, !tbaa !4
  %add4.i = fadd float %sub4.i, %13
  %arrayidx5.i45 = getelementptr inbounds [3 x float]* %11, i64 %indvars.iv53, i64 2
  %14 = load float* %arrayidx5.i45, align 4, !tbaa !4
  %add7.i = fadd float %sub7.i, %14
  store float %add.i42, float* %arraydecay12, align 4, !tbaa !4
  store float %add4.i, float* %arrayidx9.i47, align 4, !tbaa !4
  store float %add7.i, float* %arrayidx10.i48, align 4, !tbaa !4
  br label %for.body15

for.body15:                                       ; preds = %for.body15.for.body15_crit_edge, %for.body
  %15 = phi float [ %add.i42, %for.body ], [ %.pre55, %for.body15.for.body15_crit_edge ]
  %indvars.iv = phi i64 [ 0, %for.body ], [ %indvars.iv.next, %for.body15.for.body15_crit_edge ]
  %arrayidx17 = getelementptr inbounds %struct.t_pull* %pull, i64 0, i32 5, i64 %indvars.iv
  %16 = load float* %arrayidx17, align 4, !tbaa !4
  %arrayidx19 = getelementptr inbounds [3 x float]* %dr, i64 0, i64 %indvars.iv
  %mul = fmul float %16, %15
  store float %mul, float* %arrayidx19, align 4, !tbaa !4
  %indvars.iv.next = add i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 3
  br i1 %exitcond, label %for.end, label %for.body15.for.body15_crit_edge

for.body15.for.body15_crit_edge:                  ; preds = %for.body15
  %arrayidx19.phi.trans.insert = getelementptr inbounds [3 x float]* %dr, i64 0, i64 %indvars.iv.next
  %.pre55 = load float* %arrayidx19.phi.trans.insert, align 4, !tbaa !4
  br label %for.body15

for.end:                                          ; preds = %for.body15
  %tobool = icmp eq i32 %bTest.051, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.end
  %17 = load float* %arraydecay12, align 4, !tbaa !4
  %mul.i = fmul float %17, %17
  %18 = load float* %arrayidx9.i47, align 4, !tbaa !4
  %mul4.i = fmul float %18, %18
  %add.i = fadd float %mul.i, %mul4.i
  %19 = load float* %arrayidx10.i48, align 4, !tbaa !4
  %mul7.i = fmul float %19, %19
  %add8.i = fadd float %add.i, %mul7.i
  %conv9.i = call float @sqrtf(float %add8.i) #2
  %cmp23 = fcmp olt float %conv9.i, %0
  %.pre = load i32* %n, align 4, !tbaa !3
  br label %land.end

land.end:                                         ; preds = %for.end, %land.rhs
  %20 = phi i32 [ %2, %for.end ], [ %.pre, %land.rhs ]
  %21 = phi i1 [ false, %for.end ], [ %cmp23, %land.rhs ]
  %land.ext = zext i1 %21 to i32
  %indvars.iv.next54 = add i64 %indvars.iv53, 1
  %22 = trunc i64 %indvars.iv.next54 to i32
  %cmp = icmp slt i32 %22, %20
  br i1 %cmp, label %for.body, label %for.end26

for.end26:                                        ; preds = %land.end, %entry
  %bTest.0.lcssa = phi i32 [ 1, %entry ], [ %land.ext, %land.end ]
  ret i32 %bTest.0.lcssa
}
