define void @add_ebin(%struct.t_ebin* nocapture readonly %eb, i32 %index, i32 %nener, float* nocapture readonly %ener, i32 %step) #3 {
  %1 = add nsw i32 %nener, %index
  %2 = getelementptr inbounds %struct.t_ebin* %eb, i64 0, i32 0
  %3 = load i32* %2, align 4, !tbaa !14
  %4 = icmp sgt i32 %1, %3
  %5 = icmp slt i32 %index, 0
  %or.cond = or i1 %5, %4
  br i1 %or.cond, label %6, label %7

; <label>:6                                       ; preds = %0
  tail call void (i32, i8*, ...)* @fatal_error(i32 0, i8* getelementptr inbounds ([59 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([64 x i8]* @.str1, i64 0, i64 0), i32 95, i32 %index, i32 %nener, i32 %3) #7
  br label %7

; <label>:7                                       ; preds = %0, %6
  %8 = icmp sgt i32 %step, 0
  br i1 %8, label %9, label %14

; <label>:9                                       ; preds = %7
  %10 = sitofp i32 %step to double
  %11 = fdiv double 1.000000e+00, %10
  %12 = fadd double %10, 1.000000e+00
  %13 = fdiv double %11, %12
  br label %14

; <label>:14                                      ; preds = %7, %9
  %invmm.0 = phi double [ %13, %9 ], [ 0.000000e+00, %7 ]
  %15 = sext i32 %index to i64
  %16 = getelementptr inbounds %struct.t_ebin* %eb, i64 0, i32 2
  %17 = load %struct.t_energy** %16, align 8, !tbaa !16
  %18 = icmp sgt i32 %nener, 0
  br i1 %18, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %14
  %19 = sitofp i32 %step to double
  %20 = add i32 %nener, -1
  br label %21

; <label>:21                                      ; preds = %21, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %21 ]
  %22 = getelementptr inbounds float* %ener, i64 %indvars.iv
  %23 = load float* %22, align 4, !tbaa !23
  %24 = fpext float %23 to double
  %.sum = add nsw i64 %indvars.iv, %15
  %25 = getelementptr inbounds %struct.t_energy* %17, i64 %.sum, i32 0
  store float %23, float* %25, align 4, !tbaa !18
  %26 = fmul double %19, %24
  %27 = getelementptr inbounds %struct.t_energy* %17, i64 %.sum, i32 1
  %28 = bitcast double* %27 to <2 x double>*
  %29 = load <2 x double>* %28, align 8, !tbaa !24
  %30 = extractelement <2 x double> %29, i32 1
  %31 = fsub double %30, %26
  %32 = fptrunc double %31 to float
  %33 = fmul float %32, %32
  %34 = fpext float %33 to double
  %35 = fmul double %invmm.0, %34
  %36 = insertelement <2 x double> undef, double %35, i32 0
  %37 = insertelement <2 x double> %36, double %24, i32 1
  %38 = fadd <2 x double> %37, %29
  %39 = bitcast double* %27 to <2 x double>*
  store <2 x double> %38, <2 x double>* %39, align 8, !tbaa !24
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %20
  br i1 %exitcond, label %._crit_edge, label %21

._crit_edge:                                      ; preds = %21, %14
  ret void
}
