; ModuleID = '../../SPEC/benchspec/CPU2006/400.perlbench/src/op.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.hv = type { %struct.xpvhv*, i32, i32 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i32, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i32 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.sv = type { i8*, i32, i32 }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i32, i32 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i32, i32, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i32, i32, i8, %struct.hv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.regexp = type { i32*, i32*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i32*, i32, i32, i32, i32, i32, i32, i32, i32, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i32, i32, i32, %struct.sv*, %struct.sv* }
%struct.gv = type { %struct.xpvgv*, i32, i32 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i32, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i32, i32, i32, i8* }
%struct.io = type { %struct.xpvio*, i32, i32 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i32, i32 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i32 }
%union.any = type { i8* }
%struct.xpv = type { i8*, i64, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i32, i32, i32, %struct.stackinfo*, %struct.stackinfo*, i32 }
%struct.context = type { i32, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i32, %struct.cop*, i32, i32, i32, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i32, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.listop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }
%struct.loop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.op* }
%struct.svop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.sv* }

@PL_in_my = external global i32
@PL_hints = external global i32
@.str = private unnamed_addr constant [5 x i8] c"\09\0A\0D\0C\00", align 1
@.str2 = private unnamed_addr constant [28 x i8] c"Can't use global %s in \22my\22\00", align 1
@PL_curstash = external global %struct.hv*
@PL_defstash = external global %struct.hv*
@PL_in_my_stash = external global %struct.hv*
@.str3 = private unnamed_addr constant [46 x i8] c"Can't declare class for non-scalar %s in \22%s\22\00", align 1
@.str4 = private unnamed_addr constant [4 x i8] c"our\00", align 1
@.str5 = private unnamed_addr constant [3 x i8] c"my\00", align 1
@PL_check = external global [0 x %struct.op* (%struct.op*)*]
@PL_regfree = external global void (%struct.regexp*)*
@PL_ppaddr = external global [0 x %struct.op* ()*]
@PL_error_count = external global i32
@.str6 = private unnamed_addr constant [21 x i8] c"implicit split to @_\00", align 1
@PL_compiling = external global %struct.cop
@PL_curcop = external global %struct.cop*
@PL_dowarn = external global i8
@.str7 = private unnamed_addr constant [38 x i8] c"Useless use of sort in scalar context\00", align 1
@PL_opargs = external global [0 x i32]
@PL_op_desc = external global [0 x i8*]
@.str8 = private unnamed_addr constant [11 x i8] c"a variable\00", align 1
@.str9 = private unnamed_addr constant [11 x i8] c"a constant\00", align 1
@.str10 = private unnamed_addr constant [3 x i8] c"di\00", align 1
@.str11 = private unnamed_addr constant [3 x i8] c"ds\00", align 1
@.str12 = private unnamed_addr constant [3 x i8] c"ig\00", align 1
@.str13 = private unnamed_addr constant [34 x i8] c"Useless use of %s in void context\00", align 1
@PL_modcount = external global i32
@PL_eval_start = external global %struct.op*
@.str14 = private unnamed_addr constant [30 x i8] c"That use of $[ is unsupported\00", align 1
@.str15 = private unnamed_addr constant [58 x i8] c"panic: unexpected lvalue entersub args: type/targ %ld:%lu\00", align 1
@.str16 = private unnamed_addr constant [62 x i8] c"panic: unexpected lvalue entersub entry via type/targ %ld:%lu\00", align 1
@.str17 = private unnamed_addr constant [64 x i8] c"Unexpected constant lvalue entersub entry via type/targ %ld:%lu\00", align 1
@.str18 = private unnamed_addr constant [22 x i8] c"Can't modify %s in %s\00", align 1
@.str19 = private unnamed_addr constant [9 x i8] c"do block\00", align 1
@.str20 = private unnamed_addr constant [27 x i8] c"non-lvalue subroutine call\00", align 1
@.str21 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str22 = private unnamed_addr constant [35 x i8] c"Can't localize lexical variable %s\00", align 1
@PL_comppad_name = external global %struct.av*
@.str23 = private unnamed_addr constant [11 x i8] c"attributes\00", align 1
@.str24 = private unnamed_addr constant [7 x i8] c"@array\00", align 1
@.str25 = private unnamed_addr constant [6 x i8] c"%hash\00", align 1
@.str26 = private unnamed_addr constant [41 x i8] c"Applying %s to %s will act on scalar(%s)\00", align 1
@PL_perldb = external global i32
@PL_tainting = external global i8
@.str27 = private unnamed_addr constant [54 x i8] c"internal error: obsolete function save_hints() called\00", align 1
@PL_savestack_ix = external global i32
@PL_yynerrs = external global i32
@PL_savestack_max = external global i32
@PL_hintgv = external global %struct.gv*
@PL_savestack = external global %union.any*
@PL_in_eval = external global i32
@PL_eval_root = external global %struct.op*
@PL_peepp = external global void (%struct.op*)*
@PL_compcv = external global %struct.cv*
@PL_main_root = external global %struct.op*
@PL_main_start = external global %struct.op*
@.str28 = private unnamed_addr constant [14 x i8] c"DB::postponed\00", align 1
@PL_stack_sp = external global %struct.sv**
@PL_markstack_ptr = external global i32*
@PL_markstack_max = external global i32*
@PL_stack_base = external global %struct.sv**
@PL_stack_max = external global %struct.sv**
@PL_bufptr = external global i8*
@PL_oldbufptr = external global i8*
@.str29 = private unnamed_addr constant [5 x i8] c", \09\0A\00", align 1
@.str30 = private unnamed_addr constant [5 x i8] c"@$%*\00", align 1
@.str31 = private unnamed_addr constant [37 x i8] c"Parentheses missing around \22%s\22 list\00", align 1
@.str32 = private unnamed_addr constant [2 x i8] c";\00", align 1
@PL_op = external global %struct.op*
@PL_runops = external global i32 ()*
@PL_curpad = external global %struct.sv**
@PL_Sv = external global %struct.sv*
@PL_tmps_floor = external global i32
@PL_op_mask = external global i8*
@.str33 = private unnamed_addr constant [31 x i8] c"'%s' trapped by operation mask\00", align 1
@.str34 = private unnamed_addr constant [11 x i8] c"# comment\0A\00", align 1
@.str35 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str36 = private unnamed_addr constant [18 x i8] c"%04lx\09%04lx\09XXXX\0A\00", align 1
@.str37 = private unnamed_addr constant [13 x i8] c"%04lx\09\09XXXX\0A\00", align 1
@.str38 = private unnamed_addr constant [19 x i8] c"%04lx\09%04lx\09%04lx\0A\00", align 1
@.str39 = private unnamed_addr constant [14 x i8] c"%04lx\09\09%04lx\0A\00", align 1
@.str40 = private unnamed_addr constant [5 x i8] c"utf8\00", align 1
@.str41 = private unnamed_addr constant [6 x i8] c"FINAL\00", align 1
@.str42 = private unnamed_addr constant [4 x i8] c"\5Cs+\00", align 1
@PL_regcompp = external global %struct.regexp* (i8*, i8*, %struct.pmop*)*
@PL_multi_end = external global i32
@.str43 = private unnamed_addr constant [17 x i8] c"&`'123456789+-\0E\12\00", align 1
@PL_curstname = external global %struct.sv*
@.str44 = private unnamed_addr constant [28 x i8] c"\22package\22 with no arguments\00", align 1
@.str45 = private unnamed_addr constant [7 x i8] c"<none>\00", align 1
@PL_copline = external global i32
@PL_expect = external global i32
@.str46 = private unnamed_addr constant [29 x i8] c"Module name must be constant\00", align 1
@.str47 = private unnamed_addr constant [39 x i8] c"Version number must be constant number\00", align 1
@.str48 = private unnamed_addr constant [8 x i8] c"VERSION\00", align 1
@.str49 = private unnamed_addr constant [7 x i8] c"import\00", align 1
@.str50 = private unnamed_addr constant [9 x i8] c"unimport\00", align 1
@.str51 = private unnamed_addr constant [6 x i8] c"BEGIN\00", align 1
@PL_cop_seqmax = external global i32
@.str52 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str53 = private unnamed_addr constant [17 x i8] c"CORE::GLOBAL::do\00", align 1
@PL_generation = external global i32
@PL_defgv = external global %struct.gv*
@PL_debstash = external global %struct.hv*
@PL_sv_undef = external global %struct.sv
@PL_Xpv = external global %struct.xpv*
@.str54 = private unnamed_addr constant [31 x i8] c"Can't use %s for loop variable\00", align 1
@.str55 = private unnamed_addr constant [30 x i8] c"Can't undef active subroutine\00", align 1
@PL_comppad = external global %struct.av*
@.str56 = private unnamed_addr constant [20 x i8] c"Prototype mismatch:\00", align 1
@.str57 = private unnamed_addr constant [8 x i8] c" sub %_\00", align 1
@.str58 = private unnamed_addr constant [6 x i8] c" (%_)\00", align 1
@.str59 = private unnamed_addr constant [7 x i8] c": none\00", align 1
@.str60 = private unnamed_addr constant [5 x i8] c" vs \00", align 1
@.str61 = private unnamed_addr constant [5 x i8] c"(%s)\00", align 1
@.str62 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str63 = private unnamed_addr constant [3 x i8] c"%_\00", align 1
@.str64 = private unnamed_addr constant [29 x i8] c"\22my sub\22 not yet implemented\00", align 1
@.str65 = private unnamed_addr constant [11 x i8] c"%s[%s:%ld]\00", align 1
@.str66 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@.str67 = private unnamed_addr constant [19 x i8] c"__ANON__::__ANON__\00", align 1
@.str68 = private unnamed_addr constant [18 x i8] c"Runaway prototype\00", align 1
@PL_sub_generation = external global i32
@PL_curstackinfo = external global %struct.stackinfo*
@PL_sortcop = external global %struct.op*
@.str69 = private unnamed_addr constant [41 x i8] c"Can't redefine active sort subroutine %s\00", align 1
@.str70 = private unnamed_addr constant [33 x i8] c"Constant subroutine %s redefined\00", align 1
@.str71 = private unnamed_addr constant [24 x i8] c"Subroutine %s redefined\00", align 1
@.str72 = private unnamed_addr constant [49 x i8] c"BEGIN not safe after errors--compilation aborted\00", align 1
@PL_errgv = external global %struct.gv*
@.str73 = private unnamed_addr constant [11 x i8] c"%s:%ld-%ld\00", align 1
@PL_subline = external global i32
@PL_DBsub = external global %struct.gv*
@PL_scopestack_ix = external global i32
@PL_beginav = external global %struct.av*
@.str74 = private unnamed_addr constant [4 x i8] c"END\00", align 1
@PL_endav = external global %struct.av*
@.str75 = private unnamed_addr constant [6 x i8] c"CHECK\00", align 1
@PL_checkav = external global %struct.av*
@.str76 = private unnamed_addr constant [28 x i8] c"Too late to run CHECK block\00", align 1
@.str77 = private unnamed_addr constant [5 x i8] c"INIT\00", align 1
@PL_initav = external global %struct.av*
@.str78 = private unnamed_addr constant [27 x i8] c"Too late to run INIT block\00", align 1
@.str79 = private unnamed_addr constant [8 x i8] c"autouse\00", align 1
@.str80 = private unnamed_addr constant [7 x i8] c"STDOUT\00", align 1
@.str81 = private unnamed_addr constant [20 x i8] c"Format %s redefined\00", align 1
@.str82 = private unnamed_addr constant [13 x i8] c"oops: oopsAV\00", align 1
@.str83 = private unnamed_addr constant [13 x i8] c"oops: oopsHV\00", align 1
@.str84 = private unnamed_addr constant [44 x i8] c"Using an array as a reference is deprecated\00", align 1
@.str85 = private unnamed_addr constant [42 x i8] c"Using a hash as a reference is deprecated\00", align 1
@.str86 = private unnamed_addr constant [17 x i8] c"NOT IMPL LINE %d\00", align 1
@.str87 = private unnamed_addr constant [51 x i8] c"Possible precedence problem on bitwise %c operator\00", align 1
@.str88 = private unnamed_addr constant [52 x i8] c"%s argument is not a HASH or ARRAY element or slice\00", align 1
@PL_argvgv = external global %struct.gv*
@.str89 = private unnamed_addr constant [37 x i8] c"%s argument is not a subroutine name\00", align 1
@.str90 = private unnamed_addr constant [43 x i8] c"%s argument is not a HASH or ARRAY element\00", align 1
@.str91 = private unnamed_addr constant [9 x i8] c"a SCALAR\00", align 1
@.str92 = private unnamed_addr constant [9 x i8] c"an ARRAY\00", align 1
@.str93 = private unnamed_addr constant [7 x i8] c"a HASH\00", align 1
@.str94 = private unnamed_addr constant [7 x i8] c"a CODE\00", align 1
@.str95 = private unnamed_addr constant [29 x i8] c"Constant is not %s reference\00", align 1
@.str96 = private unnamed_addr constant [63 x i8] c"Can't use bareword (\22%s\22) as %s ref while \22strict refs\22 in use\00", align 1
@PL_stdingv = external global %struct.gv*
@.str97 = private unnamed_addr constant [33 x i8] c"Useless use of %s with no values\00", align 1
@.str98 = private unnamed_addr constant [48 x i8] c"Array @%s missing the @ in argument %ld of %s()\00", align 1
@.str99 = private unnamed_addr constant [6 x i8] c"array\00", align 1
@.str100 = private unnamed_addr constant [49 x i8] c"Hash %%%s missing the %% in argument %ld of %s()\00", align 1
@.str101 = private unnamed_addr constant [5 x i8] c"hash\00", align 1
@.str102 = private unnamed_addr constant [7 x i8] c"HANDLE\00", align 1
@.str103 = private unnamed_addr constant [3 x i8] c"[]\00", align 1
@.str104 = private unnamed_addr constant [3 x i8] c"{}\00", align 1
@.str105 = private unnamed_addr constant [10 x i8] c"%s%c...%c\00", align 1
@.str106 = private unnamed_addr constant [11 x i8] c"__ANONIO__\00", align 1
@.str107 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str108 = private unnamed_addr constant [5 x i8] c"glob\00", align 1
@.str109 = private unnamed_addr constant [19 x i8] c"CORE::GLOBAL::glob\00", align 1
@.str110 = private unnamed_addr constant [11 x i8] c"File::Glob\00", align 1
@.str111 = private unnamed_addr constant [21 x i8] c"File::Glob::csh_glob\00", align 1
@PL_glob_index = external global i32
@.str112 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str113 = private unnamed_addr constant [15 x i8] c"panic: ck_grep\00", align 1
@.str114 = private unnamed_addr constant [30 x i8] c"defined(@array) is deprecated\00", align 1
@.str115 = private unnamed_addr constant [46 x i8] c"\09(Maybe you should just omit the defined()?)\0A\00", align 1
@.str116 = private unnamed_addr constant [30 x i8] c"defined(%%hash) is deprecated\00", align 1
@.str117 = private unnamed_addr constant [8 x i8] c"open_IN\00", align 1
@.str118 = private unnamed_addr constant [9 x i8] c"open_OUT\00", align 1
@.str119 = private unnamed_addr constant [4 x i8] c".pm\00", align 1
@.str120 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str121 = private unnamed_addr constant [22 x i8] c"CORE::GLOBAL::require\00", align 1
@.str122 = private unnamed_addr constant [16 x i8] c"panic: ck_split\00", align 1
@.str123 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str124 = private unnamed_addr constant [43 x i8] c"Use of /g modifier is meaningless in split\00", align 1
@.str125 = private unnamed_addr constant [7 x i8] c"STRING\00", align 1
@.str126 = private unnamed_addr constant [40 x i8] c"/%s/ should probably be written as \22%s\22\00", align 1
@.str127 = private unnamed_addr constant [16 x i8] c"block or sub {}\00", align 1
@.str128 = private unnamed_addr constant [7 x i8] c"sub {}\00", align 1
@.str129 = private unnamed_addr constant [10 x i8] c"one of %s\00", align 1
@.str130 = private unnamed_addr constant [7 x i8] c"symbol\00", align 1
@.str131 = private unnamed_addr constant [17 x i8] c"subroutine entry\00", align 1
@.str132 = private unnamed_addr constant [7 x i8] c"scalar\00", align 1
@.str133 = private unnamed_addr constant [31 x i8] c"Malformed prototype for %s: %_\00", align 1
@PL_op_seqmax = external global i16
@.str134 = private unnamed_addr constant [41 x i8] c"%_() called too early to check prototype\00", align 1
@.str135 = private unnamed_addr constant [33 x i8] c"Statement unlikely to be reached\00", align 1
@.str136 = private unnamed_addr constant [51 x i8] c"\09(Maybe you meant system() when you said exec()?)\0A\00", align 1
@.str137 = private unnamed_addr constant [7 x i8] c"FIELDS\00", align 1
@.str138 = private unnamed_addr constant [57 x i8] c"No such pseudo-hash field \22%s\22 in variable %s of type %s\00", align 1
@.str139 = private unnamed_addr constant [41 x i8] c"Bad index while coercing array into hash\00", align 1
@PL_custom_op_names = external global %struct.hv*
@PL_op_name = external global [0 x i8*]
@PL_custom_op_descs = external global %struct.hv*
@.str140 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str141 = private unnamed_addr constant [2 x i8] c"b\00", align 1
@.str142 = private unnamed_addr constant [28 x i8] c"Not enough arguments for %s\00", align 1
@.str143 = private unnamed_addr constant [41 x i8] c"Type of arg %d to %s must be %s (not %s)\00", align 1
@.str144 = private unnamed_addr constant [26 x i8] c"Too many arguments for %s\00", align 1
@.str145 = private unnamed_addr constant [50 x i8] c"Missing comma after first argument to %s function\00", align 1
@PL_sv_no = external global %struct.sv
@PL_incgv = external global %struct.gv*
@.str146 = private unnamed_addr constant [14 x i8] c"attributes.pm\00", align 1
@.str147 = private unnamed_addr constant [37 x i8] c"Found = in conditional, should be ==\00", align 1
@.str148 = private unnamed_addr constant [30 x i8] c"Bareword found in conditional\00", align 1
@.str149 = private unnamed_addr constant [46 x i8] c"Value of %s%s can be \220\22; test with defined()\00", align 1
@.str150 = private unnamed_addr constant [11 x i8] c" construct\00", align 1
@.str151 = private unnamed_addr constant [12 x i8] c"() operator\00", align 1
@.str152 = private unnamed_addr constant [39 x i8] c"Assignment to both a list and a scalar\00", align 1
@.str153 = private unnamed_addr constant [23 x i8] c"Can't declare %s in %s\00", align 1
@.str154 = private unnamed_addr constant [25 x i8] c"Can't declare %s in \22%s\22\00", align 1
@.str155 = private unnamed_addr constant [53 x i8] c"Bareword \22%_\22 not allowed while \22strict subs\22 in use\00", align 1

; Function Attrs: nounwind optsize uwtable
define i64 @Perl_allocmy(i8* %name) #0 {
entry:
  %0 = load i32* @PL_in_my, align 4, !tbaa !0
  %cmp = icmp eq i32 %0, 137
  br i1 %cmp, label %if.end89, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %arrayidx = getelementptr inbounds i8* %name, i64 1
  %1 = load i8* %arrayidx, align 1, !tbaa !1
  %.off = add i8 %1, -65
  %2 = icmp ult i8 %.off, 26
  %.off159 = add i8 %1, -97
  %3 = icmp ult i8 %.off159, 26
  %or.cond = or i1 %2, %3
  br i1 %or.cond, label %if.end89, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %4 = load i32* @PL_hints, align 4, !tbaa !0
  %and = and i32 %4, 8388608
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %lor.lhs.false28, label %land.lhs.true18

land.lhs.true18:                                  ; preds = %lor.lhs.false17
  %.off160 = add i8 %1, 64
  %5 = icmp ult i8 %.off160, 62
  br i1 %5, label %if.end89, label %lor.lhs.false28

lor.lhs.false28:                                  ; preds = %lor.lhs.false17, %land.lhs.true18
  %cmp31 = icmp eq i8 %1, 95
  br i1 %cmp31, label %land.lhs.true33, label %if.then

land.lhs.true33:                                  ; preds = %lor.lhs.false28
  %call = tail call i64 @strlen(i8* %name) #7
  %conv34 = trunc i64 %call to i32
  %cmp35 = icmp sgt i32 %conv34, 2
  br i1 %cmp35, label %if.end89, label %if.then

if.then:                                          ; preds = %land.lhs.true33, %lor.lhs.false28
  %notlhs = icmp sgt i8 %1, 32
  %notrhs = icmp ne i8 %1, 127
  %or.cond156.not = and i1 %notrhs, %notlhs
  %cmp49 = icmp eq i8 %1, 32
  %or.cond158 = or i1 %or.cond156.not, %cmp49
  br i1 %or.cond158, label %lor.lhs.false51, label %if.then56

lor.lhs.false51:                                  ; preds = %if.then
  %conv53 = sext i8 %1 to i32
  %memchr = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str, i64 0, i64 0), i32 %conv53, i64 5)
  %tobool55 = icmp eq i8* %memchr, null
  br i1 %tobool55, label %if.end86, label %if.then56

if.then56:                                        ; preds = %if.then, %lor.lhs.false51
  %call57 = tail call i8* @strchr(i8* %name, i32 0) #7
  %sub.ptr.lhs.cast = ptrtoint i8* %call57 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %name to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp58 = icmp sgt i64 %sub.ptr.sub, 200
  br i1 %cmp58, label %if.then60, label %if.else

if.then60:                                        ; preds = %if.then56
  %add.ptr = getelementptr inbounds i8* %name, i64 200
  %6 = bitcast i8* %add.ptr to i32*
  store i32 3026478, i32* %6, align 1
  %add.ptr62 = getelementptr inbounds i8* %name, i64 199
  br label %for.cond.preheader

if.else:                                          ; preds = %if.then56
  %arrayidx63 = getelementptr inbounds i8* %call57, i64 1
  store i8 0, i8* %arrayidx63, align 1, !tbaa !1
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else, %if.then60
  %p.0.ph = phi i8* [ %add.ptr62, %if.then60 ], [ %call57, %if.else ]
  %sub.ptr.lhs.cast64163 = ptrtoint i8* %p.0.ph to i64
  %sub.ptr.sub66164 = sub i64 %sub.ptr.lhs.cast64163, %sub.ptr.rhs.cast
  %cmp67165 = icmp sgt i64 %sub.ptr.sub66164, 2
  br i1 %cmp67165, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %p.0166 = phi i8* [ %add.ptr69, %for.body ], [ %p.0.ph, %for.cond.preheader ]
  %add.ptr69 = getelementptr inbounds i8* %p.0166, i64 -1
  %7 = load i8* %add.ptr69, align 1, !tbaa !1
  store i8 %7, i8* %p.0166, align 1, !tbaa !1
  %sub.ptr.lhs.cast64 = ptrtoint i8* %add.ptr69 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast
  %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2
  br i1 %cmp67, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %8 = load i8* %arrayidx, align 1, !tbaa !1
  %.off161 = add i8 %8, -97
  %9 = icmp ult i8 %.off161, 26
  %sub = add i8 %8, -32
  %sub. = select i1 %9, i8 %sub, i8 %8
  %xor = xor i8 %sub., 64
  %arrayidx84 = getelementptr inbounds i8* %name, i64 2
  store i8 %xor, i8* %arrayidx84, align 1, !tbaa !1
  store i8 94, i8* %arrayidx, align 1, !tbaa !1
  br label %if.end86

if.end86:                                         ; preds = %lor.lhs.false51, %for.end
  %call87 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([28 x i8]* @.str2, i64 0, i64 0), i8* %name) #7
  %call88 = tail call i32 @Perl_yyerror(i8* %call87) #7
  %.pre = load i32* @PL_in_my, align 4, !tbaa !0
  br label %if.end89

if.end89:                                         ; preds = %land.lhs.true18, %lor.lhs.false, %if.end86, %land.lhs.true33, %entry
  %10 = phi i32 [ %0, %land.lhs.true18 ], [ %0, %lor.lhs.false ], [ %.pre, %if.end86 ], [ %0, %land.lhs.true33 ], [ 137, %entry ]
  %cmp90 = icmp eq i32 %10, 137
  %conv92 = zext i1 %cmp90 to i8
  %11 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %tobool93 = icmp ne %struct.hv* %11, null
  %12 = load %struct.hv** @PL_defstash, align 8, !tbaa !3
  %cond97 = select i1 %tobool93, %struct.hv* %11, %struct.hv* %12
  tail call void @Perl_pad_check_dup(i8* %name, i8 signext %conv92, %struct.hv* %cond97) #7
  %13 = load %struct.hv** @PL_in_my_stash, align 8, !tbaa !3
  %tobool98 = icmp eq %struct.hv* %13, null
  br i1 %tobool98, label %if.end109, label %land.lhs.true99

land.lhs.true99:                                  ; preds = %if.end89
  %14 = load i8* %name, align 1, !tbaa !1
  %cmp101 = icmp eq i8 %14, 36
  br i1 %cmp101, label %if.end109, label %if.then103

if.then103:                                       ; preds = %land.lhs.true99
  %15 = load i32* @PL_in_my, align 4, !tbaa !0
  %cmp104 = icmp eq i32 %15, 137
  %cond106 = select i1 %cmp104, i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str5, i64 0, i64 0)
  %call107 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([46 x i8]* @.str3, i64 0, i64 0), i8* %name, i8* %cond106) #7
  %call108 = tail call i32 @Perl_yyerror(i8* %call107) #7
  %.pre167 = load %struct.hv** @PL_in_my_stash, align 8, !tbaa !3
  br label %if.end109

if.end109:                                        ; preds = %land.lhs.true99, %if.end89, %if.then103
  %16 = phi %struct.hv* [ %13, %land.lhs.true99 ], [ null, %if.end89 ], [ %.pre167, %if.then103 ]
  %17 = load i32* @PL_in_my, align 4, !tbaa !0
  %cmp110 = icmp eq i32 %17, 137
  br i1 %cmp110, label %cond.true112, label %cond.end119

cond.true112:                                     ; preds = %if.end109
  %18 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %tobool113 = icmp ne %struct.hv* %18, null
  %19 = load %struct.hv** @PL_defstash, align 8, !tbaa !3
  %cond117 = select i1 %tobool113, %struct.hv* %18, %struct.hv* %19
  br label %cond.end119

cond.end119:                                      ; preds = %if.end109, %cond.true112
  %cond120 = phi %struct.hv* [ %cond117, %cond.true112 ], [ null, %if.end109 ]
  %call121 = tail call i64 @Perl_pad_add_name(i8* %name, %struct.hv* %16, %struct.hv* %cond120, i8 signext 0) #7
  ret i64 %call121
}

; Function Attrs: nounwind optsize readonly
declare i64 @strlen(i8* nocapture) #1

; Function Attrs: nounwind optsize readonly
declare i8* @strchr(i8*, i32) #1

; Function Attrs: optsize
declare i32 @Perl_yyerror(i8*) #2

; Function Attrs: optsize
declare i8* @Perl_form(i8*, ...) #2

; Function Attrs: optsize
declare void @Perl_pad_check_dup(i8*, i8 signext, %struct.hv*) #2

; Function Attrs: optsize
declare i64 @Perl_pad_add_name(i8*, %struct.hv*, %struct.hv*, i8 signext) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_op_free(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_seq = getelementptr inbounds %struct.op* %o, i64 0, i32 5
  %0 = load i16* %op_seq, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, -1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %1, 64
  %tobool3 = icmp eq i8 %and, 0
  br i1 %tobool3, label %if.end9, label %if.then4

if.then4:                                         ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %conv5 = zext i16 %2 to i32
  switch i32 %conv5, label %if.end9 [
    i32 167, label %sw.bb
    i32 168, label %sw.bb
    i32 312, label %sw.bb
    i32 178, label %sw.bb
    i32 179, label %sw.bb
    i32 207, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then4, %if.then4, %if.then4, %if.then4, %if.then4, %if.then4
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !5
  %dec = add i64 %3, -1
  store i64 %dec, i64* %op_targ, align 8, !tbaa !5
  %tobool6 = icmp eq i64 %dec, 0
  br i1 %tobool6, label %if.end9, label %return

if.end9:                                          ; preds = %sw.bb, %if.end, %if.then4
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !1
  %and11 = and i8 %4, 4
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %if.end9
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !3
  %tobool1453 = icmp eq %struct.op* %6, null
  br i1 %tobool1453, label %if.end15, label %for.body

for.body:                                         ; preds = %if.then13, %for.body
  %kid.054 = phi %struct.op* [ %7, %for.body ], [ %6, %if.then13 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid.054, i64 0, i32 1
  %7 = load %struct.op** %op_sibling, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %kid.054) #8
  %tobool14 = icmp eq %struct.op* %7, null
  br i1 %tobool14, label %if.end15, label %for.body

if.end15:                                         ; preds = %if.then13, %for.body, %if.end9
  %op_type16 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %8 = load i16* %op_type16, align 2, !tbaa !4
  %cmp18 = icmp eq i16 %8, 0
  br i1 %cmp18, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end15
  %op_targ21 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %9 = load i64* %op_targ21, align 8, !tbaa !5
  %conv22 = trunc i64 %9 to i16
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end15
  %type.0 = phi i16 [ %conv22, %if.then20 ], [ %8, %if.end15 ]
  switch i16 %type.0, label %if.end36 [
    i16 174, label %if.then35
    i16 349, label %if.then35
    i16 175, label %if.then35
  ]

if.then35:                                        ; preds = %if.end23, %if.end23, %if.end23
  %cop_label.i = getelementptr inbounds %struct.op* %o, i64 1
  %10 = bitcast %struct.op* %cop_label.i to i8**
  %11 = load i8** %10, align 8, !tbaa !3
  tail call void @Perl_safesysfree(i8* %11) #7
  %cop_filegv.i = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %12 = load %struct.op* ()** %cop_filegv.i, align 8
  %13 = bitcast %struct.op* ()* %12 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %13) #7
  store %struct.op* ()* null, %struct.op* ()** %cop_filegv.i, align 8, !tbaa !3
  %cop_warnings.i = getelementptr inbounds %struct.op* %o, i64 2
  %14 = bitcast %struct.op* %cop_warnings.i to %struct.sv**
  %15 = load %struct.sv** %14, align 8, !tbaa !3
  %magicptr20.i = ptrtoint %struct.sv* %15 to i64
  switch i64 %magicptr20.i, label %if.then.i [
    i64 0, label %if.end.i
    i64 16, label %if.end.i
    i64 32, label %if.end.i
  ]

if.then.i:                                        ; preds = %if.then35
  tail call void @Perl_sv_free(%struct.sv* %15) #7
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.then35, %if.then35, %if.then35
  %cop_io.i = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %16 = load %struct.op** %cop_io.i, align 8
  %cmp8.i = icmp eq %struct.op* %16, null
  br i1 %cmp8.i, label %if.end36, label %if.then9.i

if.then9.i:                                       ; preds = %if.end.i
  %17 = bitcast %struct.op* %16 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %17) #7
  br label %if.end36

if.end36:                                         ; preds = %if.then9.i, %if.end.i, %if.end23
  tail call void @Perl_op_clear(%struct.op* %o) #8
  %18 = bitcast %struct.op* %o to i8*
  tail call void @Perl_safesysfree(i8* %18) #7
  br label %return

return:                                           ; preds = %sw.bb, %entry, %lor.lhs.false, %if.end36
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @Perl_op_clear(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 311, label %sw.bb
    i32 6, label %sw.bb4
    i32 7, label %sw.bb4
    i32 126, label %sw.bb4
    i32 350, label %sw.bb16
    i32 5, label %sw.bb16
    i32 189, label %sw.bb19
    i32 186, label %sw.bb19
    i32 185, label %sw.bb19
    i32 187, label %sw.bb19
    i32 35, label %sw.bb26
    i32 33, label %sw.bb35
    i32 13, label %sw.bb36
    i32 31, label %clear_pmop
    i32 32, label %clear_pmop
  ]

sw.bb:                                            ; preds = %entry, %entry
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 0, i64* %op_targ, align 8, !tbaa !5
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %sw.epilog, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %2 = load %struct.op* (%struct.op*)** %arrayidx, align 8, !tbaa !3
  %cmp = icmp eq %struct.op* (%struct.op*)* %2, @Perl_ck_ftst
  br i1 %cmp, label %sw.bb4, label %sw.epilog

sw.bb4:                                           ; preds = %lor.lhs.false, %entry, %entry, %entry
  %cmp7 = icmp eq i16 %0, 126
  br i1 %cmp7, label %land.lhs.true, label %if.then13

land.lhs.true:                                    ; preds = %sw.bb4
  %op_flags9 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %3 = load i8* %op_flags9, align 1, !tbaa !1
  %tobool12 = icmp slt i8 %3, 0
  br i1 %tobool12, label %sw.epilog, label %if.then13

if.then13:                                        ; preds = %land.lhs.true, %sw.bb4
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %4 = bitcast %struct.op* %op_sv to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !3
  tail call void @Perl_sv_free(%struct.sv* %5) #7
  %6 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  store %struct.op* null, %struct.op** %6, align 8, !tbaa !3
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry, %entry
  %op_sv17 = getelementptr inbounds %struct.op* %o, i64 1
  %7 = bitcast %struct.op* %op_sv17 to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !3
  tail call void @Perl_sv_free(%struct.sv* %8) #7
  %9 = getelementptr inbounds %struct.op* %op_sv17, i64 0, i32 0
  store %struct.op* null, %struct.op** %9, align 8, !tbaa !3
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry, %entry, %entry, %entry
  %op_flags20 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %10 = load i8* %op_flags20, align 1, !tbaa !1
  %and22 = and i8 %10, -60
  %tobool23 = icmp eq i8 %and22, 0
  br i1 %tobool23, label %sw.bb26, label %sw.epilog

sw.bb26:                                          ; preds = %sw.bb19, %entry
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %11 = load i8* %op_private, align 1, !tbaa !1
  %and28 = and i8 %11, 3
  %tobool29 = icmp eq i8 %and28, 0
  %op_pv = getelementptr inbounds %struct.op* %o, i64 1
  br i1 %tobool29, label %if.else, label %if.then30

if.then30:                                        ; preds = %sw.bb26
  %12 = bitcast %struct.op* %op_pv to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !3
  tail call void @Perl_sv_free(%struct.sv* %13) #7
  %14 = getelementptr inbounds %struct.op* %op_pv, i64 0, i32 0
  store %struct.op* null, %struct.op** %14, align 8, !tbaa !3
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb26
  %15 = bitcast %struct.op* %op_pv to i8**
  %16 = load i8** %15, align 8, !tbaa !3
  tail call void @Perl_safesysfree(i8* %16) #7
  %17 = getelementptr inbounds %struct.op* %op_pv, i64 0, i32 0
  store %struct.op* null, %struct.op** %17, align 8, !tbaa !3
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  %op_pmreplroot = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %18 = load %struct.op* ()** %op_pmreplroot, align 8
  %19 = bitcast %struct.op* ()* %18 to %struct.op*
  tail call void @Perl_op_free(%struct.op* %19) #8
  br label %clear_pmop

sw.bb36:                                          ; preds = %entry
  %op_pmreplroot37 = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %20 = load %struct.op* ()** %op_pmreplroot37, align 8
  %21 = bitcast %struct.op* ()* %20 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %21) #7
  br label %clear_pmop

clear_pmop:                                       ; preds = %sw.bb36, %entry, %entry, %sw.bb35
  %22 = bitcast %struct.op* %o to %struct.pmop*
  %op_pmstash = getelementptr inbounds %struct.op* %o, i64 2, i32 3
  %23 = bitcast i64* %op_pmstash to %struct.hv**
  %24 = load %struct.hv** %23, align 8, !tbaa !3
  %tobool39 = icmp eq %struct.hv* %24, null
  br i1 %tobool39, label %if.end57, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %clear_pmop
  %sv_refcnt = getelementptr inbounds %struct.hv* %24, i64 0, i32 1
  %25 = load i32* %sv_refcnt, align 4, !tbaa !0
  %tobool41 = icmp eq i32 %25, 0
  br i1 %tobool41, label %if.end57, label %if.then42

if.then42:                                        ; preds = %land.lhs.true40
  %sv_any = getelementptr inbounds %struct.hv* %24, i64 0, i32 0
  %26 = load %struct.xpvhv** %sv_any, align 8, !tbaa !3
  %xhv_pmroot = getelementptr inbounds %struct.xpvhv* %26, i64 0, i32 9
  %pmop.0101 = load %struct.pmop** %xhv_pmroot, align 8
  %tobool43102 = icmp eq %struct.pmop* %pmop.0101, null
  br i1 %tobool43102, label %if.end57, label %while.body

while.cond:                                       ; preds = %while.body
  %op_pmnext56 = getelementptr inbounds %struct.pmop* %pmop.0104, i64 0, i32 12
  %pmop.0 = load %struct.pmop** %op_pmnext56, align 8
  %tobool43 = icmp eq %struct.pmop* %pmop.0, null
  br i1 %tobool43, label %if.end57, label %while.body

while.body:                                       ; preds = %if.then42, %while.cond
  %pmop.0104 = phi %struct.pmop* [ %pmop.0, %while.cond ], [ %pmop.0101, %if.then42 ]
  %lastpmop.0103 = phi %struct.pmop* [ %pmop.0104, %while.cond ], [ null, %if.then42 ]
  %cmp44 = icmp eq %struct.pmop* %22, %pmop.0104
  br i1 %cmp44, label %if.then46, label %while.cond

if.then46:                                        ; preds = %while.body
  %tobool47 = icmp eq %struct.pmop* %lastpmop.0103, null
  %op_pmnext = getelementptr inbounds %struct.op* %o, i64 1, i32 4
  %27 = bitcast i16* %op_pmnext to %struct.pmop**
  %28 = load %struct.pmop** %27, align 8, !tbaa !3
  br i1 %tobool47, label %if.else50, label %if.then48

if.then48:                                        ; preds = %if.then46
  %op_pmnext49 = getelementptr inbounds %struct.pmop* %lastpmop.0103, i64 0, i32 12
  store %struct.pmop* %28, %struct.pmop** %op_pmnext49, align 8, !tbaa !3
  br label %if.end57

if.else50:                                        ; preds = %if.then46
  store %struct.pmop* %28, %struct.pmop** %xhv_pmroot, align 8, !tbaa !3
  br label %if.end57

if.end57:                                         ; preds = %if.then42, %while.cond, %land.lhs.true40, %clear_pmop, %if.else50, %if.then48
  %op_pmreplroot58 = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  store %struct.op* ()* null, %struct.op* ()** %op_pmreplroot58, align 8, !tbaa !3
  %29 = load void (%struct.regexp*)** @PL_regfree, align 8, !tbaa !3
  %op_pmregexp = getelementptr inbounds %struct.op* %o, i64 2
  %30 = bitcast %struct.op* %op_pmregexp to %struct.regexp**
  %31 = load %struct.regexp** %30, align 8, !tbaa !3
  tail call void %29(%struct.regexp* %31) #7
  %32 = getelementptr inbounds %struct.op* %op_pmregexp, i64 0, i32 0
  store %struct.op* null, %struct.op** %32, align 8, !tbaa !3
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb19, %land.lhs.true, %lor.lhs.false, %sw.default, %if.then30, %if.else, %if.then13, %if.end57, %sw.bb16, %sw.bb
  %op_targ60 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %33 = load i64* %op_targ60, align 8, !tbaa !5
  %cmp61 = icmp eq i64 %33, 0
  br i1 %cmp61, label %if.end66, label %if.then63

if.then63:                                        ; preds = %sw.epilog
  tail call void @Perl_pad_free(i64 %33) #7
  store i64 0, i64* %op_targ60, align 8, !tbaa !5
  br label %if.end66

if.end66:                                         ; preds = %sw.epilog, %if.then63
  ret void
}

; Function Attrs: optsize
declare void @Perl_safesysfree(i8*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_ftst(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %conv1 = zext i8 %1 to i32
  %and = and i32 %conv1, 16
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.else, label %if.end73

if.else:                                          ; preds = %entry
  %and4 = and i32 %conv1, 4
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.else63, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %op_type6 = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type6, align 2, !tbaa !4
  switch i16 %4, label %if.else26 [
    i16 1, label %if.else63
    i16 5, label %land.lhs.true15
  ]

land.lhs.true15:                                  ; preds = %land.lhs.true
  %5 = getelementptr inbounds %struct.op* %3, i64 0, i32 7
  %6 = load i8* %5, align 1, !tbaa !1
  %and17 = and i8 %6, 64
  %tobool18 = icmp eq i8 %and17, 0
  br i1 %tobool18, label %if.else26, label %if.then19

if.then19:                                        ; preds = %land.lhs.true15
  %op_sv = getelementptr inbounds %struct.op* %3, i64 1
  %7 = bitcast %struct.op* %op_sv to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !3
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags, align 4, !tbaa !0
  %and20 = and i32 %9, 262144
  %cmp21 = icmp eq i32 %and20, 0
  br i1 %cmp21, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then19
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur to i64*
  %12 = load i64* %11, align 8, !tbaa !5
  store i64 %12, i64* %n_a, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then19
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %13, %cond.true ], [ %call, %cond.false ]
  %call24 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 1, i32 15) #7
  %14 = bitcast %struct.gv* %call24 to %struct.sv*
  store %struct.sv* %14, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %call24, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %cond.end
  %15 = getelementptr inbounds %struct.gv* %call24, i64 0, i32 1
  %16 = load i32* %15, align 4, !tbaa !0
  %inc.i = add i32 %16, 1
  store i32 %inc.i, i32* %15, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %cond.end, %land.rhs.i
  %call.i = call %struct.op* @Perl_newSVOP(i32 %conv, i32 16, %struct.sv* %14) #7
  call void @Perl_op_free(%struct.op* %o) #8
  br label %if.end73

if.else26:                                        ; preds = %land.lhs.true, %land.lhs.true15
  %17 = load i32* @PL_hints, align 4, !tbaa !0
  %and27 = and i32 %17, 4194304
  %tobool28 = icmp eq i32 %and27, 0
  br i1 %tobool28, label %if.end73, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %if.else26
  %.off = add i16 %0, -236
  %switch = icmp ult i16 %.off, 6
  br i1 %switch, label %if.then58, label %if.end73

if.then58:                                        ; preds = %land.lhs.true29
  %op_private59 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %18 = load i8* %op_private59, align 1, !tbaa !1
  %or = or i8 %18, 2
  store i8 %or, i8* %op_private59, align 1, !tbaa !1
  br label %if.end73

if.else63:                                        ; preds = %land.lhs.true, %if.else
  call void @Perl_op_free(%struct.op* %o) #8
  %cmp64 = icmp eq i16 %0, 260
  br i1 %cmp64, label %if.then66, label %if.else68

if.then66:                                        ; preds = %if.else63
  %19 = load %struct.gv** @PL_stdingv, align 8, !tbaa !3
  %20 = bitcast %struct.gv* %19 to %struct.sv*
  store %struct.sv* %20, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i92 = icmp eq %struct.gv* %19, null
  br i1 %tobool.i92, label %Perl_newGVOP.exit96, label %land.rhs.i94

land.rhs.i94:                                     ; preds = %if.then66
  %21 = getelementptr inbounds %struct.gv* %19, i64 0, i32 1
  %22 = load i32* %21, align 4, !tbaa !0
  %inc.i93 = add i32 %22, 1
  store i32 %inc.i93, i32* %21, align 4, !tbaa !0
  br label %Perl_newGVOP.exit96

Perl_newGVOP.exit96:                              ; preds = %if.then66, %land.rhs.i94
  %call.i95 = call %struct.op* @Perl_newSVOP(i32 %conv, i32 16, %struct.sv* %20) #7
  br label %if.end73

if.else68:                                        ; preds = %if.else63
  %23 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %24 = bitcast %struct.gv* %23 to %struct.sv*
  store %struct.sv* %24, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i98 = icmp eq %struct.gv* %23, null
  br i1 %tobool.i98, label %Perl_newGVOP.exit102, label %land.rhs.i100

land.rhs.i100:                                    ; preds = %if.else68
  %25 = getelementptr inbounds %struct.gv* %23, i64 0, i32 1
  %26 = load i32* %25, align 4, !tbaa !0
  %inc.i99 = add i32 %26, 1
  store i32 %inc.i99, i32* %25, align 4, !tbaa !0
  br label %Perl_newGVOP.exit102

Perl_newGVOP.exit102:                             ; preds = %if.else68, %land.rhs.i100
  %call.i101 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %24) #7
  %call1.i = call %struct.op* @Perl_newSVREF(%struct.op* %call.i101) #7
  %call70 = call %struct.op* @Perl_newUNOP(i32 %conv, i32 0, %struct.op* %call1.i) #8
  br label %if.end73

if.end73:                                         ; preds = %land.lhs.true29, %if.else26, %entry, %if.then58, %Perl_newGVOP.exit, %Perl_newGVOP.exit102, %Perl_newGVOP.exit96
  %o.addr.0 = phi %struct.op* [ %o, %entry ], [ %call.i, %Perl_newGVOP.exit ], [ %o, %if.then58 ], [ %o, %if.else26 ], [ %call.i95, %Perl_newGVOP.exit96 ], [ %call70, %Perl_newGVOP.exit102 ], [ %o, %land.lhs.true29 ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: optsize
declare void @Perl_sv_free(%struct.sv*) #2

; Function Attrs: optsize
declare void @Perl_pad_free(i64) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_op_null(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call void @Perl_op_clear(%struct.op* %o) #8
  %1 = load i16* %op_type, align 2, !tbaa !4
  %conv3 = zext i16 %1 to i64
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 %conv3, i64* %op_targ, align 8, !tbaa !5
  store i16 0, i16* %op_type, align 2, !tbaa !4
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 0), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind optsize readnone uwtable
define void @Perl_op_refcnt_lock() #3 {
entry:
  ret void
}

; Function Attrs: nounwind optsize readnone uwtable
define void @Perl_op_refcnt_unlock() #3 {
entry:
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_linklist(%struct.op* %o) #0 {
entry:
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %0 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool = icmp eq %struct.op* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %tobool2 = icmp eq %struct.op* %2, null
  br i1 %tobool2, label %if.else30, label %if.then3

if.then3:                                         ; preds = %if.end
  %op_next5 = getelementptr inbounds %struct.op* %2, i64 0, i32 0
  %3 = load %struct.op** %op_next5, align 8, !tbaa !3
  %tobool6 = icmp eq %struct.op* %3, null
  br i1 %tobool6, label %cond.end, label %cond.end.thread

cond.end.thread:                                  ; preds = %if.then3
  store %struct.op* %3, %struct.op** %op_next, align 8, !tbaa !3
  br label %for.body

cond.end:                                         ; preds = %if.then3
  %call = tail call %struct.op* @Perl_linklist(%struct.op* %2) #8
  %kid.048.pre = load %struct.op** %1, align 8
  store %struct.op* %call, %struct.op** %op_next, align 8, !tbaa !3
  %tobool1249 = icmp eq %struct.op* %kid.048.pre, null
  br i1 %tobool1249, label %return, label %for.body

for.body:                                         ; preds = %for.cond.backedge.thread58, %cond.end, %cond.end.thread, %for.cond.backedge
  %kid.050 = phi %struct.op* [ %kid.0.pre.pre, %for.cond.backedge ], [ %2, %cond.end.thread ], [ %kid.048.pre, %cond.end ], [ %4, %for.cond.backedge.thread58 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid.050, i64 0, i32 1
  %4 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool13 = icmp eq %struct.op* %4, null
  br i1 %tobool13, label %for.cond.backedge.thread, label %if.then14

if.then14:                                        ; preds = %for.body
  %op_next16 = getelementptr inbounds %struct.op* %4, i64 0, i32 0
  %5 = load %struct.op** %op_next16, align 8, !tbaa !3
  %tobool17 = icmp eq %struct.op* %5, null
  br i1 %tobool17, label %for.cond.backedge, label %for.cond.backedge.thread58

for.cond.backedge.thread58:                       ; preds = %if.then14
  %op_next2659 = getelementptr inbounds %struct.op* %kid.050, i64 0, i32 0
  store %struct.op* %5, %struct.op** %op_next2659, align 8, !tbaa !3
  br label %for.body

for.cond.backedge:                                ; preds = %if.then14
  %call23 = tail call %struct.op* @Perl_linklist(%struct.op* %4) #8
  %kid.0.pre.pre = load %struct.op** %op_sibling, align 8
  %op_next26 = getelementptr inbounds %struct.op* %kid.050, i64 0, i32 0
  store %struct.op* %call23, %struct.op** %op_next26, align 8, !tbaa !3
  %tobool12 = icmp eq %struct.op* %kid.0.pre.pre, null
  br i1 %tobool12, label %for.cond.if.end32.loopexit_crit_edge, label %for.body

for.cond.backedge.thread:                         ; preds = %for.body
  %op_next27 = getelementptr inbounds %struct.op* %kid.050, i64 0, i32 0
  store %struct.op* %o, %struct.op** %op_next27, align 8, !tbaa !3
  br label %for.cond.if.end32.loopexit_crit_edge

if.else30:                                        ; preds = %if.end
  store %struct.op* %o, %struct.op** %op_next, align 8, !tbaa !3
  br label %return

for.cond.if.end32.loopexit_crit_edge:             ; preds = %for.cond.backedge.thread, %for.cond.backedge
  %.pre.pre = load %struct.op** %op_next, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %if.else30, %for.cond.if.end32.loopexit_crit_edge, %cond.end, %entry
  %retval.0 = phi %struct.op* [ %0, %entry ], [ %o, %if.else30 ], [ %.pre.pre, %for.cond.if.end32.loopexit_crit_edge ], [ %call, %cond.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_scalarkids(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %kid.010) #8
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %if.then, %for.body, %land.lhs.true, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_scalar(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %1 = load i32* @PL_error_count, align 4, !tbaa !0
  %2 = or i32 %and, %1
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %lor.lhs.false4, label %return

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 184
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false4
  %and9 = and i8 %0, -4
  %or = or i8 %and9, 2
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  %conv13 = zext i16 %4 to i32
  switch i32 %conv13, label %sw.default [
    i32 61, label %sw.bb
    i32 160, label %sw.bb14
    i32 159, label %sw.bb14
    i32 162, label %sw.bb14
    i32 139, label %sw.bb19
    i32 150, label %sw.bb72
    i32 141, label %sw.bb57
    i32 173, label %sw.bb57
    i32 179, label %sw.bb57
    i32 178, label %sw.bb46
    i32 314, label %sw.bb46
  ]

sw.bb:                                            ; preds = %if.end
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !3
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %6) #8
  ret %struct.op* %o

sw.bb14:                                          ; preds = %if.end, %if.end, %if.end
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !3
  %kid.0.in132 = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %kid.0133 = load %struct.op** %kid.0.in132, align 8
  %tobool16134 = icmp eq %struct.op* %kid.0133, null
  br i1 %tobool16134, label %return, label %for.body

for.body:                                         ; preds = %sw.bb14, %for.body
  %kid.0135 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0133, %sw.bb14 ]
  %call17 = tail call %struct.op* @Perl_scalar(%struct.op* %kid.0135) #8
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0135, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool16 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool16, label %return, label %for.body

sw.bb19:                                          ; preds = %if.end
  %9 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %10 = load %struct.op** %9, align 8, !tbaa !3
  %tobool21 = icmp eq %struct.op* %10, null
  br i1 %tobool21, label %sw.default, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb19
  %op_type22 = getelementptr inbounds %struct.op* %10, i64 0, i32 4
  %11 = load i16* %op_type22, align 2, !tbaa !4
  %cmp24 = icmp eq i16 %11, 13
  br i1 %cmp24, label %if.then26, label %sw.default

if.then26:                                        ; preds = %land.lhs.true
  %op_pmreplroot = getelementptr inbounds %struct.op* %10, i64 1, i32 2
  %12 = load %struct.op* ()** %op_pmreplroot, align 8
  %tobool27 = icmp eq %struct.op* ()* %12, null
  br i1 %tobool27, label %if.then28, label %sw.default

if.then28:                                        ; preds = %if.then26
  tail call void @Perl_deprecate_old(i8* getelementptr inbounds ([21 x i8]* @.str6, i64 0, i64 0)) #7
  %.pre = load i8* %op_flags, align 1, !tbaa !1
  br label %sw.default

sw.default:                                       ; preds = %if.then26, %sw.bb19, %if.then28, %land.lhs.true, %if.end
  %13 = phi i8 [ %or, %if.then26 ], [ %or, %sw.bb19 ], [ %.pre, %if.then28 ], [ %or, %land.lhs.true ], [ %or, %if.end ]
  %and34 = and i8 %13, 4
  %tobool35 = icmp eq i8 %and34, 0
  br i1 %tobool35, label %return, label %if.then36

if.then36:                                        ; preds = %sw.default
  %14 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.1128 = load %struct.op** %14, align 8
  %tobool39129 = icmp eq %struct.op* %kid.1128, null
  br i1 %tobool39129, label %return, label %for.body40

for.body40:                                       ; preds = %if.then36, %for.body40
  %kid.1130 = phi %struct.op* [ %kid.1, %for.body40 ], [ %kid.1128, %if.then36 ]
  %call41 = tail call %struct.op* @Perl_scalar(%struct.op* %kid.1130) #8
  %op_sibling43 = getelementptr inbounds %struct.op* %kid.1130, i64 0, i32 1
  %kid.1 = load %struct.op** %op_sibling43, align 8
  %tobool39 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool39, label %return, label %for.body40

sw.bb46:                                          ; preds = %if.end, %if.end
  %15 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %16 = load %struct.op** %15, align 8, !tbaa !3
  %call48 = tail call %struct.op* @Perl_scalar(%struct.op* %16) #8
  %op_sibling49139 = getelementptr inbounds %struct.op* %16, i64 0, i32 1
  %17 = load %struct.op** %op_sibling49139, align 8, !tbaa !3
  %tobool50140 = icmp eq %struct.op* %17, null
  br i1 %tobool50140, label %while.end, label %while.body

while.body:                                       ; preds = %sw.bb46, %while.cond.backedge
  %18 = phi %struct.op* [ %20, %while.cond.backedge ], [ %17, %sw.bb46 ]
  %op_sibling51 = getelementptr inbounds %struct.op* %18, i64 0, i32 1
  %19 = load %struct.op** %op_sibling51, align 8, !tbaa !3
  %tobool52 = icmp eq %struct.op* %19, null
  br i1 %tobool52, label %if.else, label %if.then53

if.then53:                                        ; preds = %while.body
  %call54 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %18) #8
  br label %while.cond.backedge

if.else:                                          ; preds = %while.body
  %call55 = tail call %struct.op* @Perl_scalar(%struct.op* %18) #8
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.else, %if.then53
  %20 = load %struct.op** %op_sibling51, align 8, !tbaa !3
  %tobool50 = icmp eq %struct.op* %20, null
  br i1 %tobool50, label %while.end, label %while.body

while.end:                                        ; preds = %while.cond.backedge, %sw.bb46
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %return

sw.bb57:                                          ; preds = %if.end, %if.end, %if.end
  %21 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.3136 = load %struct.op** %21, align 8
  %tobool60137 = icmp eq %struct.op* %kid.3136, null
  br i1 %tobool60137, label %for.end71, label %for.body61

for.body61:                                       ; preds = %sw.bb57, %for.cond59.backedge
  %kid.3138 = phi %struct.op* [ %kid.3, %for.cond59.backedge ], [ %kid.3136, %sw.bb57 ]
  %op_sibling62 = getelementptr inbounds %struct.op* %kid.3138, i64 0, i32 1
  %22 = load %struct.op** %op_sibling62, align 8, !tbaa !3
  %tobool63 = icmp eq %struct.op* %22, null
  br i1 %tobool63, label %if.else66, label %if.then64

if.then64:                                        ; preds = %for.body61
  %call65 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %kid.3138) #8
  br label %for.cond59.backedge

for.cond59.backedge:                              ; preds = %if.then64, %if.else66
  %kid.3 = load %struct.op** %op_sibling62, align 8
  %tobool60 = icmp eq %struct.op* %kid.3, null
  br i1 %tobool60, label %for.end71, label %for.body61

if.else66:                                        ; preds = %for.body61
  %call67 = tail call %struct.op* @Perl_scalar(%struct.op* %kid.3138) #8
  br label %for.cond59.backedge

for.end71:                                        ; preds = %for.cond59.backedge, %sw.bb57
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %return

sw.bb72:                                          ; preds = %if.end
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %23, i64 0, i32 14
  %24 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp73 = icmp eq %struct.sv* %24, null
  br i1 %cmp73, label %lor.lhs.false88, label %land.lhs.true75

land.lhs.true75:                                  ; preds = %sw.bb72
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings76 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings76, align 8, !tbaa !3
  %cmp77 = icmp eq %struct.sv* %26, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp77, label %lor.lhs.false88, label %land.lhs.true79

land.lhs.true79:                                  ; preds = %land.lhs.true75
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings80 = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings80, align 8, !tbaa !3
  %cmp81 = icmp eq %struct.sv* %28, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp81, label %if.then96, label %lor.lhs.false83

lor.lhs.false83:                                  ; preds = %land.lhs.true79
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings84 = getelementptr inbounds %struct.cop* %29, i64 0, i32 14
  %30 = load %struct.sv** %cop_warnings84, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %30, i64 0, i32 0
  %31 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %31 to i8**
  %32 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %32, i64 11
  %33 = load i8* %arrayidx, align 1, !tbaa !1
  %and86 = and i8 %33, 4
  %tobool87 = icmp eq i8 %and86, 0
  br i1 %tobool87, label %lor.lhs.false88, label %if.then96

lor.lhs.false88:                                  ; preds = %lor.lhs.false83, %land.lhs.true75, %sw.bb72
  %34 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings89 = getelementptr inbounds %struct.cop* %34, i64 0, i32 14
  %35 = load %struct.sv** %cop_warnings89, align 8, !tbaa !3
  %cmp90 = icmp eq %struct.sv* %35, null
  br i1 %cmp90, label %land.lhs.true92, label %return

land.lhs.true92:                                  ; preds = %lor.lhs.false88
  %36 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and94 = and i8 %36, 1
  %tobool95 = icmp eq i8 %and94, 0
  br i1 %tobool95, label %return, label %if.then96

if.then96:                                        ; preds = %lor.lhs.false83, %land.lhs.true92, %land.lhs.true79
  tail call void (i32, i8*, ...)* @Perl_warner(i32 45, i8* getelementptr inbounds ([38 x i8]* @.str7, i64 0, i64 0)) #7
  br label %return

return:                                           ; preds = %sw.bb14, %for.body, %if.then36, %for.body40, %while.end, %for.end71, %if.then96, %lor.lhs.false88, %land.lhs.true92, %sw.default, %lor.lhs.false4, %entry, %lor.lhs.false
  ret %struct.op* %o
}

; Function Attrs: optsize
declare void @Perl_deprecate_old(i8*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_scalarvoid(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %if.end [
    i16 174, label %if.then
    i16 349, label %if.then
    i16 175, label %if.then
    i16 0, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %entry
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %1 = load i64* %op_targ, align 8, !tbaa !5
  switch i64 %1, label %if.end [
    i64 174, label %if.then
    i64 349, label %if.then
    i64 175, label %if.then
  ]

if.then:                                          ; preds = %land.lhs.true, %land.lhs.true, %land.lhs.true, %entry, %entry, %entry
  %2 = bitcast %struct.op* %o to %struct.cop*
  store volatile %struct.cop* %2, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %if.then
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %3 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %3, 3
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false33, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %if.end
  %cmp31 = icmp ne i8 %and, 2
  %4 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool34 = icmp ne i32 %4, 0
  %or.cond = or i1 %cmp31, %tobool34
  br i1 %or.cond, label %return, label %lor.lhs.false35

lor.lhs.false33:                                  ; preds = %if.end
  %.old = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool34.old = icmp eq i32 %.old, 0
  br i1 %tobool34.old, label %lor.lhs.false35, label %return

lor.lhs.false35:                                  ; preds = %lor.lhs.false33, %land.lhs.true29
  %5 = load i16* %op_type, align 2, !tbaa !4
  %cmp38 = icmp eq i16 %5, 184
  br i1 %cmp38, label %return, label %if.end41

if.end41:                                         ; preds = %lor.lhs.false35
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !1
  %and43 = and i8 %6, 16
  %tobool44 = icmp eq i8 %and43, 0
  br i1 %tobool44, label %if.end50, label %land.lhs.true45

land.lhs.true45:                                  ; preds = %if.end41
  %idxprom = zext i16 %5 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %7 = load i32* %arrayidx, align 4, !tbaa !0
  %and47 = and i32 %7, 256
  %tobool48 = icmp eq i32 %and47, 0
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %land.lhs.true45
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  br label %return

if.end50:                                         ; preds = %land.lhs.true45, %if.end41
  %and53 = and i8 %3, -4
  %or = or i8 %and53, 1
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  %conv57 = zext i16 %5 to i32
  switch i32 %conv57, label %sw.default [
    i32 61, label %sw.bb
    i32 111, label %sw.bb71
    i32 6, label %func_ops
    i32 4, label %func_ops
    i32 7, label %func_ops
    i32 9, label %func_ops
    i32 10, label %func_ops
    i32 11, label %func_ops
    i32 12, label %func_ops
    i32 16, label %func_ops
    i32 22, label %func_ops
    i32 20, label %func_ops
    i32 21, label %func_ops
    i32 42, label %func_ops
    i32 107, label %func_ops
    i32 108, label %func_ops
    i32 110, label %func_ops
    i32 112, label %func_ops
    i32 113, label %func_ops
    i32 114, label %func_ops
    i32 115, label %func_ops
    i32 127, label %func_ops
    i32 126, label %func_ops
    i32 128, label %func_ops
    i32 135, label %func_ops
    i32 136, label %func_ops
    i32 137, label %func_ops
    i32 138, label %func_ops
    i32 140, label %func_ops
    i32 142, label %func_ops
    i32 143, label %func_ops
    i32 144, label %func_ops
    i32 150, label %func_ops
    i32 151, label %func_ops
    i32 156, label %func_ops
    i32 157, label %func_ops
    i32 158, label %func_ops
    i32 169, label %func_ops
    i32 194, label %func_ops
    i32 216, label %func_ops
    i32 217, label %func_ops
    i32 232, label %func_ops
    i32 233, label %func_ops
    i32 272, label %func_ops
    i32 277, label %func_ops
    i32 287, label %func_ops
    i32 288, label %func_ops
    i32 290, label %func_ops
    i32 292, label %func_ops
    i32 293, label %func_ops
    i32 294, label %func_ops
    i32 295, label %func_ops
    i32 315, label %func_ops
    i32 316, label %func_ops
    i32 317, label %func_ops
    i32 318, label %func_ops
    i32 319, label %func_ops
    i32 320, label %func_ops
    i32 321, label %func_ops
    i32 322, label %func_ops
    i32 323, label %func_ops
    i32 324, label %func_ops
    i32 325, label %func_ops
    i32 326, label %func_ops
    i32 335, label %func_ops
    i32 336, label %func_ops
    i32 340, label %func_ops
    i32 341, label %func_ops
    i32 345, label %func_ops
    i32 19, label %func_ops
    i32 14, label %sw.bb93
    i32 15, label %sw.bb93
    i32 125, label %sw.bb93
    i32 134, label %sw.bb93
    i32 5, label %sw.bb108
    i32 50, label %sw.bb199
    i32 52, label %sw.bb201
    i32 160, label %sw.bb204
    i32 159, label %sw.bb204
    i32 162, label %sw.bb204
    i32 0, label %sw.bb209
    i32 174, label %sw.bb216
    i32 175, label %sw.bb216
    i32 313, label %sw.bb216
    i32 177, label %sw.bb216
    i32 179, label %sw.bb223
    i32 178, label %sw.bb223
    i32 314, label %sw.bb223
    i32 183, label %sw.bb223
    i32 173, label %sw.bb223
    i32 141, label %sw.bb223
    i32 311, label %sw.bb232
    i32 309, label %sw.bb234
    i32 2, label %sw.bb239
    i32 139, label %sw.bb241
  ]

sw.default:                                       ; preds = %if.end50
  %idxprom59 = zext i16 %5 to i64
  %arrayidx60 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom59
  %8 = load i32* %arrayidx60, align 4, !tbaa !0
  %and61 = and i32 %8, 2
  %tobool62 = icmp eq i32 %and61, 0
  br i1 %tobool62, label %return, label %sw.bb

sw.bb:                                            ; preds = %sw.default, %if.end50
  %and67 = and i8 %3, 64
  %tobool68 = icmp eq i8 %and67, 0
  br i1 %tobool68, label %func_ops, label %return

sw.bb71:                                          ; preds = %if.end50
  %cmp74 = icmp eq i8 %6, 4
  br i1 %cmp74, label %return, label %func_ops

func_ops:                                         ; preds = %sw.bb, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %sw.bb71
  %and81 = and i8 %6, -112
  %tobool82 = icmp eq i8 %and81, 0
  br i1 %tobool82, label %if.then83, label %return

if.then83:                                        ; preds = %func_ops
  %cmp86 = icmp eq i16 %5, 351
  br i1 %cmp86, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then83
  %call88 = tail call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %sw.epilog

cond.false:                                       ; preds = %if.then83
  %idxprom90 = zext i16 %5 to i64
  %arrayidx91 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom90
  %9 = load i8** %arrayidx91, align 8, !tbaa !3
  br label %sw.epilog

sw.bb93:                                          ; preds = %if.end50, %if.end50, %if.end50, %if.end50
  %and96 = and i8 %6, -112
  %tobool97 = icmp eq i8 %and96, 0
  br i1 %tobool97, label %land.lhs.true98, label %return

land.lhs.true98:                                  ; preds = %sw.bb93
  %op_sibling = getelementptr inbounds %struct.op* %o, i64 0, i32 1
  %10 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool99 = icmp eq %struct.op* %10, null
  br i1 %tobool99, label %land.lhs.true255, label %lor.lhs.false100

lor.lhs.false100:                                 ; preds = %land.lhs.true98
  %op_type102 = getelementptr inbounds %struct.op* %10, i64 0, i32 4
  %11 = load i16* %op_type102, align 2, !tbaa !4
  %cmp104 = icmp eq i16 %11, 26
  br i1 %cmp104, label %return, label %land.lhs.true255

sw.bb108:                                         ; preds = %if.end50
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %12 = bitcast %struct.op* %op_sv to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !3
  %and111 = and i8 %6, 8
  %tobool112 = icmp eq i8 %and111, 0
  br i1 %tobool112, label %if.else, label %if.then113

if.then113:                                       ; preds = %sw.bb108
  %call.i = tail call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([53 x i8]* @.str155, i64 0, i64 0), %struct.sv* %13) #7
  tail call void @Perl_qerror(%struct.sv* %call.i) #7
  br label %if.end198

if.else:                                          ; preds = %sw.bb108
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp114 = icmp eq %struct.sv* %15, null
  br i1 %cmp114, label %lor.lhs.false130, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %if.else
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings117 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings117, align 8, !tbaa !3
  %cmp118 = icmp eq %struct.sv* %17, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp118, label %lor.lhs.false130, label %land.lhs.true120

land.lhs.true120:                                 ; preds = %land.lhs.true116
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings121 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings121, align 8, !tbaa !3
  %cmp122 = icmp eq %struct.sv* %19, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp122, label %if.then138, label %lor.lhs.false124

lor.lhs.false124:                                 ; preds = %land.lhs.true120
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings125 = getelementptr inbounds %struct.cop* %20, i64 0, i32 14
  %21 = load %struct.sv** %cop_warnings125, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %22 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %22 to i8**
  %23 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx126 = getelementptr inbounds i8* %23, i64 11
  %24 = load i8* %arrayidx126, align 1, !tbaa !1
  %and128 = and i8 %24, 4
  %tobool129 = icmp eq i8 %and128, 0
  br i1 %tobool129, label %lor.lhs.false130, label %if.then138

lor.lhs.false130:                                 ; preds = %lor.lhs.false124, %land.lhs.true116, %if.else
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings131 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings131, align 8, !tbaa !3
  %cmp132 = icmp eq %struct.sv* %26, null
  br i1 %cmp132, label %land.lhs.true134, label %if.end198

land.lhs.true134:                                 ; preds = %lor.lhs.false130
  %27 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and136 = and i8 %27, 1
  %tobool137 = icmp eq i8 %and136, 0
  br i1 %tobool137, label %if.end198, label %if.then138

if.then138:                                       ; preds = %lor.lhs.false124, %land.lhs.true134, %land.lhs.true120
  %28 = load i8* %op_private, align 1, !tbaa !1
  %and141 = and i8 %28, 4
  %tobool142 = icmp eq i8 %and141, 0
  br i1 %tobool142, label %if.else144, label %if.end198

if.else144:                                       ; preds = %if.then138
  %sv_flags = getelementptr inbounds %struct.sv* %13, i64 0, i32 2
  %29 = load i32* %sv_flags, align 4, !tbaa !0
  %and145 = and i32 %29, 196608
  %tobool146 = icmp eq i32 %and145, 0
  br i1 %tobool146, label %if.else173, label %land.lhs.true147

land.lhs.true147:                                 ; preds = %if.else144
  %and149 = and i32 %29, 131072
  %tobool150 = icmp eq i32 %and149, 0
  br i1 %tobool150, label %cond.false153, label %cond.true151

cond.true151:                                     ; preds = %land.lhs.true147
  %sv_any152 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %30 = load i8** %sv_any152, align 8, !tbaa !3
  %xnv_nv = getelementptr inbounds i8* %30, i64 32
  %31 = bitcast i8* %xnv_nv to double*
  %32 = load double* %31, align 8, !tbaa !6
  br label %cond.end155

cond.false153:                                    ; preds = %land.lhs.true147
  %call154 = tail call double @Perl_sv_2nv(%struct.sv* %13) #7
  br label %cond.end155

cond.end155:                                      ; preds = %cond.false153, %cond.true151
  %cond156 = phi double [ %32, %cond.true151 ], [ %call154, %cond.false153 ]
  %cmp157 = fcmp oeq double %cond156, 0.000000e+00
  br i1 %cmp157, label %if.end198, label %lor.lhs.false159

lor.lhs.false159:                                 ; preds = %cond.end155
  %33 = load i32* %sv_flags, align 4, !tbaa !0
  %and161 = and i32 %33, 131072
  %tobool162 = icmp eq i32 %and161, 0
  br i1 %tobool162, label %cond.false166, label %cond.true163

cond.true163:                                     ; preds = %lor.lhs.false159
  %sv_any164 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %34 = load i8** %sv_any164, align 8, !tbaa !3
  %xnv_nv165 = getelementptr inbounds i8* %34, i64 32
  %35 = bitcast i8* %xnv_nv165 to double*
  %36 = load double* %35, align 8, !tbaa !6
  br label %cond.end168

cond.false166:                                    ; preds = %lor.lhs.false159
  %call167 = tail call double @Perl_sv_2nv(%struct.sv* %13) #7
  br label %cond.end168

cond.end168:                                      ; preds = %cond.false166, %cond.true163
  %cond169 = phi double [ %36, %cond.true163 ], [ %call167, %cond.false166 ]
  %cmp170 = fcmp oeq double %cond169, 1.000000e+00
  br i1 %cmp170, label %if.end198, label %cond.end168.if.else173_crit_edge

cond.end168.if.else173_crit_edge:                 ; preds = %cond.end168
  %.pre = load i32* %sv_flags, align 4, !tbaa !0
  br label %if.else173

if.else173:                                       ; preds = %cond.end168.if.else173_crit_edge, %if.else144
  %37 = phi i32 [ %.pre, %cond.end168.if.else173_crit_edge ], [ %29, %if.else144 ]
  %and175 = and i32 %37, 262144
  %tobool176 = icmp eq i32 %and175, 0
  br i1 %tobool176, label %if.end198, label %if.then177

if.then177:                                       ; preds = %if.else173
  %sv_any178 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %38 = load i8** %sv_any178, align 8, !tbaa !3
  %xpv_pv179 = bitcast i8* %38 to i8**
  %39 = load i8** %xpv_pv179, align 8, !tbaa !3
  %call180 = tail call i32 @strncmp(i8* %39, i8* getelementptr inbounds ([3 x i8]* @.str10, i64 0, i64 0), i64 2) #7
  %tobool181 = icmp eq i32 %call180, 0
  br i1 %tobool181, label %if.then192, label %lor.lhs.false182

lor.lhs.false182:                                 ; preds = %if.then177
  %call185 = tail call i32 @strncmp(i8* %39, i8* getelementptr inbounds ([3 x i8]* @.str11, i64 0, i64 0), i64 2) #7
  %tobool186 = icmp eq i32 %call185, 0
  br i1 %tobool186, label %if.then192, label %lor.lhs.false187

lor.lhs.false187:                                 ; preds = %lor.lhs.false182
  %call190 = tail call i32 @strncmp(i8* %39, i8* getelementptr inbounds ([3 x i8]* @.str12, i64 0, i64 0), i64 2) #7
  %tobool191 = icmp eq i32 %call190, 0
  br i1 %tobool191, label %if.then192, label %if.end198

if.then192:                                       ; preds = %lor.lhs.false187, %lor.lhs.false182, %if.then177
  br label %if.end198

if.end198:                                        ; preds = %cond.end155, %cond.end168, %if.then138, %lor.lhs.false187, %if.else173, %land.lhs.true134, %lor.lhs.false130, %if.then192, %if.then113
  %useless.0 = phi i8* [ null, %if.then113 ], [ getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), %lor.lhs.false187 ], [ null, %if.then192 ], [ getelementptr inbounds ([11 x i8]* @.str9, i64 0, i64 0), %if.else173 ], [ null, %land.lhs.true134 ], [ null, %lor.lhs.false130 ], [ null, %if.then138 ], [ null, %cond.end168 ], [ null, %cond.end155 ]
  tail call void @Perl_op_null(%struct.op* %o) #8
  br label %sw.epilog

sw.bb199:                                         ; preds = %if.end50
  store i16 46, i16* %op_type, align 2, !tbaa !4
  %40 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 46), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %40, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %return

sw.bb201:                                         ; preds = %if.end50
  store i16 48, i16* %op_type, align 2, !tbaa !4
  %41 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 48), align 8, !tbaa !3
  %op_ppaddr203 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %41, %struct.op* ()** %op_ppaddr203, align 8, !tbaa !3
  br label %return

sw.bb204:                                         ; preds = %if.end50, %if.end50, %if.end50
  %42 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %43 = load %struct.op** %42, align 8, !tbaa !3
  %kid.0.in351 = getelementptr inbounds %struct.op* %43, i64 0, i32 1
  %kid.0352 = load %struct.op** %kid.0.in351, align 8
  %tobool206353 = icmp eq %struct.op* %kid.0352, null
  br i1 %tobool206353, label %return, label %for.body

for.body:                                         ; preds = %sw.bb204, %for.body
  %kid.0354 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0352, %sw.bb204 ]
  %call207 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %kid.0354) #8
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0354, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool206 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool206, label %return, label %for.body

sw.bb209:                                         ; preds = %if.end50
  %44 = and i8 %3, 68
  %45 = icmp eq i8 %44, 4
  br i1 %45, label %sw.bb223, label %return

sw.bb216:                                         ; preds = %if.end50, %if.end50, %if.end50, %if.end50
  %.old359 = and i8 %3, 4
  %tobool220.old = icmp eq i8 %.old359, 0
  br i1 %tobool220.old, label %return, label %sw.bb223

sw.bb223:                                         ; preds = %sw.bb209, %sw.bb216, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50, %if.end50
  %46 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.1356 = load %struct.op** %46, align 8
  %tobool226357 = icmp eq %struct.op* %kid.1356, null
  br i1 %tobool226357, label %return, label %for.body227

for.body227:                                      ; preds = %sw.bb223, %for.body227
  %kid.1358 = phi %struct.op* [ %kid.1, %for.body227 ], [ %kid.1356, %sw.bb223 ]
  %call228 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %kid.1358) #8
  %op_sibling230 = getelementptr inbounds %struct.op* %kid.1358, i64 0, i32 1
  %kid.1 = load %struct.op** %op_sibling230, align 8
  %tobool226 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool226, label %return, label %for.body227

sw.bb232:                                         ; preds = %if.end50
  %call233 = tail call %struct.op* @Perl_scalarkids(%struct.op* %o) #8
  br label %return

sw.bb234:                                         ; preds = %if.end50
  store i8 %and53, i8* %op_flags, align 1, !tbaa !1
  br label %sw.bb239

sw.bb239:                                         ; preds = %if.end50, %sw.bb234
  %call240 = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  br label %return

sw.bb241:                                         ; preds = %if.end50
  %47 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %48 = load %struct.op** %47, align 8, !tbaa !3
  %tobool243 = icmp eq %struct.op* %48, null
  br i1 %tobool243, label %return, label %land.lhs.true244

land.lhs.true244:                                 ; preds = %sw.bb241
  %op_type245 = getelementptr inbounds %struct.op* %48, i64 0, i32 4
  %49 = load i16* %op_type245, align 2, !tbaa !4
  %cmp247 = icmp eq i16 %49, 13
  br i1 %cmp247, label %if.then249, label %return

if.then249:                                       ; preds = %land.lhs.true244
  %op_pmreplroot = getelementptr inbounds %struct.op* %48, i64 1, i32 2
  %50 = load %struct.op* ()** %op_pmreplroot, align 8
  %tobool250 = icmp eq %struct.op* ()* %50, null
  br i1 %tobool250, label %if.then251, label %return

if.then251:                                       ; preds = %if.then249
  tail call void @Perl_deprecate_old(i8* getelementptr inbounds ([21 x i8]* @.str6, i64 0, i64 0)) #7
  br label %return

sw.epilog:                                        ; preds = %cond.true, %cond.false, %if.end198
  %useless.1 = phi i8* [ %useless.0, %if.end198 ], [ %call88, %cond.true ], [ %9, %cond.false ]
  %tobool254 = icmp eq i8* %useless.1, null
  br i1 %tobool254, label %return, label %land.lhs.true255

land.lhs.true255:                                 ; preds = %lor.lhs.false100, %land.lhs.true98, %sw.epilog
  %useless.1350 = phi i8* [ %useless.1, %sw.epilog ], [ getelementptr inbounds ([11 x i8]* @.str8, i64 0, i64 0), %land.lhs.true98 ], [ getelementptr inbounds ([11 x i8]* @.str8, i64 0, i64 0), %lor.lhs.false100 ]
  %51 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings256 = getelementptr inbounds %struct.cop* %51, i64 0, i32 14
  %52 = load %struct.sv** %cop_warnings256, align 8, !tbaa !3
  %cmp257 = icmp eq %struct.sv* %52, null
  br i1 %cmp257, label %lor.lhs.false275, label %land.lhs.true259

land.lhs.true259:                                 ; preds = %land.lhs.true255
  %53 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings260 = getelementptr inbounds %struct.cop* %53, i64 0, i32 14
  %54 = load %struct.sv** %cop_warnings260, align 8, !tbaa !3
  %cmp261 = icmp eq %struct.sv* %54, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp261, label %lor.lhs.false275, label %land.lhs.true263

land.lhs.true263:                                 ; preds = %land.lhs.true259
  %55 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings264 = getelementptr inbounds %struct.cop* %55, i64 0, i32 14
  %56 = load %struct.sv** %cop_warnings264, align 8, !tbaa !3
  %cmp265 = icmp eq %struct.sv* %56, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp265, label %if.then283, label %lor.lhs.false267

lor.lhs.false267:                                 ; preds = %land.lhs.true263
  %57 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings268 = getelementptr inbounds %struct.cop* %57, i64 0, i32 14
  %58 = load %struct.sv** %cop_warnings268, align 8, !tbaa !3
  %sv_any269 = getelementptr inbounds %struct.sv* %58, i64 0, i32 0
  %59 = load i8** %sv_any269, align 8, !tbaa !3
  %xpv_pv270 = bitcast i8* %59 to i8**
  %60 = load i8** %xpv_pv270, align 8, !tbaa !3
  %arrayidx271 = getelementptr inbounds i8* %60, i64 11
  %61 = load i8* %arrayidx271, align 1, !tbaa !1
  %and273 = and i8 %61, 4
  %tobool274 = icmp eq i8 %and273, 0
  br i1 %tobool274, label %lor.lhs.false275, label %if.then283

lor.lhs.false275:                                 ; preds = %lor.lhs.false267, %land.lhs.true259, %land.lhs.true255
  %62 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings276 = getelementptr inbounds %struct.cop* %62, i64 0, i32 14
  %63 = load %struct.sv** %cop_warnings276, align 8, !tbaa !3
  %cmp277 = icmp eq %struct.sv* %63, null
  br i1 %cmp277, label %land.lhs.true279, label %return

land.lhs.true279:                                 ; preds = %lor.lhs.false275
  %64 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and281 = and i8 %64, 1
  %tobool282 = icmp eq i8 %and281, 0
  br i1 %tobool282, label %return, label %if.then283

if.then283:                                       ; preds = %lor.lhs.false267, %land.lhs.true279, %land.lhs.true263
  tail call void (i32, i8*, ...)* @Perl_warner(i32 45, i8* getelementptr inbounds ([34 x i8]* @.str13, i64 0, i64 0), i8* %useless.1350) #7
  br label %return

return:                                           ; preds = %sw.bb209, %sw.bb223, %for.body227, %sw.bb204, %for.body, %sw.bb71, %lor.lhs.false100, %sw.bb93, %sw.bb199, %sw.bb201, %sw.bb216, %sw.bb232, %sw.bb241, %land.lhs.true244, %if.then251, %if.then249, %sw.default, %func_ops, %sw.bb, %lor.lhs.false275, %if.then283, %sw.epilog, %land.lhs.true279, %land.lhs.true29, %lor.lhs.false35, %lor.lhs.false33, %sw.bb239, %if.then49
  %retval.0 = phi %struct.op* [ %call, %if.then49 ], [ %call240, %sw.bb239 ], [ %o, %lor.lhs.false33 ], [ %o, %lor.lhs.false35 ], [ %o, %land.lhs.true29 ], [ %o, %land.lhs.true279 ], [ %o, %sw.epilog ], [ %o, %if.then283 ], [ %o, %lor.lhs.false275 ], [ %o, %sw.bb ], [ %o, %func_ops ], [ %o, %sw.default ], [ %o, %if.then249 ], [ %o, %if.then251 ], [ %o, %land.lhs.true244 ], [ %o, %sw.bb241 ], [ %o, %sw.bb232 ], [ %o, %sw.bb216 ], [ %o, %sw.bb209 ], [ %o, %sw.bb201 ], [ %o, %sw.bb199 ], [ %o, %sw.bb93 ], [ %o, %lor.lhs.false100 ], [ %o, %sw.bb71 ], [ %o, %for.body ], [ %o, %sw.bb204 ], [ %o, %for.body227 ], [ %o, %sw.bb223 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_warner(i32, i8*, ...) #2

; Function Attrs: nounwind optsize uwtable
define i8* @Perl_custom_op_desc(%struct.op* nocapture %o) #0 {
entry:
  %0 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !3
  %tobool = icmp eq %struct.hv* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !3
  br label %return

if.end:                                           ; preds = %entry
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %2 = load %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %3 = ptrtoint %struct.op* ()* %2 to i64
  %call = tail call %struct.sv* @Perl_newSViv(i64 %3) #7
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #7
  %4 = load %struct.hv** @PL_custom_op_descs, align 8, !tbaa !3
  %call2 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %4, %struct.sv* %call1, i32 0, i32 0) #7
  %tobool3 = icmp eq %struct.he* %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %5 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 351), align 8, !tbaa !3
  br label %return

if.end5:                                          ; preds = %if.end
  %hent_val = getelementptr inbounds %struct.he* %call2, i64 0, i32 2
  %6 = load %struct.sv** %hent_val, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %7, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end5
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %return

cond.false:                                       ; preds = %if.end5
  %call8 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %6) #7
  br label %return

return:                                           ; preds = %cond.true, %cond.false, %if.then4, %if.then
  %retval.0 = phi i8* [ %5, %if.then4 ], [ %1, %if.then ], [ %9, %cond.true ], [ %call8, %cond.false ]
  ret i8* %retval.0
}

; Function Attrs: optsize
declare double @Perl_sv_2nv(%struct.sv*) #2

; Function Attrs: nounwind optsize readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_listkids(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call %struct.op* @Perl_list(%struct.op* %kid.010) #8
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %if.then, %for.body, %land.lhs.true, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_list(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 3
  %tobool1 = icmp ne i8 %and, 0
  %1 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool3 = icmp ne i32 %1, 0
  %or.cond = or i1 %tobool1, %tobool3
  br i1 %or.cond, label %return, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %2, 184
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false4
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !1
  %and8 = and i8 %3, 16
  %tobool9 = icmp eq i8 %and8, 0
  br i1 %tobool9, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %idxprom = zext i16 %2 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %4 = load i32* %arrayidx, align 4, !tbaa !0
  %and11 = and i32 %4, 256
  %tobool12 = icmp eq i32 %and11, 0
  br i1 %tobool12, label %if.end14, label %return

if.end14:                                         ; preds = %land.lhs.true, %if.end
  %or = or i8 %0, 3
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  %conv21 = zext i16 %2 to i32
  switch i32 %conv21, label %sw.bb27 [
    i32 158, label %sw.bb
    i32 61, label %sw.bb
    i32 160, label %sw.bb22
    i32 159, label %sw.bb22
    i32 162, label %sw.bb22
    i32 309, label %sw.bb74
    i32 173, label %sw.bb59
    i32 179, label %sw.bb59
    i32 314, label %sw.bb48
    i32 141, label %sw.bb46
    i32 178, label %sw.bb48
  ]

sw.bb:                                            ; preds = %if.end14, %if.end14
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !3
  %call = tail call %struct.op* @Perl_list(%struct.op* %6) #8
  ret %struct.op* %o

sw.bb22:                                          ; preds = %if.end14, %if.end14, %if.end14
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !3
  %kid.0.in112 = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %kid.0113 = load %struct.op** %kid.0.in112, align 8
  %tobool24114 = icmp eq %struct.op* %kid.0113, null
  br i1 %tobool24114, label %return, label %for.body

for.body:                                         ; preds = %sw.bb22, %for.body
  %kid.0115 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0113, %sw.bb22 ]
  %call25 = tail call %struct.op* @Perl_list(%struct.op* %kid.0115) #8
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0115, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool24 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool24, label %return, label %for.body

sw.bb27:                                          ; preds = %if.end14
  %and30 = and i8 %0, 4
  %tobool31 = icmp eq i8 %and30, 0
  br i1 %tobool31, label %return, label %if.end33

if.end33:                                         ; preds = %sw.bb27
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %9 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool34 = icmp eq %struct.op* %9, null
  br i1 %tobool34, label %land.lhs.true35, label %sw.bb46

land.lhs.true35:                                  ; preds = %if.end33
  %10 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !3
  %op_type37 = getelementptr inbounds %struct.op* %11, i64 0, i32 4
  %12 = load i16* %op_type37, align 2, !tbaa !4
  %cmp39 = icmp eq i16 %12, 158
  br i1 %cmp39, label %if.then41, label %sw.bb46

if.then41:                                        ; preds = %land.lhs.true35
  %call43 = tail call %struct.op* @Perl_list(%struct.op* %11) #8
  %call44 = tail call %struct.op* @Perl_gen_constant_list(%struct.op* %o) #8
  ret %struct.op* %call44

sw.bb46:                                          ; preds = %if.end33, %land.lhs.true35, %if.end14
  %call47 = tail call %struct.op* @Perl_listkids(%struct.op* %o) #8
  br label %return

sw.bb48:                                          ; preds = %if.end14, %if.end14
  %13 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %14 = load %struct.op** %13, align 8, !tbaa !3
  %call50 = tail call %struct.op* @Perl_list(%struct.op* %14) #8
  %op_sibling51119 = getelementptr inbounds %struct.op* %14, i64 0, i32 1
  %15 = load %struct.op** %op_sibling51119, align 8, !tbaa !3
  %tobool52120 = icmp eq %struct.op* %15, null
  br i1 %tobool52120, label %while.end, label %while.body

while.body:                                       ; preds = %sw.bb48, %while.cond.backedge
  %16 = phi %struct.op* [ %18, %while.cond.backedge ], [ %15, %sw.bb48 ]
  %op_sibling53 = getelementptr inbounds %struct.op* %16, i64 0, i32 1
  %17 = load %struct.op** %op_sibling53, align 8, !tbaa !3
  %tobool54 = icmp eq %struct.op* %17, null
  br i1 %tobool54, label %if.else, label %if.then55

if.then55:                                        ; preds = %while.body
  %call56 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %16) #8
  br label %while.cond.backedge

if.else:                                          ; preds = %while.body
  %call57 = tail call %struct.op* @Perl_list(%struct.op* %16) #8
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.else, %if.then55
  %18 = load %struct.op** %op_sibling53, align 8, !tbaa !3
  %tobool52 = icmp eq %struct.op* %18, null
  br i1 %tobool52, label %while.end, label %while.body

while.end:                                        ; preds = %while.cond.backedge, %sw.bb48
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %return

sw.bb59:                                          ; preds = %if.end14, %if.end14
  %19 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.2116 = load %struct.op** %19, align 8
  %tobool62117 = icmp eq %struct.op* %kid.2116, null
  br i1 %tobool62117, label %for.end73, label %for.body63

for.body63:                                       ; preds = %sw.bb59, %for.cond61.backedge
  %kid.2118 = phi %struct.op* [ %kid.2, %for.cond61.backedge ], [ %kid.2116, %sw.bb59 ]
  %op_sibling64 = getelementptr inbounds %struct.op* %kid.2118, i64 0, i32 1
  %20 = load %struct.op** %op_sibling64, align 8, !tbaa !3
  %tobool65 = icmp eq %struct.op* %20, null
  br i1 %tobool65, label %if.else68, label %if.then66

if.then66:                                        ; preds = %for.body63
  %call67 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %kid.2118) #8
  br label %for.cond61.backedge

for.cond61.backedge:                              ; preds = %if.then66, %if.else68
  %kid.2 = load %struct.op** %op_sibling64, align 8
  %tobool62 = icmp eq %struct.op* %kid.2, null
  br i1 %tobool62, label %for.end73, label %for.body63

if.else68:                                        ; preds = %for.body63
  %call69 = tail call %struct.op* @Perl_list(%struct.op* %kid.2118) #8
  br label %for.cond61.backedge

for.end73:                                        ; preds = %for.cond61.backedge, %sw.bb59
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %return

sw.bb74:                                          ; preds = %if.end14
  %and77 = and i8 %0, -4
  store i8 %and77, i8* %op_flags, align 1, !tbaa !1
  %call79 = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  br label %return

return:                                           ; preds = %sw.bb22, %for.body, %sw.bb46, %while.end, %for.end73, %sw.bb27, %land.lhs.true, %lor.lhs.false, %lor.lhs.false4, %entry, %sw.bb74
  %retval.0 = phi %struct.op* [ %call79, %sw.bb74 ], [ null, %entry ], [ %o, %lor.lhs.false4 ], [ %o, %lor.lhs.false ], [ %o, %land.lhs.true ], [ %o, %sw.bb27 ], [ %o, %for.end73 ], [ %o, %while.end ], [ %o, %sw.bb46 ], [ %o, %for.body ], [ %o, %sw.bb22 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_gen_constant_list(%struct.op* %o) #0 {
entry:
  %0 = load i32* @PL_tmps_floor, align 4, !tbaa !0
  %call = tail call %struct.op* @Perl_list(%struct.op* %o) #8
  %1 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %2 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %2, null
  br i1 %tobool1, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end
  %call3 = tail call %struct.op* @Perl_linklist(%struct.op* %o) #8
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.false
  %cond = phi %struct.op* [ %call3, %cond.false ], [ %2, %if.end ]
  store %struct.op* %cond, %struct.op** @PL_op, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !3
  %3 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !3
  tail call void %3(%struct.op* %cond) #7
  %call5 = tail call %struct.op* @Perl_pp_pushmark() #7
  %4 = load i32 ()** @PL_runops, align 8, !tbaa !3
  %call6 = tail call i32 %4() #7
  store %struct.op* %cond, %struct.op** @PL_op, align 8, !tbaa !3
  %call7 = tail call %struct.op* @Perl_pp_anonlist() #7
  store i32 %0, i32* @PL_tmps_floor, align 4, !tbaa !0
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  store i16 125, i16* %op_type, align 2, !tbaa !4
  %5 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %5, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %6, -25
  %or = or i8 %and, 8
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  %op_seq = getelementptr inbounds %struct.op* %o, i64 0, i32 5
  store i16 0, i16* %op_seq, align 2, !tbaa !4
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !3
  %9 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds %struct.sv** %9, i64 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %10 = load %struct.sv** %9, align 8, !tbaa !3
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool12 = icmp eq %struct.sv* %10, null
  br i1 %tobool12, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %cond.end
  %sv_refcnt = getelementptr inbounds %struct.sv* %10, i64 0, i32 1
  %11 = load i32* %sv_refcnt, align 4, !tbaa !0
  %inc = add i32 %11, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %cond.end, %land.rhs
  %call14 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %10) #8
  store %struct.op* %call14, %struct.op** %7, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %8) #8
  %call16 = tail call %struct.op* @Perl_linklist(%struct.op* %o) #8
  %call17 = tail call %struct.op* @Perl_list(%struct.op* %o) #8
  br label %return

return:                                           ; preds = %entry, %land.end
  %retval.0 = phi %struct.op* [ %call17, %land.end ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_scalarseq(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %if.end21 [
    i16 173, label %if.then16
    i16 179, label %if.then16
    i16 178, label %if.then16
    i16 314, label %if.then16
  ]

if.then16:                                        ; preds = %if.then, %if.then, %if.then, %if.then
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.044 = load %struct.op** %1, align 8
  %tobool1745 = icmp eq %struct.op* %kid.044, null
  br i1 %tobool1745, label %for.end, label %for.body

for.body:                                         ; preds = %if.then16, %for.cond.backedge
  %kid.046 = phi %struct.op* [ %kid.0.pre, %for.cond.backedge ], [ %kid.044, %if.then16 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid.046, i64 0, i32 1
  %2 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool18 = icmp eq %struct.op* %2, null
  br i1 %tobool18, label %for.end, label %for.cond.backedge

for.cond.backedge:                                ; preds = %for.body
  %call = tail call %struct.op* @Perl_scalarvoid(%struct.op* %kid.046) #8
  %kid.0.pre = load %struct.op** %op_sibling, align 8
  %tobool17 = icmp eq %struct.op* %kid.0.pre, null
  br i1 %tobool17, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %for.cond.backedge, %if.then16
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %if.end21

if.end21:                                         ; preds = %if.then, %for.end
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %3 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %3, -9
  store i8 %and, i8* %op_flags, align 1, !tbaa !1
  %4 = load i32* @PL_hints, align 4, !tbaa !0
  %and24 = and i32 %4, 256
  %tobool25 = icmp eq i32 %and24, 0
  br i1 %tobool25, label %if.end32, label %if.then26

if.then26:                                        ; preds = %if.end21
  %or = or i8 %3, 8
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  br label %if.end32

if.else:                                          ; preds = %entry
  %call31 = tail call %struct.op* @Perl_newOP(i32 1, i32 0) #8
  br label %if.end32

if.end32:                                         ; preds = %if.end21, %if.then26, %if.else
  %o.addr.0 = phi %struct.op* [ %o, %if.then26 ], [ %o, %if.end21 ], [ %call31, %if.else ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newOP(i32 %type, i32 %flags) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 40) #7
  %0 = bitcast i8* %call to %struct.op*
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 40, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %1 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %1, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %2 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %3 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !3
  %conv1 = trunc i32 %flags to i8
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %4, align 1, !tbaa !1
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %0, %struct.op** %op_next, align 8, !tbaa !3
  %shr41 = lshr i32 %flags, 8
  %conv2 = trunc i32 %shr41 to i8
  %5 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv2, i8* %5, align 1, !tbaa !1
  %arrayidx4 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %6 = load i32* %arrayidx4, align 4, !tbaa !0
  %and = and i32 %6, 4
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call5 = tail call %struct.op* @Perl_scalar(%struct.op* %0) #8
  %.pre = load i32* %arrayidx4, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %7 = phi i32 [ %6, %entry ], [ %.pre, %if.then ]
  %and8 = and i32 %7, 8
  %tobool9 = icmp eq i32 %and8, 0
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end
  %call11 = tail call i64 @Perl_pad_alloc(i32 %type, i32 512) #7
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %8 = bitcast i8* %op_targ to i64*
  store i64 %call11, i64* %8, align 8, !tbaa !5
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then10
  %9 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool13 = icmp eq i8* %9, null
  br i1 %tobool13, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end12
  %arrayidx15 = getelementptr inbounds i8* %9, i64 %idxprom
  %10 = load i8* %arrayidx15, align 1, !tbaa !1
  %tobool17 = icmp eq i8 %10, 0
  br i1 %tobool17, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %0) #8
  %arrayidx19 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %11 = load i8** %arrayidx19, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end12
  %arrayidx21 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %12 = load %struct.op* (%struct.op*)** %arrayidx21, align 8, !tbaa !3
  %call22 = tail call %struct.op* %12(%struct.op* %0) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call22, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_mod(%struct.op* %o, i32 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  %0 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool1 = icmp ne i32 %0, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %1, 16
  %tobool2 = icmp eq i8 %and, 0
  %op_type7.phi.trans.insert = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %.pre708 = load i16* %op_type7.phi.trans.insert, align 2, !tbaa !4
  br i1 %tobool2, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %idxprom = zext i16 %.pre708 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %2 = load i32* %arrayidx, align 4, !tbaa !0
  %and3 = and i32 %2, 256
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end6, label %return

if.end6:                                          ; preds = %if.end, %land.lhs.true
  %op_type7 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %conv8 = zext i16 %.pre708 to i32
  switch i32 %conv8, label %nomod [
    i32 43, label %sw.bb
    i32 5, label %sw.bb9
    i32 1, label %sw.bb37
    i32 166, label %sw.bb43
    i32 46, label %sw.bb260
    i32 48, label %sw.bb260
    i32 54, label %sw.bb260
    i32 55, label %sw.bb260
    i32 57, label %sw.bb260
    i32 59, label %sw.bb260
    i32 61, label %sw.bb260
    i32 62, label %sw.bb260
    i32 64, label %sw.bb260
    i32 66, label %sw.bb260
    i32 68, label %sw.bb260
    i32 69, label %sw.bb260
    i32 91, label %sw.bb260
    i32 92, label %sw.bb260
    i32 93, label %sw.bb260
    i32 56, label %sw.bb260
    i32 58, label %sw.bb260
    i32 60, label %sw.bb260
    i32 63, label %sw.bb260
    i32 65, label %sw.bb260
    i32 162, label %sw.bb268
    i32 125, label %sw.bb274
    i32 134, label %sw.bb274
    i32 14, label %sw.bb284
    i32 128, label %sw.bb293
    i32 136, label %sw.bb293
    i32 37, label %sw.bb302
    i32 174, label %sw.bb302
    i32 175, label %sw.bb302
    i32 15, label %sw.bb303
    i32 7, label %sw.bb308
    i32 16, label %sw.bb308
    i32 36, label %sw.bb310
    i32 163, label %sw.bb310
    i32 164, label %sw.bb310
    i32 126, label %sw.bb310
    i32 10, label %sw.bb312
    i32 11, label %sw.bb312
    i32 9, label %if.end6.sw.bb334_crit_edge
    i32 3, label %sw.epilog
    i32 131, label %sw.bb358
    i32 111, label %sw.bb363
    i32 45, label %sw.bb370
    i32 112, label %sw.bb370
    i32 127, label %sw.bb393
    i32 135, label %sw.bb393
    i32 179, label %sw.bb420
    i32 178, label %sw.bb420
    i32 177, label %sw.bb420
    i32 173, label %sw.bb420
    i32 0, label %sw.bb428
    i32 141, label %sw.bb449
    i32 184, label %sw.bb458
  ]

if.end6.sw.bb334_crit_edge:                       ; preds = %if.end6
  %.pre710 = load i32* @PL_modcount, align 4, !tbaa !0
  %phitmp = add i32 %.pre710, 1
  br label %sw.bb334

sw.bb:                                            ; preds = %if.end6
  %3 = load i32* @PL_modcount, align 4, !tbaa !0
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* @PL_modcount, align 4, !tbaa !0
  br label %return

sw.bb9:                                           ; preds = %if.end6
  %and12 = and i8 %1, 32
  %tobool13 = icmp eq i8 %and12, 0
  br i1 %tobool13, label %nomod, label %if.end15

if.end15:                                         ; preds = %sw.bb9
  %4 = load %struct.op** @PL_eval_start, align 8, !tbaa !3
  %tobool16 = icmp eq %struct.op* %4, null
  br i1 %tobool16, label %if.else, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %if.end15
  %op_type18 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type18, align 2, !tbaa !4
  %cmp = icmp eq i16 %5, 5
  br i1 %cmp, label %if.then21, label %if.else

if.then21:                                        ; preds = %land.lhs.true17
  %op_sv = getelementptr inbounds %struct.op* %4, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !0
  %and22 = and i32 %8, 65536
  %tobool23 = icmp eq i32 %and22, 0
  br i1 %tobool23, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then21
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %9, i64 24
  %10 = bitcast i8* %xiv_iv to i64*
  %11 = load i64* %10, align 8, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %if.then21
  %call = tail call i64 @Perl_sv_2iv(%struct.sv* %7) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ %call, %cond.false ]
  %conv26 = trunc i64 %cond to i32
  store i32 %conv26, i32* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12), align 4, !tbaa !0
  store %struct.op* null, %struct.op** @PL_eval_start, align 8, !tbaa !3
  br label %sw.epilog

if.else:                                          ; preds = %if.end15, %land.lhs.true17
  switch i32 %type, label %if.else33 [
    i32 0, label %sw.epilog.thread
    i32 20, label %land.lhs.true465
  ]

sw.epilog.thread:                                 ; preds = %if.else
  tail call void @Perl_save_I32(i32* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12)) #7
  store i32 0, i32* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 12), align 4, !tbaa !0
  br label %if.end480.thread690

if.else33:                                        ; preds = %if.else
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str14, i64 0, i64 0)) #7
  br label %sw.epilog

sw.bb37:                                          ; preds = %if.end6
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !1
  %and39 = and i8 %12, 8
  %tobool40 = icmp eq i8 %and39, 0
  br i1 %tobool40, label %nomod, label %sw.epilog

sw.bb43:                                          ; preds = %if.end6
  switch i32 %type, label %if.else57 [
    i32 43, label %land.lhs.true49
    i32 20, label %land.lhs.true49
  ]

land.lhs.true49:                                  ; preds = %sw.bb43, %sw.bb43
  %op_flags50 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %13 = load i8* %op_flags50, align 1, !tbaa !1
  %and52 = and i8 %13, 64
  %tobool53 = icmp eq i8 %and52, 0
  br i1 %tobool53, label %if.then54, label %if.else57

if.then54:                                        ; preds = %land.lhs.true49
  store i16 17, i16* %op_type7, align 2, !tbaa !4
  %14 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %14, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %15 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %16 = load %struct.op** %15, align 8, !tbaa !3
  %17 = getelementptr inbounds %struct.op* %16, i64 1, i32 0
  %18 = load %struct.op** %17, align 8, !tbaa !3
  tail call void @Perl_op_null(%struct.op* %18) #8
  br label %sw.epilog

if.else57:                                        ; preds = %sw.bb43, %land.lhs.true49
  %and60 = and i8 %1, 64
  %tobool61 = icmp eq i8 %and60, 0
  br i1 %tobool61, label %if.else63, label %return

if.else63:                                        ; preds = %if.else57
  %or = or i8 %1, -128
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  store i32 1073741823, i32* @PL_modcount, align 4, !tbaa !0
  switch i32 %type, label %if.else80 [
    i32 166, label %if.then75
    i32 152, label %if.then75
    i32 20, label %if.then75
  ]

if.then75:                                        ; preds = %if.else63, %if.else63, %if.else63
  %19 = load i8* %op_private, align 1, !tbaa !1
  %or78 = or i8 %19, 4
  store i8 %or78, i8* %op_private, align 1, !tbaa !1
  br label %sw.epilog

if.else80:                                        ; preds = %if.else63
  %20 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %21 = load %struct.op** %20, align 8, !tbaa !3
  %op_type83 = getelementptr inbounds %struct.op* %21, i64 0, i32 4
  %22 = load i16* %op_type83, align 2, !tbaa !4
  switch i16 %22, label %if.else80.if.then96_crit_edge [
    i16 3, label %while.cond
    i16 0, label %lor.lhs.false93
  ]

if.else80.if.then96_crit_edge:                    ; preds = %if.else80
  %op_targ99.phi.trans.insert = getelementptr inbounds %struct.op* %21, i64 0, i32 3
  %.pre709 = load i64* %op_targ99.phi.trans.insert, align 8, !tbaa !5
  br label %if.then96

lor.lhs.false93:                                  ; preds = %if.else80
  %op_targ = getelementptr inbounds %struct.op* %21, i64 0, i32 3
  %23 = load i64* %op_targ, align 8, !tbaa !5
  %cmp94 = icmp eq i64 %23, 141
  br i1 %cmp94, label %if.end100, label %if.then96

if.then96:                                        ; preds = %if.else80.if.then96_crit_edge, %lor.lhs.false93
  %24 = phi i64 [ %.pre709, %if.else80.if.then96_crit_edge ], [ %23, %lor.lhs.false93 ]
  %conv98 = zext i16 %22 to i64
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([58 x i8]* @.str15, i64 0, i64 0), i64 %conv98, i64 %24) #7
  br label %if.end100

if.end100:                                        ; preds = %lor.lhs.false93, %if.then96
  %25 = getelementptr inbounds %struct.op* %21, i64 1, i32 0
  %26 = load %struct.op** %25, align 8, !tbaa !3
  br label %while.cond

while.cond:                                       ; preds = %if.else80, %if.end100, %while.cond
  %kid81.0 = phi %struct.op* [ %27, %while.cond ], [ %21, %if.else80 ], [ %26, %if.end100 ]
  %op_sibling = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 1
  %27 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool102 = icmp eq %struct.op* %27, null
  br i1 %tobool102, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  %op_type104 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 4
  %28 = load i16* %op_type104, align 2, !tbaa !4
  switch i16 %28, label %if.then137 [
    i16 0, label %land.lhs.true108
    i16 350, label %if.then122
    i16 165, label %if.then122
    i16 17, label %if.end141
  ]

land.lhs.true108:                                 ; preds = %while.end
  %op_targ109 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 3
  %29 = load i64* %op_targ109, align 8, !tbaa !5
  %cmp110 = icmp eq i64 %29, 17
  br i1 %cmp110, label %if.end146, label %if.then137

if.then122:                                       ; preds = %while.end, %while.end
  %call123 = tail call i8* @Perl_safesysmalloc(i64 48) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call123, i8 0, i64 48, i32 1, i1 false)
  %op_type124 = getelementptr inbounds i8* %call123, i64 32
  %30 = bitcast i8* %op_type124 to i16*
  store i16 17, i16* %30, align 2, !tbaa !4
  %31 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !3
  %op_ppaddr125 = getelementptr inbounds i8* %call123, i64 16
  %32 = bitcast i8* %op_ppaddr125 to %struct.op* ()**
  store %struct.op* ()* %31, %struct.op* ()** %32, align 8, !tbaa !3
  %op_first126 = getelementptr inbounds i8* %call123, i64 40
  %33 = bitcast i8* %op_first126 to %struct.op**
  store %struct.op* null, %struct.op** %33, align 8, !tbaa !3
  %34 = bitcast i8* %call123 to %struct.op*
  %op_next = bitcast i8* %call123 to %struct.op**
  store %struct.op* %34, %struct.op** %op_next, align 8, !tbaa !3
  store %struct.op* %34, %struct.op** %op_sibling, align 8, !tbaa !3
  %35 = getelementptr inbounds i8* %call123, i64 37
  %36 = load i8* %35, align 1, !tbaa !1
  %or130 = or i8 %36, -128
  store i8 %or130, i8* %35, align 1, !tbaa !1
  br label %sw.epilog

if.then137:                                       ; preds = %while.end, %land.lhs.true108
  %conv139 = zext i16 %28 to i64
  %op_targ140 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 3
  %37 = load i64* %op_targ140, align 8, !tbaa !5
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([62 x i8]* @.str16, i64 0, i64 0), i64 %conv139, i64 %37) #7
  br label %if.end141

if.end141:                                        ; preds = %while.end, %if.then137
  %op_private142 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 7
  %38 = load i8* %op_private142, align 1, !tbaa !1
  %or144 = or i8 %38, -128
  store i8 %or144, i8* %op_private142, align 1, !tbaa !1
  br label %sw.epilog

if.end146:                                        ; preds = %land.lhs.true108
  %39 = getelementptr inbounds %struct.op* %kid81.0, i64 1, i32 0
  %40 = load %struct.op** %39, align 8, !tbaa !3
  %op_type148 = getelementptr inbounds %struct.op* %40, i64 0, i32 4
  %41 = load i16* %op_type148, align 2, !tbaa !4
  %cmp150 = icmp eq i16 %41, 0
  br i1 %cmp150, label %land.lhs.true152, label %if.end167

land.lhs.true152:                                 ; preds = %if.end146
  %op_targ153 = getelementptr inbounds %struct.op* %40, i64 0, i32 3
  %42 = load i64* %op_targ153, align 8, !tbaa !5
  %cmp154 = icmp eq i64 %42, 15
  br i1 %cmp154, label %if.end158, label %if.then163

if.end158:                                        ; preds = %land.lhs.true152
  %43 = getelementptr inbounds %struct.op* %40, i64 1, i32 0
  %44 = load %struct.op** %43, align 8, !tbaa !3
  %op_type159.phi.trans.insert = getelementptr inbounds %struct.op* %44, i64 0, i32 4
  %.pre = load i16* %op_type159.phi.trans.insert, align 2, !tbaa !4
  %cmp161 = icmp eq i16 %.pre, 0
  br i1 %cmp161, label %if.then163, label %if.end167

if.then163:                                       ; preds = %land.lhs.true152, %if.end158
  %kid81.1715 = phi %struct.op* [ %44, %if.end158 ], [ %40, %land.lhs.true152 ]
  %op_type159 = getelementptr inbounds %struct.op* %kid81.1715, i64 0, i32 4
  %op_targ166 = getelementptr inbounds %struct.op* %kid81.1715, i64 0, i32 3
  %45 = load i64* %op_targ166, align 8, !tbaa !5
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([64 x i8]* @.str17, i64 0, i64 0), i64 0, i64 %45) #7
  %.pr683 = load i16* %op_type159, align 2, !tbaa !4
  br label %if.end167

if.end167:                                        ; preds = %if.end146, %if.then163, %if.end158
  %kid81.1716 = phi %struct.op* [ %kid81.1715, %if.then163 ], [ %44, %if.end158 ], [ %40, %if.end146 ]
  %46 = phi i16 [ %.pr683, %if.then163 ], [ %.pre, %if.end158 ], [ %41, %if.end146 ]
  %cmp170 = icmp eq i16 %46, 7
  br i1 %cmp170, label %if.end193, label %restore_2cv

restore_2cv:                                      ; preds = %if.end193, %if.end167
  %op_next173 = getelementptr inbounds %struct.op* %kid81.1716, i64 0, i32 0
  %47 = load %struct.op** %op_next173, align 8, !tbaa !3
  %tobool174 = icmp eq %struct.op* %47, null
  %cmp177 = icmp eq %struct.op* %47, %kid81.1716
  %or.cond676 = or i1 %tobool174, %cmp177
  %op_next184 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 0
  br i1 %or.cond676, label %if.else183, label %if.then179

if.then179:                                       ; preds = %restore_2cv
  store %struct.op* %47, %struct.op** %op_next184, align 8, !tbaa !3
  store %struct.op* %kid81.0, %struct.op** %op_next173, align 8, !tbaa !3
  br label %if.end185

if.else183:                                       ; preds = %restore_2cv
  store %struct.op* null, %struct.op** %op_next184, align 8, !tbaa !3
  br label %if.end185

if.end185:                                        ; preds = %if.else183, %if.then179
  store i16 17, i16* %op_type104, align 2, !tbaa !4
  store i64 0, i64* %op_targ109, align 8, !tbaa !5
  %48 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !3
  %op_ppaddr188 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 2
  store %struct.op* ()* %48, %struct.op* ()** %op_ppaddr188, align 8, !tbaa !3
  %op_private189 = getelementptr inbounds %struct.op* %kid81.0, i64 0, i32 7
  %49 = load i8* %op_private189, align 1, !tbaa !1
  %or191 = or i8 %49, -128
  store i8 %or191, i8* %op_private189, align 1, !tbaa !1
  br label %sw.epilog

if.end193:                                        ; preds = %if.end167
  %op_sv194 = getelementptr inbounds %struct.op* %kid81.1716, i64 1
  %50 = bitcast %struct.op* %op_sv194 to %struct.sv**
  %51 = load %struct.sv** %50, align 8, !tbaa !3
  %sv_any195 = bitcast %struct.sv* %51 to %struct.xpvgv**
  %52 = load %struct.xpvgv** %sv_any195, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %52, i64 0, i32 7
  %53 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_cv = getelementptr inbounds %struct.gp* %53, i64 0, i32 7
  %54 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool196 = icmp eq %struct.cv* %54, null
  br i1 %tobool196, label %restore_2cv, label %if.end198

if.end198:                                        ; preds = %if.end193
  %sv_any199 = getelementptr inbounds %struct.cv* %54, i64 0, i32 0
  %55 = load %struct.xpvcv** %sv_any199, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %55, i64 0, i32 17
  %56 = load i16* %xcv_flags, align 2, !tbaa !4
  %and201 = and i16 %56, 256
  %tobool202 = icmp eq i16 %and201, 0
  br i1 %tobool202, label %nomod, label %sw.epilog

nomod:                                            ; preds = %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb312, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb274, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb284, %sw.bb9, %sw.bb37, %if.end198, %sw.bb260, %sw.bb428, %sw.bb363, %if.end6
  switch i32 %type, label %if.end217thread-pre-split [
    i32 20, label %land.lhs.true465
    i32 152, label %if.end480
    i32 166, label %if.end480
  ]

if.end217thread-pre-split:                        ; preds = %sw.bb458, %sw.bb358, %nomod
  %.pr699 = load i16* %op_type7, align 2, !tbaa !4
  br label %if.end217

if.end217:                                        ; preds = %if.end217thread-pre-split, %sw.bb.i, %sw.bb.i679
  %.pr684 = phi i16 [ %.pr699, %if.end217thread-pre-split ], [ %.pre708, %sw.bb.i ], [ %.pre708, %sw.bb.i679 ]
  switch i16 %.pr684, label %cond.false241 [
    i16 0, label %land.lhs.true222
    i16 166, label %cond.end249
    i16 351, label %cond.true239
  ]

land.lhs.true222:                                 ; preds = %if.end217
  %op_flags223 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %57 = load i8* %op_flags223, align 1, !tbaa !1
  %tobool226 = icmp slt i8 %57, 0
  br i1 %tobool226, label %cond.end249, label %cond.false241

cond.true239:                                     ; preds = %if.end217
  %call240 = tail call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end249

cond.false241:                                    ; preds = %if.end217, %land.lhs.true222
  %idxprom243 = zext i16 %.pr684 to i64
  %arrayidx244 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom243
  %58 = load i8** %arrayidx244, align 8, !tbaa !3
  br label %cond.end249

cond.end249:                                      ; preds = %if.end217, %cond.false241, %cond.true239, %land.lhs.true222
  %cond250 = phi i8* [ getelementptr inbounds ([9 x i8]* @.str19, i64 0, i64 0), %land.lhs.true222 ], [ %call240, %cond.true239 ], [ %58, %cond.false241 ], [ getelementptr inbounds ([27 x i8]* @.str20, i64 0, i64 0), %if.end217 ]
  %tobool251 = icmp eq i32 %type, 0
  br i1 %tobool251, label %cond.end256, label %cond.true252

cond.true252:                                     ; preds = %cond.end249
  %idxprom253 = sext i32 %type to i64
  %arrayidx254 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom253
  %59 = load i8** %arrayidx254, align 8, !tbaa !3
  br label %cond.end256

cond.end256:                                      ; preds = %cond.end249, %cond.true252
  %cond257 = phi i8* [ %59, %cond.true252 ], [ getelementptr inbounds ([6 x i8]* @.str21, i64 0, i64 0), %cond.end249 ]
  %call258 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([22 x i8]* @.str18, i64 0, i64 0), i8* %cond250, i8* %cond257) #7
  %call259 = tail call i32 @Perl_yyerror(i8* %call258) #7
  br label %return

sw.bb260:                                         ; preds = %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6, %if.end6
  %op_flags261 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %60 = load i8* %op_flags261, align 1, !tbaa !1
  %and263 = and i8 %60, 64
  %tobool264 = icmp eq i8 %and263, 0
  br i1 %tobool264, label %nomod, label %if.end266

if.end266:                                        ; preds = %sw.bb260
  %61 = load i32* @PL_modcount, align 4, !tbaa !0
  %inc267 = add nsw i32 %61, 1
  store i32 %inc267, i32* @PL_modcount, align 4, !tbaa !0
  br label %sw.epilog

sw.bb268:                                         ; preds = %if.end6
  %62 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %63 = load %struct.op** %62, align 8, !tbaa !3
  %kid.0.in700 = getelementptr inbounds %struct.op* %63, i64 0, i32 1
  %kid.0701 = load %struct.op** %kid.0.in700, align 8
  %tobool271702 = icmp eq %struct.op* %kid.0701, null
  br i1 %tobool271702, label %sw.epilog, label %for.body

for.body:                                         ; preds = %sw.bb268, %for.body
  %kid.0703 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0701, %sw.bb268 ]
  %call272 = tail call %struct.op* @Perl_mod(%struct.op* %kid.0703, i32 %type) #8
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0703, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool271 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool271, label %sw.epilog, label %for.body

sw.bb274:                                         ; preds = %if.end6, %if.end6
  switch i32 %type, label %if.end288 [
    i32 20, label %land.lhs.true277
    i32 36, label %sw.bb.i
    i32 46, label %nomod
    i32 48, label %nomod
    i32 50, label %nomod
    i32 52, label %nomod
    i32 47, label %nomod
    i32 49, label %nomod
    i32 51, label %nomod
    i32 53, label %nomod
    i32 54, label %nomod
    i32 55, label %nomod
    i32 57, label %nomod
    i32 59, label %nomod
    i32 61, label %nomod
    i32 62, label %nomod
    i32 64, label %nomod
    i32 56, label %nomod
    i32 58, label %nomod
    i32 60, label %nomod
    i32 63, label %nomod
    i32 65, label %nomod
    i32 68, label %nomod
    i32 69, label %nomod
    i32 91, label %nomod
    i32 92, label %nomod
    i32 93, label %nomod
    i32 66, label %nomod
    i32 33, label %nomod
    i32 35, label %nomod
    i32 205, label %nomod
    i32 212, label %nomod
    i32 215, label %nomod
    i32 163, label %nomod
    i32 164, label %nomod
  ]

land.lhs.true277:                                 ; preds = %sw.bb274
  %op_flags278 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %64 = load i8* %op_flags278, align 1, !tbaa !1
  %and280 = and i8 %64, 8
  %tobool281 = icmp eq i8 %and280, 0
  br i1 %tobool281, label %if.end288, label %if.then282

if.then282:                                       ; preds = %land.lhs.true277
  store i32 1073741823, i32* @PL_modcount, align 4, !tbaa !0
  br label %return

sw.bb284:                                         ; preds = %if.end6
  switch i32 %type, label %if.end288 [
    i32 36, label %sw.bb.i
    i32 46, label %nomod
    i32 48, label %nomod
    i32 50, label %nomod
    i32 52, label %nomod
    i32 47, label %nomod
    i32 49, label %nomod
    i32 51, label %nomod
    i32 53, label %nomod
    i32 54, label %nomod
    i32 55, label %nomod
    i32 57, label %nomod
    i32 59, label %nomod
    i32 61, label %nomod
    i32 62, label %nomod
    i32 64, label %nomod
    i32 56, label %nomod
    i32 58, label %nomod
    i32 60, label %nomod
    i32 63, label %nomod
    i32 65, label %nomod
    i32 68, label %nomod
    i32 69, label %nomod
    i32 91, label %nomod
    i32 92, label %nomod
    i32 93, label %nomod
    i32 66, label %nomod
    i32 33, label %nomod
    i32 35, label %nomod
    i32 205, label %nomod
    i32 212, label %nomod
    i32 215, label %nomod
    i32 163, label %nomod
    i32 164, label %nomod
  ]

sw.bb.i:                                          ; preds = %sw.bb274, %sw.bb284
  %cmp.i = icmp eq i16 %.pre708, 14
  br i1 %cmp.i, label %if.end288, label %if.end217

if.end288:                                        ; preds = %sw.bb274, %land.lhs.true277, %sw.bb.i, %sw.bb284
  %65 = phi i16 [ %.pre708, %sw.bb274 ], [ %.pre708, %land.lhs.true277 ], [ 14, %sw.bb.i ], [ %.pre708, %sw.bb284 ]
  %66 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %67 = load %struct.op** %66, align 8, !tbaa !3
  %conv291 = zext i16 %65 to i32
  %call292 = tail call %struct.op* @Perl_ref(%struct.op* %67, i32 %conv291) #8
  br label %sw.bb293

sw.bb293:                                         ; preds = %if.end6, %if.end6, %if.end288
  %cmp294 = icmp eq i32 %type, 168
  br i1 %cmp294, label %if.then296, label %sw.bb302

if.then296:                                       ; preds = %sw.bb293
  %68 = load i8* %op_private, align 1, !tbaa !1
  %or299 = or i8 %68, 8
  store i8 %or299, i8* %op_private, align 1, !tbaa !1
  br label %sw.bb302

sw.bb302:                                         ; preds = %sw.bb293, %if.then296, %if.end6, %if.end6, %if.end6
  store i32 1073741823, i32* @PL_modcount, align 4, !tbaa !0
  br label %sw.epilog

sw.bb303:                                         ; preds = %if.end6
  %69 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %70 = load %struct.op** %69, align 8, !tbaa !3
  %call307 = tail call %struct.op* @Perl_ref(%struct.op* %70, i32 15) #8
  br label %sw.bb308

sw.bb308:                                         ; preds = %if.end6, %if.end6, %sw.bb303
  %71 = load i32* @PL_hints, align 4, !tbaa !0
  %or309 = or i32 %71, 256
  store i32 %or309, i32* @PL_hints, align 4, !tbaa !0
  br label %sw.bb310

sw.bb310:                                         ; preds = %if.end6, %if.end6, %if.end6, %if.end6, %sw.bb308
  %72 = load i32* @PL_modcount, align 4, !tbaa !0
  %inc311 = add nsw i32 %72, 1
  store i32 %inc311, i32* @PL_modcount, align 4, !tbaa !0
  br label %sw.epilog

sw.bb312:                                         ; preds = %if.end6, %if.end6
  store i32 1073741823, i32* @PL_modcount, align 4, !tbaa !0
  switch i32 %type, label %sw.bb334 [
    i32 20, label %land.lhs.true315
    i32 36, label %sw.bb.i679
    i32 46, label %nomod
    i32 48, label %nomod
    i32 50, label %nomod
    i32 52, label %nomod
    i32 47, label %nomod
    i32 49, label %nomod
    i32 51, label %nomod
    i32 53, label %nomod
    i32 54, label %nomod
    i32 55, label %nomod
    i32 57, label %nomod
    i32 59, label %nomod
    i32 61, label %nomod
    i32 62, label %nomod
    i32 64, label %nomod
    i32 56, label %nomod
    i32 58, label %nomod
    i32 60, label %nomod
    i32 63, label %nomod
    i32 65, label %nomod
    i32 68, label %nomod
    i32 69, label %nomod
    i32 91, label %nomod
    i32 92, label %nomod
    i32 93, label %nomod
    i32 66, label %nomod
    i32 33, label %nomod
    i32 35, label %nomod
    i32 205, label %nomod
    i32 212, label %nomod
    i32 215, label %nomod
    i32 163, label %nomod
    i32 164, label %nomod
    i32 168, label %sw.bb334.thread
  ]

land.lhs.true315:                                 ; preds = %sw.bb312
  %op_flags316 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %73 = load i8* %op_flags316, align 1, !tbaa !1
  %and318 = and i8 %73, 8
  %tobool319 = icmp eq i8 %and318, 0
  br i1 %tobool319, label %sw.bb334.thread695, label %return

sw.bb334.thread695:                               ; preds = %land.lhs.true315
  store i32 1073741824, i32* @PL_modcount, align 4, !tbaa !0
  br label %land.lhs.true465

sw.bb.i679:                                       ; preds = %sw.bb312
  %cmp.i678 = icmp eq i16 %.pre708, 14
  br i1 %cmp.i678, label %if.end480.thread, label %if.end217

if.end480.thread:                                 ; preds = %sw.bb.i679
  store i32 1073741824, i32* @PL_modcount, align 4, !tbaa !0
  %op_flags476697 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %74 = load i8* %op_flags476697, align 1, !tbaa !1
  %or478698 = or i8 %74, 32
  store i8 %or478698, i8* %op_flags476697, align 1, !tbaa !1
  br label %if.then486

sw.bb334.thread:                                  ; preds = %sw.bb312
  %75 = load i8* %op_private, align 1, !tbaa !1
  %or331 = or i8 %75, 8
  store i8 %or331, i8* %op_private, align 1, !tbaa !1
  %76 = load i32* @PL_modcount, align 4, !tbaa !0
  %inc335688 = add nsw i32 %76, 1
  store i32 %inc335688, i32* @PL_modcount, align 4, !tbaa !0
  br label %return

sw.bb334:                                         ; preds = %if.end6.sw.bb334_crit_edge, %sw.bb312
  %77 = phi i32 [ %phitmp, %if.end6.sw.bb334_crit_edge ], [ 1073741824, %sw.bb312 ]
  store i32 %77, i32* @PL_modcount, align 4, !tbaa !0
  switch i32 %type, label %if.end480 [
    i32 0, label %if.then337
    i32 20, label %land.lhs.true465
    i32 168, label %return
  ]

if.then337:                                       ; preds = %sw.bb334
  %78 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %op_targ338 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %79 = load i64* %op_targ338, align 8, !tbaa !5
  %conv339 = trunc i64 %79 to i32
  %call340 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %78, i32 %conv339, i32 0) #7
  %80 = load %struct.sv** %call340, align 8, !tbaa !3
  %sv_flags341 = getelementptr inbounds %struct.sv* %80, i64 0, i32 2
  %81 = load i32* %sv_flags341, align 4, !tbaa !0
  %and342 = and i32 %81, 262144
  %cmp343 = icmp eq i32 %and342, 0
  %82 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %83 = load i64* %op_targ338, align 8, !tbaa !5
  %conv347 = trunc i64 %83 to i32
  %call348 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %82, i32 %conv347, i32 0) #7
  %84 = load %struct.sv** %call348, align 8, !tbaa !3
  br i1 %cmp343, label %cond.false350, label %cond.true345

cond.true345:                                     ; preds = %if.then337
  %sv_any349 = getelementptr inbounds %struct.sv* %84, i64 0, i32 0
  %85 = load i8** %sv_any349, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %85 to i8**
  %86 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end355

cond.false350:                                    ; preds = %if.then337
  %call354 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %84) #7
  br label %cond.end355

cond.end355:                                      ; preds = %cond.false350, %cond.true345
  %cond356 = phi i8* [ %86, %cond.true345 ], [ %call354, %cond.false350 ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([35 x i8]* @.str22, i64 0, i64 0), i8* %cond356) #7
  br label %sw.epilog

sw.bb358:                                         ; preds = %if.end6
  switch i32 %type, label %if.end217thread-pre-split [
    i32 36, label %lvalue_func
    i32 20, label %land.lhs.true465
    i32 152, label %if.end480
    i32 166, label %if.end480
  ]

sw.bb363:                                         ; preds = %if.end6
  %cmp366 = icmp eq i8 %1, 4
  br i1 %cmp366, label %nomod, label %sw.bb370

sw.bb370:                                         ; preds = %sw.bb363, %if.end6, %if.end6
  %cmp371 = icmp eq i32 %type, 168
  br i1 %cmp371, label %if.then373, label %lvalue_func

if.then373:                                       ; preds = %sw.bb370
  %or376 = or i8 %1, 8
  store i8 %or376, i8* %op_private, align 1, !tbaa !1
  br label %lvalue_func

lvalue_func:                                      ; preds = %sw.bb358, %sw.bb370, %if.then373
  %op_targ379 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %87 = load i64* %op_targ379, align 8, !tbaa !5
  tail call void @Perl_pad_free(i64 %87) #7
  %88 = load i16* %op_type7, align 2, !tbaa !4
  %conv381 = zext i16 %88 to i32
  %call382 = tail call i64 @Perl_pad_alloc(i32 %conv381, i32 1024) #7
  store i64 %call382, i64* %op_targ379, align 8, !tbaa !5
  %op_flags384 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %89 = load i8* %op_flags384, align 1, !tbaa !1
  %and386 = and i8 %89, 4
  %tobool387 = icmp eq i8 %and386, 0
  br i1 %tobool387, label %sw.epilog, label %if.then388

if.then388:                                       ; preds = %lvalue_func
  %90 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %91 = load %struct.op** %90, align 8, !tbaa !3
  %op_sibling390 = getelementptr inbounds %struct.op* %91, i64 0, i32 1
  %92 = load %struct.op** %op_sibling390, align 8, !tbaa !3
  %call391 = tail call %struct.op* @Perl_mod(%struct.op* %92, i32 %type) #8
  br label %sw.epilog

sw.bb393:                                         ; preds = %if.end6, %if.end6
  %93 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %94 = load %struct.op** %93, align 8, !tbaa !3
  %call397 = tail call %struct.op* @Perl_ref(%struct.op* %94, i32 %conv8) #8
  switch i32 %type, label %if.end418 [
    i32 166, label %land.lhs.true400
    i32 168, label %if.then413
  ]

land.lhs.true400:                                 ; preds = %sw.bb393
  %95 = load i8* %op_private, align 1, !tbaa !1
  %tobool404 = icmp ult i8 %95, 32
  br i1 %tobool404, label %if.then405, label %if.end418

if.then405:                                       ; preds = %land.lhs.true400
  %or408 = or i8 %95, 16
  store i8 %or408, i8* %op_private, align 1, !tbaa !1
  br label %if.end418

if.then413:                                       ; preds = %sw.bb393
  %96 = load i8* %op_private, align 1, !tbaa !1
  %or416 = or i8 %96, 8
  store i8 %or416, i8* %op_private, align 1, !tbaa !1
  br label %if.end418

if.end418:                                        ; preds = %if.then405, %land.lhs.true400, %sw.bb393, %if.then413
  %97 = load i32* @PL_modcount, align 4, !tbaa !0
  %inc419 = add nsw i32 %97, 1
  store i32 %inc419, i32* @PL_modcount, align 4, !tbaa !0
  br label %sw.epilog

sw.bb420:                                         ; preds = %if.end6, %if.end6, %if.end6, %if.end6
  %op_flags421 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %98 = load i8* %op_flags421, align 1, !tbaa !1
  %and423 = and i8 %98, 4
  %tobool424 = icmp eq i8 %and423, 0
  br i1 %tobool424, label %sw.epilog, label %if.then425

if.then425:                                       ; preds = %sw.bb420
  %99 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %100 = load %struct.op** %99, align 8, !tbaa !3
  %call426 = tail call %struct.op* @Perl_mod(%struct.op* %100, i32 %type) #8
  br label %sw.epilog

sw.bb428:                                         ; preds = %if.end6
  %op_flags429 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %101 = load i8* %op_flags429, align 1, !tbaa !1
  %conv430 = zext i8 %101 to i32
  %and431 = and i32 %conv430, 128
  %tobool432 = icmp eq i32 %and431, 0
  br i1 %tobool432, label %if.else434, label %nomod

if.else434:                                       ; preds = %sw.bb428
  %and437 = and i32 %conv430, 4
  %tobool438 = icmp eq i32 %and437, 0
  br i1 %tobool438, label %sw.epilog, label %if.end441

if.end441:                                        ; preds = %if.else434
  %op_targ442 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %102 = load i64* %op_targ442, align 8, !tbaa !5
  %cmp443 = icmp eq i64 %102, 141
  br i1 %cmp443, label %sw.bb449, label %if.then445

if.then445:                                       ; preds = %if.end441
  %103 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %104 = load %struct.op** %103, align 8, !tbaa !3
  %call447 = tail call %struct.op* @Perl_mod(%struct.op* %104, i32 %type) #8
  br label %sw.epilog

sw.bb449:                                         ; preds = %if.end441, %if.end6
  %105 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.1705 = load %struct.op** %105, align 8
  %tobool452706 = icmp eq %struct.op* %kid.1705, null
  br i1 %tobool452706, label %sw.epilog, label %for.body453

for.body453:                                      ; preds = %sw.bb449, %for.body453
  %kid.1707 = phi %struct.op* [ %kid.1, %for.body453 ], [ %kid.1705, %sw.bb449 ]
  %call454 = tail call %struct.op* @Perl_mod(%struct.op* %kid.1707, i32 %type) #8
  %op_sibling456 = getelementptr inbounds %struct.op* %kid.1707, i64 0, i32 1
  %kid.1 = load %struct.op** %op_sibling456, align 8
  %tobool452 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool452, label %sw.epilog, label %for.body453

sw.bb458:                                         ; preds = %if.end6
  switch i32 %type, label %if.end217thread-pre-split [
    i32 20, label %land.lhs.true465
    i32 168, label %return
    i32 152, label %if.end480
    i32 166, label %if.end480
  ]

sw.epilog:                                        ; preds = %sw.bb449, %for.body453, %sw.bb268, %for.body, %sw.bb37, %if.end198, %lvalue_func, %sw.bb420, %if.else434, %if.then425, %if.then388, %cond.end355, %cond.end, %if.else33, %if.then445, %if.end418, %if.end6, %sw.bb310, %sw.bb302, %if.end266, %if.end185, %if.end141, %if.then122, %if.then75, %if.then54
  switch i32 %type, label %if.end480 [
    i32 20, label %land.lhs.true465
    i32 168, label %return
  ]

land.lhs.true465:                                 ; preds = %sw.epilog, %sw.bb458, %sw.bb358, %sw.bb334, %nomod, %if.else, %sw.bb334.thread695
  %106 = load i16* %op_type7, align 2, !tbaa !4
  %idxprom467 = zext i16 %106 to i64
  %arrayidx468 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom467
  %107 = load %struct.op* (%struct.op*)** %arrayidx468, align 8, !tbaa !3
  %cmp469 = icmp eq %struct.op* (%struct.op*)* %107, @Perl_ck_ftst
  br i1 %cmp469, label %return, label %if.end480.thread690

if.end480.thread690:                              ; preds = %land.lhs.true465, %sw.epilog.thread
  %op_flags476691 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %108 = load i8* %op_flags476691, align 1, !tbaa !1
  %or478692 = or i8 %108, 32
  store i8 %or478692, i8* %op_flags476691, align 1, !tbaa !1
  br label %if.else491

if.end480:                                        ; preds = %sw.epilog, %sw.bb458, %sw.bb458, %sw.bb358, %sw.bb358, %sw.bb334, %nomod, %nomod
  %op_flags476 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %109 = load i8* %op_flags476, align 1, !tbaa !1
  %or478 = or i8 %109, 32
  store i8 %or478, i8* %op_flags476, align 1, !tbaa !1
  %110 = and i32 %type, -2
  %111 = icmp eq i32 %110, 36
  br i1 %111, label %if.then486, label %if.else491

if.then486:                                       ; preds = %if.end480.thread, %if.end480
  %112 = phi i8 [ %or478698, %if.end480.thread ], [ %or478, %if.end480 ]
  %op_flags487 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %or489 = or i8 %112, -112
  store i8 %or489, i8* %op_flags487, align 1, !tbaa !1
  br label %return

if.else491:                                       ; preds = %if.end480.thread690, %if.end480
  %113 = phi i8 [ %or478692, %if.end480.thread690 ], [ %or478, %if.end480 ]
  switch i32 %type, label %if.then512 [
    i32 0, label %if.then493
    i32 168, label %return
    i32 166, label %return
    i32 152, label %return
  ]

if.then493:                                       ; preds = %if.else491
  %114 = load i8* %op_private, align 1, !tbaa !1
  %or496 = or i8 %114, -128
  store i8 %or496, i8* %op_private, align 1, !tbaa !1
  %op_flags498 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %and500 = and i8 %113, 127
  store i8 %and500, i8* %op_flags498, align 1, !tbaa !1
  %115 = load i32* @PL_hints, align 4, !tbaa !0
  %or502 = or i32 %115, 256
  store i32 %or502, i32* @PL_hints, align 4, !tbaa !0
  br label %return

if.then512:                                       ; preds = %if.else491
  %op_flags513 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %or515 = or i8 %113, 16
  store i8 %or515, i8* %op_flags513, align 1, !tbaa !1
  br label %return

return:                                           ; preds = %sw.bb334.thread, %sw.bb458, %sw.bb334, %sw.epilog, %if.else491, %if.else491, %if.else491, %if.then486, %if.then512, %if.then493, %land.lhs.true465, %land.lhs.true315, %if.else57, %land.lhs.true, %entry, %if.then282, %cond.end256, %sw.bb
  ret %struct.op* %o
}

; Function Attrs: optsize
declare i64 @Perl_sv_2iv(%struct.sv*) #2

; Function Attrs: optsize
declare void @Perl_save_I32(i32*) #2

; Function Attrs: optsize
declare void @Perl_croak(i8*, ...) #2

; Function Attrs: optsize
declare i8* @Perl_safesysmalloc(i64) #2

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #4

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ref(%struct.op* %o, i32 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  %0 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool1 = icmp ne i32 %0, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 166, label %sw.bb
    i32 162, label %sw.bb18
    i32 15, label %sw.bb22
    i32 9, label %sw.bb35
    i32 348, label %sw.bb58
    i32 125, label %sw.bb63
    i32 134, label %sw.bb63
    i32 14, label %sw.bb68
    i32 10, label %sw.bb81
    i32 11, label %sw.bb81
    i32 2, label %sw.bb86
    i32 0, label %sw.bb86
    i32 127, label %sw.bb95
    i32 135, label %sw.bb95
    i32 179, label %sw.bb127
    i32 178, label %sw.bb127
    i32 177, label %sw.bb127
    i32 141, label %sw.bb127
  ]

sw.bb:                                            ; preds = %if.end
  switch i32 %type, label %sw.epilog [
    i32 347, label %land.lhs.true
    i32 133, label %land.lhs.true
    i32 42, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %sw.bb, %sw.bb, %sw.bb
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool10 = icmp eq i8 %and, 0
  br i1 %tobool10, label %if.then11, label %sw.epilog

if.then11:                                        ; preds = %land.lhs.true
  store i16 17, i16* %op_type, align 2, !tbaa !4
  %3 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 17), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %4 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !3
  %6 = getelementptr inbounds %struct.op* %5, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !3
  tail call void @Perl_op_null(%struct.op* %7) #8
  %8 = load i8* %op_flags, align 1, !tbaa !1
  %or = or i8 %8, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  br label %sw.epilog

sw.bb18:                                          ; preds = %if.end
  %9 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %10 = load %struct.op** %9, align 8, !tbaa !3
  %kid.0.in188 = getelementptr inbounds %struct.op* %10, i64 0, i32 1
  %kid.0189 = load %struct.op** %kid.0.in188, align 8
  %tobool20190 = icmp eq %struct.op* %kid.0189, null
  br i1 %tobool20190, label %sw.epilog, label %for.body

for.body:                                         ; preds = %sw.bb18, %for.body
  %kid.0191 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0189, %sw.bb18 ]
  %call = tail call %struct.op* @Perl_ref(%struct.op* %kid.0191, i32 %type) #8
  %kid.0.in = getelementptr inbounds %struct.op* %kid.0191, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool20 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool20, label %sw.epilog, label %for.body

sw.bb22:                                          ; preds = %if.end
  %cmp23 = icmp eq i32 %type, 42
  br i1 %cmp23, label %if.then25, label %if.end30

if.then25:                                        ; preds = %sw.bb22
  %op_flags26 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %11 = load i8* %op_flags26, align 1, !tbaa !1
  %or28 = or i8 %11, -128
  store i8 %or28, i8* %op_flags26, align 1, !tbaa !1
  br label %if.end30

if.end30:                                         ; preds = %if.then25, %sw.bb22
  %12 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %13 = load %struct.op** %12, align 8, !tbaa !3
  %call34 = tail call %struct.op* @Perl_ref(%struct.op* %13, i32 15) #8
  br label %sw.bb35

sw.bb35:                                          ; preds = %if.end, %if.end30
  %cmp42 = icmp eq i32 %type, 134
  switch i32 %type, label %sw.epilog [
    i32 125, label %cond.end
    i32 15, label %cond.false
    i32 134, label %cond.false
  ]

cond.false:                                       ; preds = %sw.bb35, %sw.bb35
  %cond = select i1 %cmp42, i8 64, i8 96
  br label %cond.end

cond.end:                                         ; preds = %sw.bb35, %cond.false
  %cond49 = phi i8 [ %cond, %cond.false ], [ 32, %sw.bb35 ]
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %14 = load i8* %op_private, align 1, !tbaa !1
  %or51 = or i8 %14, %cond49
  store i8 %or51, i8* %op_private, align 1, !tbaa !1
  %op_flags53 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %15 = load i8* %op_flags53, align 1, !tbaa !1
  %or55 = or i8 %15, 32
  store i8 %or55, i8* %op_flags53, align 1, !tbaa !1
  br label %sw.epilog

sw.bb58:                                          ; preds = %if.end
  %op_flags59 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %16 = load i8* %op_flags59, align 1, !tbaa !1
  %or61 = or i8 %16, 32
  store i8 %or61, i8* %op_flags59, align 1, !tbaa !1
  br label %sw.epilog

sw.bb63:                                          ; preds = %if.end, %if.end
  %op_flags64 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %17 = load i8* %op_flags64, align 1, !tbaa !1
  %or66 = or i8 %17, 16
  store i8 %or66, i8* %op_flags64, align 1, !tbaa !1
  br label %sw.bb68

sw.bb68:                                          ; preds = %if.end, %sw.bb63
  %cmp69 = icmp eq i32 %type, 42
  br i1 %cmp69, label %if.then71, label %if.end76

if.then71:                                        ; preds = %sw.bb68
  %op_flags72 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %18 = load i8* %op_flags72, align 1, !tbaa !1
  %or74 = or i8 %18, -128
  store i8 %or74, i8* %op_flags72, align 1, !tbaa !1
  br label %if.end76

if.end76:                                         ; preds = %if.then71, %sw.bb68
  %19 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %20 = load %struct.op** %19, align 8, !tbaa !3
  %call80 = tail call %struct.op* @Perl_ref(%struct.op* %20, i32 %conv) #8
  br label %sw.epilog

sw.bb81:                                          ; preds = %if.end, %if.end
  %op_flags82 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %21 = load i8* %op_flags82, align 1, !tbaa !1
  %or84 = or i8 %21, 16
  store i8 %or84, i8* %op_flags82, align 1, !tbaa !1
  br label %sw.epilog

sw.bb86:                                          ; preds = %if.end, %if.end
  %op_flags87 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %22 = load i8* %op_flags87, align 1, !tbaa !1
  %and89 = and i8 %22, 4
  %tobool90 = icmp eq i8 %and89, 0
  br i1 %tobool90, label %sw.epilog, label %if.end92

if.end92:                                         ; preds = %sw.bb86
  %23 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %24 = load %struct.op** %23, align 8, !tbaa !3
  %call94 = tail call %struct.op* @Perl_ref(%struct.op* %24, i32 %type) #8
  br label %sw.epilog

sw.bb95:                                          ; preds = %if.end, %if.end
  %25 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %26 = load %struct.op** %25, align 8, !tbaa !3
  %call99 = tail call %struct.op* @Perl_ref(%struct.op* %26, i32 %conv) #8
  %cmp106 = icmp eq i32 %type, 134
  switch i32 %type, label %sw.epilog [
    i32 125, label %cond.end116
    i32 15, label %cond.false112
    i32 134, label %cond.false112
  ]

cond.false112:                                    ; preds = %sw.bb95, %sw.bb95
  %cond115 = select i1 %cmp106, i8 64, i8 96
  br label %cond.end116

cond.end116:                                      ; preds = %sw.bb95, %cond.false112
  %cond117 = phi i8 [ %cond115, %cond.false112 ], [ 32, %sw.bb95 ]
  %op_private118 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %27 = load i8* %op_private118, align 1, !tbaa !1
  %or120 = or i8 %27, %cond117
  store i8 %or120, i8* %op_private118, align 1, !tbaa !1
  %op_flags122 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %28 = load i8* %op_flags122, align 1, !tbaa !1
  %or124 = or i8 %28, 32
  store i8 %or124, i8* %op_flags122, align 1, !tbaa !1
  br label %sw.epilog

sw.bb127:                                         ; preds = %if.end, %if.end, %if.end, %if.end
  %op_flags128 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %29 = load i8* %op_flags128, align 1, !tbaa !1
  %and130 = and i8 %29, 4
  %tobool131 = icmp eq i8 %and130, 0
  br i1 %tobool131, label %sw.epilog, label %if.end133

if.end133:                                        ; preds = %sw.bb127
  %30 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %31 = load %struct.op** %30, align 8, !tbaa !3
  %call134 = tail call %struct.op* @Perl_ref(%struct.op* %31, i32 %type) #8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb18, %for.body, %sw.bb95, %sw.bb35, %sw.bb, %land.lhs.true, %sw.bb86, %sw.bb127, %if.end, %cond.end116, %cond.end, %if.then11, %if.end133, %if.end92, %sw.bb81, %if.end76, %sw.bb58
  %call135 = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  %retval.0 = phi %struct.op* [ %call135, %sw.epilog ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv** @Perl_av_fetch(%struct.av*, i32, i32) #2

; Function Attrs: optsize
declare i8* @Perl_sv_2pv_nolen(%struct.sv*) #2

; Function Attrs: optsize
declare i64 @Perl_pad_alloc(i32, i32) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_refkids(%struct.op* %o, i32 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call %struct.op* @Perl_ref(%struct.op* %kid.010, i32 %type) #8
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %if.then, %for.body, %land.lhs.true, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define void @Perl_apply_attrs_string(i8* %stashpv, %struct.cv* %cv, i8* %attrstr, i64 %len) #0 {
entry:
  %tobool = icmp eq i64 %len, 0
  br i1 %tobool, label %while.cond.preheader, label %for.cond.preheader.lr.ph

while.cond.preheader:                             ; preds = %entry
  %call = tail call i64 @strlen(i8* %attrstr) #7
  %tobool18994 = icmp eq i64 %call, 0
  br i1 %tobool18994, label %while.end, label %for.cond.preheader.lr.ph

for.cond.preheader.lr.ph:                         ; preds = %entry, %while.cond.preheader, %for.end48
  %attrstr.addr.0.ph97 = phi i8* [ %attrstr.addr.2, %for.end48 ], [ %attrstr, %while.cond.preheader ], [ %attrstr, %entry ]
  %attrs.0.ph96 = phi %struct.op* [ %call51, %for.end48 ], [ null, %while.cond.preheader ], [ null, %entry ]
  %len.addr.0.ph8895 = phi i64 [ %len.addr.2.lcssa, %for.end48 ], [ %call, %while.cond.preheader ], [ %len, %entry ]
  br label %for.cond

for.cond:                                         ; preds = %for.cond.preheader.lr.ph, %for.inc
  %len.addr.1 = phi i64 [ %dec, %for.inc ], [ %len.addr.0.ph8895, %for.cond.preheader.lr.ph ]
  %attrstr.addr.1 = phi i8* [ %incdec.ptr, %for.inc ], [ %attrstr.addr.0.ph97, %for.cond.preheader.lr.ph ]
  %0 = load i8* %attrstr.addr.1, align 1, !tbaa !1
  switch i8 %0, label %for.end [
    i8 32, label %land.rhs
    i8 9, label %land.rhs
    i8 10, label %land.rhs
    i8 13, label %land.rhs
    i8 12, label %land.rhs
  ]

land.rhs:                                         ; preds = %for.cond, %for.cond, %for.cond, %for.cond, %for.cond
  %cond = icmp eq i64 %len.addr.1, 0
  br i1 %cond, label %while.end, label %for.inc

for.inc:                                          ; preds = %land.rhs
  %dec = add i64 %len.addr.1, -1
  %incdec.ptr = getelementptr inbounds i8* %attrstr.addr.1, i64 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool19 = icmp eq i64 %len.addr.1, 0
  br i1 %tobool19, label %while.end, label %for.cond21

for.cond21:                                       ; preds = %for.end, %for.inc45
  %1 = phi i8 [ %.pre, %for.inc45 ], [ %0, %for.end ]
  %len.addr.2 = phi i64 [ %dec46, %for.inc45 ], [ %len.addr.1, %for.end ]
  %attrstr.addr.2 = phi i8* [ %incdec.ptr47, %for.inc45 ], [ %attrstr.addr.1, %for.end ]
  switch i8 %1, label %land.rhs41 [
    i8 32, label %for.end48
    i8 9, label %for.end48
    i8 10, label %for.end48
    i8 13, label %for.end48
    i8 12, label %for.end48
  ]

land.rhs41:                                       ; preds = %for.cond21
  %tobool42 = icmp eq i64 %len.addr.2, 0
  br i1 %tobool42, label %for.end48, label %for.inc45

for.inc45:                                        ; preds = %land.rhs41
  %dec46 = add i64 %len.addr.2, -1
  %incdec.ptr47 = getelementptr inbounds i8* %attrstr.addr.2, i64 1
  %.pre = load i8* %incdec.ptr47, align 1, !tbaa !1
  br label %for.cond21

for.end48:                                        ; preds = %for.cond21, %for.cond21, %for.cond21, %for.cond21, %for.cond21, %land.rhs41
  %len.addr.2.lcssa = phi i64 [ %len.addr.2, %for.cond21 ], [ %len.addr.2, %for.cond21 ], [ %len.addr.2, %for.cond21 ], [ %len.addr.2, %for.cond21 ], [ %len.addr.2, %for.cond21 ], [ 0, %land.rhs41 ]
  %sub.ptr.lhs.cast = ptrtoint i8* %attrstr.addr.2 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %attrstr.addr.1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call49 = tail call %struct.sv* @Perl_newSVpvn(i8* %attrstr.addr.1, i64 %sub.ptr.sub) #7
  %call50 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call49) #8
  %call51 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %attrs.0.ph96, %struct.op* %call50) #8
  %tobool189 = icmp eq i64 %len.addr.2.lcssa, 0
  br i1 %tobool189, label %while.end, label %for.cond.preheader.lr.ph

while.end:                                        ; preds = %while.cond.preheader, %for.end48, %land.rhs, %for.end
  %attrs.0.ph93 = phi %struct.op* [ %attrs.0.ph96, %for.end ], [ %attrs.0.ph96, %land.rhs ], [ null, %while.cond.preheader ], [ %call51, %for.end48 ]
  %call53 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str23, i64 0, i64 0), i64 10) #7
  %call54 = tail call %struct.sv* @Perl_newSVpv(i8* %stashpv, i64 0) #7
  %call55 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call54) #8
  %2 = bitcast %struct.cv* %cv to %struct.sv*
  %call56 = tail call %struct.sv* @Perl_newRV(%struct.sv* %2) #7
  %call57 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call56) #8
  %call58 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call57, %struct.op* %attrs.0.ph93) #8
  %call59 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call55, %struct.op* %call58) #8
  tail call void (i32, %struct.sv*, %struct.sv*, ...)* @Perl_load_module(i32 4, %struct.sv* %call53, %struct.sv* null, %struct.op* %call59) #8
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_append_elem(i32 %type, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.op* %last, null
  br i1 %tobool1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %first, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, %type
  br i1 %cmp, label %lor.lhs.false, label %if.then9

lor.lhs.false:                                    ; preds = %if.end3
  %cmp5 = icmp eq i32 %type, 141
  %op_flags = getelementptr inbounds %struct.op* %first, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  br i1 %cmp5, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %lor.lhs.false
  %and = and i8 %1, 8
  %tobool8 = icmp eq i8 %and, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %land.lhs.true, %if.end3
  %call = tail call %struct.op* @Perl_newLISTOP(i32 %type, i32 0, %struct.op* %first, %struct.op* %last) #8
  br label %return

if.end10:                                         ; preds = %lor.lhs.false, %land.lhs.true
  %and13 = and i8 %1, 4
  %tobool14 = icmp eq i8 %and13, 0
  br i1 %tobool14, label %if.else, label %if.then15

if.then15:                                        ; preds = %if.end10
  %2 = getelementptr inbounds %struct.op* %first, i64 1, i32 1
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  store %struct.op* %last, %struct.op** %op_sibling, align 8, !tbaa !3
  br label %if.end19

if.else:                                          ; preds = %if.end10
  %op_flags11 = getelementptr inbounds %struct.op* %first, i64 0, i32 6
  %or = or i8 %1, 4
  store i8 %or, i8* %op_flags11, align 1, !tbaa !1
  %4 = getelementptr inbounds %struct.op* %first, i64 1, i32 0
  store %struct.op* %last, %struct.op** %4, align 8, !tbaa !3
  %.pre36 = getelementptr inbounds %struct.op* %first, i64 1, i32 1
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then15
  %.pre-phi = phi %struct.op** [ %.pre36, %if.else ], [ %2, %if.then15 ]
  store %struct.op* %last, %struct.op** %.pre-phi, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end19, %if.then9
  %retval.0 = phi %struct.op* [ %call, %if.then9 ], [ %first, %if.end19 ], [ %last, %entry ], [ %first, %if.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newSVOP(i32 %type, i32 %flags, %struct.sv* %sv) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 48) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !3
  %op_sv = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_sv to %struct.sv**
  store %struct.sv* %sv, %struct.sv** %3, align 8, !tbaa !3
  %4 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %4, %struct.op** %op_next, align 8, !tbaa !3
  %conv1 = trunc i32 %flags to i8
  %5 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %5, align 1, !tbaa !1
  %arrayidx3 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %6 = load i32* %arrayidx3, align 4, !tbaa !0
  %and = and i32 %6, 4
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = tail call %struct.op* @Perl_scalar(%struct.op* %4) #8
  %.pre = load i32* %arrayidx3, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %7 = phi i32 [ %6, %entry ], [ %.pre, %if.then ]
  %and7 = and i32 %7, 8
  %tobool8 = icmp eq i32 %and7, 0
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end
  %call10 = tail call i64 @Perl_pad_alloc(i32 %type, i32 512) #7
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %8 = bitcast i8* %op_targ to i64*
  store i64 %call10, i64* %8, align 8, !tbaa !5
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then9
  %9 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool12 = icmp eq i8* %9, null
  br i1 %tobool12, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end11
  %arrayidx14 = getelementptr inbounds i8* %9, i64 %idxprom
  %10 = load i8* %arrayidx14, align 1, !tbaa !1
  %tobool16 = icmp eq i8 %10, 0
  br i1 %tobool16, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %4) #8
  %arrayidx18 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %11 = load i8** %arrayidx18, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end11
  %arrayidx20 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %12 = load %struct.op* (%struct.op*)** %arrayidx20, align 8, !tbaa !3
  %call21 = tail call %struct.op* %12(%struct.op* %4) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call21, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVpvn(i8*, i64) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_load_module(i32 %flags, %struct.sv* %name, %struct.sv* %ver, ...) #0 {
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %arraydecay1 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  call void @Perl_vload_module(i32 %flags, %struct.sv* %name, %struct.sv* %ver, [1 x %struct.__va_list_tag]* %args) #8
  call void @llvm.va_end(i8* %arraydecay1)
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_prepend_elem(i32 %type, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.op* %last, null
  br i1 %tobool1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %last, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, %type
  br i1 %cmp, label %if.then5, label %if.end37

if.then5:                                         ; preds = %if.end3
  %cmp6 = icmp eq i32 %type, 141
  br i1 %cmp6, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then5
  %1 = getelementptr inbounds %struct.op* %last, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %op_sibling9 = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %3, %struct.op** %op_sibling9, align 8, !tbaa !3
  %4 = load %struct.op** %1, align 8, !tbaa !3
  %op_sibling11 = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  store %struct.op* %first, %struct.op** %op_sibling11, align 8, !tbaa !3
  %op_flags = getelementptr inbounds %struct.op* %first, i64 0, i32 6
  %5 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %5, 8
  %tobool13 = icmp eq i8 %and, 0
  %op_flags15 = getelementptr inbounds %struct.op* %last, i64 0, i32 6
  br i1 %tobool13, label %if.then14, label %if.end32

if.then14:                                        ; preds = %if.then8
  %6 = load i8* %op_flags15, align 1, !tbaa !1
  %and17 = and i8 %6, -9
  store i8 %and17, i8* %op_flags15, align 1, !tbaa !1
  br label %if.end32

if.else:                                          ; preds = %if.then5
  %op_flags20 = getelementptr inbounds %struct.op* %last, i64 0, i32 6
  %7 = load i8* %op_flags20, align 1, !tbaa !1
  %and22 = and i8 %7, 4
  %tobool23 = icmp eq i8 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end28

if.then24:                                        ; preds = %if.else
  %8 = getelementptr inbounds %struct.op* %last, i64 1, i32 1
  store %struct.op* %first, %struct.op** %8, align 8, !tbaa !3
  %or = or i8 %7, 4
  store i8 %or, i8* %op_flags20, align 1, !tbaa !1
  br label %if.end28

if.end28:                                         ; preds = %if.else, %if.then24
  %9 = getelementptr inbounds %struct.op* %last, i64 1, i32 0
  %10 = load %struct.op** %9, align 8, !tbaa !3
  %op_sibling30 = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %10, %struct.op** %op_sibling30, align 8, !tbaa !3
  store %struct.op* %first, %struct.op** %9, align 8, !tbaa !3
  br label %if.end32

if.end32:                                         ; preds = %if.then8, %if.then14, %if.end28
  %op_flags33.pre-phi = phi i8* [ %op_flags15, %if.then14 ], [ %op_flags20, %if.end28 ], [ %op_flags15, %if.then8 ]
  %11 = load i8* %op_flags33.pre-phi, align 1, !tbaa !1
  %or35 = or i8 %11, 4
  store i8 %or35, i8* %op_flags33.pre-phi, align 1, !tbaa !1
  br label %return

if.end37:                                         ; preds = %if.end3
  %call = tail call %struct.op* @Perl_newLISTOP(i32 %type, i32 0, %struct.op* %first, %struct.op* %last) #8
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end37, %if.end32
  %retval.0 = phi %struct.op* [ %last, %if.end32 ], [ %call, %if.end37 ], [ %last, %entry ], [ %first, %if.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVpv(i8*, i64) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_newRV(%struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_my_attrs(%struct.op* %o, %struct.op* %attrs) #0 {
entry:
  %rops = alloca %struct.op*, align 8
  store %struct.op* null, %struct.op** %rops, align 8, !tbaa !3
  %tobool = icmp eq %struct.op* %attrs, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @Perl_save_freeop(%struct.op* %attrs) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %call = call fastcc %struct.op* @S_my_kid(%struct.op* %o, %struct.op* %attrs, %struct.op** %rops) #8
  %0 = load %struct.op** %rops, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %0, null
  br i1 %tobool1, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %1, 9
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %2 = bitcast %struct.op* %0 to %struct.listop*
  %3 = bitcast %struct.op* %call to %struct.listop*
  %call6 = call %struct.op* @Perl_append_list(i32 141, %struct.listop* %2, %struct.listop* %3) #8
  %call7 = call %struct.op* @Perl_scalar(%struct.op* %call6) #8
  %op_private = getelementptr inbounds %struct.op* %call7, i64 0, i32 7
  %4 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %4, -128
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  br label %if.end12

if.else:                                          ; preds = %land.lhs.true
  %5 = bitcast %struct.op* %call to %struct.listop*
  %6 = bitcast %struct.op* %0 to %struct.listop*
  %call10 = call %struct.op* @Perl_append_list(i32 141, %struct.listop* %5, %struct.listop* %6) #8
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then5, %if.else
  %o.addr.0 = phi %struct.op* [ %call7, %if.then5 ], [ %call10, %if.else ], [ %call, %if.end ]
  store i32 0, i32* @PL_in_my, align 4, !tbaa !0
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8, !tbaa !3
  ret %struct.op* %o.addr.0
}

; Function Attrs: optsize
declare void @Perl_save_freeop(%struct.op*) #2

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.op* @S_my_kid(%struct.op* %o, %struct.op* %attrs, %struct.op** nocapture %imopsp) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  %0 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool1 = icmp ne i32 %0, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %1, label %if.else66 [
    i16 141, label %if.then3
    i16 43, label %return
    i16 134, label %if.then17
    i16 125, label %if.then17
    i16 15, label %if.then17
  ]

if.then3:                                         ; preds = %if.end
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.0173 = load %struct.op** %2, align 8
  %tobool4174 = icmp eq %struct.op* %kid.0173, null
  br i1 %tobool4174, label %if.end119, label %for.body

for.body:                                         ; preds = %if.then3, %for.body
  %kid.0175 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.0173, %if.then3 ]
  %call = tail call fastcc %struct.op* @S_my_kid(%struct.op* %kid.0175, %struct.op* %attrs, %struct.op** %imopsp) #8
  %op_sibling = getelementptr inbounds %struct.op* %kid.0175, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool4 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool4, label %if.end119, label %for.body

if.then17:                                        ; preds = %if.end, %if.end, %if.end
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  %op_type19 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type19, align 2, !tbaa !4
  %cmp21 = icmp eq i16 %5, 7
  br i1 %cmp21, label %if.else35, label %cond.end

cond.end:                                         ; preds = %if.then17
  %idxprom = zext i16 %1 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %6 = load i8** %arrayidx, align 8, !tbaa !3
  %7 = load i32* @PL_in_my, align 4, !tbaa !0
  %cmp30 = icmp eq i32 %7, 137
  %cond32 = select i1 %cmp30, i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str5, i64 0, i64 0)
  %call33 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([23 x i8]* @.str153, i64 0, i64 0), i8* %6, i8* %cond32) #7
  %call34 = tail call i32 @Perl_yyerror(i8* %call33) #7
  br label %if.end63

if.else35:                                        ; preds = %if.then17
  %tobool36 = icmp eq %struct.op* %attrs, null
  br i1 %tobool36, label %if.end63, label %if.then37

if.then37:                                        ; preds = %if.else35
  %op_sv = getelementptr inbounds %struct.op* %4, i64 1
  %8 = bitcast %struct.op* %op_sv to %struct.sv**
  %9 = load %struct.sv** %8, align 8, !tbaa !3
  store i32 0, i32* @PL_in_my, align 4, !tbaa !0
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8, !tbaa !3
  %sv_any = bitcast %struct.sv* %9 to %struct.xpvgv**
  %10 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %10, i64 0, i32 10
  %11 = load %struct.hv** %xgv_stash, align 8, !tbaa !3
  switch i16 %1, label %cond.end60 [
    i16 15, label %cond.true41
    i16 125, label %cond.true46
    i16 134, label %cond.true52
  ]

cond.true41:                                      ; preds = %if.then37
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %10, i64 0, i32 7
  %12 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_sv = getelementptr inbounds %struct.gp* %12, i64 0, i32 0
  %13 = load %struct.sv** %gp_sv, align 8, !tbaa !3
  br label %cond.end60

cond.true46:                                      ; preds = %if.then37
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv* %10, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp48, align 8, !tbaa !3
  %gp_av = getelementptr inbounds %struct.gp* %14, i64 0, i32 4
  %15 = load %struct.av** %gp_av, align 8, !tbaa !3
  %16 = bitcast %struct.av* %15 to %struct.sv*
  br label %cond.end60

cond.true52:                                      ; preds = %if.then37
  %xgv_gp54 = getelementptr inbounds %struct.xpvgv* %10, i64 0, i32 7
  %17 = load %struct.gp** %xgv_gp54, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %17, i64 0, i32 5
  %18 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %19 = bitcast %struct.hv* %18 to %struct.sv*
  br label %cond.end60

cond.end60:                                       ; preds = %if.then37, %cond.true46, %cond.true52, %cond.true41
  %cond61 = phi %struct.sv* [ %13, %cond.true41 ], [ %16, %cond.true46 ], [ %19, %cond.true52 ], [ %9, %if.then37 ]
  tail call fastcc void @S_apply_attrs(%struct.hv* %11, %struct.sv* %cond61, %struct.op* %attrs, i8 signext 0) #8
  br label %if.end63

if.end63:                                         ; preds = %if.else35, %cond.end60, %cond.end
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %20 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %20, 16
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  br label %return

if.else66:                                        ; preds = %if.end
  %.off = add i16 %1, -9
  %21 = icmp ugt i16 %.off, 1
  %cmp72 = icmp ne i16 %1, 11
  %or.cond130 = and i1 %21, %cmp72
  %cmp75 = icmp ne i16 %1, 3
  %or.cond131 = and i1 %or.cond130, %cmp75
  br i1 %or.cond131, label %if.then77, label %if.else95

if.then77:                                        ; preds = %if.else66
  %cmp80 = icmp eq i16 %1, 351
  br i1 %cmp80, label %cond.true82, label %cond.false84

cond.true82:                                      ; preds = %if.then77
  %call83 = tail call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end88

cond.false84:                                     ; preds = %if.then77
  %idxprom86 = zext i16 %1 to i64
  %arrayidx87 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom86
  %22 = load i8** %arrayidx87, align 8, !tbaa !3
  br label %cond.end88

cond.end88:                                       ; preds = %cond.false84, %cond.true82
  %cond89 = phi i8* [ %call83, %cond.true82 ], [ %22, %cond.false84 ]
  %23 = load i32* @PL_in_my, align 4, !tbaa !0
  %cmp90 = icmp eq i32 %23, 137
  %cond92 = select i1 %cmp90, i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str5, i64 0, i64 0)
  %call93 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([25 x i8]* @.str154, i64 0, i64 0), i8* %cond89, i8* %cond92) #7
  %call94 = tail call i32 @Perl_yyerror(i8* %call93) #7
  br label %return

if.else95:                                        ; preds = %if.else66
  %tobool96 = icmp eq %struct.op* %attrs, null
  %cmp75.not = xor i1 %cmp75, true
  %brmerge = or i1 %tobool96, %cmp75.not
  br i1 %brmerge, label %if.end119, label %if.then100

if.then100:                                       ; preds = %if.else95
  store i32 0, i32* @PL_in_my, align 4, !tbaa !0
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8, !tbaa !3
  %24 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %25 = load i64* %op_targ, align 8, !tbaa !5
  %conv101 = trunc i64 %25 to i32
  %call102 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %24, i32 %conv101, i32 0) #7
  %26 = load %struct.sv** %call102, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %26, i64 0, i32 2
  %27 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %27, 1073741824
  %tobool103 = icmp eq i32 %and, 0
  br i1 %tobool103, label %if.end.i, label %cond.true104

cond.true104:                                     ; preds = %if.then100
  %28 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %29 = load i64* %op_targ, align 8, !tbaa !5
  %conv106 = trunc i64 %29 to i32
  %call107 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %28, i32 %conv106, i32 0) #7
  %30 = load %struct.sv** %call107, align 8, !tbaa !3
  %sv_any108 = getelementptr inbounds %struct.sv* %30, i64 0, i32 0
  %31 = load i8** %sv_any108, align 8, !tbaa !3
  %xmg_stash = getelementptr inbounds i8* %31, i64 48
  %32 = bitcast i8* %xmg_stash to %struct.hv**
  %33 = load %struct.hv** %32, align 8, !tbaa !3
  br label %if.end.i

if.end.i:                                         ; preds = %cond.true104, %if.then100
  %cond111 = phi %struct.hv* [ %33, %cond.true104 ], [ null, %if.then100 ]
  %tobool112 = icmp eq %struct.hv* %cond111, null
  %34 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %.cond111 = select i1 %tobool112, %struct.hv* %34, %struct.hv* %cond111
  %35 = load i64* %op_targ, align 8, !tbaa !5
  %36 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx.i = getelementptr inbounds %struct.sv** %36, i64 %35
  %37 = load %struct.sv** %arrayidx.i, align 8, !tbaa !3
  tail call fastcc void @S_apply_attrs(%struct.hv* %.cond111, %struct.sv* %37, %struct.op* %attrs, i8 signext 1) #7
  %call.i = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str23, i64 0, i64 0), i64 10) #7
  %call1.i = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call.i) #7
  %tobool2.i = icmp eq %struct.hv* %.cond111, null
  br i1 %tobool2.i, label %if.end5.i, label %if.then3.i

if.then3.i:                                       ; preds = %if.end.i
  %sv_any.i = getelementptr inbounds %struct.hv* %.cond111, i64 0, i32 0
  %38 = load %struct.xpvhv** %sv_any.i, align 8, !tbaa !3
  %xhv_name.i = getelementptr inbounds %struct.xpvhv* %38, i64 0, i32 10
  %39 = load i8** %xhv_name.i, align 8, !tbaa !3
  %call4.i = tail call %struct.sv* @Perl_newSVpv(i8* %39, i64 0) #7
  br label %if.end5.i

if.end5.i:                                        ; preds = %if.then3.i, %if.end.i
  %stashsv.0.i = phi %struct.sv* [ %call4.i, %if.then3.i ], [ @PL_sv_no, %if.end.i ]
  %call6.i = tail call %struct.op* @Perl_newOP(i32 9, i32 0) #7
  %40 = load i64* %op_targ, align 8, !tbaa !5
  %op_targ8.i = getelementptr inbounds %struct.op* %call6.i, i64 0, i32 3
  store i64 %40, i64* %op_targ8.i, align 8, !tbaa !5
  %call9.i = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %stashsv.0.i) #7
  %call10.i = tail call %struct.op* @Perl_mod(%struct.op* %call6.i, i32 20) #7
  %call11.i = tail call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call10.i) #7
  %call12.i = tail call fastcc %struct.op* @S_dup_attrlist(%struct.op* %attrs) #7
  %call13.i = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call11.i, %struct.op* %call12.i) #7
  %call14.i = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call9.i, %struct.op* %call13.i) #7
  %call15.i = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([7 x i8]* @.str49, i64 0, i64 0), i64 6) #7
  %sv_flags.i = getelementptr inbounds %struct.sv* %call15.i, i64 0, i32 2
  %41 = load i32* %sv_flags.i, align 4, !tbaa !0
  %and.i = and i32 %41, 255
  %cmp.i = icmp ugt i32 %and.i, 4
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.end5.i
  %call16.i = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call15.i, i32 5) #7
  %.pre.i = load i32* %sv_flags.i, align 4, !tbaa !0
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %if.end5.i
  %42 = phi i32 [ %.pre.i, %lor.rhs.i ], [ %41, %if.end5.i ]
  %and19.i = and i32 %42, 2097152
  %tobool20.i = icmp eq i32 %and19.i, 0
  br i1 %tobool20.i, label %land.end.i, label %land.rhs.i

land.rhs.i:                                       ; preds = %lor.end.i
  %call21.i = tail call i32 @Perl_sv_backoff(%struct.sv* %call15.i) #7
  %.pre78.i = load i32* %sv_flags.i, align 4, !tbaa !0
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %lor.end.i
  %43 = phi i32 [ %42, %lor.end.i ], [ %.pre78.i, %land.rhs.i ]
  %or.i = or i32 %43, 16842752
  store i32 %or.i, i32* %sv_flags.i, align 4, !tbaa !0
  %sv_any24.i = getelementptr inbounds %struct.sv* %call15.i, i64 0, i32 0
  %44 = load i8** %sv_any24.i, align 8, !tbaa !3
  %xpv_cur.i = getelementptr inbounds i8* %44, i64 8
  %45 = bitcast i8* %xpv_cur.i to i64*
  %46 = load i64* %45, align 8, !tbaa !5
  %conv26.i = trunc i64 %46 to i32
  %tobool2774.i = icmp eq i32 %conv26.i, 0
  br i1 %tobool2774.i, label %while.end.i, label %while.body.lr.ph.i

while.body.lr.ph.i:                               ; preds = %land.end.i
  %xpv_pv.i = bitcast i8* %44 to i8**
  %47 = load i8** %xpv_pv.i, align 8, !tbaa !3
  br label %while.body.i

while.body.i:                                     ; preds = %while.body.i, %while.body.lr.ph.i
  %hash_PeRlHaSh.077.i = phi i32 [ 0, %while.body.lr.ph.i ], [ %xor.i, %while.body.i ]
  %i_PeRlHaSh.076.i = phi i32 [ %conv26.i, %while.body.lr.ph.i ], [ %dec.i, %while.body.i ]
  %s_PeRlHaSh.075.i = phi i8* [ %47, %while.body.lr.ph.i ], [ %incdec.ptr.i, %while.body.i ]
  %dec.i = add nsw i32 %i_PeRlHaSh.076.i, -1
  %incdec.ptr.i = getelementptr inbounds i8* %s_PeRlHaSh.075.i, i64 1
  %48 = load i8* %s_PeRlHaSh.075.i, align 1, !tbaa !1
  %conv28.i = zext i8 %48 to i32
  %add.i = add i32 %conv28.i, %hash_PeRlHaSh.077.i
  %add29.i = mul i32 %add.i, 1025
  %shr.i = lshr i32 %add29.i, 6
  %xor.i = xor i32 %shr.i, %add29.i
  %tobool27.i = icmp eq i32 %dec.i, 0
  br i1 %tobool27.i, label %while.cond.while.end_crit_edge.i, label %while.body.i

while.cond.while.end_crit_edge.i:                 ; preds = %while.body.i
  %phitmp.i = mul i32 %xor.i, 9
  br label %while.end.i

while.end.i:                                      ; preds = %while.cond.while.end_crit_edge.i, %land.end.i
  %hash_PeRlHaSh.0.lcssa.i = phi i32 [ %phitmp.i, %while.cond.while.end_crit_edge.i ], [ 0, %land.end.i ]
  %shr32.i = lshr i32 %hash_PeRlHaSh.0.lcssa.i, 11
  %xor33.i = xor i32 %shr32.i, %hash_PeRlHaSh.0.lcssa.i
  %add35.i = mul i32 %xor33.i, 32769
  %conv36.i = zext i32 %add35.i to i64
  %xuv_uv.i = getelementptr inbounds i8* %44, i64 24
  %49 = bitcast i8* %xuv_uv.i to i64*
  store i64 %conv36.i, i64* %49, align 8, !tbaa !5
  %call38.i = tail call %struct.op* @Perl_list(%struct.op* %call14.i) #7
  %call39.i = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call1.i, %struct.op* %call38.i) #7
  %call40.i = tail call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %call15.i) #7
  %call41.i = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call39.i, %struct.op* %call40.i) #7
  %call42.i = tail call %struct.op* @Perl_convert(i32 166, i32 193, %struct.op* %call41.i) #7
  %op_private.i = getelementptr inbounds %struct.op* %call42.i, i64 0, i32 7
  %50 = load i8* %op_private.i, align 1, !tbaa !1
  %or44.i = or i8 %50, 64
  store i8 %or44.i, i8* %op_private.i, align 1, !tbaa !1
  %51 = load %struct.op** %imopsp, align 8, !tbaa !3
  %call46.i = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %51, %struct.op* %call42.i) #7
  store %struct.op* %call46.i, %struct.op** %imopsp, align 8, !tbaa !3
  br label %if.end119

if.end119:                                        ; preds = %if.then3, %for.body, %while.end.i, %if.else95
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %52 = load i8* %op_flags, align 1, !tbaa !1
  %or121 = or i8 %52, 32
  store i8 %or121, i8* %op_flags, align 1, !tbaa !1
  %op_private123 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %53 = load i8* %op_private123, align 1, !tbaa !1
  %or125 = or i8 %53, -128
  store i8 %or125, i8* %op_private123, align 1, !tbaa !1
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end119, %cond.end88, %if.end63
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_append_list(i32 %type, %struct.listop* %first, %struct.listop* %last) #0 {
entry:
  %tobool = icmp eq %struct.listop* %first, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.listop* %last to %struct.op*
  br label %return

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.listop* %last, null
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %1 = bitcast %struct.listop* %first to %struct.op*
  br label %return

if.end3:                                          ; preds = %if.end
  %op_type = getelementptr inbounds %struct.listop* %first, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, %type
  br i1 %cmp, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end3
  %3 = bitcast %struct.listop* %first to %struct.op*
  %4 = bitcast %struct.listop* %last to %struct.op*
  %call = tail call %struct.op* @Perl_prepend_elem(i32 %type, %struct.op* %3, %struct.op* %4) #8
  br label %return

if.end6:                                          ; preds = %if.end3
  %op_type7 = getelementptr inbounds %struct.listop* %last, i64 0, i32 4
  %5 = load i16* %op_type7, align 2, !tbaa !4
  %conv8 = zext i16 %5 to i32
  %cmp9 = icmp eq i32 %conv8, %type
  br i1 %cmp9, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end6
  %6 = bitcast %struct.listop* %first to %struct.op*
  %7 = bitcast %struct.listop* %last to %struct.op*
  %call12 = tail call %struct.op* @Perl_append_elem(i32 %type, %struct.op* %6, %struct.op* %7) #8
  br label %return

if.end13:                                         ; preds = %if.end6
  %op_first = getelementptr inbounds %struct.listop* %last, i64 0, i32 8
  %8 = load %struct.op** %op_first, align 8, !tbaa !3
  %op_last = getelementptr inbounds %struct.listop* %first, i64 0, i32 9
  %9 = load %struct.op** %op_last, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %9, i64 0, i32 1
  store %struct.op* %8, %struct.op** %op_sibling, align 8, !tbaa !3
  %op_last14 = getelementptr inbounds %struct.listop* %last, i64 0, i32 9
  %10 = load %struct.op** %op_last14, align 8, !tbaa !3
  store %struct.op* %10, %struct.op** %op_last, align 8, !tbaa !3
  %op_flags = getelementptr inbounds %struct.listop* %last, i64 0, i32 6
  %11 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %11, 4
  %op_flags17 = getelementptr inbounds %struct.listop* %first, i64 0, i32 6
  %12 = load i8* %op_flags17, align 1, !tbaa !1
  %or = or i8 %12, %and
  store i8 %or, i8* %op_flags17, align 1, !tbaa !1
  %13 = bitcast %struct.listop* %last to i8*
  tail call void @Perl_safesysfree(i8* %13) #7
  %14 = bitcast %struct.listop* %first to %struct.op*
  br label %return

return:                                           ; preds = %if.end13, %if.then11, %if.then5, %if.then2, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then5 ], [ %call12, %if.then11 ], [ %14, %if.end13 ], [ %1, %if.then2 ], [ %0, %if.then ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_my(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_my_attrs(%struct.op* %o, %struct.op* null) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_sawparens(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %or = or i8 %0, 8
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_bind_match(i32 %type, %struct.op* %left, %struct.op* %right) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %left, i64 0, i32 4
  br label %tailrecurse

tailrecurse:                                      ; preds = %if.else128, %entry
  %right.tr = phi %struct.op* [ %right, %entry ], [ %call130, %if.else128 ]
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %0, i64 0, i32 14
  %1 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %1, null
  br i1 %cmp, label %lor.lhs.false7, label %land.lhs.true

land.lhs.true:                                    ; preds = %tailrecurse
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings1, align 8, !tbaa !3
  %cmp2 = icmp eq %struct.sv* %3, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp2, label %lor.lhs.false7, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings4 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings4, align 8, !tbaa !3
  %cmp5 = icmp eq %struct.sv* %5, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp5, label %land.lhs.true15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true3
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings6 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings6, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %9, i64 3
  %10 = load i8* %arrayidx, align 1, !tbaa !1
  %and = and i8 %10, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false7, label %land.lhs.true15

lor.lhs.false7:                                   ; preds = %lor.lhs.false, %land.lhs.true, %tailrecurse
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings8 = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings8, align 8, !tbaa !3
  %cmp9 = icmp eq %struct.sv* %12, null
  br i1 %cmp9, label %land.lhs.true11, label %if.end

land.lhs.true11:                                  ; preds = %lor.lhs.false7
  %13 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and13 = and i8 %13, 1
  %tobool14 = icmp eq i8 %and13, 0
  br i1 %tobool14, label %if.end, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %lor.lhs.false, %land.lhs.true11, %land.lhs.true3
  %14 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %14, label %if.end [
    i16 125, label %if.then
    i16 134, label %if.then
    i16 10, label %if.then
    i16 11, label %if.then
  ]

if.then:                                          ; preds = %land.lhs.true15, %land.lhs.true15, %land.lhs.true15, %land.lhs.true15
  %op_type34 = getelementptr inbounds %struct.op* %right.tr, i64 0, i32 4
  %15 = load i16* %op_type34, align 2, !tbaa !4
  switch i16 %15, label %cond.end [
    i16 33, label %cond.true
    i16 35, label %cond.true
  ]

cond.true:                                        ; preds = %if.then, %if.then
  %phitmp = zext i16 %15 to i64
  br label %cond.end

cond.end:                                         ; preds = %if.then, %cond.true
  %cond = phi i64 [ %phitmp, %cond.true ], [ 31, %if.then ]
  %arrayidx45 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %cond
  %16 = load i8** %arrayidx45, align 8, !tbaa !3
  %cmp48 = icmp eq i16 %14, 125
  br i1 %cmp48, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %cmp52 = icmp eq i16 %14, 10
  %phitmp163 = select i1 %cmp52, i8* getelementptr inbounds ([7 x i8]* @.str24, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8]* @.str25, i64 0, i64 0)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %17 = phi i8* [ getelementptr inbounds ([7 x i8]* @.str24, i64 0, i64 0), %cond.end ], [ %phitmp163, %lor.rhs ]
  tail call void (i32, i8*, ...)* @Perl_warner(i32 12, i8* getelementptr inbounds ([41 x i8]* @.str26, i64 0, i64 0), i8* %16, i8* %17, i8* %17) #7
  br label %if.end

if.end:                                           ; preds = %land.lhs.true15, %land.lhs.true11, %lor.end, %lor.lhs.false7
  %op_type55 = getelementptr inbounds %struct.op* %right.tr, i64 0, i32 4
  %18 = load i16* %op_type55, align 2, !tbaa !4
  %cmp57 = icmp eq i16 %18, 5
  br i1 %cmp57, label %land.lhs.true59, label %if.end69

land.lhs.true59:                                  ; preds = %if.end
  %19 = getelementptr inbounds %struct.op* %right.tr, i64 0, i32 7
  %20 = load i8* %19, align 1, !tbaa !1
  %21 = and i8 %20, 72
  %22 = icmp eq i8 %21, 72
  br i1 %22, label %if.then68, label %if.end69

if.then68:                                        ; preds = %land.lhs.true59
  %op_sv.i = getelementptr inbounds %struct.op* %right.tr, i64 1
  %23 = bitcast %struct.op* %op_sv.i to %struct.sv**
  %24 = load %struct.sv** %23, align 8, !tbaa !3
  %call.i = tail call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([53 x i8]* @.str155, i64 0, i64 0), %struct.sv* %24) #7
  tail call void @Perl_qerror(%struct.sv* %call.i) #7
  br label %if.end69

if.end69:                                         ; preds = %land.lhs.true59, %if.then68, %if.end
  %op_flags = getelementptr inbounds %struct.op* %right.tr, i64 0, i32 6
  %25 = load i8* %op_flags, align 1, !tbaa !1
  %and71 = and i8 %25, 64
  %tobool72 = icmp eq i8 %and71, 0
  br i1 %tobool72, label %land.lhs.true73, label %if.else128

land.lhs.true73:                                  ; preds = %if.end69
  %26 = load i16* %op_type55, align 2, !tbaa !4
  switch i16 %26, label %if.else128 [
    i16 31, label %if.then88
    i16 33, label %if.then88
    i16 35, label %if.then88
  ]

if.then88:                                        ; preds = %land.lhs.true73, %land.lhs.true73, %land.lhs.true73
  %or = or i8 %25, 64
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  switch i16 %26, label %if.end109 [
    i16 31, label %if.else
    i16 35, label %land.lhs.true101
  ]

land.lhs.true101:                                 ; preds = %if.then88
  %op_private102 = getelementptr inbounds %struct.op* %right.tr, i64 0, i32 7
  %27 = load i8* %op_private102, align 1, !tbaa !1
  %and104 = and i8 %27, 4
  %tobool105 = icmp eq i8 %and104, 0
  br i1 %tobool105, label %if.end109, label %if.then114

if.end109:                                        ; preds = %land.lhs.true101, %if.then88
  %conv108 = zext i16 %26 to i32
  %call = tail call %struct.op* @Perl_mod(%struct.op* %left, i32 %conv108) #8
  %.pr.pre = load i16* %op_type55, align 2, !tbaa !4
  %cmp112 = icmp eq i16 %.pr.pre, 35
  br i1 %cmp112, label %if.then114, label %if.else

if.then114:                                       ; preds = %land.lhs.true101, %if.end109
  %left.addr.0.ph169 = phi %struct.op* [ %call, %if.end109 ], [ %left, %land.lhs.true101 ]
  %call115 = tail call %struct.op* @Perl_scalar(%struct.op* %left.addr.0.ph169) #8
  %call116 = tail call %struct.op* @Perl_newBINOP(i32 0, i32 64, %struct.op* %call115, %struct.op* %right.tr) #8
  br label %if.end121

if.else:                                          ; preds = %if.then88, %if.end109
  %left.addr.0166 = phi %struct.op* [ %call, %if.end109 ], [ %left, %if.then88 ]
  %28 = phi i16 [ %.pr.pre, %if.end109 ], [ 31, %if.then88 ]
  %conv111 = zext i16 %28 to i32
  %call119 = tail call %struct.op* @Perl_scalar(%struct.op* %left.addr.0166) #8
  %call120 = tail call %struct.op* @Perl_prepend_elem(i32 %conv111, %struct.op* %call119, %struct.op* %right.tr) #8
  br label %if.end121

if.end121:                                        ; preds = %if.else, %if.then114
  %o.0 = phi %struct.op* [ %call116, %if.then114 ], [ %call120, %if.else ]
  %cmp122 = icmp eq i32 %type, 96
  br i1 %cmp122, label %if.then124, label %return

if.then124:                                       ; preds = %if.end121
  %call125 = tail call %struct.op* @Perl_scalar(%struct.op* %o.0) #8
  %call126 = tail call %struct.op* @Perl_newUNOP(i32 96, i32 0, %struct.op* %call125) #8
  br label %return

if.else128:                                       ; preds = %land.lhs.true73, %if.end69
  %call129 = tail call %struct.op* @Perl_newPMOP(i32 31, i32 0) #8
  %call130 = tail call %struct.op* @Perl_pmruntime(%struct.op* %call129, %struct.op* %right.tr, %struct.op* null) #8
  br label %tailrecurse

return:                                           ; preds = %if.end121, %if.then124
  %retval.0 = phi %struct.op* [ %call126, %if.then124 ], [ %o.0, %if.end121 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newBINOP(i32 %type, i32 %flags, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call %struct.op* @Perl_newOP(i32 0, i32 0) #8
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %first.addr.0 = phi %struct.op* [ %first, %entry ], [ %call1, %if.then ]
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !3
  %op_first = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first.addr.0, %struct.op** %3, align 8, !tbaa !3
  %or = or i32 %flags, 4
  %conv2 = trunc i32 %or to i8
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv2, i8* %4, align 1, !tbaa !1
  %tobool3 = icmp eq %struct.op* %last, null
  %shr58 = lshr i32 %flags, 8
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %or5 = or i32 %shr58, 1
  %conv6 = trunc i32 %or5 to i8
  %5 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv6, i8* %5, align 1, !tbaa !1
  br label %if.end11

if.else:                                          ; preds = %if.end
  %or8 = or i32 %shr58, 2
  %conv9 = trunc i32 %or8 to i8
  %6 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv9, i8* %6, align 1, !tbaa !1
  %op_sibling = getelementptr inbounds %struct.op* %first.addr.0, i64 0, i32 1
  store %struct.op* %last, %struct.op** %op_sibling, align 8, !tbaa !3
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then4
  %7 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool12 = icmp eq i8* %7, null
  br i1 %tobool12, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end11
  %arrayidx14 = getelementptr inbounds i8* %7, i64 %idxprom
  %8 = load i8* %arrayidx14, align 1, !tbaa !1
  %tobool16 = icmp eq i8 %8, 0
  br i1 %tobool16, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %9 = bitcast i8* %call to %struct.op*
  tail call void @Perl_op_free(%struct.op* %9) #8
  %arrayidx18 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %10 = load i8** %arrayidx18, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %10) #7
  unreachable

cond.false:                                       ; preds = %land.lhs.true, %if.end11
  %arrayidx20 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %11 = load %struct.op* (%struct.op*)** %arrayidx20, align 8, !tbaa !3
  %12 = bitcast i8* %call to %struct.op*
  %call21 = tail call %struct.op* %11(%struct.op* %12) #7
  %op_next = getelementptr inbounds %struct.op* %call21, i64 0, i32 0
  %13 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool22 = icmp eq %struct.op* %13, null
  br i1 %tobool22, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %cond.false
  %14 = getelementptr inbounds %struct.op* %call21, i64 0, i32 4
  %15 = load i16* %14, align 2, !tbaa !4
  %cmp = icmp eq i16 %15, %conv
  br i1 %cmp, label %if.end29, label %return

if.end29:                                         ; preds = %lor.lhs.false
  %16 = getelementptr inbounds %struct.op* %call21, i64 1, i32 0
  %17 = load %struct.op** %16, align 8, !tbaa !3
  %op_sibling31 = getelementptr inbounds %struct.op* %17, i64 0, i32 1
  %18 = load %struct.op** %op_sibling31, align 8, !tbaa !3
  %19 = getelementptr inbounds %struct.op* %call21, i64 1, i32 1
  store %struct.op* %18, %struct.op** %19, align 8, !tbaa !3
  %call32 = tail call %struct.op* @Perl_fold_constants(%struct.op* %call21) #8
  br label %return

return:                                           ; preds = %cond.false, %lor.lhs.false, %if.end29
  %retval.0 = phi %struct.op* [ %call32, %if.end29 ], [ %call21, %lor.lhs.false ], [ %call21, %cond.false ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newUNOP(i32 %type, i32 %flags, %struct.op* %first) #0 {
entry:
  %tobool = icmp eq %struct.op* %first, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_newOP(i32 1, i32 0) #8
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %first.addr.0 = phi %struct.op* [ %first, %entry ], [ %call, %if.then ]
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %0 = load i32* %arrayidx, align 4, !tbaa !0
  %and = and i32 %0, 1
  %tobool1 = icmp eq i32 %and, 0
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call3 = tail call %struct.op* @Perl_force_list(%struct.op* %first.addr.0) #8
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then2
  %first.addr.1 = phi %struct.op* [ %call3, %if.then2 ], [ %first.addr.0, %if.end ]
  %call5 = tail call i8* @Perl_safesysmalloc(i64 48) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call5, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call5, i64 32
  %1 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %1, align 2, !tbaa !4
  %arrayidx7 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %2 = load %struct.op* ()** %arrayidx7, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call5, i64 16
  %3 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !3
  %op_first = getelementptr inbounds i8* %call5, i64 40
  %4 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first.addr.1, %struct.op** %4, align 8, !tbaa !3
  %or = or i32 %flags, 4
  %conv8 = trunc i32 %or to i8
  %5 = getelementptr inbounds i8* %call5, i64 36
  store i8 %conv8, i8* %5, align 1, !tbaa !1
  %shr42 = lshr i32 %flags, 8
  %or9 = or i32 %shr42, 1
  %conv10 = trunc i32 %or9 to i8
  %6 = getelementptr inbounds i8* %call5, i64 37
  store i8 %conv10, i8* %6, align 1, !tbaa !1
  %7 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool11 = icmp eq i8* %7, null
  br i1 %tobool11, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %arrayidx13 = getelementptr inbounds i8* %7, i64 %idxprom
  %8 = load i8* %arrayidx13, align 1, !tbaa !1
  %tobool15 = icmp eq i8 %8, 0
  br i1 %tobool15, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %9 = bitcast i8* %call5 to %struct.op*
  tail call void @Perl_op_free(%struct.op* %9) #8
  %arrayidx17 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %10 = load i8** %arrayidx17, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %10) #7
  unreachable

cond.false:                                       ; preds = %land.lhs.true, %if.end4
  %arrayidx19 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %11 = load %struct.op* (%struct.op*)** %arrayidx19, align 8, !tbaa !3
  %12 = bitcast i8* %call5 to %struct.op*
  %call20 = tail call %struct.op* %11(%struct.op* %12) #7
  %op_next = getelementptr inbounds %struct.op* %call20, i64 0, i32 0
  %13 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool21 = icmp eq %struct.op* %13, null
  br i1 %tobool21, label %if.end23, label %return

if.end23:                                         ; preds = %cond.false
  %call24 = tail call %struct.op* @Perl_fold_constants(%struct.op* %call20) #8
  br label %return

return:                                           ; preds = %cond.false, %if.end23
  %retval.0 = phi %struct.op* [ %call24, %if.end23 ], [ %call20, %cond.false ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pmruntime(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #0 {
entry:
  %plen = alloca i64, align 8
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 35
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.op* @Perl_pmtrans(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32* @PL_hints, align 4, !tbaa !0
  %or = or i32 %1, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  %2 = bitcast %struct.op* %o to %struct.pmop*
  %op_type2 = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %3 = load i16* %op_type2, align 2, !tbaa !4
  %cmp4 = icmp eq i16 %3, 5
  br i1 %cmp4, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %op_sv = getelementptr inbounds %struct.op* %expr, i64 1
  %4 = bitcast %struct.op* %op_sv to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %6, 262144
  %cmp7 = icmp eq i32 %and, 0
  br i1 %cmp7, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then6
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %8 = bitcast i8* %xpv_cur to i64*
  %9 = load i64* %8, align 8, !tbaa !5
  store i64 %9, i64* %plen, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %7 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then6
  %call10 = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %plen, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %10, %cond.true ], [ %call10, %cond.false ]
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %11 = load i8* %op_flags, align 1, !tbaa !1
  %tobool = icmp slt i8 %11, 0
  br i1 %tobool, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %cond.end
  %12 = load i8* %cond, align 1, !tbaa !1
  %cmp14 = icmp eq i8 %12, 32
  br i1 %cmp14, label %land.lhs.true16, label %if.end35

land.lhs.true16:                                  ; preds = %land.lhs.true
  %arrayidx = getelementptr inbounds i8* %cond, i64 1
  %13 = load i8* %arrayidx, align 1, !tbaa !1
  %cmp18 = icmp eq i8 %13, 0
  br i1 %cmp18, label %if.then20, label %if.end35

if.then20:                                        ; preds = %land.lhs.true16
  call void @Perl_sv_setpvn(%struct.sv* %5, i8* getelementptr inbounds ([4 x i8]* @.str42, i64 0, i64 0), i64 3) #7
  %14 = load i32* %sv_flags, align 4, !tbaa !0
  %and22 = and i32 %14, 262144
  %cmp23 = icmp eq i32 %and22, 0
  br i1 %cmp23, label %cond.false30, label %cond.true25

cond.true25:                                      ; preds = %if.then20
  %sv_any26 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %15 = load i8** %sv_any26, align 8, !tbaa !3
  %xpv_cur27 = getelementptr inbounds i8* %15, i64 8
  %16 = bitcast i8* %xpv_cur27 to i64*
  %17 = load i64* %16, align 8, !tbaa !5
  store i64 %17, i64* %plen, align 8, !tbaa !5
  %xpv_pv29 = bitcast i8* %15 to i8**
  %18 = load i8** %xpv_pv29, align 8, !tbaa !3
  br label %cond.end32

cond.false30:                                     ; preds = %if.then20
  %call31 = call i8* @Perl_sv_2pv_flags(%struct.sv* %5, i64* %plen, i32 2) #7
  br label %cond.end32

cond.end32:                                       ; preds = %cond.false30, %cond.true25
  %cond33 = phi i8* [ %18, %cond.true25 ], [ %call31, %cond.false30 ]
  %op_pmflags = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %19 = bitcast %struct.op** %op_pmflags to i32*
  %20 = load i32* %19, align 4, !tbaa !0
  %or34 = or i32 %20, 16
  store i32 %or34, i32* %19, align 4, !tbaa !0
  br label %if.end35

if.end35:                                         ; preds = %land.lhs.true16, %land.lhs.true, %cond.end, %cond.end32
  %p.0 = phi i8* [ %cond33, %cond.end32 ], [ %cond, %cond.end ], [ %cond, %land.lhs.true ], [ %cond, %land.lhs.true16 ]
  %21 = load i32* %sv_flags, align 4, !tbaa !0
  %and37 = and i32 %21, 536870912
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %if.end47, label %land.lhs.true39

land.lhs.true39:                                  ; preds = %if.end35
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %op_private = getelementptr inbounds %struct.cop* %22, i64 0, i32 7
  %23 = load i8* %op_private, align 1, !tbaa !1
  %and41 = and i8 %23, 8
  %tobool42 = icmp eq i8 %and41, 0
  br i1 %tobool42, label %if.then43, label %if.end47

if.then43:                                        ; preds = %land.lhs.true39
  %op_pmdynflags = getelementptr inbounds %struct.op* %o, i64 2, i32 2
  %24 = bitcast %struct.op* ()** %op_pmdynflags to i8*
  %25 = load i8* %24, align 1, !tbaa !1
  %or45 = or i8 %25, 4
  store i8 %or45, i8* %24, align 1, !tbaa !1
  br label %if.end47

if.end47:                                         ; preds = %land.lhs.true39, %if.end35, %if.then43
  %26 = load %struct.regexp* (i8*, i8*, %struct.pmop*)** @PL_regcompp, align 8, !tbaa !3
  %27 = load i64* %plen, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds i8* %p.0, i64 %27
  %call48 = call %struct.regexp* %26(i8* %p.0, i8* %add.ptr, %struct.pmop* %2) #7
  %28 = getelementptr inbounds %struct.op* %o, i64 2, i32 0
  %call48.c = bitcast %struct.regexp* %call48 to %struct.op*
  store %struct.op* %call48.c, %struct.op** %28, align 8, !tbaa !3
  %precomp = getelementptr inbounds %struct.regexp* %call48, i64 0, i32 4
  %29 = load i8** %precomp, align 8, !tbaa !3
  %call50 = call i32 @strcmp(i8* getelementptr inbounds ([4 x i8]* @.str42, i64 0, i64 0), i8* %29) #7
  %tobool51 = icmp eq i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.end55

if.then52:                                        ; preds = %if.end47
  %op_pmflags53 = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %30 = bitcast %struct.op** %op_pmflags53 to i32*
  %31 = load i32* %30, align 4, !tbaa !0
  %or54 = or i32 %31, 32
  store i32 %or54, i32* %30, align 4, !tbaa !0
  br label %if.end55

if.end55:                                         ; preds = %if.end47, %if.then52
  call void @Perl_op_free(%struct.op* %expr) #8
  br label %if.end111

if.else:                                          ; preds = %if.end
  %op_pmflags56 = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %32 = bitcast %struct.op** %op_pmflags56 to i32*
  %33 = load i32* %32, align 4, !tbaa !0
  %and57 = and i32 %33, 128
  %tobool58 = icmp eq i32 %and57, 0
  br i1 %tobool58, label %lor.lhs.false, label %if.then61

lor.lhs.false:                                    ; preds = %if.else
  %and59 = and i32 %1, 2097152
  %tobool60 = icmp eq i32 %and59, 0
  br i1 %tobool60, label %if.then61, label %if.end66

if.then61:                                        ; preds = %lor.lhs.false, %if.else
  %and62 = lshr i32 %1, 21
  %34 = and i32 %and62, 1
  %35 = xor i32 %34, 29
  %call65 = call %struct.op* @Perl_newUNOP(i32 %35, i32 0, %struct.op* %expr) #8
  br label %if.end66

if.end66:                                         ; preds = %lor.lhs.false, %if.then61
  %expr.addr.0 = phi %struct.op* [ %call65, %if.then61 ], [ %expr, %lor.lhs.false ]
  %call67 = call i8* @Perl_safesysmalloc(i64 56) #7
  call void @llvm.memset.p0i8.i64(i8* %call67, i8 0, i64 56, i32 1, i1 false)
  %op_type68 = getelementptr inbounds i8* %call67, i64 32
  %36 = bitcast i8* %op_type68 to i16*
  store i16 30, i16* %36, align 2, !tbaa !4
  %37 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 30), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call67, i64 16
  %38 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %37, %struct.op* ()** %38, align 8, !tbaa !3
  %call69 = call %struct.op* @Perl_scalar(%struct.op* %expr.addr.0) #8
  %op_first = getelementptr inbounds i8* %call67, i64 40
  %39 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %call69, %struct.op** %39, align 8, !tbaa !3
  %40 = load i32* @PL_hints, align 4, !tbaa !0
  %and70 = lshr i32 %40, 14
  %41 = and i32 %and70, 128
  %42 = getelementptr inbounds i8* %call67, i64 36
  %43 = load i8* %42, align 1, !tbaa !1
  %conv74 = zext i8 %43 to i32
  %44 = or i32 %41, %conv74
  %or75 = or i32 %44, 4
  %conv76 = trunc i32 %or75 to i8
  store i8 %conv76, i8* %42, align 1, !tbaa !1
  %45 = getelementptr inbounds i8* %call67, i64 37
  store i8 1, i8* %45, align 1, !tbaa !1
  %op_other = getelementptr inbounds i8* %call67, i64 48
  %46 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %o, %struct.op** %46, align 8, !tbaa !3
  %47 = load i32* %32, align 4, !tbaa !0
  %and79 = and i32 %47, 128
  %tobool80 = icmp eq i32 %and79, 0
  br i1 %tobool80, label %lor.lhs.false81, label %if.then84

lor.lhs.false81:                                  ; preds = %if.end66
  %48 = load i32* @PL_hints, align 4, !tbaa !0
  %and82 = and i32 %48, 2097152
  %tobool83 = icmp eq i32 %and82, 0
  br i1 %tobool83, label %if.then84, label %if.else95

if.then84:                                        ; preds = %lor.lhs.false81, %if.end66
  %op_next = getelementptr inbounds %struct.op* %expr.addr.0, i64 0, i32 0
  %49 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool85 = icmp eq %struct.op* %49, null
  br i1 %tobool85, label %cond.false88, label %cond.end90

cond.false88:                                     ; preds = %if.then84
  %call89 = call %struct.op* @Perl_linklist(%struct.op* %expr.addr.0) #8
  br label %cond.end90

cond.end90:                                       ; preds = %if.then84, %cond.false88
  %op_next92 = bitcast i8* %call67 to %struct.op**
  store %struct.op* %expr.addr.0, %struct.op** %op_next92, align 8, !tbaa !3
  %50 = bitcast i8* %call67 to %struct.op*
  %51 = getelementptr inbounds %struct.op* %expr.addr.0, i64 1, i32 0
  %52 = load %struct.op** %51, align 8, !tbaa !3
  %op_next94 = getelementptr inbounds %struct.op* %52, i64 0, i32 0
  store %struct.op* %50, %struct.op** %op_next94, align 8, !tbaa !3
  br label %if.end106

if.else95:                                        ; preds = %lor.lhs.false81
  %op_next96 = getelementptr inbounds %struct.op* %expr.addr.0, i64 0, i32 0
  %53 = load %struct.op** %op_next96, align 8, !tbaa !3
  %tobool97 = icmp eq %struct.op* %53, null
  br i1 %tobool97, label %cond.false100, label %cond.end102

cond.false100:                                    ; preds = %if.else95
  %call101 = call %struct.op* @Perl_linklist(%struct.op* %expr.addr.0) #8
  br label %cond.end102

cond.end102:                                      ; preds = %if.else95, %cond.false100
  %cond103 = phi %struct.op* [ %call101, %cond.false100 ], [ %53, %if.else95 ]
  %op_next104 = bitcast i8* %call67 to %struct.op**
  store %struct.op* %cond103, %struct.op** %op_next104, align 8, !tbaa !3
  %54 = bitcast i8* %call67 to %struct.op*
  store %struct.op* %54, %struct.op** %op_next96, align 8, !tbaa !3
  br label %if.end106

if.end106:                                        ; preds = %cond.end102, %cond.end90
  %55 = load i16* %op_type, align 2, !tbaa !4
  %conv108 = zext i16 %55 to i32
  %56 = bitcast i8* %call67 to %struct.op*
  %call109 = call %struct.op* @Perl_scalar(%struct.op* %56) #8
  %call110 = call %struct.op* @Perl_prepend_elem(i32 %conv108, %struct.op* %call109, %struct.op* %o) #8
  br label %if.end111

if.end111:                                        ; preds = %if.end106, %if.end55
  %tobool112 = icmp eq %struct.op* %repl, null
  br i1 %tobool112, label %return, label %if.then113

if.then113:                                       ; preds = %if.end111
  %op_pmflags114 = getelementptr inbounds %struct.op* %o, i64 2, i32 1
  %57 = bitcast %struct.op** %op_pmflags114 to i32*
  %58 = load i32* %57, align 4, !tbaa !0
  %and115 = and i32 %58, 1024
  %tobool116 = icmp eq i32 %and115, 0
  br i1 %tobool116, label %if.else123, label %if.then117

if.then117:                                       ; preds = %if.then113
  %59 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %59, i64 0, i32 13
  %60 = load i32* %cop_line, align 4, !tbaa !0
  %61 = load i32* @PL_multi_end, align 4, !tbaa !0
  %cmp118 = icmp ult i32 %60, %61
  br i1 %cmp118, label %if.then120, label %if.end244

if.then120:                                       ; preds = %if.then117
  %62 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line121 = getelementptr inbounds %struct.cop* %62, i64 0, i32 13
  store i32 %61, i32* %cop_line121, align 4, !tbaa !0
  br label %if.end244

if.else123:                                       ; preds = %if.then113
  %op_type124 = getelementptr inbounds %struct.op* %repl, i64 0, i32 4
  %63 = load i16* %op_type124, align 2, !tbaa !4
  %cmp126 = icmp eq i16 %63, 5
  br i1 %cmp126, label %if.then256, label %if.else129

if.else129:                                       ; preds = %if.else123
  %op_next130 = getelementptr inbounds %struct.op* %repl, i64 0, i32 0
  %64 = load %struct.op** %op_next130, align 8, !tbaa !3
  %tobool131 = icmp eq %struct.op* %64, null
  br i1 %tobool131, label %cond.false134, label %for.cond.preheader

cond.false134:                                    ; preds = %if.else129
  %call135 = call %struct.op* @Perl_linklist(%struct.op* %repl) #8
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else129, %cond.false134
  %curop.0.ph = phi %struct.op* [ %call135, %cond.false134 ], [ %64, %if.else129 ]
  %cmp138418 = icmp eq %struct.op* %curop.0.ph, %repl
  br i1 %cmp138418, label %if.then256, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.cond.backedge
  %lastop.0421 = phi %struct.op* [ %curop.0420, %for.cond.backedge ], [ null, %for.cond.preheader ]
  %curop.0420 = phi %struct.op* [ %curop.0.be, %for.cond.backedge ], [ %curop.0.ph, %for.cond.preheader ]
  %repl_has_vars.0419 = phi i32 [ %repl_has_vars.1, %for.cond.backedge ], [ 0, %for.cond.preheader ]
  %op_type140 = getelementptr inbounds %struct.op* %curop.0420, i64 0, i32 4
  %65 = load i16* %op_type140, align 2, !tbaa !4
  %idxprom = zext i16 %65 to i64
  %arrayidx141 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %66 = load i32* %arrayidx141, align 4, !tbaa !0
  %and142 = and i32 %66, 64
  %tobool143 = icmp eq i32 %and142, 0
  br i1 %tobool143, label %if.end234, label %if.then144

if.then144:                                       ; preds = %for.body
  switch i16 %65, label %if.else222 [
    i16 7, label %if.then149
    i16 17, label %if.end244
    i16 15, label %if.then192
    i16 125, label %if.then192
    i16 134, label %if.then192
    i16 14, label %if.then192
    i16 9, label %if.end234
    i16 10, label %if.end234
    i16 11, label %if.end234
    i16 12, label %if.end234
  ]

if.then149:                                       ; preds = %if.then144
  %op_sv150 = getelementptr inbounds %struct.op* %curop.0420, i64 1
  %67 = bitcast %struct.op* %op_sv150 to %struct.sv**
  %68 = load %struct.sv** %67, align 8, !tbaa !3
  %69 = bitcast %struct.sv* %68 to %struct.gv*
  %sv_any151 = bitcast %struct.sv* %68 to %struct.xpvgv**
  %70 = load %struct.xpvgv** %sv_any151, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %70, i64 0, i32 7
  %71 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_egv = getelementptr inbounds %struct.gp* %71, i64 0, i32 6
  %72 = load %struct.gv** %gp_egv, align 8, !tbaa !3
  %tobool152 = icmp eq %struct.gv* %72, null
  %. = select i1 %tobool152, %struct.gv* %69, %struct.gv* %72
  %sv_any160 = getelementptr inbounds %struct.gv* %., i64 0, i32 0
  %73 = load %struct.xpvgv** %sv_any160, align 8, !tbaa !3
  %xgv_name = getelementptr inbounds %struct.xpvgv* %73, i64 0, i32 8
  %74 = load i8** %xgv_name, align 8, !tbaa !3
  %75 = load i8* %74, align 1, !tbaa !1
  %conv161 = sext i8 %75 to i32
  %memchr = call i8* @memchr(i8* getelementptr inbounds ([17 x i8]* @.str43, i64 0, i64 0), i32 %conv161, i64 17)
  %tobool163 = icmp eq i8* %memchr, null
  br i1 %tobool163, label %if.end234, label %if.end244

if.then192:                                       ; preds = %if.then144, %if.then144, %if.then144, %if.then144
  %tobool193 = icmp eq %struct.op* %lastop.0421, null
  br i1 %tobool193, label %if.end234, label %land.lhs.true194

land.lhs.true194:                                 ; preds = %if.then192
  %op_type195 = getelementptr inbounds %struct.op* %lastop.0421, i64 0, i32 4
  %76 = load i16* %op_type195, align 2, !tbaa !4
  %cmp197 = icmp eq i16 %76, 7
  br i1 %cmp197, label %if.end234, label %if.end244

if.else222:                                       ; preds = %if.then144
  %cmp225 = icmp eq i16 %65, 13
  br i1 %cmp225, label %if.end234, label %if.end244

if.end234:                                        ; preds = %if.then144, %if.then144, %if.then144, %if.then144, %if.then149, %land.lhs.true194, %if.then192, %for.body, %if.else222
  %repl_has_vars.1 = phi i32 [ 1, %if.then149 ], [ %repl_has_vars.0419, %land.lhs.true194 ], [ %repl_has_vars.0419, %if.then192 ], [ %repl_has_vars.0419, %if.else222 ], [ %repl_has_vars.0419, %for.body ], [ 1, %if.then144 ], [ 1, %if.then144 ], [ 1, %if.then144 ], [ 1, %if.then144 ]
  %op_next235 = getelementptr inbounds %struct.op* %curop.0420, i64 0, i32 0
  %77 = load %struct.op** %op_next235, align 8, !tbaa !3
  %tobool236 = icmp eq %struct.op* %77, null
  br i1 %tobool236, label %cond.false239, label %for.cond.backedge

for.cond.backedge:                                ; preds = %if.end234, %cond.false239
  %curop.0.be = phi %struct.op* [ %77, %if.end234 ], [ %call240, %cond.false239 ]
  %cmp138 = icmp eq %struct.op* %curop.0.be, %repl
  br i1 %cmp138, label %land.lhs.true247, label %for.body

cond.false239:                                    ; preds = %if.end234
  %call240 = call %struct.op* @Perl_linklist(%struct.op* %curop.0420) #8
  br label %for.cond.backedge

if.end244:                                        ; preds = %if.then144, %if.then149, %land.lhs.true194, %if.else222, %if.then117, %if.then120
  %repl_has_vars.2 = phi i32 [ 0, %if.then120 ], [ 0, %if.then117 ], [ %repl_has_vars.0419, %if.else222 ], [ %repl_has_vars.0419, %land.lhs.true194 ], [ 1, %if.then149 ], [ %repl_has_vars.0419, %if.then144 ]
  %curop.1 = phi %struct.op* [ null, %if.then120 ], [ null, %if.then117 ], [ %curop.0420, %if.else222 ], [ %curop.0420, %land.lhs.true194 ], [ %curop.0420, %if.then149 ], [ %curop.0420, %if.then144 ]
  %cmp245 = icmp eq %struct.op* %curop.1, %repl
  br i1 %cmp245, label %land.lhs.true247, label %if.end275

land.lhs.true247:                                 ; preds = %for.cond.backedge, %if.end244
  %repl_has_vars.2425 = phi i32 [ %repl_has_vars.2, %if.end244 ], [ %repl_has_vars.1, %for.cond.backedge ]
  %tobool248 = icmp eq i32 %repl_has_vars.2425, 0
  br i1 %tobool248, label %if.then256, label %land.lhs.true249

land.lhs.true249:                                 ; preds = %land.lhs.true247
  %op_pmregexp250 = getelementptr inbounds %struct.op* %o, i64 2
  %78 = bitcast %struct.op* %op_pmregexp250 to %struct.regexp**
  %79 = load %struct.regexp** %78, align 8, !tbaa !3
  %tobool251 = icmp eq %struct.regexp* %79, null
  br i1 %tobool251, label %if.then270, label %lor.lhs.false252

lor.lhs.false252:                                 ; preds = %land.lhs.true249
  %reganch = getelementptr inbounds %struct.regexp* %79, i64 0, i32 15
  %80 = load i32* %reganch, align 4, !tbaa !0
  %and254 = and i32 %80, 1024
  %tobool255 = icmp eq i32 %and254, 0
  br i1 %tobool255, label %if.then256, label %if.end275

if.then256:                                       ; preds = %for.cond.preheader, %lor.lhs.false252, %land.lhs.true247, %if.else123
  %81 = load i32* %57, align 4, !tbaa !0
  %or258 = or i32 %81, 64
  store i32 %or258, i32* %57, align 4, !tbaa !0
  %op_pmpermflags = getelementptr inbounds %struct.pmop* %2, i64 0, i32 15
  %82 = load i32* %op_pmpermflags, align 4, !tbaa !0
  %or259 = or i32 %82, 64
  store i32 %or259, i32* %op_pmpermflags, align 4, !tbaa !0
  %83 = load i16* %op_type, align 2, !tbaa !4
  %conv261 = zext i16 %83 to i32
  %call262 = call %struct.op* @Perl_scalar(%struct.op* %repl) #8
  %call263 = call %struct.op* @Perl_prepend_elem(i32 %conv261, %struct.op* %call262, %struct.op* %o) #8
  br label %return

if.then270:                                       ; preds = %land.lhs.true249
  %84 = load i32* %57, align 4, !tbaa !0
  %or272 = or i32 %84, 8
  store i32 %or272, i32* %57, align 4, !tbaa !0
  %op_pmpermflags273 = getelementptr inbounds %struct.pmop* %2, i64 0, i32 15
  %85 = load i32* %op_pmpermflags273, align 4, !tbaa !0
  %or274 = or i32 %85, 8
  store i32 %or274, i32* %op_pmpermflags273, align 4, !tbaa !0
  br label %if.end275

if.end275:                                        ; preds = %lor.lhs.false252, %if.end244, %if.then270
  %call276 = call i8* @Perl_safesysmalloc(i64 56) #7
  call void @llvm.memset.p0i8.i64(i8* %call276, i8 0, i64 56, i32 1, i1 false)
  %op_type277 = getelementptr inbounds i8* %call276, i64 32
  %86 = bitcast i8* %op_type277 to i16*
  store i16 34, i16* %86, align 2, !tbaa !4
  %87 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 34), align 8, !tbaa !3
  %op_ppaddr278 = getelementptr inbounds i8* %call276, i64 16
  %88 = bitcast i8* %op_ppaddr278 to %struct.op* ()**
  store %struct.op* ()* %87, %struct.op* ()** %88, align 8, !tbaa !3
  %call279 = call %struct.op* @Perl_scalar(%struct.op* %repl) #8
  %op_first280 = getelementptr inbounds i8* %call276, i64 40
  %89 = bitcast i8* %op_first280 to %struct.op**
  store %struct.op* %call279, %struct.op** %89, align 8, !tbaa !3
  %90 = getelementptr inbounds i8* %call276, i64 36
  %91 = load i8* %90, align 1, !tbaa !1
  %or283 = or i8 %91, 4
  store i8 %or283, i8* %90, align 1, !tbaa !1
  %92 = getelementptr inbounds i8* %call276, i64 37
  store i8 1, i8* %92, align 1, !tbaa !1
  %op_other286 = getelementptr inbounds i8* %call276, i64 48
  %93 = bitcast i8* %op_other286 to %struct.op**
  store %struct.op* %o, %struct.op** %93, align 8, !tbaa !3
  %op_next287 = getelementptr inbounds %struct.op* %repl, i64 0, i32 0
  %94 = load %struct.op** %op_next287, align 8, !tbaa !3
  %tobool288 = icmp eq %struct.op* %94, null
  br i1 %tobool288, label %cond.false291, label %cond.end293

cond.false291:                                    ; preds = %if.end275
  %call292 = call %struct.op* @Perl_linklist(%struct.op* %repl) #8
  br label %cond.end293

cond.end293:                                      ; preds = %if.end275, %cond.false291
  %cond294 = phi %struct.op* [ %call292, %cond.false291 ], [ %94, %if.end275 ]
  %op_next295 = bitcast i8* %call276 to %struct.op**
  store %struct.op* %cond294, %struct.op** %op_next295, align 8, !tbaa !3
  %95 = bitcast i8* %call276 to %struct.op*
  store %struct.op* %95, %struct.op** %op_next287, align 8, !tbaa !3
  %call297 = call %struct.op* @Perl_scalar(%struct.op* %95) #8
  %op_pmreplroot = getelementptr inbounds %struct.op* %o, i64 1, i32 2
  %call297.c = bitcast %struct.op* %call297 to %struct.op* ()*
  store %struct.op* ()* %call297.c, %struct.op* ()** %op_pmreplroot, align 8, !tbaa !3
  %96 = load %struct.op** %op_next295, align 8, !tbaa !3
  %tobool299 = icmp eq %struct.op* %96, null
  br i1 %tobool299, label %cond.false302, label %cond.end304

cond.false302:                                    ; preds = %cond.end293
  %call303 = call %struct.op* @Perl_linklist(%struct.op* %95) #8
  br label %cond.end304

cond.end304:                                      ; preds = %cond.end293, %cond.false302
  %cond305 = phi %struct.op* [ %call303, %cond.false302 ], [ %96, %cond.end293 ]
  %op_pmreplstart = getelementptr inbounds %struct.op* %o, i64 1, i32 3
  %cond305.c = ptrtoint %struct.op* %cond305 to i64
  store i64 %cond305.c, i64* %op_pmreplstart, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %op_next295, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %cond.end304, %if.then256, %if.end111, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %o, %if.end111 ], [ %o, %if.then256 ], [ %o, %cond.end304 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newPMOP(i32 %type, i32 %flags) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 112) #7
  %0 = bitcast i8* %call to %struct.pmop*
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 112, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %1 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %1, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %2 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %3 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %2, %struct.op* ()** %3, align 8, !tbaa !3
  %conv1 = trunc i32 %flags to i8
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %4, align 1, !tbaa !1
  %shr47 = lshr i32 %flags, 8
  %conv2 = trunc i32 %shr47 to i8
  %5 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv2, i8* %5, align 1, !tbaa !1
  %6 = load i32* @PL_hints, align 4, !tbaa !0
  %and = and i32 %6, 1048576
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %op_pmpermflags = getelementptr inbounds i8* %call, i64 92
  %7 = bitcast i8* %op_pmpermflags to i32*
  store i32 1, i32* %7, align 4, !tbaa !0
  %.pre = load i32* @PL_hints, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %8 = phi i32 [ 0, %entry ], [ 1, %if.then ]
  %9 = phi i32 [ %6, %entry ], [ %.pre, %if.then ]
  %and4 = and i32 %9, 4
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.end9, label %if.then6

if.then6:                                         ; preds = %if.end
  %op_pmpermflags7 = getelementptr inbounds i8* %call, i64 92
  %10 = bitcast i8* %op_pmpermflags7 to i32*
  %or8 = or i32 %8, 2048
  store i32 %or8, i32* %10, align 4, !tbaa !0
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then6
  %11 = phi i32 [ %or8, %if.then6 ], [ %8, %if.end ]
  %op_pmflags = getelementptr inbounds i8* %call, i64 88
  %12 = bitcast i8* %op_pmflags to i32*
  store i32 %11, i32* %12, align 4, !tbaa !0
  %cmp = icmp ne i32 %type, 35
  %13 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %tobool12 = icmp ne %struct.hv* %13, null
  %or.cond = and i1 %cmp, %tobool12
  br i1 %or.cond, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end9
  %sv_any = getelementptr inbounds %struct.hv* %13, i64 0, i32 0
  %14 = load %struct.xpvhv** %sv_any, align 8, !tbaa !3
  %xhv_pmroot = getelementptr inbounds %struct.xpvhv* %14, i64 0, i32 9
  %15 = load %struct.pmop** %xhv_pmroot, align 8, !tbaa !3
  %op_pmnext = getelementptr inbounds i8* %call, i64 72
  %16 = bitcast i8* %op_pmnext to %struct.pmop**
  store %struct.pmop* %15, %struct.pmop** %16, align 8, !tbaa !3
  %17 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %sv_any14 = getelementptr inbounds %struct.hv* %17, i64 0, i32 0
  %18 = load %struct.xpvhv** %sv_any14, align 8, !tbaa !3
  %xhv_pmroot15 = getelementptr inbounds %struct.xpvhv* %18, i64 0, i32 9
  store %struct.pmop* %0, %struct.pmop** %xhv_pmroot15, align 8, !tbaa !3
  %19 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %op_pmstash = getelementptr inbounds i8* %call, i64 104
  %20 = bitcast i8* %op_pmstash to %struct.hv**
  store %struct.hv* %19, %struct.hv** %20, align 8, !tbaa !3
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end9
  %21 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool17 = icmp eq i8* %21, null
  br i1 %tobool17, label %cond.false, label %land.lhs.true18

land.lhs.true18:                                  ; preds = %if.end16
  %arrayidx20 = getelementptr inbounds i8* %21, i64 %idxprom
  %22 = load i8* %arrayidx20, align 1, !tbaa !1
  %tobool22 = icmp eq i8 %22, 0
  br i1 %tobool22, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true18
  %23 = bitcast i8* %call to %struct.op*
  tail call void @Perl_op_free(%struct.op* %23) #8
  %arrayidx24 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %24 = load i8** %arrayidx24, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %24) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true18, %if.end16
  %arrayidx26 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %25 = load %struct.op* (%struct.op*)** %arrayidx26, align 8, !tbaa !3
  %26 = bitcast i8* %call to %struct.op*
  %call27 = tail call %struct.op* %25(%struct.op* %26) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call27, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_invert(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  %call1 = tail call %struct.op* @Perl_newUNOP(i32 96, i32 128, %struct.op* %call) #8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi %struct.op* [ %call1, %if.end ], [ null, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_scope(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end30, label %if.then

if.then:                                          ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 8
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %lor.lhs.false, label %if.then8

lor.lhs.false:                                    ; preds = %if.then
  %1 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool2 = icmp eq i32 %1, 0
  %and3 = and i32 %1, 4
  %tobool4 = icmp eq i32 %and3, 0
  %or.cond = or i1 %tobool2, %tobool4
  %2 = load i8* @PL_tainting, align 1, !tbaa !1
  %tobool7 = icmp eq i8 %2, 0
  %or.cond42 = and i1 %or.cond, %tobool7
  br i1 %or.cond42, label %if.else, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.then
  %call = tail call %struct.op* @Perl_newOP(i32 177, i32 0) #8
  %call9 = tail call %struct.op* @Perl_prepend_elem(i32 173, %struct.op* %call, %struct.op* %o) #8
  %op_type = getelementptr inbounds %struct.op* %call9, i64 0, i32 4
  store i16 178, i16* %op_type, align 2, !tbaa !4
  %3 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 178), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %call9, i64 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %if.end30

if.else:                                          ; preds = %lor.lhs.false
  %op_type10 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %4 = load i16* %op_type10, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 173
  br i1 %cmp, label %if.then13, label %if.else26

if.then13:                                        ; preds = %if.else
  store i16 179, i16* %op_type10, align 2, !tbaa !4
  %5 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 179), align 8, !tbaa !3
  %op_ppaddr15 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %5, %struct.op* ()** %op_ppaddr15, align 8, !tbaa !3
  %6 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !3
  %op_type16 = getelementptr inbounds %struct.op* %7, i64 0, i32 4
  %8 = load i16* %op_type16, align 2, !tbaa !4
  %.off = add i16 %8, -174
  %switch = icmp ult i16 %.off, 2
  br i1 %switch, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.then13
  tail call void @Perl_op_null(%struct.op* %7) #8
  br label %if.end30

if.else26:                                        ; preds = %if.else
  %call27 = tail call %struct.op* @Perl_newLISTOP(i32 179, i32 0, %struct.op* %o, %struct.op* null) #8
  br label %if.end30

if.end30:                                         ; preds = %if.then13, %entry, %if.then8, %if.then25, %if.else26
  %o.addr.0 = phi %struct.op* [ %call9, %if.then8 ], [ %o, %if.then25 ], [ %call27, %if.else26 ], [ null, %entry ], [ %o, %if.then13 ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newLISTOP(i32 %type, i32 %flags, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !3
  %tobool.not = icmp eq %struct.op* %first, null
  %tobool1 = icmp eq %struct.op* %last, null
  %or.cond = and i1 %tobool1, %tobool.not
  %or = or i32 %flags, 4
  %flags.addr.0 = select i1 %or.cond, i32 %flags, i32 %or
  %conv2 = trunc i32 %flags.addr.0 to i8
  %3 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv2, i8* %3, align 1, !tbaa !1
  %tobool3 = icmp ne %struct.op* %last, null
  %brmerge = or i1 %tobool3, %tobool.not
  br i1 %brmerge, label %if.else, label %if.end15

if.else:                                          ; preds = %entry
  %brmerge73.not = and i1 %tobool3, %tobool.not
  %last.mux = select i1 %brmerge73.not, %struct.op* %last, %struct.op* %first
  br i1 %tobool.not, label %if.end15, label %if.then12

if.then12:                                        ; preds = %if.else
  %op_sibling = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %last, %struct.op** %op_sibling, align 8, !tbaa !3
  br label %if.end15

if.end15:                                         ; preds = %if.else, %entry, %if.then12
  %last.addr.0 = phi %struct.op* [ %last, %if.then12 ], [ %first, %entry ], [ %last, %if.else ]
  %first.addr.0 = phi %struct.op* [ %first, %if.then12 ], [ %first, %entry ], [ %last.mux, %if.else ]
  %op_first = getelementptr inbounds i8* %call, i64 40
  %4 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first.addr.0, %struct.op** %4, align 8, !tbaa !3
  %op_last = getelementptr inbounds i8* %call, i64 48
  %5 = bitcast i8* %op_last to %struct.op**
  store %struct.op* %last.addr.0, %struct.op** %5, align 8, !tbaa !3
  %cmp = icmp eq i32 %type, 141
  br i1 %cmp, label %if.then17, label %if.end29

if.then17:                                        ; preds = %if.end15
  %call18 = tail call %struct.op* @Perl_newOP(i32 3, i32 0) #8
  %op_sibling19 = getelementptr inbounds %struct.op* %call18, i64 0, i32 1
  store %struct.op* %first.addr.0, %struct.op** %op_sibling19, align 8, !tbaa !3
  store %struct.op* %call18, %struct.op** %4, align 8, !tbaa !3
  %6 = load i8* %3, align 1, !tbaa !1
  %or23 = or i8 %6, 4
  store i8 %or23, i8* %3, align 1, !tbaa !1
  %tobool25 = icmp eq %struct.op* %last.addr.0, null
  br i1 %tobool25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.then17
  store %struct.op* %call18, %struct.op** %5, align 8, !tbaa !3
  br label %if.end29

if.end29:                                         ; preds = %if.then17, %if.then26, %if.end15
  %7 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool30 = icmp eq i8* %7, null
  br i1 %tobool30, label %cond.false, label %land.lhs.true31

land.lhs.true31:                                  ; preds = %if.end29
  %arrayidx33 = getelementptr inbounds i8* %7, i64 %idxprom
  %8 = load i8* %arrayidx33, align 1, !tbaa !1
  %tobool35 = icmp eq i8 %8, 0
  br i1 %tobool35, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true31
  %9 = bitcast i8* %call to %struct.op*
  tail call void @Perl_op_free(%struct.op* %9) #8
  %arrayidx37 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %10 = load i8** %arrayidx37, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %10) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true31, %if.end29
  %arrayidx39 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %11 = load %struct.op* (%struct.op*)** %arrayidx39, align 8, !tbaa !3
  %12 = bitcast i8* %call to %struct.op*
  %call40 = tail call %struct.op* %11(%struct.op* %12) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call40, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind optsize uwtable
define void @Perl_save_hints() #0 {
entry:
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([54 x i8]* @.str27, i64 0, i64 0)) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @Perl_block_start(i32 %full) #0 {
entry:
  %0 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %1 = load i32* @PL_yynerrs, align 4, !tbaa !0
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  tail call void @Perl_pad_block_start(i32 %full) #7
  %2 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %add = add nsw i32 %2, 3
  %3 = load i32* @PL_savestack_max, align 4, !tbaa !0
  %cmp = icmp sgt i32 %add, %3
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  tail call void @Perl_savestack_grow() #7
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %4 = load i32* @PL_hints, align 4, !tbaa !0
  %and = and i32 %4, 131072
  %tobool4 = icmp eq i32 %and, 0
  br i1 %tobool4, label %if.end12, label %if.then5

if.then5:                                         ; preds = %if.end3
  %5 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.gv* %5, i64 0, i32 0
  %6 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %6, i64 0, i32 7
  %7 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %7, i64 0, i32 5
  %8 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %9 = bitcast %struct.hv* %8 to i8*
  %10 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom = sext i32 %10 to i64
  %11 = load %union.any** @PL_savestack, align 8, !tbaa !3
  %any_ptr = getelementptr inbounds %union.any* %11, i64 %idxprom, i32 0
  store i8* %9, i8** %any_ptr, align 8, !tbaa !3
  %12 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any6 = getelementptr inbounds %struct.gv* %12, i64 0, i32 0
  %13 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !3
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp7, align 8, !tbaa !3
  %gp_hv8 = getelementptr inbounds %struct.gp* %14, i64 0, i32 5
  %15 = load %struct.hv** %gp_hv8, align 8, !tbaa !3
  %call = tail call %struct.hv* @Perl_newHVhv(%struct.hv* %15) #7
  %16 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any9 = getelementptr inbounds %struct.gv* %16, i64 0, i32 0
  %17 = load %struct.xpvgv** %sv_any9, align 8, !tbaa !3
  %xgv_gp10 = getelementptr inbounds %struct.xpvgv* %17, i64 0, i32 7
  %18 = load %struct.gp** %xgv_gp10, align 8, !tbaa !3
  %gp_hv11 = getelementptr inbounds %struct.gp* %18, i64 0, i32 5
  store %struct.hv* %call, %struct.hv** %gp_hv11, align 8, !tbaa !3
  %.pre = load i32* @PL_hints, align 4, !tbaa !0
  br label %if.end12

if.end12:                                         ; preds = %if.end3, %if.then5
  %19 = phi i32 [ %.pre, %if.then5 ], [ %4, %if.end3 ]
  %20 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %inc13 = add nsw i32 %20, 1
  store i32 %inc13, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom14 = sext i32 %20 to i64
  %21 = load %union.any** @PL_savestack, align 8, !tbaa !3
  %arrayidx15 = getelementptr inbounds %union.any* %21, i64 %idxprom14
  %any_i32 = bitcast %union.any* %arrayidx15 to i32*
  store i32 %19, i32* %any_i32, align 4, !tbaa !0
  %22 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %inc16 = add nsw i32 %22, 1
  store i32 %inc16, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom17 = sext i32 %22 to i64
  %arrayidx18 = getelementptr inbounds %union.any* %21, i64 %idxprom17
  %any_i3219 = bitcast %union.any* %arrayidx18 to i32*
  store i32 27, i32* %any_i3219, align 4, !tbaa !0
  %23 = load i32* @PL_hints, align 4, !tbaa !0
  %and20 = and i32 %23, -257
  store i32 %and20, i32* @PL_hints, align 4, !tbaa !0
  tail call void @Perl_save_sptr(%struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14)) #7
  %24 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !3
  %magicptr = ptrtoint %struct.sv* %24 to i64
  switch i64 %magicptr, label %if.then25 [
    i64 32, label %if.end27
    i64 16, label %if.end27
    i64 0, label %if.end27
  ]

if.then25:                                        ; preds = %if.end12
  %call26 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %24) #7
  store %struct.sv* %call26, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 14), align 8, !tbaa !3
  tail call void @Perl_save_freesv(%struct.sv* %call26) #7
  br label %if.end27

if.end27:                                         ; preds = %if.end12, %if.end12, %if.end12, %if.then25
  tail call void @Perl_save_sptr(%struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15)) #7
  %25 = load %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !3
  %cmp28 = icmp eq %struct.sv* %25, null
  br i1 %cmp28, label %return, label %if.then29

if.then29:                                        ; preds = %if.end27
  %call30 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %25) #7
  store %struct.sv* %call30, %struct.sv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 15), align 8, !tbaa !3
  tail call void @Perl_save_freesv(%struct.sv* %call30) #7
  br label %return

return:                                           ; preds = %if.end27, %if.then29, %entry
  ret i32 %0
}

; Function Attrs: optsize
declare void @Perl_pad_block_start(i32) #2

; Function Attrs: optsize
declare void @Perl_savestack_grow() #2

; Function Attrs: optsize
declare %struct.hv* @Perl_newHVhv(%struct.hv*) #2

; Function Attrs: optsize
declare void @Perl_save_sptr(%struct.sv**) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVsv(%struct.sv*) #2

; Function Attrs: optsize
declare void @Perl_save_freesv(%struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_block_end(i32 %floor, %struct.op* %seq) #0 {
entry:
  %0 = load i32* @PL_hints, align 4, !tbaa !0
  %and = and i32 %0, 256
  %call = tail call %struct.op* @Perl_scalarseq(%struct.op* %seq) #8
  %1 = load i32* @PL_yynerrs, align 4, !tbaa !0
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %2 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %cmp = icmp sgt i32 %2, %floor
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  tail call void @Perl_leave_scope(i32 %floor) #7
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %3 = load i32* @PL_hints, align 4, !tbaa !0
  %conv = trunc i32 %3 to i8
  store i8 %conv, i8* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 7), align 1, !tbaa !1
  %tobool5 = icmp eq i32 %and, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end3
  %or = or i32 %3, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  br label %if.end7

if.end7:                                          ; preds = %if.end3, %if.then6
  tail call void @Perl_pad_leavemy() #7
  br label %return

return:                                           ; preds = %entry, %if.end7
  ret %struct.op* %call
}

; Function Attrs: optsize
declare void @Perl_leave_scope(i32) #2

; Function Attrs: optsize
declare void @Perl_pad_leavemy() #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_newPROG(%struct.op* %o) #0 {
entry:
  %0 = load volatile i32* @PL_in_eval, align 4, !tbaa !0
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.op** @PL_eval_root, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %1, null
  br i1 %tobool1, label %if.end, label %if.end49

if.end:                                           ; preds = %if.then
  %2 = load volatile i32* @PL_in_eval, align 4, !tbaa !0
  %and = shl i32 %2, 5
  %3 = and i32 %and, 128
  %call = tail call %struct.op* @Perl_newUNOP(i32 312, i32 %3, %struct.op* %o) #8
  store %struct.op* %call, %struct.op** @PL_eval_root, align 8, !tbaa !3
  %call4 = tail call %struct.op* @Perl_linklist(%struct.op* %call) #8
  store %struct.op* %call4, %struct.op** @PL_eval_start, align 8, !tbaa !3
  %4 = load %struct.op** @PL_eval_root, align 8, !tbaa !3
  %op_private = getelementptr inbounds %struct.op* %4, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %5, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  %6 = load %struct.op** @PL_eval_root, align 8, !tbaa !3
  %op_targ = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  store i64 1, i64* %op_targ, align 8, !tbaa !5
  %op_next = getelementptr inbounds %struct.op* %6, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !3
  %7 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !3
  %8 = load %struct.op** @PL_eval_start, align 8, !tbaa !3
  tail call void %7(%struct.op* %8) #7
  br label %if.end49

if.else:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %9 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %9, 1
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.else
  store %struct.av* null, %struct.av** @PL_comppad_name, align 8, !tbaa !3
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !3
  %10 = bitcast %struct.op* %o to i8*
  tail call void @Perl_safesysfree(i8* %10) #7
  br label %if.end49

if.end9:                                          ; preds = %if.else
  %call10 = tail call %struct.op* @Perl_scalarvoid(%struct.op* %o) #8
  %tobool.i = icmp eq %struct.op* %call10, null
  br i1 %tobool.i, label %Perl_sawparens.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end9
  %op_flags.i = getelementptr inbounds %struct.op* %call10, i64 0, i32 6
  %11 = load i8* %op_flags.i, align 1, !tbaa !1
  %or.i = or i8 %11, 8
  store i8 %or.i, i8* %op_flags.i, align 1, !tbaa !1
  br label %Perl_sawparens.exit

Perl_sawparens.exit:                              ; preds = %if.end9, %if.then.i
  %call12 = tail call %struct.op* @Perl_scope(%struct.op* %call10) #8
  store %struct.op* %call12, %struct.op** @PL_main_root, align 8, !tbaa !3
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  %op_next13 = getelementptr inbounds %struct.op* %call12, i64 0, i32 0
  %12 = load %struct.op** %op_next13, align 8, !tbaa !3
  %tobool14 = icmp eq %struct.op* %12, null
  br i1 %tobool14, label %cond.false, label %cond.end

cond.false:                                       ; preds = %Perl_sawparens.exit
  %call16 = tail call %struct.op* @Perl_linklist(%struct.op* %call12) #8
  br label %cond.end

cond.end:                                         ; preds = %Perl_sawparens.exit, %cond.false
  %cond17 = phi %struct.op* [ %call16, %cond.false ], [ %12, %Perl_sawparens.exit ]
  store %struct.op* %cond17, %struct.op** @PL_main_start, align 8, !tbaa !3
  %13 = load %struct.op** @PL_main_root, align 8, !tbaa !3
  %op_private18 = getelementptr inbounds %struct.op* %13, i64 0, i32 7
  %14 = load i8* %op_private18, align 1, !tbaa !1
  %or20 = or i8 %14, 64
  store i8 %or20, i8* %op_private18, align 1, !tbaa !1
  %15 = load %struct.op** @PL_main_root, align 8, !tbaa !3
  %op_targ22 = getelementptr inbounds %struct.op* %15, i64 0, i32 3
  store i64 1, i64* %op_targ22, align 8, !tbaa !5
  %op_next23 = getelementptr inbounds %struct.op* %15, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next23, align 8, !tbaa !3
  %16 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !3
  %17 = load %struct.op** @PL_main_start, align 8, !tbaa !3
  tail call void %16(%struct.op* %17) #7
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !3
  %18 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool24 = icmp eq i32 %18, 0
  %and25 = and i32 %18, 8
  %tobool26 = icmp eq i32 %and25, 0
  %or.cond = or i1 %tobool24, %tobool26
  br i1 %or.cond, label %if.end49, label %if.then27

if.then27:                                        ; preds = %cond.end
  %call28 = tail call %struct.cv* @Perl_get_cv(i8* getelementptr inbounds ([14 x i8]* @.str28, i64 0, i64 0), i32 0) #7
  %tobool29 = icmp eq %struct.cv* %call28, null
  br i1 %tobool29, label %if.end49, label %if.then30

if.then30:                                        ; preds = %if.then27
  %19 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %20 = load i32** @PL_markstack_ptr, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds i32* %20, i64 1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !3
  %21 = load i32** @PL_markstack_max, align 8, !tbaa !3
  %cmp31 = icmp eq i32* %incdec.ptr, %21
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.then30
  tail call void @Perl_markstack_grow() #7
  %.pre = load i32** @PL_markstack_ptr, align 8, !tbaa !3
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.then30
  %22 = phi i32* [ %.pre, %if.then33 ], [ %incdec.ptr, %if.then30 ]
  %23 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div59 = lshr exact i64 %sub.ptr.sub, 3
  %conv35 = trunc i64 %sub.ptr.div59 to i32
  store i32 %conv35, i32* %22, align 4, !tbaa !0
  %24 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !3
  %sub.ptr.lhs.cast36 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub38 = sub i64 %sub.ptr.lhs.cast36, %sub.ptr.lhs.cast
  %cmp40 = icmp slt i64 %sub.ptr.sub38, 8
  br i1 %cmp40, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end34
  %call43 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %19, %struct.sv** %19, i32 1) #7
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end34
  %sp.0 = phi %struct.sv** [ %call43, %if.then42 ], [ %19, %if.end34 ]
  %25 = load %struct.gv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 10), align 8, !tbaa !3
  %26 = bitcast %struct.gv* %25 to %struct.sv*
  %incdec.ptr45 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %26, %struct.sv** %incdec.ptr45, align 8, !tbaa !3
  store %struct.sv** %incdec.ptr45, %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %27 = bitcast %struct.cv* %call28 to %struct.sv*
  %call46 = tail call i32 @Perl_call_sv(%struct.sv* %27, i32 2) #7
  br label %if.end49

if.end49:                                         ; preds = %if.then, %if.then27, %cond.end, %if.end44, %if.then8, %if.end
  ret void
}

; Function Attrs: optsize
declare %struct.cv* @Perl_get_cv(i8*, i32) #2

; Function Attrs: optsize
declare void @Perl_markstack_grow() #2

; Function Attrs: optsize
declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #2

; Function Attrs: optsize
declare i32 @Perl_call_sv(%struct.sv*, i32) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_localize(%struct.op* %o, i32 %lex) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 8
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.end148

if.else:                                          ; preds = %entry
  %1 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %1, i64 0, i32 14
  %2 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %2, null
  br i1 %cmp, label %lor.lhs.false13, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings2 = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings2, align 8, !tbaa !3
  %cmp3 = icmp eq %struct.sv* %4, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp3, label %lor.lhs.false13, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings6 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings6, align 8, !tbaa !3
  %cmp7 = icmp eq %struct.sv* %6, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp7, label %land.lhs.true21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true5
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings9 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings9, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %9 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %10, i64 8
  %11 = load i8* %arrayidx, align 1, !tbaa !1
  %and11 = and i8 %11, 1
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %lor.lhs.false13, label %land.lhs.true21

lor.lhs.false13:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.else
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings14 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings14, align 8, !tbaa !3
  %cmp15 = icmp eq %struct.sv* %13, null
  br i1 %cmp15, label %land.lhs.true17, label %if.end148

land.lhs.true17:                                  ; preds = %lor.lhs.false13
  %14 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and19 = and i8 %14, 1
  %tobool20 = icmp eq i8 %and19, 0
  br i1 %tobool20, label %if.end148, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %lor.lhs.false, %land.lhs.true17, %land.lhs.true5
  %15 = load i8** @PL_bufptr, align 8, !tbaa !3
  %16 = load i8** @PL_oldbufptr, align 8, !tbaa !3
  %cmp22 = icmp ugt i8* %15, %16
  br i1 %cmp22, label %land.lhs.true24, label %if.end148

land.lhs.true24:                                  ; preds = %land.lhs.true21
  %arrayidx25 = getelementptr inbounds i8* %15, i64 -1
  %17 = load i8* %arrayidx25, align 1, !tbaa !1
  %cmp27 = icmp eq i8 %17, 44
  br i1 %cmp27, label %while.cond.preheader, label %if.end148

while.cond.preheader:                             ; preds = %land.lhs.true24
  %18 = load i8* %15, align 1, !tbaa !1
  %tobool31222 = icmp eq i8 %18, 0
  br i1 %tobool31222, label %if.end148, label %land.rhs

while.cond:                                       ; preds = %land.rhs
  %19 = load i8* %incdec.ptr, align 1, !tbaa !1
  %tobool31 = icmp eq i8 %19, 0
  br i1 %tobool31, label %if.end148, label %land.rhs

land.rhs:                                         ; preds = %while.cond.preheader, %while.cond
  %20 = phi i8 [ %19, %while.cond ], [ %18, %while.cond.preheader ]
  %s.0223 = phi i8* [ %incdec.ptr, %while.cond ], [ %15, %while.cond.preheader ]
  %conv30 = sext i8 %20 to i32
  %memchr191 = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str29, i64 0, i64 0), i32 %conv30, i64 5)
  %tobool33 = icmp eq i8* %memchr191, null
  %incdec.ptr = getelementptr inbounds i8* %s.0223, i64 1
  br i1 %tobool33, label %land.lhs.true38, label %while.cond

while.body35.loopexit:                            ; preds = %land.rhs121
  %tobool37 = icmp eq i8 %33, 0
  br i1 %tobool37, label %if.end148, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %land.rhs, %while.body35.loopexit
  %21 = phi i8 [ %33, %while.body35.loopexit ], [ %20, %land.rhs ]
  %sigil.0219 = phi i32 [ 1, %while.body35.loopexit ], [ 0, %land.rhs ]
  %s.1218 = phi i8* [ %s.3215, %while.body35.loopexit ], [ %s.0223, %land.rhs ]
  %conv36 = sext i8 %21 to i32
  %memchr = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str30, i64 0, i64 0), i32 %conv36, i64 5)
  %tobool41 = icmp eq i8* %memchr, null
  br i1 %tobool41, label %while.end130, label %land.lhs.true42

land.lhs.true42:                                  ; preds = %land.lhs.true38
  %incdec.ptr43 = getelementptr inbounds i8* %s.1218, i64 1
  %22 = load i8* %incdec.ptr43, align 1, !tbaa !1
  %tobool45 = icmp eq i8 %22, 0
  br i1 %tobool45, label %while.end130, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %land.lhs.true42
  %.off = add i8 %22, -65
  %23 = icmp ult i8 %.off, 26
  %.off200 = add i8 %22, -97
  %24 = icmp ult i8 %.off200, 26
  %or.cond = or i1 %23, %24
  %.off201 = add i8 %22, -48
  %25 = icmp ult i8 %.off201, 10
  %or.cond207 = or i1 %or.cond, %25
  br i1 %or.cond207, label %if.then78, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %land.lhs.true46
  %cmp72 = icmp eq i8 %22, 95
  %tobool77 = icmp slt i8 %22, 0
  %or.cond195 = or i1 %cmp72, %tobool77
  br i1 %or.cond195, label %if.then78, label %while.end130

if.then78:                                        ; preds = %land.lhs.true46, %lor.lhs.false70
  %incdec.ptr79 = getelementptr inbounds i8* %s.1218, i64 2
  %26 = load i8* %incdec.ptr79, align 1, !tbaa !1
  %tobool82212 = icmp eq i8 %26, 0
  br i1 %tobool82212, label %if.end148, label %land.rhs83

land.rhs83:                                       ; preds = %if.then78, %while.body115
  %27 = phi i8 [ %31, %while.body115 ], [ %26, %if.then78 ]
  %s.2213 = phi i8* [ %incdec.ptr116, %while.body115 ], [ %incdec.ptr79, %if.then78 ]
  %.off202 = add i8 %27, -65
  %28 = icmp ult i8 %.off202, 26
  %.off203 = add i8 %27, -97
  %29 = icmp ult i8 %.off203, 26
  %or.cond209 = or i1 %28, %29
  %.off204 = add i8 %27, -48
  %30 = icmp ult i8 %.off204, 10
  %or.cond211 = or i1 %or.cond209, %30
  br i1 %or.cond211, label %while.body115, label %lor.lhs.false107

lor.lhs.false107:                                 ; preds = %land.rhs83
  %cmp109 = icmp eq i8 %27, 95
  %tobool113 = icmp slt i8 %27, 0
  %or.cond199 = or i1 %cmp109, %tobool113
  br i1 %or.cond199, label %while.body115, label %while.cond118.loopexit

while.body115:                                    ; preds = %land.rhs83, %lor.lhs.false107
  %incdec.ptr116 = getelementptr inbounds i8* %s.2213, i64 1
  %31 = load i8* %incdec.ptr116, align 1, !tbaa !1
  %tobool82 = icmp eq i8 %31, 0
  br i1 %tobool82, label %if.end148, label %land.rhs83

while.cond118.loopexit:                           ; preds = %lor.lhs.false107
  %tobool120214 = icmp eq i8 %27, 0
  br i1 %tobool120214, label %if.end148, label %land.rhs121

while.cond118:                                    ; preds = %land.rhs121
  %32 = load i8* %incdec.ptr127, align 1, !tbaa !1
  %tobool120 = icmp eq i8 %32, 0
  br i1 %tobool120, label %if.end148, label %land.rhs121

land.rhs121:                                      ; preds = %while.cond118.loopexit, %while.cond118
  %33 = phi i8 [ %32, %while.cond118 ], [ %27, %while.cond118.loopexit ]
  %s.3215 = phi i8* [ %incdec.ptr127, %while.cond118 ], [ %s.2213, %while.cond118.loopexit ]
  %conv119 = sext i8 %33 to i32
  %memchr190 = tail call i8* @memchr(i8* getelementptr inbounds ([5 x i8]* @.str29, i64 0, i64 0), i32 %conv119, i64 5)
  %tobool124 = icmp eq i8* %memchr190, null
  %incdec.ptr127 = getelementptr inbounds i8* %s.3215, i64 1
  br i1 %tobool124, label %while.body35.loopexit, label %while.cond118

while.end130:                                     ; preds = %lor.lhs.false70, %land.lhs.true42, %land.lhs.true38
  %34 = phi i8 [ %21, %land.lhs.true38 ], [ 0, %land.lhs.true42 ], [ %22, %lor.lhs.false70 ]
  %tobool132 = icmp eq i32 %sigil.0219, 0
  br i1 %tobool132, label %if.end148, label %land.lhs.true133

land.lhs.true133:                                 ; preds = %while.end130
  switch i8 %34, label %if.end148 [
    i8 59, label %if.then141
    i8 61, label %if.then141
  ]

if.then141:                                       ; preds = %land.lhs.true133, %land.lhs.true133
  %tobool142 = icmp eq i32 %lex, 0
  br i1 %tobool142, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then141
  %35 = load i32* @PL_in_my, align 4, !tbaa !0
  %cmp143 = icmp eq i32 %35, 137
  %cond = select i1 %cmp143, i8* getelementptr inbounds ([4 x i8]* @.str4, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str5, i64 0, i64 0)
  br label %cond.end

cond.end:                                         ; preds = %if.then141, %cond.true
  %cond145 = phi i8* [ %cond, %cond.true ], [ getelementptr inbounds ([6 x i8]* @.str21, i64 0, i64 0), %if.then141 ]
  tail call void (i32, i8*, ...)* @Perl_warner(i32 32, i8* getelementptr inbounds ([37 x i8]* @.str31, i64 0, i64 0), i8* %cond145) #7
  br label %if.end148

if.end148:                                        ; preds = %while.body35.loopexit, %while.cond118.loopexit, %while.cond118, %if.then78, %while.body115, %while.cond.preheader, %while.cond, %land.lhs.true133, %while.end130, %land.lhs.true17, %entry, %lor.lhs.false13, %land.lhs.true21, %land.lhs.true24, %cond.end
  %tobool149 = icmp eq i32 %lex, 0
  br i1 %tobool149, label %if.else152, label %if.then150

if.then150:                                       ; preds = %if.end148
  %call.i = tail call %struct.op* @Perl_my_attrs(%struct.op* %o, %struct.op* null) #7
  br label %if.end154

if.else152:                                       ; preds = %if.end148
  %call153 = tail call %struct.op* @Perl_mod(%struct.op* %o, i32 0) #8
  br label %if.end154

if.end154:                                        ; preds = %if.else152, %if.then150
  %o.addr.0 = phi %struct.op* [ %call.i, %if.then150 ], [ %call153, %if.else152 ]
  store i32 0, i32* @PL_in_my, align 4, !tbaa !0
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8, !tbaa !3
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_jmaybe(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 141
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8]* @.str32, i64 0, i64 0), i32 1, i32 4) #7
  %1 = bitcast %struct.gv* %call to %struct.sv*
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %call, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then
  %2 = getelementptr inbounds %struct.gv* %call, i64 0, i32 1
  %3 = load i32* %2, align 4, !tbaa !0
  %inc.i = add i32 %3, 1
  store i32 %inc.i, i32* %2, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then, %land.rhs.i
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %1) #7
  %call3 = tail call %struct.op* @Perl_newSVREF(%struct.op* %call.i) #8
  %call4 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call3, %struct.op* %o) #8
  %call5 = tail call %struct.op* @Perl_convert(i32 140, i32 0, %struct.op* %call4) #8
  br label %if.end

if.end:                                           ; preds = %Perl_newGVOP.exit, %entry
  %o.addr.0 = phi %struct.op* [ %call5, %Perl_newGVOP.exit ], [ %o, %entry ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newSVREF(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %if.end12 [
    i16 12, label %if.then
    i16 348, label %land.lhs.true
  ]

if.then:                                          ; preds = %entry
  store i16 9, i16* %op_type, align 2, !tbaa !4
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 9), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %return

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.then8, label %if.end12

if.then8:                                         ; preds = %land.lhs.true
  %or = or i8 %2, 64
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  br label %return

if.end12:                                         ; preds = %entry, %land.lhs.true
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  %call13 = tail call %struct.op* @Perl_newUNOP(i32 15, i32 0, %struct.op* %call) #8
  br label %return

return:                                           ; preds = %if.end12, %if.then8, %if.then
  %retval.0 = phi %struct.op* [ %o, %if.then ], [ %call13, %if.end12 ], [ %o, %if.then8 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newGVOP(i32 %type, i32 %flags, %struct.gv* %gv) #0 {
entry:
  %0 = bitcast %struct.gv* %gv to %struct.sv*
  store %struct.sv* %0, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool = icmp eq %struct.gv* %gv, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = getelementptr inbounds %struct.gv* %gv, i64 0, i32 1
  %2 = load i32* %1, align 4, !tbaa !0
  %inc = add i32 %2, 1
  store i32 %inc, i32* %1, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %entry, %land.rhs
  %call = tail call %struct.op* @Perl_newSVOP(i32 %type, i32 %flags, %struct.sv* %0) #8
  ret %struct.op* %call
}

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_fetchpv(i8*, i32, i32) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_convert(i32 %type, i32 %flags, %struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 141
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = tail call %struct.op* @Perl_newLISTOP(i32 141, i32 0, %struct.op* %o, %struct.op* null) #8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, -4
  store i8 %and, i8* %op_flags, align 1, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %o.addr.0 = phi %struct.op* [ %call, %if.then ], [ %o, %if.else ]
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %2 = load i32* %arrayidx, align 4, !tbaa !0
  %and4 = and i32 %2, 1
  %tobool5 = icmp eq i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %3 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  tail call void @Perl_op_null(%struct.op* %4) #8
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then6
  %conv8 = trunc i32 %type to i16
  %op_type9 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 4
  store i16 %conv8, i16* %op_type9, align 2, !tbaa !4
  %arrayidx11 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %5 = load %struct.op* ()** %arrayidx11, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 2
  store %struct.op* ()* %5, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %op_flags12 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 6
  %6 = load i8* %op_flags12, align 1, !tbaa !1
  %conv13 = zext i8 %6 to i32
  %or = or i32 %conv13, %flags
  %conv14 = trunc i32 %or to i8
  store i8 %conv14, i8* %op_flags12, align 1, !tbaa !1
  %7 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool15 = icmp eq i8* %7, null
  br i1 %tobool15, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end7
  %arrayidx17 = getelementptr inbounds i8* %7, i64 %idxprom
  %8 = load i8* %arrayidx17, align 1, !tbaa !1
  %tobool19 = icmp eq i8 %8, 0
  br i1 %tobool19, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %o.addr.0) #8
  %arrayidx21 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %9 = load i8** %arrayidx21, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %9) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end7
  %arrayidx23 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %10 = load %struct.op* (%struct.op*)** %arrayidx23, align 8, !tbaa !3
  %call24 = tail call %struct.op* %10(%struct.op* %o.addr.0) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call24, %cond.false ]
  %op_type25 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %11 = load i16* %op_type25, align 2, !tbaa !4
  %conv26 = zext i16 %11 to i32
  %cmp27 = icmp eq i32 %conv26, %type
  br i1 %cmp27, label %if.end30, label %return

if.end30:                                         ; preds = %cond.end
  %call31 = tail call %struct.op* @Perl_fold_constants(%struct.op* %cond) #8
  br label %return

return:                                           ; preds = %cond.end, %if.end30
  %retval.0 = phi %struct.op* [ %call31, %if.end30 ], [ %cond, %cond.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_fold_constants(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %1 = load i32* %arrayidx, align 4, !tbaa !0
  %and = and i32 %1, 4
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  %.pre = load i32* %arrayidx, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %2 = phi i32 [ %1, %entry ], [ %.pre, %if.then ]
  %and3 = and i32 %2, 8
  %tobool4 = icmp eq i32 %and3, 0
  br i1 %tobool4, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %3 = load i64* %op_targ, align 8, !tbaa !5
  %tobool5 = icmp eq i64 %3, 0
  br i1 %tobool5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %land.lhs.true
  %call7 = tail call i64 @Perl_pad_alloc(i32 %conv, i32 512) #7
  store i64 %call7, i64* %op_targ, align 8, !tbaa !5
  %.pre174 = load i32* %arrayidx, align 4, !tbaa !0
  br label %if.end9

if.end9:                                          ; preds = %land.lhs.true, %if.end, %if.then6
  %4 = phi i32 [ %2, %land.lhs.true ], [ %2, %if.end ], [ %.pre174, %if.then6 ]
  %and12 = and i32 %4, 32
  %tobool13 = icmp eq i32 %and12, 0
  br i1 %tobool13, label %if.end34, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %if.end9
  %5 = load i32* @PL_hints, align 4, !tbaa !0
  %and15 = and i32 %5, 1
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %if.end34, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %land.lhs.true14
  %cmp = icmp eq i16 %0, 94
  br i1 %cmp, label %land.lhs.true19, label %if.then29

land.lhs.true19:                                  ; preds = %land.lhs.true17
  %6 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !3
  %op_type20 = getelementptr inbounds %struct.op* %7, i64 0, i32 4
  %8 = load i16* %op_type20, align 2, !tbaa !4
  %cmp22 = icmp eq i16 %8, 5
  br i1 %cmp22, label %land.lhs.true24, label %if.then29

land.lhs.true24:                                  ; preds = %land.lhs.true19
  %op_private = getelementptr inbounds %struct.op* %7, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !1
  %and27 = and i8 %9, 64
  %tobool28 = icmp eq i8 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %land.lhs.true24, %land.lhs.true19, %land.lhs.true17
  %10 = load i16* %op_type, align 2, !tbaa !4
  %inc = add i16 %10, 1
  store i16 %inc, i16* %op_type, align 2, !tbaa !4
  %conv31 = zext i16 %inc to i32
  %idxprom32 = zext i16 %inc to i64
  %arrayidx33 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom32
  %11 = load %struct.op* ()** %arrayidx33, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %11, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %if.end34

if.end34:                                         ; preds = %land.lhs.true24, %land.lhs.true14, %if.end9, %if.then29
  %type.0 = phi i32 [ %conv, %land.lhs.true24 ], [ %conv31, %if.then29 ], [ %conv, %land.lhs.true14 ], [ %conv, %if.end9 ]
  %idxprom35171 = zext i32 %type.0 to i64
  %arrayidx36 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom35171
  %12 = load i32* %arrayidx36, align 4, !tbaa !0
  %and37 = and i32 %12, 2
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %return, label %if.end40

if.end40:                                         ; preds = %if.end34
  switch i32 %type.0, label %sw.epilog [
    i32 94, label %sw.bb
    i32 115, label %sw.bb46
    i32 120, label %sw.bb46
    i32 121, label %sw.bb46
    i32 122, label %sw.bb46
    i32 123, label %sw.bb46
    i32 84, label %sw.bb46
    i32 85, label %sw.bb46
    i32 86, label %sw.bb46
    i32 87, label %sw.bb46
    i32 90, label %sw.bb46
  ]

sw.bb:                                            ; preds = %if.end40
  %13 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %14 = load %struct.op** %13, align 8, !tbaa !3
  %op_private42 = getelementptr inbounds %struct.op* %14, i64 0, i32 7
  %15 = load i8* %op_private42, align 1, !tbaa !1
  %and44 = and i8 %15, -9
  store i8 %and44, i8* %op_private42, align 1, !tbaa !1
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.end40, %if.end40, %if.end40, %if.end40, %if.end40, %if.end40, %if.end40, %if.end40, %if.end40, %if.end40
  %16 = load i32* @PL_hints, align 4, !tbaa !0
  %and47 = and i32 %16, 4
  %17 = load i32* @PL_error_count, align 4, !tbaa !0
  %18 = or i32 %and47, %17
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %if.end53, label %return

sw.epilog:                                        ; preds = %if.end40, %sw.bb
  %.old = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool51.old = icmp eq i32 %.old, 0
  br i1 %tobool51.old, label %if.end53, label %return

if.end53:                                         ; preds = %sw.epilog, %sw.bb46
  %op_next = getelementptr inbounds %struct.op* %o, i64 0, i32 0
  %20 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool54 = icmp eq %struct.op* %20, null
  br i1 %tobool54, label %cond.false, label %for.cond.preheader

cond.false:                                       ; preds = %if.end53
  %call56 = tail call %struct.op* @Perl_linklist(%struct.op* %o) #8
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end53, %cond.false
  %curop.0.ph = phi %struct.op* [ %call56, %cond.false ], [ %20, %if.end53 ]
  %cmp57172 = icmp eq %struct.op* %curop.0.ph, %o
  br i1 %cmp57172, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.cond.backedge
  %curop.0173 = phi %struct.op* [ %curop.0.be, %for.cond.backedge ], [ %curop.0.ph, %for.cond.preheader ]
  %op_type59 = getelementptr inbounds %struct.op* %curop.0173, i64 0, i32 4
  %21 = load i16* %op_type59, align 2, !tbaa !4
  switch i16 %21, label %return [
    i16 5, label %lor.lhs.false
    i16 141, label %for.inc
    i16 2, label %for.inc
    i16 0, label %for.inc
    i16 3, label %for.inc
  ]

lor.lhs.false:                                    ; preds = %for.body
  %op_private63 = getelementptr inbounds %struct.op* %curop.0173, i64 0, i32 7
  %22 = load i8* %op_private63, align 1, !tbaa !1
  %and65 = and i8 %22, 64
  %tobool66 = icmp eq i8 %and65, 0
  br i1 %tobool66, label %for.inc, label %return

for.inc:                                          ; preds = %for.body, %for.body, %for.body, %for.body, %lor.lhs.false
  %op_next89 = getelementptr inbounds %struct.op* %curop.0173, i64 0, i32 0
  %23 = load %struct.op** %op_next89, align 8, !tbaa !3
  %tobool90 = icmp eq %struct.op* %23, null
  br i1 %tobool90, label %cond.false93, label %for.cond.backedge

for.cond.backedge:                                ; preds = %for.inc, %cond.false93
  %curop.0.be = phi %struct.op* [ %call94, %cond.false93 ], [ %23, %for.inc ]
  %cmp57 = icmp eq %struct.op* %curop.0.be, %o
  br i1 %cmp57, label %for.end, label %for.body

cond.false93:                                     ; preds = %for.inc
  %call94 = tail call %struct.op* @Perl_linklist(%struct.op* %curop.0173) #8
  br label %for.cond.backedge

for.end:                                          ; preds = %for.cond.backedge, %for.cond.preheader
  %24 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool98 = icmp eq %struct.op* %24, null
  br i1 %tobool98, label %cond.false101, label %cond.end103

cond.false101:                                    ; preds = %for.end
  %call102 = tail call %struct.op* @Perl_linklist(%struct.op* %o) #8
  br label %cond.end103

cond.end103:                                      ; preds = %for.end, %cond.false101
  %cond104 = phi %struct.op* [ %call102, %cond.false101 ], [ %24, %for.end ]
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !3
  store %struct.op* %cond104, %struct.op** @PL_op, align 8, !tbaa !3
  %25 = load i32 ()** @PL_runops, align 8, !tbaa !3
  %call106 = tail call i32 %25() #7
  %26 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds %struct.sv** %26, i64 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %27 = load %struct.sv** %26, align 8, !tbaa !3
  %op_targ107 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  %28 = load i64* %op_targ107, align 8, !tbaa !5
  %tobool108 = icmp eq i64 %28, 0
  br i1 %tobool108, label %if.else, label %land.lhs.true109

land.lhs.true109:                                 ; preds = %cond.end103
  %29 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx111 = getelementptr inbounds %struct.sv** %29, i64 %28
  %30 = load %struct.sv** %arrayidx111, align 8, !tbaa !3
  %cmp112 = icmp eq %struct.sv* %27, %30
  br i1 %cmp112, label %if.then114, label %if.else

if.then114:                                       ; preds = %land.lhs.true109
  tail call void @Perl_pad_swipe(i64 %28, i8 signext 0) #7
  br label %if.end125

if.else:                                          ; preds = %cond.end103, %land.lhs.true109
  %sv_flags = getelementptr inbounds %struct.sv* %27, i64 0, i32 2
  %31 = load i32* %sv_flags, align 4, !tbaa !0
  %and116 = and i32 %31, 2048
  %tobool117 = icmp eq i32 %and116, 0
  br i1 %tobool117, label %if.end125, label %if.then118

if.then118:                                       ; preds = %if.else
  store %struct.sv* %27, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool119 = icmp eq %struct.sv* %27, null
  br i1 %tobool119, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then118
  %sv_refcnt = getelementptr inbounds %struct.sv* %27, i64 0, i32 1
  %32 = load i32* %sv_refcnt, align 4, !tbaa !0
  %inc120 = add i32 %32, 1
  store i32 %inc120, i32* %sv_refcnt, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %if.then118, %land.rhs
  %and123 = and i32 %31, -2049
  store i32 %and123, i32* %sv_flags, align 4, !tbaa !0
  br label %if.end125

if.end125:                                        ; preds = %if.else, %land.end, %if.then114
  tail call void @Perl_op_free(%struct.op* %o) #8
  %cmp126 = icmp eq i32 %type.0, 14
  br i1 %cmp126, label %if.then128, label %if.end130

if.then128:                                       ; preds = %if.end125
  store %struct.sv* %27, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.sv* %27, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then128
  %33 = getelementptr inbounds %struct.sv* %27, i64 0, i32 1
  %34 = load i32* %33, align 4, !tbaa !0
  %inc.i = add i32 %34, 1
  store i32 %inc.i, i32* %33, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then128, %land.rhs.i
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %27) #7
  br label %return

if.end130:                                        ; preds = %if.end125
  %call131 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %27) #8
  br label %return

return:                                           ; preds = %for.body, %lor.lhs.false, %if.end34, %sw.bb46, %sw.epilog, %if.end130, %Perl_newGVOP.exit
  %retval.0 = phi %struct.op* [ %call.i, %Perl_newGVOP.exit ], [ %call131, %if.end130 ], [ %o, %sw.epilog ], [ %o, %sw.bb46 ], [ %o, %if.end34 ], [ %o, %lor.lhs.false ], [ %o, %for.body ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare void @Perl_pad_swipe(i64, i8 signext) #2

; Function Attrs: optsize
declare %struct.op* @Perl_pp_pushmark() #2

; Function Attrs: optsize
declare %struct.op* @Perl_pp_anonlist() #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newNULLLIST() #0 {
entry:
  %call = tail call %struct.op* @Perl_newOP(i32 1, i32 0) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_force_list(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 141
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = tail call %struct.op* @Perl_newLISTOP(i32 141, i32 0, %struct.op* %o, %struct.op* null) #8
  br label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  %o.addr.0 = phi %struct.op* [ %call, %if.then ], [ %o, %lor.lhs.false ]
  tail call void @Perl_op_null(%struct.op* %o.addr.0) #8
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_pmtrans(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #0 {
entry:
  %tlen = alloca i64, align 8
  %rlen = alloca i64, align 8
  %ulen = alloca i64, align 8
  %len = alloca i64, align 8
  %len58 = alloca i64, align 8
  %tmpbuf = alloca [14 x i8], align 1
  %range_mark = alloca i8, align 1
  %range_mark140 = alloca i8, align 1
  %op_sv = getelementptr inbounds %struct.op* %expr, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !3
  %op_sv1 = getelementptr inbounds %struct.op* %repl, i64 1
  %2 = bitcast %struct.op* %op_sv1 to %struct.sv**
  %3 = load %struct.sv** %2, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %4, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %5, i64 8
  %6 = bitcast i8* %xpv_cur to i64*
  %7 = load i64* %6, align 8, !tbaa !5
  store i64 %7, i64* %tlen, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %5 to i8**
  %8 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %tlen, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %8, %cond.true ], [ %call, %cond.false ]
  %sv_flags3 = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %9 = load i32* %sv_flags3, align 4, !tbaa !0
  %and4 = and i32 %9, 262144
  %cmp5 = icmp eq i32 %and4, 0
  br i1 %cmp5, label %cond.false11, label %cond.true6

cond.true6:                                       ; preds = %cond.end
  %sv_any7 = getelementptr inbounds %struct.sv* %3, i64 0, i32 0
  %10 = load i8** %sv_any7, align 8, !tbaa !3
  %xpv_cur8 = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur8 to i64*
  %12 = load i64* %11, align 8, !tbaa !5
  store i64 %12, i64* %rlen, align 8, !tbaa !5
  %xpv_pv10 = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv10, align 8, !tbaa !3
  br label %cond.end13

cond.false11:                                     ; preds = %cond.end
  %call12 = call i8* @Perl_sv_2pv_flags(%struct.sv* %3, i64* %rlen, i32 2) #7
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false11, %cond.true6
  %cond14 = phi i8* [ %13, %cond.true6 ], [ %call12, %cond.false11 ]
  %14 = load i32* @PL_hints, align 4, !tbaa !0
  %or = or i32 %14, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %15 = load i8* %op_private, align 1, !tbaa !1
  %conv = zext i8 %15 to i32
  %and15 = and i32 %conv, 32
  %and18 = and i32 %conv, 16
  %and21 = and i32 %conv, 8
  %16 = load i32* %sv_flags, align 4, !tbaa !0
  %and23 = and i32 %16, 536870912
  %tobool = icmp eq i32 %and23, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end13
  %or26 = or i8 %15, 1
  store i8 %or26, i8* %op_private, align 1, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %cond.end13, %if.then
  %17 = phi i8 [ %15, %cond.end13 ], [ %or26, %if.then ]
  %18 = load i32* %sv_flags3, align 4, !tbaa !0
  %and29 = and i32 %18, 536870912
  %tobool30 = icmp eq i32 %and29, 0
  br i1 %tobool30, label %if.end36, label %if.then31

if.then31:                                        ; preds = %if.end
  %or34 = or i8 %17, 2
  store i8 %or34, i8* %op_private, align 1, !tbaa !1
  br label %if.end36

if.end36:                                         ; preds = %if.end, %if.then31
  %19 = phi i8 [ %17, %if.end ], [ %or34, %if.then31 ]
  %and39 = and i8 %19, 3
  %tobool40 = icmp eq i8 %and39, 0
  br i1 %tobool40, label %if.end425, label %if.then41

if.then41:                                        ; preds = %if.end36
  %call42 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str34, i64 0, i64 0), i64 10) #7
  %20 = load i64* %tlen, align 8, !tbaa !5
  %add.ptr = getelementptr inbounds i8* %cond, i64 %20
  %21 = load i64* %rlen, align 8, !tbaa !5
  %add.ptr43 = getelementptr inbounds i8* %cond14, i64 %21
  %22 = load i8* %op_private, align 1, !tbaa !1
  %conv45 = zext i8 %22 to i32
  %and46 = and i32 %conv45, 1
  %and49 = and i32 %conv45, 2
  %tobool50 = icmp eq i32 %and46, 0
  br i1 %tobool50, label %if.then51, label %if.end54

if.then51:                                        ; preds = %if.then41
  store i64 %20, i64* %len, align 8, !tbaa !5
  %call52 = call i8* @Perl_bytes_to_utf8(i8* %cond, i64* %len) #7
  %23 = load i64* %len, align 8, !tbaa !5
  %add.ptr53 = getelementptr inbounds i8* %call52, i64 %23
  br label %if.end54

if.end54:                                         ; preds = %if.then41, %if.then51
  %tend.0 = phi i8* [ %add.ptr, %if.then41 ], [ %add.ptr53, %if.then51 ]
  %t.0 = phi i8* [ %cond, %if.then41 ], [ %call52, %if.then51 ]
  %tsave.0 = phi i8* [ null, %if.then41 ], [ %call52, %if.then51 ]
  %tobool55 = icmp eq i32 %and49, 0
  br i1 %tobool55, label %land.lhs.true, label %if.end61

land.lhs.true:                                    ; preds = %if.end54
  %24 = load i64* %rlen, align 8, !tbaa !5
  %tobool56 = icmp eq i64 %24, 0
  br i1 %tobool56, label %if.end61, label %if.then57

if.then57:                                        ; preds = %land.lhs.true
  store i64 %24, i64* %len58, align 8, !tbaa !5
  %call59 = call i8* @Perl_bytes_to_utf8(i8* %cond14, i64* %len58) #7
  %25 = load i64* %len58, align 8, !tbaa !5
  %add.ptr60 = getelementptr inbounds i8* %call59, i64 %25
  br label %if.end61

if.end61:                                         ; preds = %land.lhs.true, %if.end54, %if.then57
  %rend.0 = phi i8* [ %add.ptr43, %if.end54 ], [ %add.ptr60, %if.then57 ], [ %add.ptr43, %land.lhs.true ]
  %r.0 = phi i8* [ %cond14, %if.end54 ], [ %call59, %if.then57 ], [ %cond14, %land.lhs.true ]
  %rsave.0 = phi i8* [ null, %if.end54 ], [ %call59, %if.then57 ], [ null, %land.lhs.true ]
  %tobool62 = icmp eq i32 %and15, 0
  br i1 %tobool62, label %if.else153, label %if.then63

if.then63:                                        ; preds = %if.end61
  %26 = load i64* %tlen, align 8, !tbaa !5
  %mul64 = shl i64 %26, 4
  %call65 = call i8* @Perl_safesysmalloc(i64 %mul64) #7
  %27 = bitcast i8* %call65 to i64*
  %call66 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), i64 0) #7
  %cmp67986 = icmp ult i8* %t.0, %tend.0
  br i1 %cmp67986, label %while.body.lr.ph, label %while.end.thread

while.end.thread:                                 ; preds = %if.then63
  call void @qsort(i8* %call65, i64 0, i64 16, i32 (i8*, i8*)* @uvcompare) #7
  br label %while.end.for.end_crit_edge

while.body.lr.ph:                                 ; preds = %if.then63
  %sub.ptr.lhs.cast = ptrtoint i8* %tend.0 to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end94
  %indvars.iv1004 = phi i64 [ 0, %while.body.lr.ph ], [ %indvars.iv.next1005, %if.end94 ]
  %t.1988 = phi i8* [ %t.0, %while.body.lr.ph ], [ %t.2, %if.end94 ]
  %i.0987 = phi i32 [ 0, %while.body.lr.ph ], [ %inc, %if.end94 ]
  %sub.ptr.rhs.cast = ptrtoint i8* %t.1988 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call69 = call i64 @Perl_utf8n_to_uvuni(i8* %t.1988, i64 %sub.ptr.sub, i64* %ulen, i32 0) #7
  %28 = trunc i64 %indvars.iv1004 to i32
  %mul70 = shl nsw i32 %28, 1
  %idxprom = sext i32 %mul70 to i64
  %arrayidx = getelementptr inbounds i64* %27, i64 %idxprom
  store i64 %call69, i64* %arrayidx, align 8, !tbaa !5
  %29 = load i64* %ulen, align 8, !tbaa !5
  %add.ptr71 = getelementptr inbounds i8* %t.1988, i64 %29
  %cmp72 = icmp ult i8* %add.ptr71, %tend.0
  br i1 %cmp72, label %land.lhs.true74, label %if.else

land.lhs.true74:                                  ; preds = %while.body
  %30 = load i8* %add.ptr71, align 1, !tbaa !1
  %cmp76 = icmp eq i8 %30, -1
  br i1 %cmp76, label %if.then78, label %if.else

if.then78:                                        ; preds = %land.lhs.true74
  %add.ptr71.sum = add i64 %29, 1
  %incdec.ptr = getelementptr inbounds i8* %t.1988, i64 %add.ptr71.sum
  %sub.ptr.rhs.cast80 = ptrtoint i8* %incdec.ptr to i64
  %sub.ptr.sub81 = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast80
  %call82 = call i64 @Perl_utf8n_to_uvuni(i8* %incdec.ptr, i64 %sub.ptr.sub81, i64* %ulen, i32 0) #7
  %add914 = or i32 %mul70, 1
  %idxprom84 = sext i32 %add914 to i64
  %arrayidx85 = getelementptr inbounds i64* %27, i64 %idxprom84
  store i64 %call82, i64* %arrayidx85, align 8, !tbaa !5
  %31 = load i64* %ulen, align 8, !tbaa !5
  %incdec.ptr.sum = add i64 %31, %add.ptr71.sum
  %add.ptr86 = getelementptr inbounds i8* %t.1988, i64 %incdec.ptr.sum
  br label %if.end94

if.else:                                          ; preds = %land.lhs.true74, %while.body
  %add91913 = or i32 %mul70, 1
  %idxprom92 = sext i32 %add91913 to i64
  %arrayidx93 = getelementptr inbounds i64* %27, i64 %idxprom92
  store i64 %call69, i64* %arrayidx93, align 8, !tbaa !5
  br label %if.end94

if.end94:                                         ; preds = %if.else, %if.then78
  %t.2 = phi i8* [ %add.ptr86, %if.then78 ], [ %add.ptr71, %if.else ]
  %indvars.iv.next1005 = add i64 %indvars.iv1004, 1
  %inc = add nsw i32 %i.0987, 1
  %cmp67 = icmp ult i8* %t.2, %tend.0
  br i1 %cmp67, label %while.body, label %while.end

while.end:                                        ; preds = %if.end94
  %conv95 = sext i32 %inc to i64
  call void @qsort(i8* %call65, i64 %conv95, i64 16, i32 (i8*, i8*)* @uvcompare) #7
  %cmp96982 = icmp sgt i32 %i.0987, -1
  br i1 %cmp96982, label %for.body.lr.ph, label %while.end.for.end_crit_edge

while.end.for.end_crit_edge:                      ; preds = %while.end.thread, %while.end
  %arraydecay133.pre = getelementptr inbounds [14 x i8]* %tmpbuf, i64 0, i64 0
  %sub.ptr.rhs.cast138.pre = ptrtoint [14 x i8]* %tmpbuf to i64
  br label %for.end

for.body.lr.ph:                                   ; preds = %while.end
  %arraydecay = getelementptr inbounds [14 x i8]* %tmpbuf, i64 0, i64 0
  %sub.ptr.rhs.cast108 = ptrtoint [14 x i8]* %tmpbuf to i64
  br label %for.body

for.body:                                         ; preds = %if.end122, %for.body.lr.ph
  %indvars.iv1000 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next1001, %if.end122 ]
  %nextmin.0984 = phi i64 [ 0, %for.body.lr.ph ], [ %nextmin.0.add130, %if.end122 ]
  %32 = trunc i64 %indvars.iv1000 to i32
  %mul98 = shl nsw i32 %32, 1
  %idxprom99 = sext i32 %mul98 to i64
  %arrayidx100 = getelementptr inbounds i64* %27, i64 %idxprom99
  %33 = load i64* %arrayidx100, align 8, !tbaa !5
  %sub = sub i64 %33, %nextmin.0984
  %cmp101 = icmp sgt i64 %sub, 0
  br i1 %cmp101, label %if.then103, label %if.end122

if.then103:                                       ; preds = %for.body
  %call104 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay, i64 %nextmin.0984) #7
  %sub.ptr.lhs.cast107 = ptrtoint i8* %call104 to i64
  %sub.ptr.sub109 = sub i64 %sub.ptr.lhs.cast107, %sub.ptr.rhs.cast108
  call void @Perl_sv_catpvn_flags(%struct.sv* %call66, i8* %arraydecay, i64 %sub.ptr.sub109, i32 2) #7
  %cmp110 = icmp sgt i64 %sub, 1
  br i1 %cmp110, label %if.then112, label %if.end122

if.then112:                                       ; preds = %if.then103
  store i8 -1, i8* %range_mark, align 1, !tbaa !1
  %sub114 = add i64 %33, -1
  %call115 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay, i64 %sub114) #7
  call void @Perl_sv_catpvn_flags(%struct.sv* %call66, i8* %range_mark, i64 1, i32 2) #7
  %sub.ptr.lhs.cast118 = ptrtoint i8* %call115 to i64
  %sub.ptr.sub120 = sub i64 %sub.ptr.lhs.cast118, %sub.ptr.rhs.cast108
  call void @Perl_sv_catpvn_flags(%struct.sv* %call66, i8* %arraydecay, i64 %sub.ptr.sub120, i32 2) #7
  br label %if.end122

if.end122:                                        ; preds = %if.then103, %if.then112, %for.body
  %add124912 = or i32 %mul98, 1
  %idxprom125 = sext i32 %add124912 to i64
  %arrayidx126 = getelementptr inbounds i64* %27, i64 %idxprom125
  %34 = load i64* %arrayidx126, align 8, !tbaa !5
  %cmp127 = icmp ult i64 %34, %nextmin.0984
  %add130 = add i64 %34, 1
  %nextmin.0.add130 = select i1 %cmp127, i64 %nextmin.0984, i64 %add130
  %indvars.iv.next1001 = add i64 %indvars.iv1000, 1
  %lftr.wideiv1002 = trunc i64 %indvars.iv.next1001 to i32
  %exitcond1003 = icmp eq i32 %lftr.wideiv1002, %inc
  br i1 %exitcond1003, label %for.end, label %for.body

for.end:                                          ; preds = %if.end122, %while.end.for.end_crit_edge
  %sub.ptr.rhs.cast138.pre-phi = phi i64 [ %sub.ptr.rhs.cast138.pre, %while.end.for.end_crit_edge ], [ %sub.ptr.rhs.cast108, %if.end122 ]
  %arraydecay133.pre-phi = phi i8* [ %arraydecay133.pre, %while.end.for.end_crit_edge ], [ %arraydecay, %if.end122 ]
  %nextmin.0.lcssa = phi i64 [ 0, %while.end.for.end_crit_edge ], [ %nextmin.0.add130, %if.end122 ]
  %call134 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay133.pre-phi, i64 %nextmin.0.lcssa) #7
  %sub.ptr.lhs.cast137 = ptrtoint i8* %call134 to i64
  %sub.ptr.sub139 = sub i64 %sub.ptr.lhs.cast137, %sub.ptr.rhs.cast138.pre-phi
  call void @Perl_sv_catpvn_flags(%struct.sv* %call66, i8* %arraydecay133.pre-phi, i64 %sub.ptr.sub139, i32 2) #7
  store i8 -1, i8* %range_mark140, align 1, !tbaa !1
  call void @Perl_sv_catpvn_flags(%struct.sv* %call66, i8* %range_mark140, i64 1, i32 2) #7
  %call142 = call i8* @Perl_uvuni_to_utf8_flags(i8* %arraydecay133.pre-phi, i64 2147483647, i64 8) #7
  %sub.ptr.lhs.cast145 = ptrtoint i8* %call142 to i64
  %sub.ptr.sub147 = sub i64 %sub.ptr.lhs.cast145, %sub.ptr.rhs.cast138.pre-phi
  call void @Perl_sv_catpvn_flags(%struct.sv* %call66, i8* %arraydecay133.pre-phi, i64 %sub.ptr.sub147, i32 2) #7
  %sv_any148 = getelementptr inbounds %struct.sv* %call66, i64 0, i32 0
  %35 = load i8** %sv_any148, align 8, !tbaa !3
  %xpv_pv149 = bitcast i8* %35 to i8**
  %36 = load i8** %xpv_pv149, align 8, !tbaa !3
  %xpv_cur151 = getelementptr inbounds i8* %35, i64 8
  %37 = bitcast i8* %xpv_cur151 to i64*
  %38 = load i64* %37, align 8, !tbaa !5
  store i64 %38, i64* %tlen, align 8, !tbaa !5
  %add.ptr152 = getelementptr inbounds i8* %36, i64 %38
  call void @Perl_safesysfree(i8* %call65) #7
  br label %if.end159

if.else153:                                       ; preds = %if.end61
  %39 = load i64* %rlen, align 8, !tbaa !5
  %tobool154 = icmp eq i64 %39, 0
  %tobool156 = icmp eq i32 %and18, 0
  %or.cond = and i1 %tobool154, %tobool156
  br i1 %or.cond, label %if.then157, label %if.end159

if.then157:                                       ; preds = %if.else153
  %40 = load i64* %tlen, align 8, !tbaa !5
  store i64 %40, i64* %rlen, align 8, !tbaa !5
  br label %if.end159

if.end159:                                        ; preds = %if.else153, %if.then157, %for.end
  %transv.0 = phi %struct.sv* [ %call66, %for.end ], [ null, %if.else153 ], [ null, %if.then157 ]
  %tend.1 = phi i8* [ %add.ptr152, %for.end ], [ %tend.0, %if.else153 ], [ %tend.0, %if.then157 ]
  %rend.1 = phi i8* [ %rend.0, %for.end ], [ %rend.0, %if.else153 ], [ %tend.0, %if.then157 ]
  %r.1 = phi i8* [ %r.0, %for.end ], [ %r.0, %if.else153 ], [ %t.0, %if.then157 ]
  %t.3 = phi i8* [ %36, %for.end ], [ %t.0, %if.else153 ], [ %t.0, %if.then157 ]
  %tobool160 = icmp eq i32 %and21, 0
  br i1 %tobool160, label %if.then161, label %while.cond180.preheader

if.then161:                                       ; preds = %if.end159
  %41 = load i64* %rlen, align 8, !tbaa !5
  %tobool162 = icmp eq i64 %41, 0
  %tobool164 = icmp eq i32 %and18, 0
  %or.cond915 = and i1 %tobool162, %tobool164
  %cmp165 = icmp eq i8* %t.3, %r.1
  %or.cond916 = or i1 %or.cond915, %cmp165
  br i1 %or.cond916, label %if.then173, label %lor.lhs.false167

lor.lhs.false167:                                 ; preds = %if.then161
  %42 = load i64* %tlen, align 8, !tbaa !5
  %cmp168 = icmp eq i64 %42, %41
  br i1 %cmp168, label %land.lhs.true170, label %while.cond180.preheader

land.lhs.true170:                                 ; preds = %lor.lhs.false167
  %call171 = call i32 @memcmp(i8* %t.3, i8* %r.1, i64 %41) #7
  %tobool172 = icmp eq i32 %call171, 0
  br i1 %tobool172, label %if.then173, label %while.cond180.preheader

if.then173:                                       ; preds = %land.lhs.true170, %if.then161
  %43 = load i8* %op_private, align 1, !tbaa !1
  %or176 = or i8 %43, 4
  store i8 %or176, i8* %op_private, align 1, !tbaa !1
  br label %while.cond180.preheader

while.cond180.preheader:                          ; preds = %lor.lhs.false167, %if.then173, %if.end159, %land.lhs.true170
  %cmp181966 = icmp ult i8* %t.3, %tend.1
  br i1 %cmp181966, label %while.body185.lr.ph, label %while.end379

while.body185.lr.ph:                              ; preds = %while.cond180.preheader
  %sub.ptr.lhs.cast189 = ptrtoint i8* %tend.1 to i64
  %sub.ptr.lhs.cast220 = ptrtoint i8* %rend.1 to i64
  br label %while.body185

while.body185:                                    ; preds = %while.body185.lr.ph, %if.end376
  %cmp183977 = phi i1 [ true, %while.body185.lr.ph ], [ %cmp183, %if.end376 ]
  %t.4976 = phi i8* [ %t.3, %while.body185.lr.ph ], [ %t.5, %if.end376 ]
  %r.2975 = phi i8* [ %r.1, %while.body185.lr.ph ], [ %r.3932, %if.end376 ]
  %final.0974 = phi i32 [ 0, %while.body185.lr.ph ], [ %final.2930, %if.end376 ]
  %havefinal.0973 = phi i32 [ 0, %while.body185.lr.ph ], [ %havefinal.1928, %if.end376 ]
  %max.0972 = phi i32 [ 0, %while.body185.lr.ph ], [ %max.2, %if.end376 ]
  %rlast.0971 = phi i64 [ 0, %while.body185.lr.ph ], [ %rlast.1926, %if.end376 ]
  %rfirst.0970 = phi i64 [ 1, %while.body185.lr.ph ], [ %rfirst.2, %if.end376 ]
  %tlast.0969 = phi i64 [ 0, %while.body185.lr.ph ], [ %tlast.1, %if.end376 ]
  %tfirst.0968 = phi i64 [ 1, %while.body185.lr.ph ], [ %add378, %if.end376 ]
  %grows.0967 = phi i32 [ 0, %while.body185.lr.ph ], [ %grows.2, %if.end376 ]
  br i1 %cmp183977, label %if.then188, label %if.end213

if.then188:                                       ; preds = %while.body185
  %sub.ptr.rhs.cast190 = ptrtoint i8* %t.4976 to i64
  %sub.ptr.sub191 = sub i64 %sub.ptr.lhs.cast189, %sub.ptr.rhs.cast190
  %call192 = call i64 @Perl_utf8n_to_uvuni(i8* %t.4976, i64 %sub.ptr.sub191, i64* %ulen, i32 0) #7
  %sext910 = shl i64 %call192, 32
  %conv194 = ashr exact i64 %sext910, 32
  %44 = load i64* %ulen, align 8, !tbaa !5
  %add.ptr195 = getelementptr inbounds i8* %t.4976, i64 %44
  %cmp196 = icmp ult i8* %add.ptr195, %tend.1
  br i1 %cmp196, label %land.lhs.true198, label %if.end213

land.lhs.true198:                                 ; preds = %if.then188
  %45 = load i8* %add.ptr195, align 1, !tbaa !1
  %cmp200 = icmp eq i8 %45, -1
  br i1 %cmp200, label %if.then202, label %if.end213

if.then202:                                       ; preds = %land.lhs.true198
  %add.ptr195.sum = add i64 %44, 1
  %incdec.ptr203 = getelementptr inbounds i8* %t.4976, i64 %add.ptr195.sum
  %sub.ptr.rhs.cast205 = ptrtoint i8* %incdec.ptr203 to i64
  %sub.ptr.sub206 = sub i64 %sub.ptr.lhs.cast189, %sub.ptr.rhs.cast205
  %call207 = call i64 @Perl_utf8n_to_uvuni(i8* %incdec.ptr203, i64 %sub.ptr.sub206, i64* %ulen, i32 0) #7
  %sext911 = shl i64 %call207, 32
  %conv209 = ashr exact i64 %sext911, 32
  %46 = load i64* %ulen, align 8, !tbaa !5
  %incdec.ptr203.sum = add i64 %46, %add.ptr195.sum
  %add.ptr210 = getelementptr inbounds i8* %t.4976, i64 %incdec.ptr203.sum
  br label %if.end213

if.end213:                                        ; preds = %if.then188, %land.lhs.true198, %if.then202, %while.body185
  %tfirst.1 = phi i64 [ %conv194, %if.then202 ], [ %tfirst.0968, %while.body185 ], [ %conv194, %land.lhs.true198 ], [ %conv194, %if.then188 ]
  %tlast.1 = phi i64 [ %conv209, %if.then202 ], [ %tlast.0969, %while.body185 ], [ %conv194, %land.lhs.true198 ], [ %conv194, %if.then188 ]
  %t.5 = phi i8* [ %add.ptr210, %if.then202 ], [ %t.4976, %while.body185 ], [ %add.ptr195, %land.lhs.true198 ], [ %add.ptr195, %if.then188 ]
  %cmp214 = icmp ugt i64 %rfirst.0970, %rlast.0971
  br i1 %cmp214, label %if.then216, label %if.end251

if.then216:                                       ; preds = %if.end213
  %cmp217 = icmp ult i8* %r.2975, %rend.1
  br i1 %cmp217, label %if.then219, label %if.end251.thread935

if.then219:                                       ; preds = %if.then216
  %sub.ptr.rhs.cast221 = ptrtoint i8* %r.2975 to i64
  %sub.ptr.sub222 = sub i64 %sub.ptr.lhs.cast220, %sub.ptr.rhs.cast221
  %call223 = call i64 @Perl_utf8n_to_uvuni(i8* %r.2975, i64 %sub.ptr.sub222, i64* %ulen, i32 0) #7
  %sext = shl i64 %call223, 32
  %conv225 = ashr exact i64 %sext, 32
  %47 = load i64* %ulen, align 8, !tbaa !5
  %add.ptr226 = getelementptr inbounds i8* %r.2975, i64 %47
  %cmp227 = icmp ult i8* %add.ptr226, %rend.1
  br i1 %cmp227, label %land.lhs.true229, label %if.end251.thread

land.lhs.true229:                                 ; preds = %if.then219
  %48 = load i8* %add.ptr226, align 1, !tbaa !1
  %cmp231 = icmp eq i8 %48, -1
  br i1 %cmp231, label %if.then233, label %if.end251.thread

if.then233:                                       ; preds = %land.lhs.true229
  %add.ptr226.sum = add i64 %47, 1
  %incdec.ptr234 = getelementptr inbounds i8* %r.2975, i64 %add.ptr226.sum
  %sub.ptr.rhs.cast236 = ptrtoint i8* %incdec.ptr234 to i64
  %sub.ptr.sub237 = sub i64 %sub.ptr.lhs.cast220, %sub.ptr.rhs.cast236
  %call238 = call i64 @Perl_utf8n_to_uvuni(i8* %incdec.ptr234, i64 %sub.ptr.sub237, i64* %ulen, i32 0) #7
  %sext909 = shl i64 %call238, 32
  %conv240 = ashr exact i64 %sext909, 32
  %49 = load i64* %ulen, align 8, !tbaa !5
  %incdec.ptr234.sum = add i64 %49, %add.ptr226.sum
  %add.ptr241 = getelementptr inbounds i8* %r.2975, i64 %incdec.ptr234.sum
  br label %if.end251.thread

if.end251.thread935:                              ; preds = %if.then216
  %inc245 = add nsw i32 %havefinal.0973, 1
  %tobool246 = icmp eq i32 %havefinal.0973, 0
  %conv248 = trunc i64 %rlast.0971 to i32
  %conv248.final.0 = select i1 %tobool246, i32 %conv248, i32 %final.0974
  %sub252936 = sub i64 %tlast.1, %tfirst.1
  br label %if.then261

if.end251.thread:                                 ; preds = %if.then233, %land.lhs.true229, %if.then219
  %rlast.1.ph = phi i64 [ %conv240, %if.then233 ], [ %conv225, %land.lhs.true229 ], [ %conv225, %if.then219 ]
  %r.3.ph = phi i8* [ %add.ptr241, %if.then233 ], [ %add.ptr226, %land.lhs.true229 ], [ %add.ptr226, %if.then219 ]
  %sub252920 = sub i64 %tlast.1, %tfirst.1
  %sub253921 = sub i64 %rlast.1.ph, %conv225
  %cmp254922 = icmp sgt i64 %sub252920, %sub253921
  %sub253.sub252923 = select i1 %cmp254922, i64 %sub253921, i64 %sub252920
  br label %if.else267

if.end251:                                        ; preds = %if.end213
  %sub252 = sub i64 %tlast.1, %tfirst.1
  %sub253 = sub i64 %rlast.0971, %rfirst.0970
  %cmp254 = icmp sgt i64 %sub252, %sub253
  %sub253.sub252 = select i1 %cmp254, i64 %sub253, i64 %sub252
  %cmp259 = icmp eq i64 %rfirst.0970, 4294967295
  br i1 %cmp259, label %if.then261, label %if.else267

if.then261:                                       ; preds = %if.end251.thread935, %if.end251
  %sub252946 = phi i64 [ %sub252936, %if.end251.thread935 ], [ %sub252, %if.end251 ]
  %final.2944 = phi i32 [ %conv248.final.0, %if.end251.thread935 ], [ %final.0974, %if.end251 ]
  %havefinal.1943 = phi i32 [ %inc245, %if.end251.thread935 ], [ %havefinal.0973, %if.end251 ]
  %rlast.1942 = phi i64 [ 4294967295, %if.end251.thread935 ], [ %rlast.0971, %if.end251 ]
  %cmp262 = icmp sgt i64 %sub252946, 0
  br i1 %cmp262, label %if.then264, label %if.else265

if.then264:                                       ; preds = %if.then261
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call42, i8* getelementptr inbounds ([18 x i8]* @.str36, i64 0, i64 0), i64 %tfirst.1, i64 %tlast.1) #7
  br label %if.end376

if.else265:                                       ; preds = %if.then261
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call42, i8* getelementptr inbounds ([13 x i8]* @.str37, i64 0, i64 0), i64 %tfirst.1) #7
  br label %if.end376

if.else267:                                       ; preds = %if.end251.thread, %if.end251
  %sub253.sub252934 = phi i64 [ %sub253.sub252923, %if.end251.thread ], [ %sub253.sub252, %if.end251 ]
  %r.3933 = phi i8* [ %r.3.ph, %if.end251.thread ], [ %r.2975, %if.end251 ]
  %rlast.1927 = phi i64 [ %rlast.1.ph, %if.end251.thread ], [ %rlast.0971, %if.end251 ]
  %rfirst.1925 = phi i64 [ %conv225, %if.end251.thread ], [ %rfirst.0970, %if.end251 ]
  %cmp268 = icmp sgt i64 %sub253.sub252934, 0
  br i1 %cmp268, label %if.then270, label %if.else272

if.then270:                                       ; preds = %if.else267
  %add271 = add i64 %sub253.sub252934, %tfirst.1
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call42, i8* getelementptr inbounds ([19 x i8]* @.str38, i64 0, i64 0), i64 %tfirst.1, i64 %add271, i64 %rfirst.1925) #7
  br label %if.end273

if.else272:                                       ; preds = %if.else267
  call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call42, i8* getelementptr inbounds ([14 x i8]* @.str39, i64 0, i64 0), i64 %tfirst.1, i64 %rfirst.1925) #7
  br label %if.end273

if.end273:                                        ; preds = %if.else272, %if.then270
  %add274 = add i64 %rfirst.1925, %sub253.sub252934
  %conv275 = zext i32 %max.0972 to i64
  %cmp276 = icmp ugt i64 %add274, %conv275
  %conv280 = trunc i64 %add274 to i32
  %conv280.max.0 = select i1 %cmp276, i32 %conv280, i32 %max.0972
  %tobool282 = icmp eq i32 %grows.0967, 0
  br i1 %tobool282, label %if.then283, label %if.end373

if.then283:                                       ; preds = %if.end273
  %cmp284 = icmp ult i64 %tfirst.1, %rfirst.1925
  br i1 %cmp284, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then283
  %cmp286 = icmp ult i64 %tfirst.1, 128
  br i1 %cmp286, label %cond.end323, label %cond.false289

cond.false289:                                    ; preds = %land.rhs
  %cmp290 = icmp ult i64 %tfirst.1, 2048
  br i1 %cmp290, label %cond.end323, label %cond.false293

cond.false293:                                    ; preds = %cond.false289
  %cmp294 = icmp ult i64 %tfirst.1, 65536
  br i1 %cmp294, label %cond.end323, label %cond.false297

cond.false297:                                    ; preds = %cond.false293
  %cmp298 = icmp ult i64 %tfirst.1, 2097152
  br i1 %cmp298, label %cond.end323, label %cond.false301

cond.false301:                                    ; preds = %cond.false297
  %cmp302 = icmp ult i64 %tfirst.1, 67108864
  br i1 %cmp302, label %cond.end323, label %cond.false305

cond.false305:                                    ; preds = %cond.false301
  %cmp306 = icmp ult i64 %tfirst.1, 2147483648
  br i1 %cmp306, label %cond.end323, label %cond.false309

cond.false309:                                    ; preds = %cond.false305
  %cmp310 = icmp ult i64 %tfirst.1, 68719476736
  %cond312 = select i1 %cmp310, i32 7, i32 13
  br label %cond.end323

cond.end323:                                      ; preds = %cond.false289, %cond.false297, %cond.false309, %cond.false305, %cond.false301, %cond.false293, %land.rhs
  %cond324 = phi i32 [ 1, %land.rhs ], [ 2, %cond.false289 ], [ 3, %cond.false293 ], [ 4, %cond.false297 ], [ 5, %cond.false301 ], [ %cond312, %cond.false309 ], [ 6, %cond.false305 ]
  %cmp326 = icmp ult i64 %add274, 128
  br i1 %cmp326, label %cond.end369, label %cond.false329

cond.false329:                                    ; preds = %cond.end323
  %cmp331 = icmp ult i64 %add274, 2048
  br i1 %cmp331, label %cond.end369, label %cond.false334

cond.false334:                                    ; preds = %cond.false329
  %cmp336 = icmp ult i64 %add274, 65536
  br i1 %cmp336, label %cond.end369, label %cond.false339

cond.false339:                                    ; preds = %cond.false334
  %cmp341 = icmp ult i64 %add274, 2097152
  br i1 %cmp341, label %cond.end369, label %cond.false344

cond.false344:                                    ; preds = %cond.false339
  %cmp346 = icmp ult i64 %add274, 67108864
  br i1 %cmp346, label %cond.end369, label %cond.false349

cond.false349:                                    ; preds = %cond.false344
  %cmp351 = icmp ult i64 %add274, 2147483648
  br i1 %cmp351, label %cond.end369, label %cond.false354

cond.false354:                                    ; preds = %cond.false349
  %cmp356 = icmp ult i64 %add274, 68719476736
  %cond358 = select i1 %cmp356, i32 7, i32 13
  br label %cond.end369

cond.end369:                                      ; preds = %cond.false329, %cond.false339, %cond.false354, %cond.false349, %cond.false344, %cond.false334, %cond.end323
  %cond370 = phi i32 [ 1, %cond.end323 ], [ 2, %cond.false329 ], [ 3, %cond.false334 ], [ 4, %cond.false339 ], [ 5, %cond.false344 ], [ %cond358, %cond.false354 ], [ 6, %cond.false349 ]
  %cmp371 = icmp ult i32 %cond324, %cond370
  br label %land.end

land.end:                                         ; preds = %cond.end369, %if.then283
  %50 = phi i1 [ false, %if.then283 ], [ %cmp371, %cond.end369 ]
  %land.ext = zext i1 %50 to i32
  br label %if.end373

if.end373:                                        ; preds = %if.end273, %land.end
  %grows.1 = phi i32 [ %grows.0967, %if.end273 ], [ %land.ext, %land.end ]
  %add374 = add nsw i64 %sub253.sub252934, 1
  %add375 = add i64 %add374, %rfirst.1925
  br label %if.end376

if.end376:                                        ; preds = %if.then264, %if.else265, %if.end373
  %r.3932 = phi i8* [ %r.2975, %if.then264 ], [ %r.2975, %if.else265 ], [ %r.3933, %if.end373 ]
  %final.2930 = phi i32 [ %final.2944, %if.then264 ], [ %final.2944, %if.else265 ], [ %final.0974, %if.end373 ]
  %havefinal.1928 = phi i32 [ %havefinal.1943, %if.then264 ], [ %havefinal.1943, %if.else265 ], [ %havefinal.0973, %if.end373 ]
  %rlast.1926 = phi i64 [ %rlast.1942, %if.then264 ], [ %rlast.1942, %if.else265 ], [ %rlast.1927, %if.end373 ]
  %grows.2 = phi i32 [ %grows.0967, %if.then264 ], [ %grows.0967, %if.else265 ], [ %grows.1, %if.end373 ]
  %rfirst.2 = phi i64 [ 4294967295, %if.then264 ], [ 4294967295, %if.else265 ], [ %add375, %if.end373 ]
  %diff.1 = phi i64 [ %sub252946, %if.then264 ], [ %sub252946, %if.else265 ], [ %sub253.sub252934, %if.end373 ]
  %max.2 = phi i32 [ %max.0972, %if.then264 ], [ %max.0972, %if.else265 ], [ %conv280.max.0, %if.end373 ]
  %add377 = add i64 %tfirst.1, 1
  %add378 = add i64 %add377, %diff.1
  %cmp181 = icmp uge i8* %t.5, %tend.1
  %cmp183 = icmp ugt i64 %add378, %tlast.1
  %or.cond917 = and i1 %cmp181, %cmp183
  br i1 %or.cond917, label %while.end379, label %while.body185

while.end379:                                     ; preds = %if.end376, %while.cond180.preheader
  %final.0.lcssa = phi i32 [ 0, %while.cond180.preheader ], [ %final.2930, %if.end376 ]
  %havefinal.0.lcssa = phi i32 [ 0, %while.cond180.preheader ], [ %havefinal.1928, %if.end376 ]
  %max.0.lcssa = phi i32 [ 0, %while.cond180.preheader ], [ %max.2, %if.end376 ]
  %grows.0.lcssa = phi i32 [ 0, %while.cond180.preheader ], [ %grows.2, %if.end376 ]
  %inc380 = add i32 %max.0.lcssa, 1
  %tobool381 = icmp eq i32 %and18, 0
  %inc383 = add i32 %max.0.lcssa, 2
  %inc380.inc383 = select i1 %tobool381, i32 %inc380, i32 %inc383
  %cmp385 = icmp ugt i32 %inc380.inc383, 65535
  br i1 %cmp385, label %if.end394, label %if.else388

if.else388:                                       ; preds = %while.end379
  %cmp389 = icmp ugt i32 %inc380.inc383, 255
  %. = select i1 %cmp389, i32 16, i32 8
  br label %if.end394

if.end394:                                        ; preds = %if.else388, %while.end379
  %bits.0 = phi i32 [ 32, %while.end379 ], [ %., %if.else388 ]
  %op_pv = getelementptr inbounds %struct.op* %o, i64 1
  %51 = bitcast %struct.op* %op_pv to i8**
  %52 = load i8** %51, align 8, !tbaa !3
  call void @Perl_safesysfree(i8* %52) #7
  %call395 = call %struct.sv* @Perl_swash_init(i8* getelementptr inbounds ([5 x i8]* @.str40, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), %struct.sv* %call42, i32 %bits.0, i32 %inc380) #7
  %53 = bitcast %struct.op* %op_pv to %struct.sv**
  %54 = getelementptr inbounds %struct.op* %op_pv, i64 0, i32 0
  %call395.c = bitcast %struct.sv* %call395 to %struct.op*
  store %struct.op* %call395.c, %struct.op** %54, align 8, !tbaa !3
  call void @Perl_sv_free(%struct.sv* %call42) #7
  %tobool397 = icmp eq %struct.sv* %transv.0, null
  br i1 %tobool397, label %if.end399, label %if.then398

if.then398:                                       ; preds = %if.end394
  call void @Perl_sv_free(%struct.sv* %transv.0) #7
  br label %if.end399

if.end399:                                        ; preds = %if.end394, %if.then398
  %tobool400947 = icmp ne i32 %inc383, 0
  %not.tobool381 = xor i1 %tobool381, true
  %tobool400 = and i1 %tobool400947, %not.tobool381
  %tobool402 = icmp eq i32 %havefinal.0.lcssa, 0
  %or.cond918 = or i1 %tobool400, %tobool402
  br i1 %or.cond918, label %if.end411, label %land.lhs.true403

land.lhs.true403:                                 ; preds = %if.end399
  %55 = load i64* %rlen, align 8, !tbaa !5
  %tobool404 = icmp eq i64 %55, 0
  br i1 %tobool404, label %if.end411, label %if.then405

if.then405:                                       ; preds = %land.lhs.true403
  %56 = load %struct.sv** %53, align 8, !tbaa !3
  %sv_any407 = getelementptr inbounds %struct.sv* %56, i64 0, i32 0
  %57 = load i8** %sv_any407, align 8, !tbaa !3
  %xrv_rv = bitcast i8* %57 to %struct.sv**
  %58 = load %struct.sv** %xrv_rv, align 8, !tbaa !3
  %59 = bitcast %struct.sv* %58 to %struct.hv*
  %conv408 = zext i32 %final.0.lcssa to i64
  %call409 = call %struct.sv* @Perl_newSVuv(i64 %conv408) #7
  %call410 = call %struct.sv** @Perl_hv_store(%struct.hv* %59, i8* getelementptr inbounds ([6 x i8]* @.str41, i64 0, i64 0), i32 5, %struct.sv* %call409, i32 0) #7
  br label %if.end411

if.end411:                                        ; preds = %if.end399, %land.lhs.true403, %if.then405
  %tobool412 = icmp eq i32 %grows.0.lcssa, 0
  br i1 %tobool412, label %if.end418, label %if.then413

if.then413:                                       ; preds = %if.end411
  %60 = load i8* %op_private, align 1, !tbaa !1
  %or416 = or i8 %60, 64
  store i8 %or416, i8* %op_private, align 1, !tbaa !1
  br label %if.end418

if.end418:                                        ; preds = %if.end411, %if.then413
  %tobool419 = icmp eq i8* %tsave.0, null
  br i1 %tobool419, label %if.end421, label %if.then420

if.then420:                                       ; preds = %if.end418
  call void @Perl_safesysfree(i8* %tsave.0) #7
  br label %if.end421

if.end421:                                        ; preds = %if.end418, %if.then420
  %tobool422 = icmp eq i8* %rsave.0, null
  br i1 %tobool422, label %if.end424, label %if.then423

if.then423:                                       ; preds = %if.end421
  call void @Perl_safesysfree(i8* %rsave.0) #7
  br label %if.end424

if.end424:                                        ; preds = %if.end421, %if.then423
  call void @Perl_op_free(%struct.op* %expr) #8
  call void @Perl_op_free(%struct.op* %repl) #8
  br label %return

if.end425:                                        ; preds = %if.end36
  %op_pv426 = getelementptr inbounds %struct.op* %o, i64 1
  %61 = bitcast %struct.op* %op_pv426 to i8**
  %62 = load i8** %61, align 8, !tbaa !3
  %63 = bitcast i8* %62 to i16*
  %tobool427 = icmp eq i32 %and15, 0
  br i1 %tobool427, label %if.else543, label %if.then428

if.then428:                                       ; preds = %if.end425
  call void @llvm.memset.p0i8.i64(i8* %62, i8 0, i64 512, i32 1, i1 false)
  %64 = load i64* %tlen, align 8, !tbaa !5
  %conv430963 = trunc i64 %64 to i32
  %cmp431964 = icmp sgt i32 %conv430963, 0
  br i1 %cmp431964, label %for.body433, label %for.cond441.preheader

for.cond441.preheader:                            ; preds = %for.body433, %if.then428
  %tobool453 = icmp eq i32 %and18, 0
  br label %for.body444

for.body433:                                      ; preds = %if.then428, %for.body433
  %indvars.iv998 = phi i64 [ %indvars.iv.next999, %for.body433 ], [ 0, %if.then428 ]
  %arrayidx435 = getelementptr inbounds i8* %cond, i64 %indvars.iv998
  %65 = load i8* %arrayidx435, align 1, !tbaa !1
  %idxprom436 = zext i8 %65 to i64
  %arrayidx437 = getelementptr inbounds i16* %63, i64 %idxprom436
  store i16 -1, i16* %arrayidx437, align 2, !tbaa !4
  %indvars.iv.next999 = add i64 %indvars.iv998, 1
  %66 = trunc i64 %indvars.iv.next999 to i32
  %cmp431 = icmp slt i32 %66, %conv430963
  br i1 %cmp431, label %for.body433, label %for.cond441.preheader

for.body444:                                      ; preds = %for.inc491.for.body444_crit_edge, %for.cond441.preheader
  %indvars.iv996 = phi i64 [ 0, %for.cond441.preheader ], [ %indvars.iv.next997, %for.inc491.for.body444_crit_edge ]
  %i.2962 = phi i32 [ 0, %for.cond441.preheader ], [ %inc492, %for.inc491.for.body444_crit_edge ]
  %j.1961 = phi i32 [ 0, %for.cond441.preheader ], [ %j.2, %for.inc491.for.body444_crit_edge ]
  %grows.3960 = phi i32 [ 0, %for.cond441.preheader ], [ %grows.5, %for.inc491.for.body444_crit_edge ]
  %arrayidx446 = getelementptr inbounds i16* %63, i64 %indvars.iv996
  %67 = load i16* %arrayidx446, align 2, !tbaa !4
  %tobool447 = icmp eq i16 %67, 0
  br i1 %tobool447, label %if.then448, label %for.inc491

if.then448:                                       ; preds = %for.body444
  %68 = load i64* %rlen, align 8, !tbaa !5
  %conv449 = trunc i64 %68 to i32
  %cmp450 = icmp slt i32 %j.1961, %conv449
  br i1 %cmp450, label %if.else472, label %if.then452

if.then452:                                       ; preds = %if.then448
  br i1 %tobool453, label %if.else457, label %if.then454

if.then454:                                       ; preds = %if.then452
  store i16 -2, i16* %arrayidx446, align 2, !tbaa !4
  br label %for.inc491

if.else457:                                       ; preds = %if.then452
  %tobool458 = icmp eq i64 %68, 0
  br i1 %tobool458, label %if.else466, label %if.then459

if.then459:                                       ; preds = %if.else457
  %sub460 = add nsw i32 %j.1961, -1
  %idxprom461 = sext i32 %sub460 to i64
  %arrayidx462 = getelementptr inbounds i8* %cond14, i64 %idxprom461
  %69 = load i8* %arrayidx462, align 1, !tbaa !1
  %conv463 = zext i8 %69 to i16
  store i16 %conv463, i16* %arrayidx446, align 2, !tbaa !4
  br label %for.inc491

if.else466:                                       ; preds = %if.else457
  %conv467 = trunc i32 %i.2962 to i16
  store i16 %conv467, i16* %arrayidx446, align 2, !tbaa !4
  br label %for.inc491

if.else472:                                       ; preds = %if.then448
  %70 = trunc i64 %indvars.iv996 to i32
  %cmp473 = icmp slt i32 %70, 128
  %idxprom476 = sext i32 %j.1961 to i64
  %arrayidx477 = getelementptr inbounds i8* %cond14, i64 %idxprom476
  %71 = load i8* %arrayidx477, align 1, !tbaa !1
  br i1 %cmp473, label %land.lhs.true475, label %if.end482

land.lhs.true475:                                 ; preds = %if.else472
  %cmp479 = icmp slt i8 %71, 0
  %.grows.3 = select i1 %cmp479, i32 1, i32 %grows.3960
  br label %if.end482

if.end482:                                        ; preds = %if.else472, %land.lhs.true475
  %grows.4 = phi i32 [ %.grows.3, %land.lhs.true475 ], [ %grows.3960, %if.else472 ]
  %inc483 = add nsw i32 %j.1961, 1
  %conv486 = zext i8 %71 to i16
  store i16 %conv486, i16* %arrayidx446, align 2, !tbaa !4
  br label %for.inc491

for.inc491:                                       ; preds = %for.body444, %if.then454, %if.else466, %if.then459, %if.end482
  %grows.5 = phi i32 [ %grows.3960, %for.body444 ], [ %grows.3960, %if.then454 ], [ %grows.3960, %if.then459 ], [ %grows.3960, %if.else466 ], [ %grows.4, %if.end482 ]
  %j.2 = phi i32 [ %j.1961, %for.body444 ], [ %j.1961, %if.then454 ], [ %j.1961, %if.then459 ], [ %j.1961, %if.else466 ], [ %inc483, %if.end482 ]
  %indvars.iv.next997 = add i64 %indvars.iv996, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next997 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 256
  br i1 %exitcond, label %for.end493, label %for.inc491.for.body444_crit_edge

for.inc491.for.body444_crit_edge:                 ; preds = %for.inc491
  %inc492 = add nsw i32 %i.2962, 1
  br label %for.body444

for.end493:                                       ; preds = %for.inc491
  br i1 %tobool453, label %if.then495, label %if.end638

if.then495:                                       ; preds = %for.end493
  %72 = load i64* %rlen, align 8, !tbaa !5
  %tobool496 = icmp eq i64 %72, 0
  %conv498 = trunc i64 %72 to i32
  br i1 %tobool496, label %if.then497, label %if.else506

if.then497:                                       ; preds = %if.then495
  %tobool499 = icmp eq i32 %and21, 0
  br i1 %tobool499, label %if.then500, label %if.end521

if.then500:                                       ; preds = %if.then497
  %73 = load i8* %op_private, align 1, !tbaa !1
  %or503 = or i8 %73, 4
  store i8 %or503, i8* %op_private, align 1, !tbaa !1
  br label %if.end521

if.else506:                                       ; preds = %if.then495
  %cmp508 = icmp slt i32 %j.2, %conv498
  br i1 %cmp508, label %if.else513, label %if.then510

if.then510:                                       ; preds = %if.else506
  %sub511 = add i64 %72, 4294967295
  %conv512 = trunc i64 %sub511 to i32
  br label %if.end521

if.else513:                                       ; preds = %if.else506
  %conv515 = sext i32 %j.2 to i64
  %add514 = sub i64 257, %conv515
  %sub516 = add i64 %add514, %72
  %mul517 = shl i64 %sub516, 1
  %call518 = call i8* @Perl_safesysrealloc(i8* %62, i64 %mul517) #7
  %74 = bitcast i8* %call518 to i16*
  %75 = getelementptr inbounds %struct.op* %op_pv426, i64 0, i32 0
  %call518.c = bitcast i8* %call518 to %struct.op*
  store %struct.op* %call518.c, %struct.op** %75, align 8, !tbaa !3
  %.pre = load i64* %rlen, align 8, !tbaa !5
  br label %if.end521

if.end521:                                        ; preds = %if.then497, %if.then510, %if.else513, %if.then500
  %76 = phi i64 [ %72, %if.then510 ], [ %.pre, %if.else513 ], [ 0, %if.then497 ], [ 0, %if.then500 ]
  %tbl.0 = phi i16* [ %63, %if.then510 ], [ %74, %if.else513 ], [ %63, %if.then497 ], [ %63, %if.then500 ]
  %j.3 = phi i32 [ %conv512, %if.then510 ], [ %j.2, %if.else513 ], [ %conv498, %if.then497 ], [ %conv498, %if.then500 ]
  %conv522908 = zext i32 %j.3 to i64
  %sub523 = sub i64 %76, %conv522908
  %conv524 = trunc i64 %sub523 to i16
  %arrayidx525 = getelementptr inbounds i16* %tbl.0, i64 256
  store i16 %conv524, i16* %arrayidx525, align 2, !tbaa !4
  %conv527956 = trunc i64 %76 to i32
  %sub528957 = sub nsw i32 %conv527956, %j.3
  %cmp529958 = icmp sgt i32 %sub528957, 0
  br i1 %cmp529958, label %for.body531.lr.ph, label %if.end638

for.body531.lr.ph:                                ; preds = %if.end521
  %77 = sext i32 %j.3 to i64
  br label %for.body531

for.body531:                                      ; preds = %for.body531.lr.ph, %for.body531
  %indvars.iv992 = phi i64 [ 0, %for.body531.lr.ph ], [ %indvars.iv.next993, %for.body531 ]
  %78 = add nsw i64 %indvars.iv992, %77
  %arrayidx534 = getelementptr inbounds i8* %cond14, i64 %78
  %79 = load i8* %arrayidx534, align 1, !tbaa !1
  %conv535 = zext i8 %79 to i16
  %80 = add nsw i64 %indvars.iv992, 257
  %arrayidx538 = getelementptr inbounds i16* %tbl.0, i64 %80
  store i16 %conv535, i16* %arrayidx538, align 2, !tbaa !4
  %indvars.iv.next993 = add i64 %indvars.iv992, 1
  %81 = trunc i64 %indvars.iv.next993 to i32
  %cmp529 = icmp slt i32 %81, %sub528957
  br i1 %cmp529, label %for.body531, label %if.end638

if.else543:                                       ; preds = %if.end425
  %82 = load i64* %rlen, align 8, !tbaa !5
  %tobool544 = icmp eq i64 %82, 0
  %tobool546 = icmp eq i32 %and18, 0
  %or.cond919 = and i1 %tobool544, %tobool546
  br i1 %or.cond919, label %if.then547, label %if.else555

if.then547:                                       ; preds = %if.else543
  %83 = load i64* %tlen, align 8, !tbaa !5
  store i64 %83, i64* %rlen, align 8, !tbaa !5
  %tobool548 = icmp eq i32 %and21, 0
  br i1 %tobool548, label %if.then549, label %if.end569

if.then549:                                       ; preds = %if.then547
  %or552 = or i8 %19, 4
  store i8 %or552, i8* %op_private, align 1, !tbaa !1
  br label %if.end569

if.else555:                                       ; preds = %if.else543
  %tobool556 = icmp eq i32 %and21, 0
  %84 = load i64* %tlen, align 8, !tbaa !5
  %cmp558 = icmp eq i64 %82, %84
  %or.cond1012 = and i1 %tobool556, %cmp558
  br i1 %or.cond1012, label %land.lhs.true560, label %if.end569

land.lhs.true560:                                 ; preds = %if.else555
  %call561 = call i32 @memcmp(i8* %cond, i8* %cond14, i64 %82) #7
  %tobool562 = icmp eq i32 %call561, 0
  br i1 %tobool562, label %if.then563, label %if.end569

if.then563:                                       ; preds = %land.lhs.true560
  %or566 = or i8 %19, 4
  store i8 %or566, i8* %op_private, align 1, !tbaa !1
  br label %if.end569

if.end569:                                        ; preds = %if.else555, %land.lhs.true560, %if.then547, %if.then563, %if.then549
  %85 = phi i64 [ %82, %land.lhs.true560 ], [ %82, %if.then563 ], [ %83, %if.then547 ], [ %83, %if.then549 ], [ %84, %if.else555 ]
  %86 = phi i64 [ %82, %land.lhs.true560 ], [ %82, %if.then563 ], [ %83, %if.then547 ], [ %83, %if.then549 ], [ %82, %if.else555 ]
  %r.4 = phi i8* [ %cond14, %land.lhs.true560 ], [ %cond14, %if.then563 ], [ %cond, %if.then547 ], [ %cond, %if.then549 ], [ %cond14, %if.else555 ]
  call void @llvm.memset.p0i8.i64(i8* %62, i8 -1, i64 512, i32 2, i1 false)
  %conv580948 = trunc i64 %85 to i32
  %cmp581949 = icmp sgt i32 %conv580948, 0
  br i1 %cmp581949, label %for.body583, label %if.end645

for.body583:                                      ; preds = %if.end569, %for.inc634
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc634 ], [ 0, %if.end569 ]
  %j.4951 = phi i32 [ %inc636, %for.inc634 ], [ 0, %if.end569 ]
  %grows.6950 = phi i32 [ %grows.8, %for.inc634 ], [ 0, %if.end569 ]
  %conv584 = trunc i64 %86 to i32
  %cmp585 = icmp slt i32 %j.4951, %conv584
  br i1 %cmp585, label %if.end604, label %if.then587

if.then587:                                       ; preds = %for.body583
  br i1 %tobool546, label %if.end603, label %if.then589

if.then589:                                       ; preds = %if.then587
  %arrayidx591 = getelementptr inbounds i8* %cond, i64 %indvars.iv
  %87 = load i8* %arrayidx591, align 1, !tbaa !1
  %idxprom592 = zext i8 %87 to i64
  %arrayidx593 = getelementptr inbounds i16* %63, i64 %idxprom592
  %88 = load i16* %arrayidx593, align 2, !tbaa !4
  %cmp595 = icmp eq i16 %88, -1
  br i1 %cmp595, label %if.then597, label %for.inc634

if.then597:                                       ; preds = %if.then589
  store i16 -2, i16* %arrayidx593, align 2, !tbaa !4
  br label %for.inc634

if.end603:                                        ; preds = %if.then587
  %dec = add nsw i32 %j.4951, -1
  br label %if.end604

if.end604:                                        ; preds = %for.body583, %if.end603
  %j.5 = phi i32 [ %dec, %if.end603 ], [ %j.4951, %for.body583 ]
  %arrayidx606 = getelementptr inbounds i8* %cond, i64 %indvars.iv
  %89 = load i8* %arrayidx606, align 1, !tbaa !1
  %idxprom607 = zext i8 %89 to i64
  %arrayidx608 = getelementptr inbounds i16* %63, i64 %idxprom607
  %90 = load i16* %arrayidx608, align 2, !tbaa !4
  %cmp610 = icmp eq i16 %90, -1
  br i1 %cmp610, label %if.then612, label %for.inc634

if.then612:                                       ; preds = %if.end604
  %cmp616 = icmp sgt i8 %89, -1
  %idxprom619 = sext i32 %j.5 to i64
  %arrayidx620 = getelementptr inbounds i8* %r.4, i64 %idxprom619
  %91 = load i8* %arrayidx620, align 1, !tbaa !1
  br i1 %cmp616, label %land.lhs.true618, label %if.end625

land.lhs.true618:                                 ; preds = %if.then612
  %cmp622 = icmp slt i8 %91, 0
  %.grows.6 = select i1 %cmp622, i32 1, i32 %grows.6950
  br label %if.end625

if.end625:                                        ; preds = %if.then612, %land.lhs.true618
  %grows.7 = phi i32 [ %.grows.6, %land.lhs.true618 ], [ %grows.6950, %if.then612 ]
  %conv628 = zext i8 %91 to i16
  store i16 %conv628, i16* %arrayidx608, align 2, !tbaa !4
  br label %for.inc634

for.inc634:                                       ; preds = %if.end604, %if.end625, %if.then589, %if.then597
  %grows.8 = phi i32 [ %grows.6950, %if.then597 ], [ %grows.6950, %if.then589 ], [ %grows.7, %if.end625 ], [ %grows.6950, %if.end604 ]
  %j.6 = phi i32 [ %j.4951, %if.then597 ], [ %j.4951, %if.then589 ], [ %j.5, %if.end625 ], [ %j.5, %if.end604 ]
  %indvars.iv.next = add i64 %indvars.iv, 1
  %inc636 = add nsw i32 %j.6, 1
  %92 = trunc i64 %indvars.iv.next to i32
  %cmp581 = icmp slt i32 %92, %conv580948
  br i1 %cmp581, label %for.body583, label %if.end638

if.end638:                                        ; preds = %if.end521, %for.body531, %for.inc634, %for.end493
  %grows.9 = phi i32 [ %grows.5, %for.end493 ], [ %grows.8, %for.inc634 ], [ %grows.5, %for.body531 ], [ %grows.5, %if.end521 ]
  %tobool639 = icmp eq i32 %grows.9, 0
  br i1 %tobool639, label %if.end645, label %if.then640

if.then640:                                       ; preds = %if.end638
  %93 = load i8* %op_private, align 1, !tbaa !1
  %or643 = or i8 %93, 64
  store i8 %or643, i8* %op_private, align 1, !tbaa !1
  br label %if.end645

if.end645:                                        ; preds = %if.end569, %if.end638, %if.then640
  call void @Perl_op_free(%struct.op* %expr) #8
  call void @Perl_op_free(%struct.op* %repl) #8
  br label %return

return:                                           ; preds = %if.end645, %if.end424
  ret %struct.op* %o
}

; Function Attrs: optsize
declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i32) #2

; Function Attrs: optsize
declare i8* @Perl_bytes_to_utf8(i8*, i64*) #2

; Function Attrs: optsize
declare i64 @Perl_utf8n_to_uvuni(i8*, i64, i64*, i32) #2

; Function Attrs: optsize
declare void @qsort(i8*, i64, i64, i32 (i8*, i8*)* nocapture) #2

; Function Attrs: nounwind optsize readonly uwtable
define internal i32 @uvcompare(i8* nocapture %a, i8* nocapture %b) #5 {
entry:
  %0 = bitcast i8* %a to i64*
  %1 = load i64* %0, align 8, !tbaa !5
  %2 = bitcast i8* %b to i64*
  %3 = load i64* %2, align 8, !tbaa !5
  %cmp = icmp ult i64 %1, %3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i64 %1, %3
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %add.ptr = getelementptr inbounds i8* %a, i64 8
  %4 = bitcast i8* %add.ptr to i64*
  %5 = load i64* %4, align 8, !tbaa !5
  %add = add i64 %3, 1
  %cmp4 = icmp ult i64 %5, %add
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end3
  %cmp9 = icmp ugt i64 %5, %add
  %. = zext i1 %cmp9 to i32
  br label %return

return:                                           ; preds = %if.end6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ 1, %if.end ], [ -1, %if.end3 ], [ %., %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: optsize
declare i8* @Perl_uvuni_to_utf8(i8*, i64) #2

; Function Attrs: optsize
declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i32) #2

; Function Attrs: optsize
declare i8* @Perl_uvuni_to_utf8_flags(i8*, i64, i64) #2

; Function Attrs: nounwind optsize readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) #1

; Function Attrs: optsize
declare void @Perl_sv_catpvf(%struct.sv*, i8*, ...) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_swash_init(i8*, i8*, %struct.sv*, i32, i32) #2

; Function Attrs: optsize
declare %struct.sv** @Perl_hv_store(%struct.hv*, i8*, i32, %struct.sv*, i32) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVuv(i64) #2

; Function Attrs: optsize
declare i8* @Perl_safesysrealloc(i8*, i64) #2

; Function Attrs: optsize
declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #2

; Function Attrs: nounwind optsize readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) #1

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newPADOP(i32 %type, i32 %flags, %struct.sv* %sv) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 48) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !3
  %call1 = tail call i64 @Perl_pad_alloc(i32 %type, i32 512) #7
  %op_padix = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_padix to i64*
  store i64 %call1, i64* %3, align 8, !tbaa !5
  %4 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx3 = getelementptr inbounds %struct.sv** %4, i64 %call1
  %5 = load %struct.sv** %arrayidx3, align 8, !tbaa !3
  tail call void @Perl_sv_free(%struct.sv* %5) #7
  %6 = load i64* %3, align 8, !tbaa !5
  %7 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx5 = getelementptr inbounds %struct.sv** %7, i64 %6
  store %struct.sv* %sv, %struct.sv** %arrayidx5, align 8, !tbaa !3
  %tobool = icmp eq %struct.sv* %sv, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sv_flags = getelementptr inbounds %struct.sv* %sv, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !0
  %or = or i32 %8, 768
  store i32 %or, i32* %sv_flags, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %9 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %9, %struct.op** %op_next, align 8, !tbaa !3
  %conv6 = trunc i32 %flags to i8
  %10 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv6, i8* %10, align 1, !tbaa !1
  %arrayidx8 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %11 = load i32* %arrayidx8, align 4, !tbaa !0
  %and = and i32 %11, 4
  %tobool9 = icmp eq i32 %and, 0
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end
  %call11 = tail call %struct.op* @Perl_scalar(%struct.op* %9) #8
  %.pre = load i32* %arrayidx8, align 4, !tbaa !0
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then10
  %12 = phi i32 [ %11, %if.end ], [ %.pre, %if.then10 ]
  %and15 = and i32 %12, 8
  %tobool16 = icmp eq i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end12
  %call18 = tail call i64 @Perl_pad_alloc(i32 %type, i32 512) #7
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %13 = bitcast i8* %op_targ to i64*
  store i64 %call18, i64* %13, align 8, !tbaa !5
  br label %if.end19

if.end19:                                         ; preds = %if.end12, %if.then17
  %14 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool20 = icmp eq i8* %14, null
  br i1 %tobool20, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end19
  %arrayidx22 = getelementptr inbounds i8* %14, i64 %idxprom
  %15 = load i8* %arrayidx22, align 1, !tbaa !1
  %tobool24 = icmp eq i8 %15, 0
  br i1 %tobool24, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %9) #8
  %arrayidx26 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %16 = load i8** %arrayidx26, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %16) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end19
  %arrayidx28 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %17 = load %struct.op* (%struct.op*)** %arrayidx28, align 8, !tbaa !3
  %call29 = tail call %struct.op* %17(%struct.op* %9) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call29, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newPVOP(i32 %type, i32 %flags, i8* %pv) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 48) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 48, i32 1, i1 false)
  %conv = trunc i32 %type to i16
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 %conv, i16* %0, align 2, !tbaa !4
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %1 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !3
  %op_pv = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_pv to i8**
  store i8* %pv, i8** %3, align 8, !tbaa !3
  %4 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %4, %struct.op** %op_next, align 8, !tbaa !3
  %conv1 = trunc i32 %flags to i8
  %5 = getelementptr inbounds i8* %call, i64 36
  store i8 %conv1, i8* %5, align 1, !tbaa !1
  %arrayidx3 = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %6 = load i32* %arrayidx3, align 4, !tbaa !0
  %and = and i32 %6, 4
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = tail call %struct.op* @Perl_scalar(%struct.op* %4) #8
  %.pre = load i32* %arrayidx3, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %7 = phi i32 [ %6, %entry ], [ %.pre, %if.then ]
  %and7 = and i32 %7, 8
  %tobool8 = icmp eq i32 %and7, 0
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end
  %call10 = tail call i64 @Perl_pad_alloc(i32 %type, i32 512) #7
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %8 = bitcast i8* %op_targ to i64*
  store i64 %call10, i64* %8, align 8, !tbaa !5
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then9
  %9 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool12 = icmp eq i8* %9, null
  br i1 %tobool12, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end11
  %arrayidx14 = getelementptr inbounds i8* %9, i64 %idxprom
  %10 = load i8* %arrayidx14, align 1, !tbaa !1
  %tobool16 = icmp eq i8 %10, 0
  br i1 %tobool16, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  tail call void @Perl_op_free(%struct.op* %4) #8
  %arrayidx18 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %11 = load i8** %arrayidx18, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %11) #7
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end11
  %arrayidx20 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom
  %12 = load %struct.op* (%struct.op*)** %arrayidx20, align 8, !tbaa !3
  %call21 = tail call %struct.op* %12(%struct.op* %4) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call21, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind optsize uwtable
define void @Perl_package(%struct.op* %o) #0 {
entry:
  %len = alloca i64, align 8
  call void @Perl_save_hptr(%struct.hv** @PL_curstash) #7
  %0 = load %struct.sv** @PL_curstname, align 8, !tbaa !3
  call void @Perl_save_item(%struct.sv* %0) #7
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %1 = bitcast %struct.op* %op_sv to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %3, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %2, i64 0, i32 0
  %4 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %4, i64 8
  %5 = bitcast i8* %xpv_cur to i64*
  %6 = load i64* %5, align 8, !tbaa !5
  store i64 %6, i64* %len, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %4 to i8**
  %7 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %2, i64* %len, i32 2) #7
  %.pre = load i64* %len, align 8, !tbaa !5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %8 = phi i64 [ %6, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %7, %cond.true ], [ %call, %cond.false ]
  %conv = trunc i64 %8 to i32
  %call2 = call %struct.hv* @Perl_gv_stashpvn(i8* %cond, i32 %conv, i32 1) #7
  store %struct.hv* %call2, %struct.hv** @PL_curstash, align 8, !tbaa !3
  %9 = load %struct.sv** @PL_curstname, align 8, !tbaa !3
  %10 = load i64* %len, align 8, !tbaa !5
  call void @Perl_sv_setpvn(%struct.sv* %9, i8* %cond, i64 %10) #7
  call void @Perl_op_free(%struct.op* %o) #8
  br label %if.end

if.else:                                          ; preds = %entry
  call void @Perl_deprecate(i8* getelementptr inbounds ([28 x i8]* @.str44, i64 0, i64 0)) #7
  %11 = load %struct.sv** @PL_curstname, align 8, !tbaa !3
  call void @Perl_sv_setpv(%struct.sv* %11, i8* getelementptr inbounds ([7 x i8]* @.str45, i64 0, i64 0)) #7
  store %struct.hv* null, %struct.hv** @PL_curstash, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  %12 = load i32* @PL_hints, align 4, !tbaa !0
  %or = or i32 %12, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  store i32 -1, i32* @PL_copline, align 4, !tbaa !0
  store i32 3, i32* @PL_expect, align 4, !tbaa !0
  ret void
}

; Function Attrs: optsize
declare void @Perl_save_hptr(%struct.hv**) #2

; Function Attrs: optsize
declare void @Perl_save_item(%struct.sv*) #2

; Function Attrs: optsize
declare %struct.hv* @Perl_gv_stashpvn(i8*, i32, i32) #2

; Function Attrs: optsize
declare void @Perl_deprecate(i8*) #2

; Function Attrs: optsize
declare void @Perl_sv_setpv(%struct.sv*, i8*) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_utilize(i32 %aver, i32 %floor, %struct.op* %version, %struct.op* %idop, %struct.op* %arg) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %idop, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 5
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str46, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %cmp2 = icmp eq %struct.op* %version, null
  br i1 %cmp2, label %if.end47, label %if.then4

if.then4:                                         ; preds = %if.end
  %op_sv = getelementptr inbounds %struct.op* %version, i64 1
  %1 = bitcast %struct.op* %op_sv to %struct.sv**
  %2 = load %struct.sv** %1, align 8, !tbaa !3
  %cmp5 = icmp eq %struct.op* %arg, null
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then4
  %sv_flags = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %3 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %3, 50331648
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end47, label %if.else

if.else:                                          ; preds = %land.lhs.true, %if.then4
  %op_type9 = getelementptr inbounds %struct.op* %version, i64 0, i32 4
  %4 = load i16* %op_type9, align 2, !tbaa !4
  %cmp11 = icmp eq i16 %4, 5
  br i1 %cmp11, label %lor.lhs.false, label %if.then16

lor.lhs.false:                                    ; preds = %if.else
  %sv_flags13 = getelementptr inbounds %struct.sv* %2, i64 0, i32 2
  %5 = load i32* %sv_flags13, align 4, !tbaa !0
  %and14 = and i32 %5, 50331648
  %tobool15 = icmp eq i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.else
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([39 x i8]* @.str47, i64 0, i64 0)) #7
  br label %if.end17

if.end17:                                         ; preds = %lor.lhs.false, %if.then16
  %op_sv18 = getelementptr inbounds %struct.op* %idop, i64 1
  %6 = bitcast %struct.op* %op_sv18 to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !3
  %call = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %7) #7
  %call19 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call) #8
  %call20 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([8 x i8]* @.str48, i64 0, i64 0), i64 7) #7
  %call21 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call20, i32 5) #7
  %sv_flags22 = getelementptr inbounds %struct.sv* %call20, i64 0, i32 2
  %8 = load i32* %sv_flags22, align 4, !tbaa !0
  %and23 = and i32 %8, 2097152
  %tobool24 = icmp eq i32 %and23, 0
  br i1 %tobool24, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end17
  %call25 = tail call i32 @Perl_sv_backoff(%struct.sv* %call20) #7
  %.pre192 = load i32* %sv_flags22, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %if.end17, %land.rhs
  %9 = phi i32 [ %8, %if.end17 ], [ %.pre192, %land.rhs ]
  %or = or i32 %9, 16842752
  store i32 %or, i32* %sv_flags22, align 4, !tbaa !0
  %sv_any = getelementptr inbounds %struct.sv* %call20, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur to i64*
  %12 = load i64* %11, align 8, !tbaa !5
  %conv29 = trunc i64 %12 to i32
  %tobool30185 = icmp eq i32 %conv29, 0
  br i1 %tobool30185, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %land.end
  %xpv_pv = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %hash_PeRlHaSh.0188 = phi i32 [ 0, %while.body.lr.ph ], [ %xor, %while.body ]
  %i_PeRlHaSh.0187 = phi i32 [ %conv29, %while.body.lr.ph ], [ %dec, %while.body ]
  %s_PeRlHaSh.0186 = phi i8* [ %13, %while.body.lr.ph ], [ %incdec.ptr, %while.body ]
  %dec = add nsw i32 %i_PeRlHaSh.0187, -1
  %incdec.ptr = getelementptr inbounds i8* %s_PeRlHaSh.0186, i64 1
  %14 = load i8* %s_PeRlHaSh.0186, align 1, !tbaa !1
  %conv31 = zext i8 %14 to i32
  %add = add i32 %conv31, %hash_PeRlHaSh.0188
  %add32 = mul i32 %add, 1025
  %shr = lshr i32 %add32, 6
  %xor = xor i32 %shr, %add32
  %tobool30 = icmp eq i32 %dec, 0
  br i1 %tobool30, label %while.cond.while.end_crit_edge, label %while.body

while.cond.while.end_crit_edge:                   ; preds = %while.body
  %phitmp = mul i32 %xor, 9
  br label %while.end

while.end:                                        ; preds = %while.cond.while.end_crit_edge, %land.end
  %hash_PeRlHaSh.0.lcssa = phi i32 [ %phitmp, %while.cond.while.end_crit_edge ], [ 0, %land.end ]
  %shr35 = lshr i32 %hash_PeRlHaSh.0.lcssa, 11
  %xor36 = xor i32 %shr35, %hash_PeRlHaSh.0.lcssa
  %add38 = mul i32 %xor36, 32769
  %conv39 = zext i32 %add38 to i64
  %xuv_uv = getelementptr inbounds i8* %10, i64 24
  %15 = bitcast i8* %xuv_uv to i64*
  store i64 %conv39, i64* %15, align 8, !tbaa !5
  %call41 = tail call %struct.op* @Perl_list(%struct.op* %version) #8
  %call42 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call19, %struct.op* %call41) #8
  %call43 = tail call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %call20) #8
  %call44 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call42, %struct.op* %call43) #8
  %call45 = tail call %struct.op* @Perl_convert(i32 166, i32 192, %struct.op* %call44) #8
  br label %if.end47

if.end47:                                         ; preds = %land.lhs.true, %if.end, %while.end
  %veop.0 = phi %struct.op* [ %call45, %while.end ], [ null, %if.end ], [ null, %land.lhs.true ]
  %arg.addr.0 = phi %struct.op* [ %arg, %while.end ], [ %arg, %if.end ], [ %version, %land.lhs.true ]
  %tobool48 = icmp eq %struct.op* %arg.addr.0, null
  br i1 %tobool48, label %if.else55, label %land.lhs.true49

land.lhs.true49:                                  ; preds = %if.end47
  %op_type50 = getelementptr inbounds %struct.op* %arg.addr.0, i64 0, i32 4
  %16 = load i16* %op_type50, align 2, !tbaa !4
  %cmp52 = icmp eq i16 %16, 1
  br i1 %cmp52, label %if.end122, label %if.else55

if.else55:                                        ; preds = %if.end47, %land.lhs.true49
  %op_sv56 = getelementptr inbounds %struct.op* %idop, i64 1
  %17 = bitcast %struct.op* %op_sv56 to %struct.sv**
  %18 = load %struct.sv** %17, align 8, !tbaa !3
  %sv_flags57 = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags57, align 4, !tbaa !0
  %and58 = and i32 %19, 50331648
  %tobool59 = icmp eq i32 %and58, 0
  br i1 %tobool59, label %if.else61, label %if.end122

if.else61:                                        ; preds = %if.else55
  %call64 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %18) #7
  %call65 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call64) #8
  %tobool66 = icmp eq i32 %aver, 0
  br i1 %tobool66, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else61
  %call67 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([7 x i8]* @.str49, i64 0, i64 0), i64 6) #7
  br label %cond.end

cond.false:                                       ; preds = %if.else61
  %call68 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([9 x i8]* @.str50, i64 0, i64 0), i64 8) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %call67, %cond.true ], [ %call68, %cond.false ]
  %sv_flags69 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 2
  %20 = load i32* %sv_flags69, align 4, !tbaa !0
  %and70 = and i32 %20, 255
  %cmp71 = icmp ugt i32 %and70, 4
  br i1 %cmp71, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %call73 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %cond, i32 5) #7
  %.pre = load i32* %sv_flags69, align 4, !tbaa !0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %21 = phi i32 [ %.pre, %lor.rhs ], [ %20, %cond.end ]
  %and77 = and i32 %21, 2097152
  %tobool78 = icmp eq i32 %and77, 0
  br i1 %tobool78, label %land.end82, label %land.rhs79

land.rhs79:                                       ; preds = %lor.end
  %call80 = tail call i32 @Perl_sv_backoff(%struct.sv* %cond) #7
  %.pre191 = load i32* %sv_flags69, align 4, !tbaa !0
  br label %land.end82

land.end82:                                       ; preds = %lor.end, %land.rhs79
  %22 = phi i32 [ %21, %lor.end ], [ %.pre191, %land.rhs79 ]
  %or85 = or i32 %22, 16842752
  store i32 %or85, i32* %sv_flags69, align 4, !tbaa !0
  %sv_any87 = getelementptr inbounds %struct.sv* %cond, i64 0, i32 0
  %23 = load i8** %sv_any87, align 8, !tbaa !3
  %xpv_cur92 = getelementptr inbounds i8* %23, i64 8
  %24 = bitcast i8* %xpv_cur92 to i64*
  %25 = load i64* %24, align 8, !tbaa !5
  %conv93 = trunc i64 %25 to i32
  %tobool97181 = icmp eq i32 %conv93, 0
  br i1 %tobool97181, label %while.end106, label %while.body98.lr.ph

while.body98.lr.ph:                               ; preds = %land.end82
  %xpv_pv88 = bitcast i8* %23 to i8**
  %26 = load i8** %xpv_pv88, align 8, !tbaa !3
  br label %while.body98

while.body98:                                     ; preds = %while.body98.lr.ph, %while.body98
  %hash_PeRlHaSh94.0184 = phi i32 [ 0, %while.body98.lr.ph ], [ %xor105, %while.body98 ]
  %i_PeRlHaSh90.0183 = phi i32 [ %conv93, %while.body98.lr.ph ], [ %dec96, %while.body98 ]
  %s_PeRlHaSh89.0182 = phi i8* [ %26, %while.body98.lr.ph ], [ %incdec.ptr99, %while.body98 ]
  %dec96 = add nsw i32 %i_PeRlHaSh90.0183, -1
  %incdec.ptr99 = getelementptr inbounds i8* %s_PeRlHaSh89.0182, i64 1
  %27 = load i8* %s_PeRlHaSh89.0182, align 1, !tbaa !1
  %conv100 = zext i8 %27 to i32
  %add101 = add i32 %conv100, %hash_PeRlHaSh94.0184
  %add103 = mul i32 %add101, 1025
  %shr104 = lshr i32 %add103, 6
  %xor105 = xor i32 %shr104, %add103
  %tobool97 = icmp eq i32 %dec96, 0
  br i1 %tobool97, label %while.cond95.while.end106_crit_edge, label %while.body98

while.cond95.while.end106_crit_edge:              ; preds = %while.body98
  %phitmp190 = mul i32 %xor105, 9
  br label %while.end106

while.end106:                                     ; preds = %while.cond95.while.end106_crit_edge, %land.end82
  %hash_PeRlHaSh94.0.lcssa = phi i32 [ %phitmp190, %while.cond95.while.end106_crit_edge ], [ 0, %land.end82 ]
  %shr109 = lshr i32 %hash_PeRlHaSh94.0.lcssa, 11
  %xor110 = xor i32 %shr109, %hash_PeRlHaSh94.0.lcssa
  %add112 = mul i32 %xor110, 32769
  %conv113 = zext i32 %add112 to i64
  %xuv_uv115 = getelementptr inbounds i8* %23, i64 24
  %28 = bitcast i8* %xuv_uv115 to i64*
  store i64 %conv113, i64* %28, align 8, !tbaa !5
  %call116 = tail call %struct.op* @Perl_list(%struct.op* %arg.addr.0) #8
  %call117 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call65, %struct.op* %call116) #8
  %call118 = tail call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %cond) #8
  %call119 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call117, %struct.op* %call118) #8
  %call120 = tail call %struct.op* @Perl_convert(i32 166, i32 192, %struct.op* %call119) #8
  br label %if.end122

if.end122:                                        ; preds = %if.else55, %land.lhs.true49, %while.end106
  %imop.0 = phi %struct.op* [ %call120, %while.end106 ], [ %arg.addr.0, %land.lhs.true49 ], [ null, %if.else55 ]
  %call123 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0), i64 5) #7
  %call124 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call123) #8
  %call125 = tail call %struct.op* @Perl_newUNOP(i32 309, i32 0, %struct.op* %idop) #8
  %call126 = tail call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* %call125) #8
  %call127 = tail call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* %veop.0) #8
  %call128 = tail call %struct.op* @Perl_append_elem(i32 173, %struct.op* %call126, %struct.op* %call127) #8
  %call129 = tail call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* %imop.0) #8
  %call130 = tail call %struct.op* @Perl_append_elem(i32 173, %struct.op* %call128, %struct.op* %call129) #8
  %call131 = tail call %struct.cv* @Perl_newATTRSUB(i32 %floor, %struct.op* %call124, %struct.op* null, %struct.op* null, %struct.op* %call130) #8
  %29 = load i32* @PL_hints, align 4, !tbaa !0
  %or132 = or i32 %29, 256
  store i32 %or132, i32* @PL_hints, align 4, !tbaa !0
  store i32 -1, i32* @PL_copline, align 4, !tbaa !0
  store i32 3, i32* @PL_expect, align 4, !tbaa !0
  %30 = load i32* @PL_cop_seqmax, align 4, !tbaa !0
  %inc = add i32 %30, 1
  store i32 %inc, i32* @PL_cop_seqmax, align 4, !tbaa !0
  ret void
}

; Function Attrs: optsize
declare signext i8 @Perl_sv_upgrade(%struct.sv*, i32) #2

; Function Attrs: optsize
declare i32 @Perl_sv_backoff(%struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.cv* @Perl_newATTRSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %n_a = alloca i64, align 8
  %tobool = icmp ne %struct.op* %o, null
  br i1 %tobool, label %cond.true, label %cond.end4

cond.true:                                        ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !3
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %2, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true1

cond.true1:                                       ; preds = %cond.true
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !5
  store i64 %5, i64* %n_a, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %3 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end4

cond.false:                                       ; preds = %cond.true
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %n_a, i32 2) #7
  br label %cond.end4

cond.end4:                                        ; preds = %entry, %cond.true1, %cond.false
  %cond5 = phi i8* [ %6, %cond.true1 ], [ %call, %cond.false ], [ null, %entry ]
  %tobool6 = icmp ne %struct.op* %proto, null
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  %op_sv7 = getelementptr inbounds %struct.op* %proto, i64 1
  %7 = bitcast %struct.op* %op_sv7 to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !3
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags8 = getelementptr inbounds %struct.sv* %8, i64 0, i32 2
  %9 = load i32* %sv_flags8, align 4, !tbaa !0
  %and9 = and i32 %9, 262144
  %cmp10 = icmp eq i32 %and9, 0
  br i1 %cmp10, label %cond.false16, label %cond.true11

cond.true11:                                      ; preds = %if.then
  %sv_any12 = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %10 = load i8** %sv_any12, align 8, !tbaa !3
  %xpv_cur13 = getelementptr inbounds i8* %10, i64 8
  %11 = bitcast i8* %xpv_cur13 to i64*
  %12 = load i64* %11, align 8, !tbaa !5
  store i64 %12, i64* %n_a, align 8, !tbaa !5
  %xpv_pv15 = bitcast i8* %10 to i8**
  %13 = load i8** %xpv_pv15, align 8, !tbaa !3
  br label %if.end

cond.false16:                                     ; preds = %if.then
  %call17 = call i8* @Perl_sv_2pv_flags(%struct.sv* %8, i64* %n_a, i32 2) #7
  br label %if.end

if.end:                                           ; preds = %cond.end4, %cond.true11, %cond.false16
  %ps.0 = phi i8* [ %13, %cond.true11 ], [ %call17, %cond.false16 ], [ null, %cond.end4 ]
  %14 = load i32* @PL_perldb, align 4, !tbaa !0
  %notlhs = icmp ne i8* %cond5, null
  %notrhs = icmp eq i32 %14, 0
  %or.cond.not = or i1 %notrhs, %notlhs
  %and23 = and i32 %14, 512
  %tobool24 = icmp eq i32 %and23, 0
  %or.cond953 = or i1 %or.cond.not, %tobool24
  br i1 %or.cond953, label %if.end57, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %if.end
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %15, i64 0, i32 13
  %16 = load i32* %cop_line, align 4, !tbaa !0
  %tobool26 = icmp eq i32 %16, 0
  br i1 %tobool26, label %if.end57, label %if.then27

if.then27:                                        ; preds = %land.lhs.true25
  %call28 = call %struct.sv* @Perl_sv_newmortal() #7
  %17 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %tobool29 = icmp ne %struct.hv* %17, null
  %cond30 = select i1 %tobool29, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str67, i64 0, i64 0)
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv = getelementptr inbounds %struct.cop* %18, i64 0, i32 10
  %19 = load %struct.gv** %cop_filegv, align 8, !tbaa !3
  %tobool31 = icmp eq %struct.gv* %19, null
  br i1 %tobool31, label %cond.end51, label %cond.true32

cond.true32:                                      ; preds = %if.then27
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv33 = getelementptr inbounds %struct.cop* %20, i64 0, i32 10
  %21 = load %struct.gv** %cop_filegv33, align 8, !tbaa !3
  %sv_any34 = getelementptr inbounds %struct.gv* %21, i64 0, i32 0
  %22 = load %struct.xpvgv** %sv_any34, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %22, i64 0, i32 7
  %23 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_sv = getelementptr inbounds %struct.gp* %23, i64 0, i32 0
  %24 = load %struct.sv** %gp_sv, align 8, !tbaa !3
  %tobool35 = icmp eq %struct.sv* %24, null
  br i1 %tobool35, label %cond.end51, label %cond.true37

cond.true37:                                      ; preds = %cond.true32
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv41 = getelementptr inbounds %struct.cop* %26, i64 0, i32 10
  %27 = load %struct.gv** %cop_filegv41, align 8, !tbaa !3
  %sv_any42 = getelementptr inbounds %struct.gv* %27, i64 0, i32 0
  %28 = load %struct.xpvgv** %sv_any42, align 8, !tbaa !3
  %xgv_gp43 = getelementptr inbounds %struct.xpvgv* %28, i64 0, i32 7
  %29 = load %struct.gp** %xgv_gp43, align 8, !tbaa !3
  %gp_sv44 = getelementptr inbounds %struct.gp* %29, i64 0, i32 0
  %30 = load %struct.sv** %gp_sv44, align 8, !tbaa !3
  %sv_any48 = getelementptr inbounds %struct.sv* %30, i64 0, i32 0
  %31 = load i8** %sv_any48, align 8, !tbaa !3
  %xpv_pv49 = bitcast i8* %31 to i8**
  %32 = load i8** %xpv_pv49, align 8, !tbaa !3
  br label %cond.end51

cond.end51:                                       ; preds = %cond.true32, %if.then27, %cond.true37
  %cond52 = phi i8* [ %32, %cond.true37 ], [ null, %if.then27 ], [ null, %cond.true32 ]
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line53 = getelementptr inbounds %struct.cop* %33, i64 0, i32 13
  %34 = load i32* %cop_line53, align 4, !tbaa !0
  %conv = zext i32 %34 to i64
  call void (%struct.sv*, i8*, ...)* @Perl_sv_setpvf(%struct.sv* %call28, i8* getelementptr inbounds ([11 x i8]* @.str65, i64 0, i64 0), i8* %cond30, i8* %cond52, i64 %conv) #7
  %sv_any54 = getelementptr inbounds %struct.sv* %call28, i64 0, i32 0
  %35 = load i8** %sv_any54, align 8, !tbaa !3
  %xpv_pv55 = bitcast i8* %35 to i8**
  %36 = load i8** %xpv_pv55, align 8, !tbaa !3
  br label %if.end57

if.end57:                                         ; preds = %land.lhs.true25, %if.end, %cond.end51
  %aname.0 = phi i8* [ %36, %cond.end51 ], [ null, %if.end ], [ null, %land.lhs.true25 ]
  br i1 %notlhs, label %cond.end68, label %cond.false60

cond.false60:                                     ; preds = %if.end57
  %tobool61 = icmp eq i8* %aname.0, null
  br i1 %tobool61, label %cond.false63, label %cond.end68

cond.false63:                                     ; preds = %cond.false60
  %37 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %tobool64 = icmp ne %struct.hv* %37, null
  %cond65 = select i1 %tobool64, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str67, i64 0, i64 0)
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false60, %if.end57, %cond.false63
  %cond69 = phi i8* [ %cond65, %cond.false63 ], [ %cond5, %if.end57 ], [ %aname.0, %cond.false60 ]
  %tobool70 = icmp ne %struct.op* %block, null
  br i1 %tobool70, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end68
  %tobool71 = icmp ne %struct.op* %attrs, null
  %phitmp947 = select i1 %tobool71, i32 2, i32 18
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end68
  %38 = phi i32 [ 2, %cond.end68 ], [ %phitmp947, %lor.rhs ]
  %call73 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond69, i32 %38, i32 12) #7
  br i1 %tobool, label %if.then75, label %if.end76

if.then75:                                        ; preds = %lor.end
  call void @Perl_save_freeop(%struct.op* %o) #7
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %lor.end
  br i1 %tobool6, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.end76
  call void @Perl_save_freeop(%struct.op* %proto) #7
  br label %if.end79

if.end79:                                         ; preds = %if.then78, %if.end76
  %tobool80 = icmp ne %struct.op* %attrs, null
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end79
  call void @Perl_save_freeop(%struct.op* %attrs) #7
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %if.end79
  %sv_flags83 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 2
  %39 = load i32* %sv_flags83, align 4, !tbaa !0
  %and84 = and i32 %39, 255
  switch i32 %and84, label %if.then92 [
    i32 13, label %if.end128
    i32 0, label %if.end123
  ]

if.then92:                                        ; preds = %if.end82
  %and94 = and i32 %39, 262144
  %tobool95 = icmp eq i32 %and94, 0
  br i1 %tobool95, label %land.lhs.true96, label %if.end122

land.lhs.true96:                                  ; preds = %if.then92
  %and98 = and i32 %39, 65536
  %tobool99 = icmp eq i32 %and98, 0
  br i1 %tobool99, label %land.lhs.true104, label %land.lhs.true100

land.lhs.true100:                                 ; preds = %land.lhs.true96
  %sv_any101 = bitcast %struct.gv* %call73 to i8**
  %40 = load i8** %sv_any101, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %40, i64 24
  %41 = bitcast i8* %xiv_iv to i64*
  %42 = load i64* %41, align 8, !tbaa !5
  %cmp102 = icmp eq i64 %42, -1
  br i1 %cmp102, label %if.end122, label %land.lhs.true104

land.lhs.true104:                                 ; preds = %land.lhs.true96, %land.lhs.true100
  %43 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %43, i64 0, i32 14
  %44 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp105 = icmp eq %struct.sv* %44, null
  br i1 %cmp105, label %if.then121, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true104
  %45 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings107 = getelementptr inbounds %struct.cop* %45, i64 0, i32 14
  %46 = load %struct.sv** %cop_warnings107, align 8, !tbaa !3
  %cmp108 = icmp eq %struct.sv* %46, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp108, label %if.then121, label %lor.lhs.false110

lor.lhs.false110:                                 ; preds = %lor.lhs.false
  %47 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings111 = getelementptr inbounds %struct.cop* %47, i64 0, i32 14
  %48 = load %struct.sv** %cop_warnings111, align 8, !tbaa !3
  %cmp112 = icmp eq %struct.sv* %48, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp112, label %if.end122, label %land.lhs.true114

land.lhs.true114:                                 ; preds = %lor.lhs.false110
  %49 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings115 = getelementptr inbounds %struct.cop* %49, i64 0, i32 14
  %50 = load %struct.sv** %cop_warnings115, align 8, !tbaa !3
  %sv_any116 = getelementptr inbounds %struct.sv* %50, i64 0, i32 0
  %51 = load i8** %sv_any116, align 8, !tbaa !3
  %xpv_pv117 = bitcast i8* %51 to i8**
  %52 = load i8** %xpv_pv117, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %52, i64 8
  %53 = load i8* %arrayidx, align 1, !tbaa !1
  %and119 = and i8 %53, 64
  %tobool120 = icmp eq i8 %and119, 0
  br i1 %tobool120, label %if.end122, label %if.then121

if.then121:                                       ; preds = %land.lhs.true114, %lor.lhs.false, %land.lhs.true104
  call void (i32, i8*, ...)* @Perl_warner(i32 35, i8* getelementptr inbounds ([18 x i8]* @.str68, i64 0, i64 0)) #7
  br label %if.end122

if.end122:                                        ; preds = %land.lhs.true114, %lor.lhs.false110, %if.then92, %if.then121, %land.lhs.true100
  %54 = bitcast %struct.gv* %call73 to %struct.cv*
  call void @Perl_cv_ckproto(%struct.cv* %54, %struct.gv* null, i8* %ps.0) #8
  br label %if.end123

if.end123:                                        ; preds = %if.end82, %if.end122
  %tobool124 = icmp eq i8* %ps.0, null
  %55 = bitcast %struct.gv* %call73 to %struct.sv*
  br i1 %tobool124, label %if.else126, label %if.then125

if.then125:                                       ; preds = %if.end123
  call void @Perl_sv_setpv(%struct.sv* %55, i8* %ps.0) #7
  br label %if.end127

if.else126:                                       ; preds = %if.end123
  call void @Perl_sv_setiv(%struct.sv* %55, i64 -1) #7
  br label %if.end127

if.end127:                                        ; preds = %if.else126, %if.then125
  %56 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %57 = bitcast %struct.cv* %56 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %57) #7
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !3
  %58 = load i32* @PL_sub_generation, align 4, !tbaa !0
  %inc = add i32 %58, 1
  store i32 %inc, i32* @PL_sub_generation, align 4, !tbaa !0
  br label %done

if.end128:                                        ; preds = %if.end82
  br i1 %notlhs, label %lor.lhs.false130, label %cond.end138

lor.lhs.false130:                                 ; preds = %if.end128
  %sv_any131 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %59 = load %struct.xpvgv** %sv_any131, align 8, !tbaa !3
  %xgv_gp132 = getelementptr inbounds %struct.xpvgv* %59, i64 0, i32 7
  %60 = load %struct.gp** %xgv_gp132, align 8, !tbaa !3
  %gp_cvgen = getelementptr inbounds %struct.gp* %60, i64 0, i32 8
  %61 = load i32* %gp_cvgen, align 4, !tbaa !0
  %tobool133 = icmp eq i32 %61, 0
  br i1 %tobool133, label %cond.false135, label %cond.end138

cond.false135:                                    ; preds = %lor.lhs.false130
  %gp_cv = getelementptr inbounds %struct.gp* %60, i64 0, i32 7
  %62 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  br label %cond.end138

cond.end138:                                      ; preds = %lor.lhs.false130, %if.end128, %cond.false135
  %cond139 = phi %struct.cv* [ %62, %cond.false135 ], [ null, %lor.lhs.false130 ], [ null, %if.end128 ]
  %tobool70.not = xor i1 %tobool70, true
  %tobool142 = icmp eq i8* %ps.0, null
  %or.cond954 = or i1 %tobool142, %tobool70.not
  br i1 %or.cond954, label %if.end151, label %lor.lhs.false143

lor.lhs.false143:                                 ; preds = %cond.end138
  %63 = load i8* %ps.0, align 1, !tbaa !1
  %tobool145.not = icmp ne i8 %63, 0
  %brmerge = or i1 %tobool145.not, %tobool80
  br i1 %brmerge, label %if.end151, label %if.else149

if.else149:                                       ; preds = %lor.lhs.false143
  %call150 = call %struct.sv* @Perl_op_const_sv(%struct.op* %block, %struct.cv* null) #8
  br label %if.end151

if.end151:                                        ; preds = %cond.end138, %lor.lhs.false143, %if.else149
  %const_sv.0 = phi %struct.sv* [ %call150, %if.else149 ], [ null, %lor.lhs.false143 ], [ null, %cond.end138 ]
  %tobool152 = icmp eq %struct.cv* %cond139, null
  br i1 %tobool152, label %if.end261, label %if.then153

if.then153:                                       ; preds = %if.end151
  %sv_any154 = getelementptr inbounds %struct.cv* %cond139, i64 0, i32 0
  %64 = load %struct.xpvcv** %sv_any154, align 8, !tbaa !3
  %xcv_root = getelementptr inbounds %struct.xpvcv* %64, i64 0, i32 9
  %65 = load %struct.op** %xcv_root, align 8, !tbaa !3
  %tobool155 = icmp eq %struct.op* %65, null
  br i1 %tobool155, label %lor.end159, label %if.end168.thread961

lor.end159:                                       ; preds = %if.then153
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %64, i64 0, i32 10
  %66 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !3
  %tobool158 = icmp eq void (%struct.cv*)* %66, null
  br i1 %tobool158, label %lor.lhs.false163, label %if.end168.thread961

lor.lhs.false163:                                 ; preds = %lor.end159
  %sv_flags164 = getelementptr inbounds %struct.cv* %cond139, i64 0, i32 2
  %67 = load i32* %sv_flags164, align 4, !tbaa !0
  %and165 = and i32 %67, 262144
  %tobool166 = icmp eq i32 %and165, 0
  br i1 %tobool166, label %lor.lhs.false171, label %if.end168.thread962

if.end168.thread962:                              ; preds = %lor.lhs.false163
  call void @Perl_cv_ckproto(%struct.cv* %cond139, %struct.gv* %call73, i8* %ps.0) #8
  br label %lor.lhs.false171

if.end168.thread961:                              ; preds = %lor.end159, %if.then153
  call void @Perl_cv_ckproto(%struct.cv* %cond139, %struct.gv* %call73, i8* %ps.0) #8
  br label %if.then176

lor.lhs.false171:                                 ; preds = %lor.lhs.false163, %if.end168.thread962
  %sv_any172 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %68 = load %struct.xpvgv** %sv_any172, align 8, !tbaa !3
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %68, i64 0, i32 11
  %69 = load i8* %xgv_flags, align 1, !tbaa !1
  %and174 = and i8 %69, 4
  %tobool175 = icmp eq i8 %and174, 0
  br i1 %tobool175, label %if.end261, label %if.then176

if.then176:                                       ; preds = %if.end168.thread961, %lor.lhs.false171
  %brmerge955 = or i1 %tobool70, %tobool80
  br i1 %brmerge955, label %if.end194, label %if.then180

if.then180:                                       ; preds = %if.then176
  %70 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any181 = getelementptr inbounds %struct.cv* %70, i64 0, i32 0
  %71 = load %struct.xpvcv** %sv_any181, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %71, i64 0, i32 17
  %72 = load i16* %xcv_flags, align 2, !tbaa !4
  %tobool182 = icmp eq i16 %72, 0
  br i1 %tobool182, label %if.end193, label %if.then183

if.then183:                                       ; preds = %if.then180
  %and187 = and i16 %72, 448
  %73 = load %struct.xpvcv** %sv_any154, align 8, !tbaa !3
  %xcv_flags189 = getelementptr inbounds %struct.xpvcv* %73, i64 0, i32 17
  %74 = load i16* %xcv_flags189, align 2, !tbaa !4
  %or191 = or i16 %74, %and187
  store i16 %or191, i16* %xcv_flags189, align 2, !tbaa !4
  br label %if.end193

if.end193:                                        ; preds = %if.then180, %if.then183
  %75 = bitcast %struct.cv* %70 to %struct.sv*
  call void @Perl_save_freesv(%struct.sv* %75) #7
  br label %done

if.end194:                                        ; preds = %if.then176
  %76 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !3
  %si_type = getelementptr inbounds %struct.stackinfo* %76, i64 0, i32 4
  %77 = load i32* %si_type, align 4, !tbaa !0
  %cmp195 = icmp eq i32 %77, 3
  br i1 %cmp195, label %land.lhs.true197, label %if.end202

land.lhs.true197:                                 ; preds = %if.end194
  %78 = load %struct.op** @PL_sortcop, align 8, !tbaa !3
  %79 = load %struct.xpvcv** %sv_any154, align 8, !tbaa !3
  %xcv_start = getelementptr inbounds %struct.xpvcv* %79, i64 0, i32 8
  %80 = load %struct.op** %xcv_start, align 8, !tbaa !3
  %cmp199 = icmp eq %struct.op* %78, %80
  br i1 %cmp199, label %if.then201, label %if.end202

if.then201:                                       ; preds = %land.lhs.true197
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str69, i64 0, i64 0), i8* %cond5) #7
  br label %if.end202

if.end202:                                        ; preds = %if.then201, %land.lhs.true197, %if.end194
  br i1 %tobool70, label %if.then204, label %if.end261

if.then204:                                       ; preds = %if.end202
  %81 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings205 = getelementptr inbounds %struct.cop* %81, i64 0, i32 14
  %82 = load %struct.sv** %cop_warnings205, align 8, !tbaa !3
  %cmp206 = icmp eq %struct.sv* %82, null
  br i1 %cmp206, label %lor.lhs.false224, label %land.lhs.true208

land.lhs.true208:                                 ; preds = %if.then204
  %83 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings209 = getelementptr inbounds %struct.cop* %83, i64 0, i32 14
  %84 = load %struct.sv** %cop_warnings209, align 8, !tbaa !3
  %cmp210 = icmp eq %struct.sv* %84, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp210, label %lor.lhs.false224, label %land.lhs.true212

land.lhs.true212:                                 ; preds = %land.lhs.true208
  %85 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings213 = getelementptr inbounds %struct.cop* %85, i64 0, i32 14
  %86 = load %struct.sv** %cop_warnings213, align 8, !tbaa !3
  %cmp214 = icmp eq %struct.sv* %86, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp214, label %if.then244, label %lor.lhs.false216

lor.lhs.false216:                                 ; preds = %land.lhs.true212
  %87 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings217 = getelementptr inbounds %struct.cop* %87, i64 0, i32 14
  %88 = load %struct.sv** %cop_warnings217, align 8, !tbaa !3
  %sv_any218 = getelementptr inbounds %struct.sv* %88, i64 0, i32 0
  %89 = load i8** %sv_any218, align 8, !tbaa !3
  %xpv_pv219 = bitcast i8* %89 to i8**
  %90 = load i8** %xpv_pv219, align 8, !tbaa !3
  %arrayidx220 = getelementptr inbounds i8* %90, i64 4
  %91 = load i8* %arrayidx220, align 1, !tbaa !1
  %and222 = and i8 %91, 64
  %tobool223 = icmp eq i8 %and222, 0
  br i1 %tobool223, label %lor.lhs.false224, label %if.then244

lor.lhs.false224:                                 ; preds = %lor.lhs.false216, %land.lhs.true208, %if.then204
  %92 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings225 = getelementptr inbounds %struct.cop* %92, i64 0, i32 14
  %93 = load %struct.sv** %cop_warnings225, align 8, !tbaa !3
  %cmp226 = icmp eq %struct.sv* %93, null
  br i1 %cmp226, label %land.lhs.true228, label %lor.lhs.false232

land.lhs.true228:                                 ; preds = %lor.lhs.false224
  %94 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and230 = and i8 %94, 1
  %tobool231 = icmp eq i8 %and230, 0
  br i1 %tobool231, label %lor.lhs.false232, label %if.then244

lor.lhs.false232:                                 ; preds = %land.lhs.true228, %lor.lhs.false224
  %95 = load %struct.xpvcv** %sv_any154, align 8, !tbaa !3
  %xcv_flags234 = getelementptr inbounds %struct.xpvcv* %95, i64 0, i32 17
  %96 = load i16* %xcv_flags234, align 2, !tbaa !4
  %and236 = and i16 %96, 512
  %tobool237 = icmp eq i16 %and236, 0
  br i1 %tobool237, label %if.end258, label %land.lhs.true238

land.lhs.true238:                                 ; preds = %lor.lhs.false232
  %tobool239 = icmp eq %struct.sv* %const_sv.0, null
  br i1 %tobool239, label %if.then244, label %Perl_cv_const_sv.exit

Perl_cv_const_sv.exit:                            ; preds = %land.lhs.true238
  %any_ptr.i = getelementptr inbounds %struct.xpvcv* %95, i64 0, i32 11, i32 0
  %97 = load i8** %any_ptr.i, align 8, !tbaa !3
  %98 = bitcast i8* %97 to %struct.sv*
  %call242 = call i32 @Perl_sv_cmp(%struct.sv* %98, %struct.sv* %const_sv.0) #7
  %tobool243 = icmp eq i32 %call242, 0
  br i1 %tobool243, label %if.end258, label %if.then244

if.then244:                                       ; preds = %lor.lhs.false216, %land.lhs.true228, %Perl_cv_const_sv.exit, %land.lhs.true238, %land.lhs.true212
  %99 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line245 = getelementptr inbounds %struct.cop* %99, i64 0, i32 13
  %100 = load i32* %cop_line245, align 4, !tbaa !0
  %101 = load i32* @PL_copline, align 4, !tbaa !0
  %cmp246 = icmp eq i32 %101, -1
  br i1 %cmp246, label %if.end250, label %if.then248

if.then248:                                       ; preds = %if.then244
  %102 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line249 = getelementptr inbounds %struct.cop* %102, i64 0, i32 13
  store i32 %101, i32* %cop_line249, align 4, !tbaa !0
  br label %if.end250

if.end250:                                        ; preds = %if.then244, %if.then248
  %103 = load %struct.xpvcv** %sv_any154, align 8, !tbaa !3
  %xcv_flags252 = getelementptr inbounds %struct.xpvcv* %103, i64 0, i32 17
  %104 = load i16* %xcv_flags252, align 2, !tbaa !4
  %and254 = and i16 %104, 512
  %tobool255 = icmp ne i16 %and254, 0
  %cond256 = select i1 %tobool255, i8* getelementptr inbounds ([33 x i8]* @.str70, i64 0, i64 0), i8* getelementptr inbounds ([24 x i8]* @.str71, i64 0, i64 0)
  call void (i32, i8*, ...)* @Perl_warner(i32 19, i8* %cond256, i8* %cond5) #7
  %105 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line257 = getelementptr inbounds %struct.cop* %105, i64 0, i32 13
  store i32 %100, i32* %cop_line257, align 4, !tbaa !0
  br label %if.end258

if.end258:                                        ; preds = %Perl_cv_const_sv.exit, %lor.lhs.false232, %if.end250
  %106 = bitcast %struct.cv* %cond139 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %106) #7
  br label %if.end261

if.end261:                                        ; preds = %lor.lhs.false171, %if.end151, %if.end258, %if.end202
  %cv.0 = phi %struct.cv* [ null, %if.end258 ], [ %cond139, %if.end202 ], [ %cond139, %lor.lhs.false171 ], [ null, %if.end151 ]
  %tobool262 = icmp eq %struct.sv* %const_sv.0, null
  br i1 %tobool262, label %if.end284, label %if.then263

if.then263:                                       ; preds = %if.end261
  store %struct.sv* %const_sv.0, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_refcnt = getelementptr inbounds %struct.sv* %const_sv.0, i64 0, i32 1
  %107 = load i32* %sv_refcnt, align 4, !tbaa !0
  %inc265 = add i32 %107, 1
  store i32 %inc265, i32* %sv_refcnt, align 4, !tbaa !0
  %tobool267 = icmp eq %struct.cv* %cv.0, null
  br i1 %tobool267, label %if.else277, label %if.then268

if.then268:                                       ; preds = %if.then263
  %108 = bitcast %struct.cv* %cv.0 to %struct.sv*
  call void @Perl_sv_setpv(%struct.sv* %108, i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0)) #7
  %109 = bitcast %struct.sv* %const_sv.0 to i8*
  %sv_any269 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %110 = load %struct.xpvcv** %sv_any269, align 8, !tbaa !3
  %any_ptr = getelementptr inbounds %struct.xpvcv* %110, i64 0, i32 11, i32 0
  store i8* %109, i8** %any_ptr, align 8, !tbaa !3
  %111 = load %struct.xpvcv** %sv_any269, align 8, !tbaa !3
  %xcv_xsub271 = getelementptr inbounds %struct.xpvcv* %111, i64 0, i32 10
  store void (%struct.cv*)* @const_sv_xsub, void (%struct.cv*)** %xcv_xsub271, align 8, !tbaa !3
  %112 = load %struct.xpvcv** %sv_any269, align 8, !tbaa !3
  %xcv_flags273 = getelementptr inbounds %struct.xpvcv* %112, i64 0, i32 17
  %113 = load i16* %xcv_flags273, align 2, !tbaa !4
  %or275 = or i16 %113, 512
  store i16 %or275, i16* %xcv_flags273, align 2, !tbaa !4
  br label %if.end282

if.else277:                                       ; preds = %if.then263
  %sv_any278 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %114 = load %struct.xpvgv** %sv_any278, align 8, !tbaa !3
  %xgv_gp279 = getelementptr inbounds %struct.xpvgv* %114, i64 0, i32 7
  %115 = load %struct.gp** %xgv_gp279, align 8, !tbaa !3
  %gp_cv280 = getelementptr inbounds %struct.gp* %115, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv280, align 8, !tbaa !3
  %call281 = call %struct.cv* @Perl_newCONSTSUB(%struct.hv* null, i8* %cond5, %struct.sv* %const_sv.0) #8
  br label %if.end282

if.end282:                                        ; preds = %if.else277, %if.then268
  %cv.1 = phi %struct.cv* [ %cv.0, %if.then268 ], [ %call281, %if.else277 ]
  call void @Perl_op_free(%struct.op* %block) #8
  %116 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %117 = bitcast %struct.cv* %116 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %117) #7
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8, !tbaa !3
  %118 = load i32* @PL_sub_generation, align 4, !tbaa !0
  %inc283 = add i32 %118, 1
  store i32 %inc283, i32* @PL_sub_generation, align 4, !tbaa !0
  br label %done

if.end284:                                        ; preds = %if.end261
  br i1 %tobool80, label %if.then286, label %if.end333

if.then286:                                       ; preds = %if.end284
  %tobool287 = icmp eq %struct.cv* %cv.0, null
  %brmerge956 = or i1 %tobool287, %tobool70
  br i1 %brmerge956, label %if.else321, label %if.then290

if.then290:                                       ; preds = %if.then286
  %119 = bitcast %struct.cv* %cv.0 to %struct.sv*
  %120 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any291 = getelementptr inbounds %struct.cv* %120, i64 0, i32 0
  %121 = load %struct.xpvcv** %sv_any291, align 8, !tbaa !3
  %xcv_flags292 = getelementptr inbounds %struct.xpvcv* %121, i64 0, i32 17
  %122 = load i16* %xcv_flags292, align 2, !tbaa !4
  %and294 = and i16 %122, 448
  %sv_any295 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %123 = load %struct.xpvcv** %sv_any295, align 8, !tbaa !3
  %xcv_flags296 = getelementptr inbounds %struct.xpvcv* %123, i64 0, i32 17
  %124 = load i16* %xcv_flags296, align 2, !tbaa !4
  %or298 = or i16 %124, %and294
  store i16 %or298, i16* %xcv_flags296, align 2, !tbaa !4
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %123, i64 0, i32 12
  %125 = load %struct.gv** %xcv_gv, align 8, !tbaa !3
  %tobool301 = icmp eq %struct.gv* %125, null
  br i1 %tobool301, label %if.else312, label %land.lhs.true302

land.lhs.true302:                                 ; preds = %if.then290
  %sv_any305 = getelementptr inbounds %struct.gv* %125, i64 0, i32 0
  %126 = load %struct.xpvgv** %sv_any305, align 8, !tbaa !3
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %126, i64 0, i32 10
  %127 = load %struct.hv** %xgv_stash, align 8, !tbaa !3
  %tobool306 = icmp eq %struct.hv* %127, null
  br i1 %tobool306, label %if.else312, label %if.end332

if.else312:                                       ; preds = %land.lhs.true302, %if.then290
  %xcv_stash = getelementptr inbounds %struct.xpvcv* %123, i64 0, i32 7
  %128 = load %struct.hv** %xcv_stash, align 8, !tbaa !3
  %tobool314 = icmp eq %struct.hv* %128, null
  %129 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %. = select i1 %tobool314, %struct.hv* %129, %struct.hv* %128
  br label %if.end332

if.else321:                                       ; preds = %if.then286
  %130 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %131 = bitcast %struct.cv* %130 to %struct.sv*
  br i1 %notlhs, label %land.lhs.true323, label %if.else330

land.lhs.true323:                                 ; preds = %if.else321
  %sv_any324 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %132 = load %struct.xpvgv** %sv_any324, align 8, !tbaa !3
  %xgv_stash325 = getelementptr inbounds %struct.xpvgv* %132, i64 0, i32 10
  %133 = load %struct.hv** %xgv_stash325, align 8, !tbaa !3
  %tobool326 = icmp eq %struct.hv* %133, null
  br i1 %tobool326, label %if.else330, label %if.end332

if.else330:                                       ; preds = %land.lhs.true323, %if.else321
  %134 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  br label %if.end332

if.end332:                                        ; preds = %if.else312, %land.lhs.true323, %land.lhs.true302, %if.else330
  %rcv.0 = phi %struct.sv* [ %131, %if.else330 ], [ %119, %land.lhs.true302 ], [ %131, %land.lhs.true323 ], [ %119, %if.else312 ]
  %stash.0 = phi %struct.hv* [ %134, %if.else330 ], [ %127, %land.lhs.true302 ], [ %133, %land.lhs.true323 ], [ %., %if.else312 ]
  call fastcc void @S_apply_attrs(%struct.hv* %stash.0, %struct.sv* %rcv.0, %struct.op* %attrs, i8 signext 0) #8
  br label %if.end333

if.end333:                                        ; preds = %if.end332, %if.end284
  %tobool334 = icmp eq %struct.cv* %cv.0, null
  br i1 %tobool334, label %if.else374, label %if.then335

if.then335:                                       ; preds = %if.end333
  br i1 %tobool70, label %if.end338, label %if.then337

if.then337:                                       ; preds = %if.then335
  %135 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %136 = bitcast %struct.cv* %135 to %struct.sv*
  call void @Perl_save_freesv(%struct.sv* %136) #7
  br label %done

if.end338:                                        ; preds = %if.then335
  call void @Perl_cv_undef(%struct.cv* %cv.0) #8
  %137 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any339 = getelementptr inbounds %struct.cv* %137, i64 0, i32 0
  %138 = load %struct.xpvcv** %sv_any339, align 8, !tbaa !3
  %xcv_flags340 = getelementptr inbounds %struct.xpvcv* %138, i64 0, i32 17
  %139 = load i16* %xcv_flags340, align 2, !tbaa !4
  %sv_any341 = getelementptr inbounds %struct.cv* %cv.0, i64 0, i32 0
  %140 = load %struct.xpvcv** %sv_any341, align 8, !tbaa !3
  %xcv_flags342 = getelementptr inbounds %struct.xpvcv* %140, i64 0, i32 17
  store i16 %139, i16* %xcv_flags342, align 2, !tbaa !4
  %and346 = and i16 %139, 1024
  %tobool347 = icmp eq i16 %and346, 0
  br i1 %tobool347, label %if.then348, label %if.end350

if.then348:                                       ; preds = %if.end338
  %xcv_outside = getelementptr inbounds %struct.xpvcv* %140, i64 0, i32 16
  %141 = load %struct.cv** %xcv_outside, align 8, !tbaa !3
  %142 = bitcast %struct.cv* %141 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %142) #7
  %.pre966 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any351.phi.trans.insert = getelementptr inbounds %struct.cv* %.pre966, i64 0, i32 0
  %.pre967 = load %struct.xpvcv** %sv_any351.phi.trans.insert, align 8, !tbaa !3
  %.pre968 = load %struct.xpvcv** %sv_any341, align 8, !tbaa !3
  br label %if.end350

if.end350:                                        ; preds = %if.end338, %if.then348
  %143 = phi %struct.xpvcv* [ %140, %if.end338 ], [ %.pre968, %if.then348 ]
  %144 = phi %struct.xpvcv* [ %138, %if.end338 ], [ %.pre967, %if.then348 ]
  %xcv_outside352 = getelementptr inbounds %struct.xpvcv* %144, i64 0, i32 16
  %145 = load %struct.cv** %xcv_outside352, align 8, !tbaa !3
  %xcv_outside354 = getelementptr inbounds %struct.xpvcv* %143, i64 0, i32 16
  store %struct.cv* %145, %struct.cv** %xcv_outside354, align 8, !tbaa !3
  %146 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any355 = getelementptr inbounds %struct.cv* %146, i64 0, i32 0
  %147 = load %struct.xpvcv** %sv_any355, align 8, !tbaa !3
  %xcv_outside_seq = getelementptr inbounds %struct.xpvcv* %147, i64 0, i32 18
  %148 = load i32* %xcv_outside_seq, align 4, !tbaa !0
  %149 = load %struct.xpvcv** %sv_any341, align 8, !tbaa !3
  %xcv_outside_seq357 = getelementptr inbounds %struct.xpvcv* %149, i64 0, i32 18
  store i32 %148, i32* %xcv_outside_seq357, align 4, !tbaa !0
  %xcv_outside359 = getelementptr inbounds %struct.xpvcv* %147, i64 0, i32 16
  store %struct.cv* null, %struct.cv** %xcv_outside359, align 8, !tbaa !3
  %150 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any360 = getelementptr inbounds %struct.cv* %150, i64 0, i32 0
  %151 = load %struct.xpvcv** %sv_any360, align 8, !tbaa !3
  %xcv_padlist = getelementptr inbounds %struct.xpvcv* %151, i64 0, i32 15
  %152 = load %struct.av** %xcv_padlist, align 8, !tbaa !3
  %153 = load %struct.xpvcv** %sv_any341, align 8, !tbaa !3
  %xcv_padlist362 = getelementptr inbounds %struct.xpvcv* %153, i64 0, i32 15
  store %struct.av* %152, %struct.av** %xcv_padlist362, align 8, !tbaa !3
  %154 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any363 = getelementptr inbounds %struct.cv* %154, i64 0, i32 0
  %155 = load %struct.xpvcv** %sv_any363, align 8, !tbaa !3
  %xcv_padlist364 = getelementptr inbounds %struct.xpvcv* %155, i64 0, i32 15
  store %struct.av* null, %struct.av** %xcv_padlist364, align 8, !tbaa !3
  %156 = load %struct.xpvcv** %sv_any341, align 8, !tbaa !3
  %xcv_padlist366 = getelementptr inbounds %struct.xpvcv* %156, i64 0, i32 15
  %157 = load %struct.av** %xcv_padlist366, align 8, !tbaa !3
  %158 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  call void @Perl_pad_fixup_inner_anons(%struct.av* %157, %struct.cv* %158, %struct.cv* %cv.0) #7
  %159 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %160 = bitcast %struct.cv* %159 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %160) #7
  %161 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool367 = icmp eq i32 %161, 0
  %and369 = and i32 %161, 8
  %tobool370 = icmp eq i32 %and369, 0
  %or.cond957 = or i1 %tobool367, %tobool370
  br i1 %or.cond957, label %if.end385, label %if.then371

if.then371:                                       ; preds = %if.end350
  %162 = load i32* @PL_sub_generation, align 4, !tbaa !0
  %inc372 = add i32 %162, 1
  store i32 %inc372, i32* @PL_sub_generation, align 4, !tbaa !0
  br label %if.end385

if.else374:                                       ; preds = %if.end333
  %163 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  br i1 %notlhs, label %if.then376, label %if.end385

if.then376:                                       ; preds = %if.else374
  %sv_any377 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %164 = load %struct.xpvgv** %sv_any377, align 8, !tbaa !3
  %xgv_gp378 = getelementptr inbounds %struct.xpvgv* %164, i64 0, i32 7
  %165 = load %struct.gp** %xgv_gp378, align 8, !tbaa !3
  %gp_cv379 = getelementptr inbounds %struct.gp* %165, i64 0, i32 7
  store %struct.cv* %163, %struct.cv** %gp_cv379, align 8, !tbaa !3
  %166 = load %struct.xpvgv** %sv_any377, align 8, !tbaa !3
  %xgv_gp381 = getelementptr inbounds %struct.xpvgv* %166, i64 0, i32 7
  %167 = load %struct.gp** %xgv_gp381, align 8, !tbaa !3
  %gp_cvgen382 = getelementptr inbounds %struct.gp* %167, i64 0, i32 8
  store i32 0, i32* %gp_cvgen382, align 4, !tbaa !0
  %168 = load i32* @PL_sub_generation, align 4, !tbaa !0
  %inc383 = add i32 %168, 1
  store i32 %inc383, i32* @PL_sub_generation, align 4, !tbaa !0
  br label %if.end385

if.end385:                                        ; preds = %if.end350, %if.else374, %if.then376, %if.then371
  %cv.2 = phi %struct.cv* [ %cv.0, %if.then371 ], [ %cv.0, %if.end350 ], [ %163, %if.then376 ], [ %163, %if.else374 ]
  %sv_any386 = getelementptr inbounds %struct.cv* %cv.2, i64 0, i32 0
  %169 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_gv387 = getelementptr inbounds %struct.xpvcv* %169, i64 0, i32 12
  store %struct.gv* %call73, %struct.gv** %xcv_gv387, align 8, !tbaa !3
  %170 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv388 = getelementptr inbounds %struct.cop* %170, i64 0, i32 10
  %171 = load %struct.gv** %cop_filegv388, align 8, !tbaa !3
  %tobool389 = icmp eq %struct.gv* %171, null
  br i1 %tobool389, label %cond.end411, label %cond.true390

cond.true390:                                     ; preds = %if.end385
  %172 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv391 = getelementptr inbounds %struct.cop* %172, i64 0, i32 10
  %173 = load %struct.gv** %cop_filegv391, align 8, !tbaa !3
  %sv_any392 = getelementptr inbounds %struct.gv* %173, i64 0, i32 0
  %174 = load %struct.xpvgv** %sv_any392, align 8, !tbaa !3
  %xgv_gp393 = getelementptr inbounds %struct.xpvgv* %174, i64 0, i32 7
  %175 = load %struct.gp** %xgv_gp393, align 8, !tbaa !3
  %gp_sv394 = getelementptr inbounds %struct.gp* %175, i64 0, i32 0
  %176 = load %struct.sv** %gp_sv394, align 8, !tbaa !3
  %tobool395 = icmp eq %struct.sv* %176, null
  br i1 %tobool395, label %cond.end411, label %cond.true397

cond.true397:                                     ; preds = %cond.true390
  %177 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %178 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv401 = getelementptr inbounds %struct.cop* %178, i64 0, i32 10
  %179 = load %struct.gv** %cop_filegv401, align 8, !tbaa !3
  %sv_any402 = getelementptr inbounds %struct.gv* %179, i64 0, i32 0
  %180 = load %struct.xpvgv** %sv_any402, align 8, !tbaa !3
  %xgv_gp403 = getelementptr inbounds %struct.xpvgv* %180, i64 0, i32 7
  %181 = load %struct.gp** %xgv_gp403, align 8, !tbaa !3
  %gp_sv404 = getelementptr inbounds %struct.gp* %181, i64 0, i32 0
  %182 = load %struct.sv** %gp_sv404, align 8, !tbaa !3
  %sv_any408 = getelementptr inbounds %struct.sv* %182, i64 0, i32 0
  %183 = load i8** %sv_any408, align 8, !tbaa !3
  %xpv_pv409 = bitcast i8* %183 to i8**
  %184 = load i8** %xpv_pv409, align 8, !tbaa !3
  br label %cond.end411

cond.end411:                                      ; preds = %cond.true390, %if.end385, %cond.true397
  %cond412 = phi i8* [ %184, %cond.true397 ], [ null, %if.end385 ], [ null, %cond.true390 ]
  %185 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_file = getelementptr inbounds %struct.xpvcv* %185, i64 0, i32 13
  store i8* %cond412, i8** %xcv_file, align 8, !tbaa !3
  %186 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %187 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_stash415 = getelementptr inbounds %struct.xpvcv* %187, i64 0, i32 7
  store %struct.hv* %186, %struct.hv** %xcv_stash415, align 8, !tbaa !3
  %tobool416 = icmp ne i8* %ps.0, null
  br i1 %tobool416, label %if.then417, label %if.end418

if.then417:                                       ; preds = %cond.end411
  %188 = bitcast %struct.cv* %cv.2 to %struct.sv*
  call void @Perl_sv_setpv(%struct.sv* %188, i8* %ps.0) #7
  br label %if.end418

if.end418:                                        ; preds = %if.then417, %cond.end411
  %189 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool419 = icmp eq i32 %189, 0
  br i1 %tobool419, label %if.end445, label %if.then420

if.then420:                                       ; preds = %if.end418
  call void @Perl_op_free(%struct.op* %block) #8
  br i1 %notlhs, label %if.then422, label %done

if.then422:                                       ; preds = %if.then420
  %call423 = call i8* @strrchr(i8* %cond5, i32 58) #7
  %tobool424 = icmp eq i8* %call423, null
  %add.ptr = getelementptr inbounds i8* %call423, i64 1
  %cond428 = select i1 %tobool424, i8* %cond5, i8* %add.ptr
  %call429 = call i32 @strcmp(i8* %cond428, i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0)) #7
  %tobool430 = icmp eq i32 %call429, 0
  br i1 %tobool430, label %if.then431, label %done

if.then431:                                       ; preds = %if.then422
  %190 = load volatile i32* @PL_in_eval, align 4, !tbaa !0
  %and432 = and i32 %190, 4
  %tobool433 = icmp eq i32 %and432, 0
  br i1 %tobool433, label %if.else435, label %if.then434

if.then434:                                       ; preds = %if.then431
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([49 x i8]* @.str72, i64 0, i64 0)) #7
  br label %done

if.else435:                                       ; preds = %if.then431
  %191 = load %struct.gv** @PL_errgv, align 8, !tbaa !3
  %sv_any436 = getelementptr inbounds %struct.gv* %191, i64 0, i32 0
  %192 = load %struct.xpvgv** %sv_any436, align 8, !tbaa !3
  %xgv_gp437 = getelementptr inbounds %struct.xpvgv* %192, i64 0, i32 7
  %193 = load %struct.gp** %xgv_gp437, align 8, !tbaa !3
  %gp_sv438 = getelementptr inbounds %struct.gp* %193, i64 0, i32 0
  %194 = load %struct.sv** %gp_sv438, align 8, !tbaa !3
  call void @Perl_sv_catpv(%struct.sv* %194, i8* getelementptr inbounds ([49 x i8]* @.str72, i64 0, i64 0)) #7
  %195 = load %struct.gv** @PL_errgv, align 8, !tbaa !3
  %sv_any439 = getelementptr inbounds %struct.gv* %195, i64 0, i32 0
  %196 = load %struct.xpvgv** %sv_any439, align 8, !tbaa !3
  %xgv_gp440 = getelementptr inbounds %struct.xpvgv* %196, i64 0, i32 7
  %197 = load %struct.gp** %xgv_gp440, align 8, !tbaa !3
  %gp_sv441 = getelementptr inbounds %struct.gp* %197, i64 0, i32 0
  %198 = load %struct.sv** %gp_sv441, align 8, !tbaa !3
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([3 x i8]* @.str63, i64 0, i64 0), %struct.sv* %198) #7
  br label %done

if.end445:                                        ; preds = %if.end418
  %tobool446 = icmp eq %struct.op* %block, null
  br i1 %tobool446, label %done, label %if.end448

if.end448:                                        ; preds = %if.end445
  %199 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_flags450 = getelementptr inbounds %struct.xpvcv* %199, i64 0, i32 17
  %200 = load i16* %xcv_flags450, align 2, !tbaa !4
  %and452 = and i16 %200, 256
  %tobool453 = icmp eq i16 %and452, 0
  br i1 %tobool453, label %if.else460, label %if.then454

if.then454:                                       ; preds = %if.end448
  %call455 = call %struct.op* @Perl_scalarseq(%struct.op* %block) #8
  %call456 = call %struct.op* @Perl_mod(%struct.op* %call455, i32 168) #8
  %call457 = call %struct.op* @Perl_newUNOP(i32 168, i32 0, %struct.op* %call456) #8
  %201 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_root459 = getelementptr inbounds %struct.xpvcv* %201, i64 0, i32 9
  store %struct.op* %call457, %struct.op** %xcv_root459, align 8, !tbaa !3
  br label %if.end471

if.else460:                                       ; preds = %if.end448
  %op_type = getelementptr inbounds %struct.op* %block, i64 0, i32 4
  %202 = load i16* %op_type, align 2, !tbaa !4
  %cmp462 = icmp eq i16 %202, 1
  br i1 %cmp462, label %if.then464, label %if.end466

if.then464:                                       ; preds = %if.else460
  call void @Perl_op_free(%struct.op* %block) #8
  %call465 = call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* null) #8
  br label %if.end466

if.end466:                                        ; preds = %if.then464, %if.else460
  %block.addr.1 = phi %struct.op* [ %call465, %if.then464 ], [ %block, %if.else460 ]
  %call467 = call %struct.op* @Perl_scalarseq(%struct.op* %block.addr.1) #8
  %call468 = call %struct.op* @Perl_newUNOP(i32 167, i32 0, %struct.op* %call467) #8
  %203 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_root470 = getelementptr inbounds %struct.xpvcv* %203, i64 0, i32 9
  store %struct.op* %call468, %struct.op** %xcv_root470, align 8, !tbaa !3
  br label %if.end471

if.end471:                                        ; preds = %if.end466, %if.then454
  %block.addr.2 = phi %struct.op* [ %block, %if.then454 ], [ %block.addr.1, %if.end466 ]
  %204 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_root473 = getelementptr inbounds %struct.xpvcv* %204, i64 0, i32 9
  %205 = load %struct.op** %xcv_root473, align 8, !tbaa !3
  %op_private = getelementptr inbounds %struct.op* %205, i64 0, i32 7
  %206 = load i8* %op_private, align 1, !tbaa !1
  %or475 = or i8 %206, 64
  store i8 %or475, i8* %op_private, align 1, !tbaa !1
  %207 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_root478 = getelementptr inbounds %struct.xpvcv* %207, i64 0, i32 9
  %208 = load %struct.op** %xcv_root478, align 8, !tbaa !3
  %op_targ = getelementptr inbounds %struct.op* %208, i64 0, i32 3
  store i64 1, i64* %op_targ, align 8, !tbaa !5
  %op_next = getelementptr inbounds %struct.op* %208, i64 0, i32 0
  %209 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool481 = icmp eq %struct.op* %209, null
  br i1 %tobool481, label %cond.false486, label %cond.end490

cond.false486:                                    ; preds = %if.end471
  %call489 = call %struct.op* @Perl_linklist(%struct.op* %208) #8
  %.pre = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  br label %cond.end490

cond.end490:                                      ; preds = %if.end471, %cond.false486
  %210 = phi %struct.xpvcv* [ %.pre, %cond.false486 ], [ %207, %if.end471 ]
  %cond491 = phi %struct.op* [ %call489, %cond.false486 ], [ %209, %if.end471 ]
  %xcv_start493 = getelementptr inbounds %struct.xpvcv* %210, i64 0, i32 8
  store %struct.op* %cond491, %struct.op** %xcv_start493, align 8, !tbaa !3
  %211 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_root495 = getelementptr inbounds %struct.xpvcv* %211, i64 0, i32 9
  %212 = load %struct.op** %xcv_root495, align 8, !tbaa !3
  %op_next496 = getelementptr inbounds %struct.op* %212, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next496, align 8, !tbaa !3
  %213 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !3
  %214 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_start498 = getelementptr inbounds %struct.xpvcv* %214, i64 0, i32 8
  %215 = load %struct.op** %xcv_start498, align 8, !tbaa !3
  call void %213(%struct.op* %215) #7
  %216 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_flags500 = getelementptr inbounds %struct.xpvcv* %216, i64 0, i32 17
  %217 = load i16* %xcv_flags500, align 2, !tbaa !4
  %and502 = and i16 %217, 1
  %cond504 = zext i16 %and502 to i32
  call void @Perl_pad_tidy(i32 %cond504) #7
  %218 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_flags506 = getelementptr inbounds %struct.xpvcv* %218, i64 0, i32 17
  %219 = load i16* %xcv_flags506, align 2, !tbaa !4
  %and508 = and i16 %219, 1
  %tobool509 = icmp eq i16 %and508, 0
  %tobool416.not = xor i1 %tobool416, true
  %brmerge958 = or i1 %tobool509, %tobool416.not
  br i1 %brmerge958, label %if.end524, label %land.lhs.true512

land.lhs.true512:                                 ; preds = %cond.end490
  %220 = load i8* %ps.0, align 1, !tbaa !1
  %tobool513 = icmp eq i8 %220, 0
  br i1 %tobool513, label %land.lhs.true514, label %if.end524

land.lhs.true514:                                 ; preds = %land.lhs.true512
  %call515 = call %struct.sv* @Perl_op_const_sv(%struct.op* %block.addr.2, %struct.cv* %cv.2) #8
  %tobool516 = icmp eq %struct.sv* %call515, null
  br i1 %tobool516, label %if.end524, label %if.then517

if.then517:                                       ; preds = %land.lhs.true514
  %221 = load %struct.xpvcv** %sv_any386, align 8, !tbaa !3
  %xcv_flags519 = getelementptr inbounds %struct.xpvcv* %221, i64 0, i32 17
  %222 = load i16* %xcv_flags519, align 2, !tbaa !4
  %or521 = or i16 %222, 512
  store i16 %or521, i16* %xcv_flags519, align 2, !tbaa !4
  br label %if.end524

if.end524:                                        ; preds = %cond.end490, %land.lhs.true514, %land.lhs.true512, %if.then517
  %tobool58.not = xor i1 %notlhs, true
  %tobool527 = icmp eq i8* %aname.0, null
  %or.cond959 = and i1 %tobool527, %tobool58.not
  br i1 %or.cond959, label %done, label %if.then528

if.then528:                                       ; preds = %if.end524
  %cond534 = select i1 %notlhs, i8* %cond5, i8* %aname.0
  %223 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool535 = icmp eq i32 %223, 0
  %and537 = and i32 %223, 16
  %tobool538 = icmp eq i32 %and537, 0
  %or.cond960 = or i1 %tobool535, %tobool538
  br i1 %or.cond960, label %if.end633, label %land.lhs.true539

land.lhs.true539:                                 ; preds = %if.then528
  %224 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %225 = load %struct.hv** @PL_debstash, align 8, !tbaa !3
  %cmp540 = icmp eq %struct.hv* %224, %225
  br i1 %cmp540, label %if.end633, label %if.then542

if.then542:                                       ; preds = %land.lhs.true539
  %call544 = call %struct.sv* @Perl_newSV(i64 0) #7
  %call545 = call %struct.sv* @Perl_sv_newmortal() #7
  %call546 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([14 x i8]* @.str28, i64 0, i64 0), i32 2, i32 11) #7
  %226 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv547 = getelementptr inbounds %struct.cop* %226, i64 0, i32 10
  %227 = load %struct.gv** %cop_filegv547, align 8, !tbaa !3
  %tobool548 = icmp eq %struct.gv* %227, null
  br i1 %tobool548, label %cond.end570, label %cond.true549

cond.true549:                                     ; preds = %if.then542
  %228 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv550 = getelementptr inbounds %struct.cop* %228, i64 0, i32 10
  %229 = load %struct.gv** %cop_filegv550, align 8, !tbaa !3
  %sv_any551 = getelementptr inbounds %struct.gv* %229, i64 0, i32 0
  %230 = load %struct.xpvgv** %sv_any551, align 8, !tbaa !3
  %xgv_gp552 = getelementptr inbounds %struct.xpvgv* %230, i64 0, i32 7
  %231 = load %struct.gp** %xgv_gp552, align 8, !tbaa !3
  %gp_sv553 = getelementptr inbounds %struct.gp* %231, i64 0, i32 0
  %232 = load %struct.sv** %gp_sv553, align 8, !tbaa !3
  %tobool554 = icmp eq %struct.sv* %232, null
  br i1 %tobool554, label %cond.end570, label %cond.true556

cond.true556:                                     ; preds = %cond.true549
  %233 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %234 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv560 = getelementptr inbounds %struct.cop* %234, i64 0, i32 10
  %235 = load %struct.gv** %cop_filegv560, align 8, !tbaa !3
  %sv_any561 = getelementptr inbounds %struct.gv* %235, i64 0, i32 0
  %236 = load %struct.xpvgv** %sv_any561, align 8, !tbaa !3
  %xgv_gp562 = getelementptr inbounds %struct.xpvgv* %236, i64 0, i32 7
  %237 = load %struct.gp** %xgv_gp562, align 8, !tbaa !3
  %gp_sv563 = getelementptr inbounds %struct.gp* %237, i64 0, i32 0
  %238 = load %struct.sv** %gp_sv563, align 8, !tbaa !3
  %sv_any567 = getelementptr inbounds %struct.sv* %238, i64 0, i32 0
  %239 = load i8** %sv_any567, align 8, !tbaa !3
  %xpv_pv568 = bitcast i8* %239 to i8**
  %240 = load i8** %xpv_pv568, align 8, !tbaa !3
  br label %cond.end570

cond.end570:                                      ; preds = %cond.true549, %if.then542, %cond.true556
  %cond571 = phi i8* [ %240, %cond.true556 ], [ null, %if.then542 ], [ null, %cond.true549 ]
  %241 = load i32* @PL_subline, align 4, !tbaa !0
  %conv572 = sext i32 %241 to i64
  %242 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line573 = getelementptr inbounds %struct.cop* %242, i64 0, i32 13
  %243 = load i32* %cop_line573, align 4, !tbaa !0
  %conv574 = zext i32 %243 to i64
  call void (%struct.sv*, i8*, ...)* @Perl_sv_setpvf(%struct.sv* %call544, i8* getelementptr inbounds ([11 x i8]* @.str73, i64 0, i64 0), i8* %cond571, i64 %conv572, i64 %conv574) #7
  call void @Perl_gv_efullname4(%struct.sv* %call545, %struct.gv* %call73, i8* null, i8 signext 1) #7
  %244 = load %struct.gv** @PL_DBsub, align 8, !tbaa !3
  %sv_any575 = getelementptr inbounds %struct.gv* %244, i64 0, i32 0
  %245 = load %struct.xpvgv** %sv_any575, align 8, !tbaa !3
  %xgv_gp576 = getelementptr inbounds %struct.xpvgv* %245, i64 0, i32 7
  %246 = load %struct.gp** %xgv_gp576, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %246, i64 0, i32 5
  %247 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %sv_any577 = getelementptr inbounds %struct.sv* %call545, i64 0, i32 0
  %248 = load i8** %sv_any577, align 8, !tbaa !3
  %xpv_pv578 = bitcast i8* %248 to i8**
  %249 = load i8** %xpv_pv578, align 8, !tbaa !3
  %xpv_cur580 = getelementptr inbounds i8* %248, i64 8
  %250 = bitcast i8* %xpv_cur580 to i64*
  %251 = load i64* %250, align 8, !tbaa !5
  %conv581 = trunc i64 %251 to i32
  %call582 = call %struct.sv** @Perl_hv_store(%struct.hv* %247, i8* %249, i32 %conv581, %struct.sv* %call544, i32 0) #7
  %sv_any583 = getelementptr inbounds %struct.gv* %call546, i64 0, i32 0
  %252 = load %struct.xpvgv** %sv_any583, align 8, !tbaa !3
  %xgv_gp584 = getelementptr inbounds %struct.xpvgv* %252, i64 0, i32 7
  %253 = load %struct.gp** %xgv_gp584, align 8, !tbaa !3
  %gp_hv585 = getelementptr inbounds %struct.gp* %253, i64 0, i32 5
  %254 = load %struct.hv** %gp_hv585, align 8, !tbaa !3
  %tobool586 = icmp eq %struct.hv* %254, null
  br i1 %tobool586, label %cond.false591, label %cond.end596

cond.false591:                                    ; preds = %cond.end570
  %call592 = call %struct.gv* @Perl_gv_HVadd(%struct.gv* %call546) #7
  %sv_any593 = getelementptr inbounds %struct.gv* %call592, i64 0, i32 0
  %255 = load %struct.xpvgv** %sv_any593, align 8, !tbaa !3
  %xgv_gp594 = getelementptr inbounds %struct.xpvgv* %255, i64 0, i32 7
  %256 = load %struct.gp** %xgv_gp594, align 8, !tbaa !3
  %gp_hv595 = getelementptr inbounds %struct.gp* %256, i64 0, i32 5
  %257 = load %struct.hv** %gp_hv595, align 8, !tbaa !3
  br label %cond.end596

cond.end596:                                      ; preds = %cond.end570, %cond.false591
  %cond597 = phi %struct.hv* [ %257, %cond.false591 ], [ %254, %cond.end570 ]
  %sv_any598 = getelementptr inbounds %struct.hv* %cond597, i64 0, i32 0
  %258 = load %struct.xpvhv** %sv_any598, align 8, !tbaa !3
  %xhv_fill = getelementptr inbounds %struct.xpvhv* %258, i64 0, i32 1
  %259 = load i64* %xhv_fill, align 8, !tbaa !5
  %cmp599 = icmp eq i64 %259, 0
  br i1 %cmp599, label %if.end633, label %land.lhs.true601

land.lhs.true601:                                 ; preds = %cond.end596
  %260 = load i8** %sv_any577, align 8, !tbaa !3
  %xpv_pv603 = bitcast i8* %260 to i8**
  %261 = load i8** %xpv_pv603, align 8, !tbaa !3
  %xpv_cur605 = getelementptr inbounds i8* %260, i64 8
  %262 = bitcast i8* %xpv_cur605 to i64*
  %263 = load i64* %262, align 8, !tbaa !5
  %conv606 = trunc i64 %263 to i32
  %call607 = call signext i8 @Perl_hv_exists(%struct.hv* %cond597, i8* %261, i32 %conv606) #7
  %tobool609 = icmp eq i8 %call607, 0
  br i1 %tobool609, label %if.end633, label %land.lhs.true610

land.lhs.true610:                                 ; preds = %land.lhs.true601
  %264 = load %struct.xpvgv** %sv_any583, align 8, !tbaa !3
  %xgv_gp612 = getelementptr inbounds %struct.xpvgv* %264, i64 0, i32 7
  %265 = load %struct.gp** %xgv_gp612, align 8, !tbaa !3
  %gp_cv613 = getelementptr inbounds %struct.gp* %265, i64 0, i32 7
  %266 = load %struct.cv** %gp_cv613, align 8, !tbaa !3
  %tobool614 = icmp eq %struct.cv* %266, null
  br i1 %tobool614, label %if.end633, label %if.then615

if.then615:                                       ; preds = %land.lhs.true610
  %267 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %268 = load i32** @PL_markstack_ptr, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds i32* %268, i64 1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !3
  %269 = load i32** @PL_markstack_max, align 8, !tbaa !3
  %cmp616 = icmp eq i32* %incdec.ptr, %269
  br i1 %cmp616, label %if.then618, label %if.end619

if.then618:                                       ; preds = %if.then615
  call void @Perl_markstack_grow() #7
  %.pre965 = load i32** @PL_markstack_ptr, align 8, !tbaa !3
  br label %if.end619

if.end619:                                        ; preds = %if.then618, %if.then615
  %270 = phi i32* [ %.pre965, %if.then618 ], [ %incdec.ptr, %if.then615 ]
  %271 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !3
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %267 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %271 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div950 = lshr exact i64 %sub.ptr.sub, 3
  %conv620 = trunc i64 %sub.ptr.div950 to i32
  store i32 %conv620, i32* %270, align 4, !tbaa !0
  %272 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !3
  %sub.ptr.lhs.cast621 = ptrtoint %struct.sv** %272 to i64
  %sub.ptr.sub623 = sub i64 %sub.ptr.lhs.cast621, %sub.ptr.lhs.cast
  %cmp625 = icmp slt i64 %sub.ptr.sub623, 8
  br i1 %cmp625, label %if.then627, label %if.end629

if.then627:                                       ; preds = %if.end619
  %call628 = call %struct.sv** @Perl_stack_grow(%struct.sv** %267, %struct.sv** %267, i32 1) #7
  br label %if.end629

if.end629:                                        ; preds = %if.then627, %if.end619
  %sp.0 = phi %struct.sv** [ %call628, %if.then627 ], [ %267, %if.end619 ]
  %incdec.ptr630 = getelementptr inbounds %struct.sv** %sp.0, i64 1
  store %struct.sv* %call545, %struct.sv** %incdec.ptr630, align 8, !tbaa !3
  store %struct.sv** %incdec.ptr630, %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %273 = bitcast %struct.cv* %266 to %struct.sv*
  %call631 = call i32 @Perl_call_sv(%struct.sv* %273, i32 2) #7
  br label %if.end633

if.end633:                                        ; preds = %land.lhs.true610, %land.lhs.true601, %cond.end596, %land.lhs.true539, %if.then528, %if.end629
  %call634 = call i8* @strrchr(i8* %cond534, i32 58) #7
  %tobool635 = icmp eq i8* %call634, null
  %incdec.ptr637 = getelementptr inbounds i8* %call634, i64 1
  %s529.0 = select i1 %tobool635, i8* %cond534, i8* %incdec.ptr637
  %274 = load i8* %s529.0, align 1, !tbaa !1
  switch i8 %274, label %done [
    i8 66, label %if.end656
    i8 69, label %if.end656
    i8 67, label %if.end656
    i8 73, label %if.end656
  ]

if.end656:                                        ; preds = %if.end633, %if.end633, %if.end633, %if.end633
  %call657 = call i32 @strcmp(i8* %s529.0, i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0)) #7
  %tobool658 = icmp eq i32 %call657, 0
  br i1 %tobool658, label %if.then659, label %if.else669

if.then659:                                       ; preds = %if.end656
  %275 = load i32* @PL_scopestack_ix, align 4, !tbaa !0
  call void @Perl_push_scope() #7
  call void @Perl_save_sptr(%struct.sv** bitcast (%struct.gv** getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 10) to %struct.sv**)) #7
  call void @Perl_save_I32(i32* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 13)) #7
  %276 = load %struct.av** @PL_beginav, align 8, !tbaa !3
  %tobool660 = icmp eq %struct.av* %276, null
  br i1 %tobool660, label %if.then661, label %if.end663

if.then661:                                       ; preds = %if.then659
  %call662 = call %struct.av* @Perl_newAV() #7
  store %struct.av* %call662, %struct.av** @PL_beginav, align 8, !tbaa !3
  br label %if.end663

if.end663:                                        ; preds = %if.then659, %if.then661
  %277 = phi %struct.av* [ %276, %if.then659 ], [ %call662, %if.then661 ]
  %278 = bitcast %struct.cv* %cv.2 to %struct.sv*
  call void @Perl_av_push(%struct.av* %277, %struct.sv* %278) #7
  %sv_any664 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %279 = load %struct.xpvgv** %sv_any664, align 8, !tbaa !3
  %xgv_gp665 = getelementptr inbounds %struct.xpvgv* %279, i64 0, i32 7
  %280 = load %struct.gp** %xgv_gp665, align 8, !tbaa !3
  %gp_cv666 = getelementptr inbounds %struct.gp* %280, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv666, align 8, !tbaa !3
  %281 = load %struct.av** @PL_beginav, align 8, !tbaa !3
  call void @Perl_call_list(i32 %275, %struct.av* %281) #7
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8, !tbaa !3
  %282 = load i32* @PL_hints, align 4, !tbaa !0
  %conv668 = trunc i32 %282 to i8
  store i8 %conv668, i8* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 7), align 1, !tbaa !1
  call void @Perl_pop_scope() #7
  br label %done

if.else669:                                       ; preds = %if.end656
  %call670 = call i32 @strcmp(i8* %s529.0, i8* getelementptr inbounds ([4 x i8]* @.str74, i64 0, i64 0)) #7
  %283 = load i32* @PL_error_count, align 4, !tbaa !0
  %284 = or i32 %283, %call670
  %285 = icmp eq i32 %284, 0
  br i1 %285, label %if.then674, label %if.else683

if.then674:                                       ; preds = %if.else669
  %286 = load %struct.av** @PL_endav, align 8, !tbaa !3
  %tobool675 = icmp eq %struct.av* %286, null
  br i1 %tobool675, label %if.then676, label %if.end678

if.then676:                                       ; preds = %if.then674
  %call677 = call %struct.av* @Perl_newAV() #7
  store %struct.av* %call677, %struct.av** @PL_endav, align 8, !tbaa !3
  br label %if.end678

if.end678:                                        ; preds = %if.then674, %if.then676
  %287 = phi %struct.av* [ %286, %if.then674 ], [ %call677, %if.then676 ]
  call void @Perl_av_unshift(%struct.av* %287, i32 1) #7
  %288 = load %struct.av** @PL_endav, align 8, !tbaa !3
  %289 = bitcast %struct.cv* %cv.2 to %struct.sv*
  %call679 = call %struct.sv** @Perl_av_store(%struct.av* %288, i32 0, %struct.sv* %289) #7
  %sv_any680 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %290 = load %struct.xpvgv** %sv_any680, align 8, !tbaa !3
  %xgv_gp681 = getelementptr inbounds %struct.xpvgv* %290, i64 0, i32 7
  %291 = load %struct.gp** %xgv_gp681, align 8, !tbaa !3
  %gp_cv682 = getelementptr inbounds %struct.gp* %291, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv682, align 8, !tbaa !3
  br label %done

if.else683:                                       ; preds = %if.else669
  %call684 = call i32 @strcmp(i8* %s529.0, i8* getelementptr inbounds ([6 x i8]* @.str75, i64 0, i64 0)) #7
  %292 = or i32 %call684, %283
  %293 = icmp eq i32 %292, 0
  br i1 %293, label %if.then688, label %if.else728

if.then688:                                       ; preds = %if.else683
  %294 = load %struct.av** @PL_checkav, align 8, !tbaa !3
  %tobool689 = icmp eq %struct.av* %294, null
  br i1 %tobool689, label %if.then690, label %if.end692

if.then690:                                       ; preds = %if.then688
  %call691 = call %struct.av* @Perl_newAV() #7
  store %struct.av* %call691, %struct.av** @PL_checkav, align 8, !tbaa !3
  br label %if.end692

if.end692:                                        ; preds = %if.then688, %if.then690
  %295 = load %struct.op** @PL_main_start, align 8, !tbaa !3
  %tobool693 = icmp eq %struct.op* %295, null
  br i1 %tobool693, label %if.end723, label %land.lhs.true694

land.lhs.true694:                                 ; preds = %if.end692
  %296 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings695 = getelementptr inbounds %struct.cop* %296, i64 0, i32 14
  %297 = load %struct.sv** %cop_warnings695, align 8, !tbaa !3
  %cmp696 = icmp eq %struct.sv* %297, null
  br i1 %cmp696, label %lor.lhs.false714, label %land.lhs.true698

land.lhs.true698:                                 ; preds = %land.lhs.true694
  %298 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings699 = getelementptr inbounds %struct.cop* %298, i64 0, i32 14
  %299 = load %struct.sv** %cop_warnings699, align 8, !tbaa !3
  %cmp700 = icmp eq %struct.sv* %299, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp700, label %lor.lhs.false714, label %land.lhs.true702

land.lhs.true702:                                 ; preds = %land.lhs.true698
  %300 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings703 = getelementptr inbounds %struct.cop* %300, i64 0, i32 14
  %301 = load %struct.sv** %cop_warnings703, align 8, !tbaa !3
  %cmp704 = icmp eq %struct.sv* %301, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp704, label %if.then722, label %lor.lhs.false706

lor.lhs.false706:                                 ; preds = %land.lhs.true702
  %302 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings707 = getelementptr inbounds %struct.cop* %302, i64 0, i32 14
  %303 = load %struct.sv** %cop_warnings707, align 8, !tbaa !3
  %sv_any708 = getelementptr inbounds %struct.sv* %303, i64 0, i32 0
  %304 = load i8** %sv_any708, align 8, !tbaa !3
  %xpv_pv709 = bitcast i8* %304 to i8**
  %305 = load i8** %xpv_pv709, align 8, !tbaa !3
  %arrayidx710 = getelementptr inbounds i8* %305, i64 11
  %306 = load i8* %arrayidx710, align 1, !tbaa !1
  %and712 = and i8 %306, 4
  %tobool713 = icmp eq i8 %and712, 0
  br i1 %tobool713, label %lor.lhs.false714, label %if.then722

lor.lhs.false714:                                 ; preds = %lor.lhs.false706, %land.lhs.true698, %land.lhs.true694
  %307 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings715 = getelementptr inbounds %struct.cop* %307, i64 0, i32 14
  %308 = load %struct.sv** %cop_warnings715, align 8, !tbaa !3
  %cmp716 = icmp eq %struct.sv* %308, null
  br i1 %cmp716, label %land.lhs.true718, label %if.end723

land.lhs.true718:                                 ; preds = %lor.lhs.false714
  %309 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and720 = and i8 %309, 1
  %tobool721 = icmp eq i8 %and720, 0
  br i1 %tobool721, label %if.end723, label %if.then722

if.then722:                                       ; preds = %lor.lhs.false706, %land.lhs.true718, %land.lhs.true702
  call void (i32, i8*, ...)* @Perl_warner(i32 45, i8* getelementptr inbounds ([28 x i8]* @.str76, i64 0, i64 0)) #7
  br label %if.end723

if.end723:                                        ; preds = %land.lhs.true718, %lor.lhs.false714, %if.end692, %if.then722
  %310 = load %struct.av** @PL_checkav, align 8, !tbaa !3
  call void @Perl_av_unshift(%struct.av* %310, i32 1) #7
  %311 = load %struct.av** @PL_checkav, align 8, !tbaa !3
  %312 = bitcast %struct.cv* %cv.2 to %struct.sv*
  %call724 = call %struct.sv** @Perl_av_store(%struct.av* %311, i32 0, %struct.sv* %312) #7
  %sv_any725 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %313 = load %struct.xpvgv** %sv_any725, align 8, !tbaa !3
  %xgv_gp726 = getelementptr inbounds %struct.xpvgv* %313, i64 0, i32 7
  %314 = load %struct.gp** %xgv_gp726, align 8, !tbaa !3
  %gp_cv727 = getelementptr inbounds %struct.gp* %314, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv727, align 8, !tbaa !3
  br label %done

if.else728:                                       ; preds = %if.else683
  %call729 = call i32 @strcmp(i8* %s529.0, i8* getelementptr inbounds ([5 x i8]* @.str77, i64 0, i64 0)) #7
  %315 = or i32 %call729, %283
  %316 = icmp eq i32 %315, 0
  br i1 %316, label %if.then733, label %done

if.then733:                                       ; preds = %if.else728
  %317 = load %struct.av** @PL_initav, align 8, !tbaa !3
  %tobool734 = icmp eq %struct.av* %317, null
  br i1 %tobool734, label %if.then735, label %if.end737

if.then735:                                       ; preds = %if.then733
  %call736 = call %struct.av* @Perl_newAV() #7
  store %struct.av* %call736, %struct.av** @PL_initav, align 8, !tbaa !3
  br label %if.end737

if.end737:                                        ; preds = %if.then733, %if.then735
  %318 = load %struct.op** @PL_main_start, align 8, !tbaa !3
  %tobool738 = icmp eq %struct.op* %318, null
  br i1 %tobool738, label %if.end768, label %land.lhs.true739

land.lhs.true739:                                 ; preds = %if.end737
  %319 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings740 = getelementptr inbounds %struct.cop* %319, i64 0, i32 14
  %320 = load %struct.sv** %cop_warnings740, align 8, !tbaa !3
  %cmp741 = icmp eq %struct.sv* %320, null
  br i1 %cmp741, label %lor.lhs.false759, label %land.lhs.true743

land.lhs.true743:                                 ; preds = %land.lhs.true739
  %321 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings744 = getelementptr inbounds %struct.cop* %321, i64 0, i32 14
  %322 = load %struct.sv** %cop_warnings744, align 8, !tbaa !3
  %cmp745 = icmp eq %struct.sv* %322, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp745, label %lor.lhs.false759, label %land.lhs.true747

land.lhs.true747:                                 ; preds = %land.lhs.true743
  %323 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings748 = getelementptr inbounds %struct.cop* %323, i64 0, i32 14
  %324 = load %struct.sv** %cop_warnings748, align 8, !tbaa !3
  %cmp749 = icmp eq %struct.sv* %324, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp749, label %if.then767, label %lor.lhs.false751

lor.lhs.false751:                                 ; preds = %land.lhs.true747
  %325 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings752 = getelementptr inbounds %struct.cop* %325, i64 0, i32 14
  %326 = load %struct.sv** %cop_warnings752, align 8, !tbaa !3
  %sv_any753 = getelementptr inbounds %struct.sv* %326, i64 0, i32 0
  %327 = load i8** %sv_any753, align 8, !tbaa !3
  %xpv_pv754 = bitcast i8* %327 to i8**
  %328 = load i8** %xpv_pv754, align 8, !tbaa !3
  %arrayidx755 = getelementptr inbounds i8* %328, i64 11
  %329 = load i8* %arrayidx755, align 1, !tbaa !1
  %and757 = and i8 %329, 4
  %tobool758 = icmp eq i8 %and757, 0
  br i1 %tobool758, label %lor.lhs.false759, label %if.then767

lor.lhs.false759:                                 ; preds = %lor.lhs.false751, %land.lhs.true743, %land.lhs.true739
  %330 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings760 = getelementptr inbounds %struct.cop* %330, i64 0, i32 14
  %331 = load %struct.sv** %cop_warnings760, align 8, !tbaa !3
  %cmp761 = icmp eq %struct.sv* %331, null
  br i1 %cmp761, label %land.lhs.true763, label %if.end768

land.lhs.true763:                                 ; preds = %lor.lhs.false759
  %332 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and765 = and i8 %332, 1
  %tobool766 = icmp eq i8 %and765, 0
  br i1 %tobool766, label %if.end768, label %if.then767

if.then767:                                       ; preds = %lor.lhs.false751, %land.lhs.true763, %land.lhs.true747
  call void (i32, i8*, ...)* @Perl_warner(i32 45, i8* getelementptr inbounds ([27 x i8]* @.str78, i64 0, i64 0)) #7
  br label %if.end768

if.end768:                                        ; preds = %land.lhs.true763, %lor.lhs.false759, %if.end737, %if.then767
  %333 = load %struct.av** @PL_initav, align 8, !tbaa !3
  %334 = bitcast %struct.cv* %cv.2 to %struct.sv*
  call void @Perl_av_push(%struct.av* %333, %struct.sv* %334) #7
  %sv_any769 = getelementptr inbounds %struct.gv* %call73, i64 0, i32 0
  %335 = load %struct.xpvgv** %sv_any769, align 8, !tbaa !3
  %xgv_gp770 = getelementptr inbounds %struct.xpvgv* %335, i64 0, i32 7
  %336 = load %struct.gp** %xgv_gp770, align 8, !tbaa !3
  %gp_cv771 = getelementptr inbounds %struct.gp* %336, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv771, align 8, !tbaa !3
  br label %done

done:                                             ; preds = %if.then420, %if.else435, %if.then434, %if.then422, %if.end633, %if.end524, %if.else728, %if.end445, %if.end678, %if.end768, %if.end723, %if.end663, %if.then337, %if.end282, %if.end193, %if.end127
  %cv.3 = phi %struct.cv* [ null, %if.end127 ], [ %cv.1, %if.end282 ], [ %cv.2, %if.else728 ], [ %cv.2, %if.end768 ], [ %cv.2, %if.end723 ], [ %cv.2, %if.end678 ], [ %cv.2, %if.end663 ], [ %cv.2, %if.end445 ], [ %cv.0, %if.then337 ], [ %cond139, %if.end193 ], [ %cv.2, %if.end524 ], [ %cv.2, %if.end633 ], [ %cv.2, %if.then422 ], [ %cv.2, %if.then434 ], [ %cv.2, %if.else435 ], [ %cv.2, %if.then420 ]
  store i32 -1, i32* @PL_copline, align 4, !tbaa !0
  %337 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %cmp777 = icmp sgt i32 %337, %floor
  br i1 %cmp777, label %if.then779, label %if.end780

if.then779:                                       ; preds = %done
  call void @Perl_leave_scope(i32 %floor) #7
  br label %if.end780

if.end780:                                        ; preds = %if.then779, %done
  ret %struct.cv* %cv.3
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newSTATEOP(i32 %flags, i8* %label, %struct.op* %o) #0 {
entry:
  %call = tail call i32 @Perl_intro_my() #7
  %call1 = tail call i8* @Perl_safesysmalloc(i64 96) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call1, i8 0, i64 96, i32 1, i1 false)
  %0 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool = icmp eq i32 %0, 0
  %and = and i32 %0, 2
  %tobool2 = icmp eq i32 %and, 0
  %or.cond = or i1 %tobool, %tobool2
  br i1 %or.cond, label %if.else, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %entry
  %1 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %1, i64 0, i32 13
  %2 = load i32* %cop_line, align 4, !tbaa !0
  %tobool4 = icmp eq i32 %2, 0
  br i1 %tobool4, label %if.else, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %3 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %4 = load %struct.hv** @PL_debstash, align 8, !tbaa !3
  %cmp = icmp eq %struct.hv* %3, %4
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true5
  %op_type = getelementptr inbounds i8* %call1, i64 32
  %5 = bitcast i8* %op_type to i16*
  store i16 175, i16* %5, align 2, !tbaa !4
  %6 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 175), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call1, i64 16
  %7 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %6, %struct.op* ()** %7, align 8, !tbaa !3
  br label %if.end

if.else:                                          ; preds = %land.lhs.true5, %land.lhs.true3, %entry
  %op_type6 = getelementptr inbounds i8* %call1, i64 32
  %8 = bitcast i8* %op_type6 to i16*
  store i16 174, i16* %8, align 2, !tbaa !4
  %9 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 174), align 8, !tbaa !3
  %op_ppaddr7 = getelementptr inbounds i8* %call1, i64 16
  %10 = bitcast i8* %op_ppaddr7 to %struct.op* ()**
  store %struct.op* ()* %9, %struct.op* ()** %10, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %conv = trunc i32 %flags to i8
  %11 = getelementptr inbounds i8* %call1, i64 36
  store i8 %conv, i8* %11, align 1, !tbaa !1
  %12 = load i32* @PL_hints, align 4, !tbaa !0
  %conv9 = trunc i32 %12 to i8
  %13 = getelementptr inbounds i8* %call1, i64 37
  store i8 %conv9, i8* %13, align 1, !tbaa !1
  store i8 %conv9, i8* getelementptr inbounds (%struct.cop* @PL_compiling, i64 0, i32 7), align 1, !tbaa !1
  %14 = bitcast i8* %call1 to %struct.op*
  %op_next = bitcast i8* %call1 to %struct.op**
  store %struct.op* %14, %struct.op** %op_next, align 8, !tbaa !3
  %tobool11 = icmp eq i8* %label, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end
  %cop_label = getelementptr inbounds i8* %call1, i64 40
  %15 = bitcast i8* %cop_label to i8**
  store i8* %label, i8** %15, align 8, !tbaa !3
  %16 = load i32* @PL_hints, align 4, !tbaa !0
  %or = or i32 %16, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then12
  %cop_seq = getelementptr inbounds i8* %call1, i64 64
  %17 = bitcast i8* %cop_seq to i32*
  store i32 %call, i32* %17, align 4, !tbaa !0
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_arybase = getelementptr inbounds %struct.cop* %18, i64 0, i32 12
  %19 = load i32* %cop_arybase, align 4, !tbaa !0
  %cop_arybase14 = getelementptr inbounds i8* %call1, i64 68
  %20 = bitcast i8* %cop_arybase14 to i32*
  store i32 %19, i32* %20, align 4, !tbaa !0
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp15 = icmp eq %struct.sv* %22, null
  br i1 %cmp15, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end13
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings17 = getelementptr inbounds %struct.cop* %23, i64 0, i32 14
  %24 = load %struct.sv** %cop_warnings17, align 8, !tbaa !3
  %cmp18 = icmp eq %struct.sv* %24, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp18, label %if.then24, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings21 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings21, align 8, !tbaa !3
  %cmp22 = icmp eq %struct.sv* %26, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp22, label %if.then24, label %if.else27

if.then24:                                        ; preds = %lor.lhs.false20, %lor.lhs.false, %if.end13
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings25 = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings25, align 8, !tbaa !3
  %cop_warnings26 = getelementptr inbounds i8* %call1, i64 80
  %29 = bitcast i8* %cop_warnings26 to %struct.sv**
  store %struct.sv* %28, %struct.sv** %29, align 8, !tbaa !3
  br label %if.end31

if.else27:                                        ; preds = %lor.lhs.false20
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings28 = getelementptr inbounds %struct.cop* %30, i64 0, i32 14
  %31 = load %struct.sv** %cop_warnings28, align 8, !tbaa !3
  %call29 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %31) #7
  %cop_warnings30 = getelementptr inbounds i8* %call1, i64 80
  %32 = bitcast i8* %cop_warnings30 to %struct.sv**
  store %struct.sv* %call29, %struct.sv** %32, align 8, !tbaa !3
  br label %if.end31

if.end31:                                         ; preds = %if.else27, %if.then24
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_io = getelementptr inbounds %struct.cop* %33, i64 0, i32 15
  %34 = load %struct.sv** %cop_io, align 8, !tbaa !3
  %cmp32 = icmp eq %struct.sv* %34, null
  %35 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_io35 = getelementptr inbounds %struct.cop* %35, i64 0, i32 15
  %36 = load %struct.sv** %cop_io35, align 8, !tbaa !3
  br i1 %cmp32, label %if.then34, label %if.else37

if.then34:                                        ; preds = %if.end31
  %cop_io36 = getelementptr inbounds i8* %call1, i64 88
  %37 = bitcast i8* %cop_io36 to %struct.sv**
  store %struct.sv* %36, %struct.sv** %37, align 8, !tbaa !3
  br label %if.end41

if.else37:                                        ; preds = %if.end31
  %call39 = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %36) #7
  %cop_io40 = getelementptr inbounds i8* %call1, i64 88
  %38 = bitcast i8* %cop_io40 to %struct.sv**
  store %struct.sv* %call39, %struct.sv** %38, align 8, !tbaa !3
  br label %if.end41

if.end41:                                         ; preds = %if.else37, %if.then34
  %39 = load i32* @PL_copline, align 4, !tbaa !0
  %cmp42 = icmp eq i32 %39, -1
  br i1 %cmp42, label %if.then44, label %if.else47

if.then44:                                        ; preds = %if.end41
  %40 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line45 = getelementptr inbounds %struct.cop* %40, i64 0, i32 13
  %41 = load i32* %cop_line45, align 4, !tbaa !0
  %cop_line46 = getelementptr inbounds i8* %call1, i64 72
  %42 = bitcast i8* %cop_line46 to i32*
  store i32 %41, i32* %42, align 4, !tbaa !0
  br label %if.end49

if.else47:                                        ; preds = %if.end41
  %cop_line48 = getelementptr inbounds i8* %call1, i64 72
  %43 = bitcast i8* %cop_line48 to i32*
  store i32 %39, i32* %43, align 4, !tbaa !0
  store i32 -1, i32* @PL_copline, align 4, !tbaa !0
  br label %if.end49

if.end49:                                         ; preds = %if.else47, %if.then44
  %44 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv = getelementptr inbounds %struct.cop* %44, i64 0, i32 10
  %45 = load %struct.gv** %cop_filegv, align 8, !tbaa !3
  %46 = bitcast %struct.gv* %45 to %struct.sv*
  store %struct.sv* %46, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool50 = icmp eq %struct.gv* %45, null
  br i1 %tobool50, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end49
  %47 = getelementptr inbounds %struct.gv* %45, i64 0, i32 1
  %48 = load i32* %47, align 4, !tbaa !0
  %inc = add i32 %48, 1
  store i32 %inc, i32* %47, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %if.end49, %land.rhs
  %cop_filegv52 = getelementptr inbounds i8* %call1, i64 56
  %49 = bitcast i8* %cop_filegv52 to %struct.gv**
  store %struct.gv* %45, %struct.gv** %49, align 8, !tbaa !3
  %50 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %cop_stash = getelementptr inbounds i8* %call1, i64 48
  %51 = bitcast i8* %cop_stash to %struct.hv**
  store %struct.hv* %50, %struct.hv** %51, align 8, !tbaa !3
  %52 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool53 = icmp eq i32 %52, 0
  %and55 = and i32 %52, 2
  %tobool56 = icmp eq i32 %and55, 0
  %or.cond113 = or i1 %tobool53, %tobool56
  br i1 %or.cond113, label %if.end82, label %land.lhs.true57

land.lhs.true57:                                  ; preds = %land.end
  %53 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %54 = load %struct.hv** @PL_debstash, align 8, !tbaa !3
  %cmp58 = icmp eq %struct.hv* %53, %54
  br i1 %cmp58, label %if.end82, label %if.then60

if.then60:                                        ; preds = %land.lhs.true57
  %55 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv61 = getelementptr inbounds %struct.cop* %55, i64 0, i32 10
  %56 = load %struct.gv** %cop_filegv61, align 8, !tbaa !3
  %tobool62 = icmp eq %struct.gv* %56, null
  br i1 %tobool62, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then60
  %57 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv63 = getelementptr inbounds %struct.cop* %57, i64 0, i32 10
  %58 = load %struct.gv** %cop_filegv63, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.gv* %58, i64 0, i32 0
  %59 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %59, i64 0, i32 7
  %60 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_av = getelementptr inbounds %struct.gp* %60, i64 0, i32 4
  %61 = load %struct.av** %gp_av, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %if.then60, %cond.true
  %cond = phi %struct.av* [ %61, %cond.true ], [ null, %if.then60 ]
  %cop_line64 = getelementptr inbounds i8* %call1, i64 72
  %62 = bitcast i8* %cop_line64 to i32*
  %63 = load i32* %62, align 4, !tbaa !0
  %call65 = tail call %struct.sv** @Perl_av_fetch(%struct.av* %cond, i32 %63, i32 0) #7
  %tobool66 = icmp eq %struct.sv** %call65, null
  br i1 %tobool66, label %if.end82, label %land.lhs.true67

land.lhs.true67:                                  ; preds = %cond.end
  %64 = load %struct.sv** %call65, align 8, !tbaa !3
  %cmp68 = icmp eq %struct.sv* %64, @PL_sv_undef
  br i1 %cmp68, label %if.end82, label %if.then70

if.then70:                                        ; preds = %land.lhs.true67
  %sv_flags = getelementptr inbounds %struct.sv* %64, i64 0, i32 2
  %65 = load i32* %sv_flags, align 4, !tbaa !0
  %and71 = and i32 %65, 2097152
  %tobool72 = icmp eq i32 %and71, 0
  br i1 %tobool72, label %land.end76, label %land.rhs73

land.rhs73:                                       ; preds = %if.then70
  %call74 = tail call i32 @Perl_sv_backoff(%struct.sv* %64) #7
  %.pre = load %struct.sv** %call65, align 8, !tbaa !3
  %sv_flags78.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre, i64 0, i32 2
  %.pre114 = load i32* %sv_flags78.phi.trans.insert, align 4, !tbaa !0
  br label %land.end76

land.end76:                                       ; preds = %if.then70, %land.rhs73
  %66 = phi i32 [ %65, %if.then70 ], [ %.pre114, %land.rhs73 ]
  %67 = phi %struct.sv* [ %64, %if.then70 ], [ %.pre, %land.rhs73 ]
  %sv_flags78 = getelementptr inbounds %struct.sv* %67, i64 0, i32 2
  %or79 = or i32 %66, 16842752
  store i32 %or79, i32* %sv_flags78, align 4, !tbaa !0
  %68 = ptrtoint i8* %call1 to i64
  %sv_any80 = getelementptr inbounds %struct.sv* %67, i64 0, i32 0
  %69 = load i8** %sv_any80, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %69, i64 24
  %70 = bitcast i8* %xiv_iv to i64*
  store i64 %68, i64* %70, align 8, !tbaa !5
  br label %if.end82

if.end82:                                         ; preds = %land.lhs.true67, %cond.end, %land.lhs.true57, %land.end, %land.end76
  %call83 = tail call %struct.op* @Perl_prepend_elem(i32 173, %struct.op* %14, %struct.op* %o) #8
  ret %struct.op* %call83
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #4

; Function Attrs: nounwind optsize uwtable
define void @Perl_vload_module(i32 %flags, %struct.sv* %name, %struct.sv* %ver, [1 x %struct.__va_list_tag]* nocapture %args) #0 {
entry:
  %call = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %name) #8
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  %0 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %0, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  %tobool = icmp eq %struct.sv* %ver, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call2 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %ver) #8
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %veop.0 = phi %struct.op* [ %call2, %if.then ], [ null, %entry ]
  %and = and i32 %flags, 2
  %tobool3 = icmp eq i32 %and, 0
  br i1 %tobool3, label %if.else7, label %if.then4

if.then4:                                         ; preds = %if.end
  %call.i = tail call %struct.op* @Perl_newOP(i32 1, i32 0) #7
  %tobool.i = icmp eq %struct.op* %call.i, null
  br i1 %tobool.i, label %if.end40, label %if.then.i

if.then.i:                                        ; preds = %if.then4
  %op_flags.i = getelementptr inbounds %struct.op* %call.i, i64 0, i32 6
  %1 = load i8* %op_flags.i, align 1, !tbaa !1
  %or.i = or i8 %1, 8
  store i8 %or.i, i8* %op_flags.i, align 1, !tbaa !1
  br label %if.end40

if.else7:                                         ; preds = %if.end
  %and8 = and i32 %flags, 4
  %tobool9 = icmp eq i32 %and8, 0
  %gp_offset_p13 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 0
  %gp_offset14 = load i32* %gp_offset_p13, align 4
  %fits_in_gp15 = icmp ult i32 %gp_offset14, 41
  br i1 %tobool9, label %if.else11, label %if.then10

if.then10:                                        ; preds = %if.else7
  br i1 %fits_in_gp15, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then10
  %2 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 3
  %reg_save_area = load i8** %2, align 8
  %3 = sext i32 %gp_offset14 to i64
  %4 = getelementptr i8* %reg_save_area, i64 %3
  %5 = add i32 %gp_offset14, 8
  store i32 %5, i32* %gp_offset_p13, align 4
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then10
  %overflow_arg_area_p = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 2
  %overflow_arg_area = load i8** %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8* %overflow_arg_area, i64 8
  store i8* %overflow_arg_area.next, i8** %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr.in = phi i8* [ %4, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %vaarg.addr = bitcast i8* %vaarg.addr.in to %struct.op**
  %6 = load %struct.op** %vaarg.addr, align 8
  br label %if.end40

if.else11:                                        ; preds = %if.else7
  br i1 %fits_in_gp15, label %vaarg.in_reg16, label %vaarg.in_mem18

vaarg.in_reg16:                                   ; preds = %if.else11
  %7 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 3
  %reg_save_area17 = load i8** %7, align 8
  %8 = sext i32 %gp_offset14 to i64
  %9 = getelementptr i8* %reg_save_area17, i64 %8
  %10 = add i32 %gp_offset14, 8
  store i32 %10, i32* %gp_offset_p13, align 4
  br label %while.cond.preheader

vaarg.in_mem18:                                   ; preds = %if.else11
  %overflow_arg_area_p19 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 2
  %overflow_arg_area20 = load i8** %overflow_arg_area_p19, align 8
  %overflow_arg_area.next21 = getelementptr i8* %overflow_arg_area20, i64 8
  store i8* %overflow_arg_area.next21, i8** %overflow_arg_area_p19, align 8
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %vaarg.in_mem18, %vaarg.in_reg16
  %sv.0.in.in.ph = phi i8* [ %9, %vaarg.in_reg16 ], [ %overflow_arg_area20, %vaarg.in_mem18 ]
  %sv.0.in52 = bitcast i8* %sv.0.in.in.ph to %struct.sv**
  %sv.053 = load %struct.sv** %sv.0.in52, align 8
  %tobool2454 = icmp eq %struct.sv* %sv.053, null
  br i1 %tobool2454, label %if.end40, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %11 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 3
  %overflow_arg_area_p34 = getelementptr inbounds [1 x %struct.__va_list_tag]* %args, i64 0, i64 0, i32 2
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %sv.056 = phi %struct.sv* [ %sv.053, %while.body.lr.ph ], [ %sv.0, %while.cond.backedge ]
  %imop.055 = phi %struct.op* [ null, %while.body.lr.ph ], [ %call26, %while.cond.backedge ]
  %call25 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %sv.056) #8
  %call26 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %imop.055, %struct.op* %call25) #8
  %gp_offset29 = load i32* %gp_offset_p13, align 4
  %fits_in_gp30 = icmp ult i32 %gp_offset29, 41
  br i1 %fits_in_gp30, label %vaarg.in_reg31, label %vaarg.in_mem33

vaarg.in_reg31:                                   ; preds = %while.body
  %reg_save_area32 = load i8** %11, align 8
  %12 = sext i32 %gp_offset29 to i64
  %13 = getelementptr i8* %reg_save_area32, i64 %12
  %14 = add i32 %gp_offset29, 8
  store i32 %14, i32* %gp_offset_p13, align 4
  br label %while.cond.backedge

vaarg.in_mem33:                                   ; preds = %while.body
  %overflow_arg_area35 = load i8** %overflow_arg_area_p34, align 8
  %overflow_arg_area.next36 = getelementptr i8* %overflow_arg_area35, i64 8
  store i8* %overflow_arg_area.next36, i8** %overflow_arg_area_p34, align 8
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %vaarg.in_mem33, %vaarg.in_reg31
  %sv.0.in.in.be = phi i8* [ %13, %vaarg.in_reg31 ], [ %overflow_arg_area35, %vaarg.in_mem33 ]
  %sv.0.in = bitcast i8* %sv.0.in.in.be to %struct.sv**
  %sv.0 = load %struct.sv** %sv.0.in, align 8
  %tobool24 = icmp eq %struct.sv* %sv.0, null
  br i1 %tobool24, label %if.end40, label %while.body

if.end40:                                         ; preds = %while.cond.preheader, %while.cond.backedge, %if.then.i, %if.then4, %vaarg.end
  %imop.1 = phi %struct.op* [ %6, %vaarg.end ], [ null, %if.then4 ], [ %call.i, %if.then.i ], [ null, %while.cond.preheader ], [ %call26, %while.cond.backedge ]
  %15 = load i32* @PL_copline, align 4, !tbaa !0
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %17 = load i32* @PL_expect, align 4, !tbaa !0
  %and41 = and i32 %flags, 1
  %18 = xor i32 %and41, 1
  %call43 = tail call i32 @Perl_start_subparse(i32 0, i32 0) #7
  tail call void @Perl_utilize(i32 %18, i32 %call43, %struct.op* %veop.0, %struct.op* %call, %struct.op* %imop.1) #8
  store i32 %17, i32* @PL_expect, align 4, !tbaa !0
  store i32 %15, i32* @PL_copline, align 4, !tbaa !0
  store volatile %struct.cop* %16, %struct.cop** @PL_curcop, align 8, !tbaa !3
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #4

; Function Attrs: optsize
declare i32 @Perl_start_subparse(i32, i32) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_dofile(%struct.op* %term) #0 {
entry:
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([3 x i8]* @.str52, i64 0, i64 0), i32 0, i32 12) #7
  %tobool = icmp eq %struct.gv* %call, null
  br i1 %tobool, label %if.then, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.gv* %call, i64 0, i32 0
  %0 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 7
  %1 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_cvgen = getelementptr inbounds %struct.gp* %1, i64 0, i32 8
  %2 = load i32* %gp_cvgen, align 4, !tbaa !0
  %tobool1 = icmp eq i32 %2, 0
  br i1 %tobool1, label %cond.false, label %if.then

cond.false:                                       ; preds = %land.lhs.true
  %gp_cv = getelementptr inbounds %struct.gp* %1, i64 0, i32 7
  %3 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool4 = icmp eq %struct.cv* %3, null
  br i1 %tobool4, label %if.then, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %cond.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %0, i64 0, i32 11
  %4 = load i8* %xgv_flags, align 1, !tbaa !1
  %tobool7 = icmp slt i8 %4, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %cond.false, %land.lhs.true, %entry, %land.lhs.true5
  %call8 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([17 x i8]* @.str53, i64 0, i64 0), i32 0, i32 12) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true5
  %gv.0 = phi %struct.gv* [ %call8, %if.then ], [ %call, %land.lhs.true5 ]
  %tobool9 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool9, label %if.else, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %if.end
  %sv_any11 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %5 = load %struct.xpvgv** %sv_any11, align 8, !tbaa !3
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 7
  %6 = load %struct.gp** %xgv_gp12, align 8, !tbaa !3
  %gp_cvgen13 = getelementptr inbounds %struct.gp* %6, i64 0, i32 8
  %7 = load i32* %gp_cvgen13, align 4, !tbaa !0
  %tobool14 = icmp eq i32 %7, 0
  br i1 %tobool14, label %cond.false16, label %if.else

cond.false16:                                     ; preds = %land.lhs.true10
  %gp_cv19 = getelementptr inbounds %struct.gp* %6, i64 0, i32 7
  %8 = load %struct.cv** %gp_cv19, align 8, !tbaa !3
  %tobool20 = icmp eq %struct.cv* %8, null
  br i1 %tobool20, label %if.else, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %cond.false16
  %xgv_flags23 = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 11
  %9 = load i8* %xgv_flags23, align 1, !tbaa !1
  %tobool26 = icmp slt i8 %9, 0
  br i1 %tobool26, label %Perl_newGVOP.exit, label %if.else

Perl_newGVOP.exit:                                ; preds = %land.lhs.true21
  %10 = bitcast %struct.gv* %gv.0 to %struct.sv*
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %11 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 1
  %12 = load i32* %11, align 4, !tbaa !0
  %inc.i = add i32 %12, 1
  store i32 %inc.i, i32* %11, align 4, !tbaa !0
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %10) #7
  %call29 = tail call %struct.op* @Perl_newUNOP(i32 17, i32 0, %struct.op* %call.i) #8
  %call30 = tail call %struct.op* @Perl_scalar(%struct.op* %call29) #8
  %call31 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %term, %struct.op* %call30) #8
  %call32 = tail call %struct.op* @Perl_newUNOP(i32 166, i32 64, %struct.op* %call31) #8
  %call33 = tail call %struct.op* @Perl_ck_subr(%struct.op* %call32) #8
  br label %if.end36

if.else:                                          ; preds = %cond.false16, %land.lhs.true10, %if.end, %land.lhs.true21
  %call34 = tail call %struct.op* @Perl_scalar(%struct.op* %term) #8
  %call35 = tail call %struct.op* @Perl_newUNOP(i32 310, i32 0, %struct.op* %call34) #8
  br label %if.end36

if.end36:                                         ; preds = %if.else, %Perl_newGVOP.exit
  %doop.0 = phi %struct.op* [ %call35, %if.else ], [ %call33, %Perl_newGVOP.exit ]
  ret %struct.op* %doop.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_subr(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %2 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool = icmp eq %struct.op* %2, null
  %.o = select i1 %tobool, %struct.op* %1, %struct.op* %o
  %3 = getelementptr inbounds %struct.op* %.o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  %op_sibling3 = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %5 = load %struct.op** %op_sibling3, align 8, !tbaa !3
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %6, 32
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %entry
  %cvop.0 = phi %struct.op* [ %5, %entry ], [ %7, %for.cond ]
  %op_sibling5 = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 1
  %7 = load %struct.op** %op_sibling5, align 8, !tbaa !3
  %tobool6 = icmp eq %struct.op* %7, null
  br i1 %tobool6, label %for.end, label %for.cond

for.end:                                          ; preds = %for.cond
  %op_type = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 4
  %8 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %8, label %if.end106 [
    i16 17, label %if.then
    i16 165, label %if.then72
    i16 350, label %if.then72
  ]

if.then:                                          ; preds = %for.end
  %op_private10 = getelementptr inbounds %struct.op* %cvop.0, i64 0, i32 7
  %9 = load i8* %op_private10, align 1, !tbaa !1
  %and = and i8 %9, 8
  %or14 = or i8 %or, %and
  store i8 %or14, i8* %op_private, align 1, !tbaa !1
  call void @Perl_op_null(%struct.op* %cvop.0) #8
  %10 = getelementptr inbounds %struct.op* %cvop.0, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !3
  %12 = getelementptr inbounds %struct.op* %11, i64 0, i32 4
  %13 = load i16* %12, align 2, !tbaa !4
  %cmp19 = icmp eq i16 %13, 7
  br i1 %cmp19, label %land.lhs.true, label %if.end106

land.lhs.true:                                    ; preds = %if.then
  %14 = load i8* %op_private, align 1, !tbaa !1
  %and23 = and i8 %14, 8
  %tobool24 = icmp eq i8 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end106

if.then25:                                        ; preds = %land.lhs.true
  %op_sv = getelementptr inbounds %struct.op* %11, i64 1
  %15 = bitcast %struct.op* %op_sv to %struct.sv**
  %16 = load %struct.sv** %15, align 8, !tbaa !3
  %17 = bitcast %struct.sv* %16 to %struct.gv*
  %sv_any = bitcast %struct.sv* %16 to %struct.xpvgv**
  %18 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_cvgen = getelementptr inbounds %struct.gp* %19, i64 0, i32 8
  %20 = load i32* %gp_cvgen, align 4, !tbaa !0
  %tobool26 = icmp eq i32 %20, 0
  br i1 %tobool26, label %cond.end31, label %if.then34

cond.end31:                                       ; preds = %if.then25
  %gp_cv = getelementptr inbounds %struct.gp* %19, i64 0, i32 7
  %21 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool33 = icmp eq %struct.cv* %21, null
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.then25, %cond.end31
  %22 = getelementptr inbounds %struct.op* %11, i64 0, i32 7
  %23 = load i8* %22, align 1, !tbaa !1
  %or37 = or i8 %23, 32
  store i8 %or37, i8* %22, align 1, !tbaa !1
  br label %if.end106

if.else:                                          ; preds = %cond.end31
  %sv_flags = getelementptr inbounds %struct.cv* %21, i64 0, i32 2
  %24 = load i32* %sv_flags, align 4, !tbaa !0
  %and39 = and i32 %24, 262144
  %tobool40 = icmp eq i32 %and39, 0
  br i1 %tobool40, label %if.end106, label %if.then41

if.then41:                                        ; preds = %if.else
  %sv_any42 = getelementptr inbounds %struct.cv* %21, i64 0, i32 0
  %25 = load %struct.xpvcv** %sv_any42, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %25, i64 0, i32 17
  %26 = load i16* %xcv_flags, align 2, !tbaa !4
  %and44 = and i16 %26, 4
  %tobool45 = icmp eq i16 %and44, 0
  br i1 %tobool45, label %cond.false47, label %cond.true55

cond.false47:                                     ; preds = %if.then41
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %25, i64 0, i32 12
  %27 = load %struct.gv** %xcv_gv, align 8, !tbaa !3
  br label %cond.true55

cond.true55:                                      ; preds = %cond.false47, %if.then41
  %cond50 = phi %struct.gv* [ %27, %cond.false47 ], [ %17, %if.then41 ]
  %xpv_pv = getelementptr inbounds %struct.xpvcv* %25, i64 0, i32 0
  %28 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %if.end106

if.then72:                                        ; preds = %for.end, %for.end
  %op_type73 = getelementptr inbounds %struct.op* %5, i64 0, i32 4
  %29 = load i16* %op_type73, align 2, !tbaa !4
  switch i16 %29, label %if.end106 [
    i16 5, label %if.then77
    i16 141, label %if.then87
  ]

if.then77:                                        ; preds = %if.then72
  %op_private78 = getelementptr inbounds %struct.op* %5, i64 0, i32 7
  %30 = load i8* %op_private78, align 1, !tbaa !1
  %and80 = and i8 %30, -9
  store i8 %and80, i8* %op_private78, align 1, !tbaa !1
  br label %if.end106

if.then87:                                        ; preds = %if.then72
  %31 = getelementptr inbounds %struct.op* %5, i64 1, i32 0
  %32 = load %struct.op** %31, align 8, !tbaa !3
  %op_sibling90 = getelementptr inbounds %struct.op* %32, i64 0, i32 1
  %33 = load %struct.op** %op_sibling90, align 8, !tbaa !3
  %tobool91 = icmp eq %struct.op* %33, null
  br i1 %tobool91, label %if.end106, label %land.lhs.true92

land.lhs.true92:                                  ; preds = %if.then87
  %op_type93 = getelementptr inbounds %struct.op* %33, i64 0, i32 4
  %34 = load i16* %op_type93, align 2, !tbaa !4
  %cmp95 = icmp eq i16 %34, 5
  br i1 %cmp95, label %if.then97, label %if.end106

if.then97:                                        ; preds = %land.lhs.true92
  %op_private98 = getelementptr inbounds %struct.op* %33, i64 0, i32 7
  %35 = load i8* %op_private98, align 1, !tbaa !1
  %and100 = and i8 %35, -9
  store i8 %and100, i8* %op_private98, align 1, !tbaa !1
  br label %if.end106

if.end106:                                        ; preds = %if.then, %if.then72, %for.end, %cond.true55, %if.else, %land.lhs.true, %if.then87, %if.then97, %land.lhs.true92, %if.then77, %if.then34
  %namegv.0 = phi %struct.gv* [ null, %land.lhs.true ], [ null, %if.else ], [ null, %if.then34 ], [ null, %if.then77 ], [ null, %if.then97 ], [ null, %land.lhs.true92 ], [ null, %if.then87 ], [ %cond50, %cond.true55 ], [ null, %for.end ], [ null, %if.then72 ], [ null, %if.then ]
  %cv.0 = phi %struct.cv* [ null, %land.lhs.true ], [ %21, %if.else ], [ null, %if.then34 ], [ null, %if.then77 ], [ null, %if.then97 ], [ null, %land.lhs.true92 ], [ null, %if.then87 ], [ %21, %cond.true55 ], [ null, %for.end ], [ null, %if.then72 ], [ null, %if.then ]
  %proto.0 = phi i8* [ null, %land.lhs.true ], [ null, %if.else ], [ null, %if.then34 ], [ null, %if.then77 ], [ null, %if.then97 ], [ null, %land.lhs.true92 ], [ null, %if.then87 ], [ %28, %cond.true55 ], [ null, %for.end ], [ null, %if.then72 ], [ null, %if.then ]
  %36 = load i32* @PL_hints, align 4, !tbaa !0
  %and107 = and i32 %36, 2
  %37 = load i8* %op_private, align 1, !tbaa !1
  %conv109 = zext i8 %37 to i32
  %or110 = or i32 %conv109, %and107
  %conv111 = trunc i32 %or110 to i8
  store i8 %conv111, i8* %op_private, align 1, !tbaa !1
  %38 = load i32* @PL_perldb, align 4, !tbaa !0
  %tobool112 = icmp eq i32 %38, 0
  %and114 = and i32 %38, 1
  %tobool115 = icmp eq i32 %and114, 0
  %or.cond = or i1 %tobool112, %tobool115
  br i1 %or.cond, label %while.cond.preheader, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %if.end106
  %39 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %40 = load %struct.hv** @PL_debstash, align 8, !tbaa !3
  %cmp117 = icmp eq %struct.hv* %39, %40
  br i1 %cmp117, label %while.cond.preheader, label %if.then119

if.then119:                                       ; preds = %land.lhs.true116
  %or122 = or i32 %or110, 16
  %conv123 = trunc i32 %or122 to i8
  store i8 %conv123, i8* %op_private, align 1, !tbaa !1
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then119, %if.end106, %land.lhs.true116
  %cmp125629 = icmp eq %struct.op* %5, %cvop.0
  %tobool127576613630 = icmp ne i8* %proto.0, null
  br i1 %cmp125629, label %while.end369, label %while.body.lr.ph.lr.ph

while.body.lr.ph.lr.ph:                           ; preds = %while.cond.preheader, %if.end366
  %tobool127576613639 = phi i1 [ %tobool127576613, %if.end366 ], [ %tobool127576613630, %while.cond.preheader ]
  %prev.0.ph637 = phi %struct.op* [ %o2.6, %if.end366 ], [ %4, %while.cond.preheader ]
  %o2.0.ph636 = phi %struct.op* [ %68, %if.end366 ], [ %5, %while.cond.preheader ]
  %proto.1.ph635 = phi i8* [ %proto.6, %if.end366 ], [ %proto.0, %while.cond.preheader ]
  %optional.0.ph634 = phi i32 [ %optional.0.ph554590, %if.end366 ], [ 0, %while.cond.preheader ]
  %arg.0.ph633 = phi i32 [ %arg.5, %if.end366 ], [ 0, %while.cond.preheader ]
  %e.0.ph632 = phi i8* [ %e.5, %if.end366 ], [ null, %while.cond.preheader ]
  %contextclass.0.ph631 = phi i32 [ %contextclass.5, %if.end366 ], [ 0, %while.cond.preheader ]
  br label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %sw.bb132, %while.body.lr.ph.lr.ph
  %tobool127576616 = phi i1 [ %tobool127576613639, %while.body.lr.ph.lr.ph ], [ true, %sw.bb132 ]
  %proto.1.ph555615 = phi i8* [ %proto.1.ph635, %while.body.lr.ph.lr.ph ], [ %incdec.ptr, %sw.bb132 ]
  %optional.0.ph554614 = phi i32 [ %optional.0.ph634, %while.body.lr.ph.lr.ph ], [ 1, %sw.bb132 ]
  br label %while.body

while.body:                                       ; preds = %sw.bb359, %while.body.lr.ph
  %tobool127578 = phi i1 [ %tobool127576616, %while.body.lr.ph ], [ true, %sw.bb359 ]
  %proto.1577 = phi i8* [ %proto.1.ph555615, %while.body.lr.ph ], [ %incdec.ptr360, %sw.bb359 ]
  br i1 %tobool127578, label %if.then128, label %if.else364

if.then128:                                       ; preds = %while.body
  %41 = load i8* %proto.1577, align 1, !tbaa !1
  %conv129 = sext i8 %41 to i32
  switch i32 %conv129, label %oops [
    i32 0, label %sw.bb
    i32 59, label %sw.bb132
    i32 36, label %sw.bb133
    i32 37, label %sw.bb136
    i32 64, label %sw.bb136
    i32 38, label %sw.bb139
    i32 42, label %sw.bb157
    i32 32, label %sw.bb359
    i32 92, label %sw.bb229
  ]

sw.bb:                                            ; preds = %if.then128
  %call130 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  %call.i = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([26 x i8]* @.str144, i64 0, i64 0), i8* %call130) #7
  %call1.i = call i32 @Perl_yyerror(i8* %call.i) #7
  br label %return

sw.bb132:                                         ; preds = %if.then128
  %incdec.ptr = getelementptr inbounds i8* %proto.1577, i64 1
  br label %while.body.lr.ph

sw.bb133:                                         ; preds = %if.then128
  %incdec.ptr134 = getelementptr inbounds i8* %proto.1577, i64 1
  %inc = add nsw i32 %arg.0.ph633, 1
  %call135 = call %struct.op* @Perl_scalar(%struct.op* %o2.0.ph636) #8
  br label %if.end366

sw.bb136:                                         ; preds = %if.then128, %if.then128
  %call137 = call %struct.op* @Perl_list(%struct.op* %o2.0.ph636) #8
  %inc138 = add nsw i32 %arg.0.ph633, 1
  br label %if.end366

sw.bb139:                                         ; preds = %if.then128
  %incdec.ptr140 = getelementptr inbounds i8* %proto.1577, i64 1
  %inc141 = add nsw i32 %arg.0.ph633, 1
  %op_type142 = getelementptr inbounds %struct.op* %o2.0.ph636, i64 0, i32 4
  %42 = load i16* %op_type142, align 2, !tbaa !4
  switch i16 %42, label %if.then151 [
    i16 20, label %if.end366
    i16 43, label %if.end366
  ]

if.then151:                                       ; preds = %sw.bb139
  %cmp152 = icmp eq i32 %arg.0.ph633, 0
  %cond154 = select i1 %cmp152, i8* getelementptr inbounds ([16 x i8]* @.str127, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str128, i64 0, i64 0)
  %call155 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %inc141, i8* %cond154, i8* %call155, %struct.op* %o2.0.ph636) #8
  br label %if.end366

sw.bb157:                                         ; preds = %if.then128
  %incdec.ptr158 = getelementptr inbounds i8* %proto.1577, i64 1
  %inc159 = add nsw i32 %arg.0.ph633, 1
  %op_type160 = getelementptr inbounds %struct.op* %o2.0.ph636, i64 0, i32 4
  %43 = load i16* %op_type160, align 2, !tbaa !4
  switch i16 %43, label %if.end226 [
    i16 14, label %wrapref
    i16 5, label %if.then170
    i16 166, label %if.then180
  ]

if.then170:                                       ; preds = %sw.bb157
  %op_private171 = getelementptr inbounds %struct.op* %o2.0.ph636, i64 0, i32 7
  %44 = load i8* %op_private171, align 1, !tbaa !1
  %and173 = and i8 %44, -9
  store i8 %and173, i8* %op_private171, align 1, !tbaa !1
  br label %if.end226

if.then180:                                       ; preds = %sw.bb157
  %45 = getelementptr inbounds %struct.op* %o2.0.ph636, i64 1, i32 0
  %46 = load %struct.op** %45, align 8, !tbaa !3
  %tobool182 = icmp eq %struct.op* %46, null
  br i1 %tobool182, label %if.end226, label %land.lhs.true183

land.lhs.true183:                                 ; preds = %if.then180
  %op_type184 = getelementptr inbounds %struct.op* %46, i64 0, i32 4
  %47 = load i16* %op_type184, align 2, !tbaa !4
  %cmp186 = icmp eq i16 %47, 0
  br i1 %cmp186, label %if.then188, label %if.end226

if.then188:                                       ; preds = %land.lhs.true183
  %48 = getelementptr inbounds %struct.op* %46, i64 1, i32 0
  %49 = load %struct.op** %48, align 8, !tbaa !3
  %tobool190 = icmp eq %struct.op* %49, null
  br i1 %tobool190, label %if.end226, label %for.cond192

for.cond192:                                      ; preds = %if.then188, %for.cond192
  %gvop.0 = phi %struct.op* [ %50, %for.cond192 ], [ %49, %if.then188 ]
  %op_sibling193 = getelementptr inbounds %struct.op* %gvop.0, i64 0, i32 1
  %50 = load %struct.op** %op_sibling193, align 8, !tbaa !3
  %tobool194 = icmp eq %struct.op* %50, null
  br i1 %tobool194, label %land.lhs.true200, label %for.cond192

land.lhs.true200:                                 ; preds = %for.cond192
  %op_private201 = getelementptr inbounds %struct.op* %gvop.0, i64 0, i32 7
  %51 = load i8* %op_private201, align 1, !tbaa !1
  %tobool204 = icmp slt i8 %51, 0
  br i1 %tobool204, label %land.lhs.true205, label %if.end226

land.lhs.true205:                                 ; preds = %land.lhs.true200
  %52 = getelementptr inbounds %struct.op* %gvop.0, i64 1, i32 0
  %53 = load %struct.op** %52, align 8, !tbaa !3
  %tobool207 = icmp eq %struct.op* %53, null
  br i1 %tobool207, label %if.end226, label %land.lhs.true208

land.lhs.true208:                                 ; preds = %land.lhs.true205
  %op_type209 = getelementptr inbounds %struct.op* %53, i64 0, i32 4
  %54 = load i16* %op_type209, align 2, !tbaa !4
  %cmp211 = icmp eq i16 %54, 7
  br i1 %cmp211, label %if.then213, label %if.end226

if.then213:                                       ; preds = %land.lhs.true208
  %op_sv215 = getelementptr inbounds %struct.op* %53, i64 1
  %55 = bitcast %struct.op* %op_sv215 to %struct.sv**
  %56 = load %struct.sv** %55, align 8, !tbaa !3
  %57 = bitcast %struct.sv* %56 to %struct.gv*
  %op_sibling216 = getelementptr inbounds %struct.op* %o2.0.ph636, i64 0, i32 1
  %58 = load %struct.op** %op_sibling216, align 8, !tbaa !3
  %call217 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), i64 0) #7
  call void @Perl_op_free(%struct.op* %o2.0.ph636) #8
  call void @Perl_gv_fullname4(%struct.sv* %call217, %struct.gv* %57, i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), i8 signext 0) #7
  %call218 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call217) #8
  %op_sibling219 = getelementptr inbounds %struct.op* %prev.0.ph637, i64 0, i32 1
  store %struct.op* %call218, %struct.op** %op_sibling219, align 8, !tbaa !3
  %op_sibling220 = getelementptr inbounds %struct.op* %call218, i64 0, i32 1
  store %struct.op* %58, %struct.op** %op_sibling220, align 8, !tbaa !3
  br label %if.end226

if.end226:                                        ; preds = %sw.bb157, %land.lhs.true205, %if.then188, %if.then180, %if.then170, %land.lhs.true183, %land.lhs.true200, %land.lhs.true208, %if.then213
  %o2.1 = phi %struct.op* [ %o2.0.ph636, %if.then170 ], [ %call218, %if.then213 ], [ %o2.0.ph636, %land.lhs.true208 ], [ %o2.0.ph636, %land.lhs.true205 ], [ %o2.0.ph636, %land.lhs.true200 ], [ %o2.0.ph636, %if.then188 ], [ %o2.0.ph636, %land.lhs.true183 ], [ %o2.0.ph636, %if.then180 ], [ %o2.0.ph636, %sw.bb157 ]
  %call227 = call %struct.op* @Perl_scalar(%struct.op* %o2.1) #8
  br label %if.end366

sw.bb229:                                         ; preds = %if.then128
  %incdec.ptr230 = getelementptr inbounds i8* %proto.1577, i64 1
  %inc231 = add nsw i32 %arg.0.ph633, 1
  br label %again.preheader

again.preheader:                                  ; preds = %sw.bb229, %sw.epilog
  %optional.0.ph554592 = phi i32 [ %optional.0.ph554593, %sw.epilog ], [ %optional.0.ph554614, %sw.bb229 ]
  %contextclass.1.ph = phi i32 [ %contextclass.3, %sw.epilog ], [ %contextclass.0.ph631, %sw.bb229 ]
  %e.1.ph = phi i8* [ %e.3, %sw.epilog ], [ %e.0.ph632, %sw.bb229 ]
  %arg.1.ph = phi i32 [ %arg.3, %sw.epilog ], [ %inc231, %sw.bb229 ]
  %proto.2.ph = phi i8* [ %proto.4, %sw.epilog ], [ %incdec.ptr230, %sw.bb229 ]
  %o2.2.ph = phi %struct.op* [ %o2.4, %sw.epilog ], [ %o2.0.ph636, %sw.bb229 ]
  br label %again

again:                                            ; preds = %if.then238, %again.preheader
  %contextclass.1 = phi i32 [ %contextclass.1.ph, %again.preheader ], [ %inc235, %if.then238 ]
  %e.1 = phi i8* [ %e.1.ph, %again.preheader ], [ %call239, %if.then238 ]
  %proto.2 = phi i8* [ %proto.2.ph, %again.preheader ], [ %incdec.ptr232, %if.then238 ]
  %incdec.ptr232 = getelementptr inbounds i8* %proto.2, i64 1
  %59 = load i8* %proto.2, align 1, !tbaa !1
  %conv233 = sext i8 %59 to i32
  switch i32 %conv233, label %oops [
    i32 91, label %sw.bb234
    i32 93, label %sw.bb248
    i32 42, label %sw.bb261
    i32 38, label %sw.bb272
    i32 36, label %sw.bb283
    i32 64, label %sw.bb314
    i32 37, label %sw.bb330
  ]

sw.bb234:                                         ; preds = %again
  %inc235 = add nsw i32 %contextclass.1, 1
  %cmp236 = icmp eq i32 %contextclass.1, 0
  br i1 %cmp236, label %if.then238, label %oops

if.then238:                                       ; preds = %sw.bb234
  %call239 = call i8* @strchr(i8* %incdec.ptr232, i32 93) #7
  %tobool240 = icmp eq i8* %call239, null
  %cmp242 = icmp eq i8* %call239, %incdec.ptr232
  %or.cond527 = or i1 %tobool240, %cmp242
  br i1 %or.cond527, label %oops, label %again

sw.bb248:                                         ; preds = %again
  %tobool249 = icmp eq i32 %contextclass.1, 0
  br i1 %tobool249, label %oops, label %if.then250

if.then250:                                       ; preds = %sw.bb248
  %60 = load i8* %incdec.ptr232, align 1, !tbaa !1
  store i8 0, i8* %incdec.ptr232, align 1, !tbaa !1
  br label %while.cond251

while.cond251:                                    ; preds = %while.cond251, %if.then250
  %p.0 = phi i8* [ %incdec.ptr232, %if.then250 ], [ %incdec.ptr252, %while.cond251 ]
  %incdec.ptr252 = getelementptr inbounds i8* %p.0, i64 -1
  %61 = load i8* %incdec.ptr252, align 1, !tbaa !1
  %cmp254 = icmp eq i8 %61, 91
  br i1 %cmp254, label %while.end, label %while.cond251

while.end:                                        ; preds = %while.cond251
  %call257 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([10 x i8]* @.str129, i64 0, i64 0), i8* %incdec.ptr252) #7
  %call258 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %arg.1.ph, i8* %call257, i8* %call258, %struct.op* %o2.2.ph) #8
  store i8 %60, i8* %incdec.ptr232, align 1, !tbaa !1
  br label %sw.epilog

sw.bb261:                                         ; preds = %again
  %op_type262 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %62 = load i16* %op_type262, align 2, !tbaa !4
  %cmp264 = icmp eq i16 %62, 14
  br i1 %cmp264, label %wrapref, label %if.end267

if.end267:                                        ; preds = %sw.bb261
  %tobool268 = icmp eq i32 %contextclass.1, 0
  br i1 %tobool268, label %if.then269, label %sw.epilog

if.then269:                                       ; preds = %if.end267
  %call270 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %arg.1.ph, i8* getelementptr inbounds ([7 x i8]* @.str130, i64 0, i64 0), i8* %call270, %struct.op* %o2.2.ph) #8
  br label %sw.epilog

sw.bb272:                                         ; preds = %again
  %op_type273 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %63 = load i16* %op_type273, align 2, !tbaa !4
  %cmp275 = icmp eq i16 %63, 166
  br i1 %cmp275, label %wrapref, label %if.end278

if.end278:                                        ; preds = %sw.bb272
  %tobool279 = icmp eq i32 %contextclass.1, 0
  br i1 %tobool279, label %if.then280, label %sw.epilog

if.then280:                                       ; preds = %if.end278
  %call281 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %arg.1.ph, i8* getelementptr inbounds ([17 x i8]* @.str131, i64 0, i64 0), i8* %call281, %struct.op* %o2.2.ph) #8
  br label %sw.epilog

sw.bb283:                                         ; preds = %again
  %op_type284 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %64 = load i16* %op_type284, align 2, !tbaa !4
  switch i16 %64, label %if.end309 [
    i16 15, label %wrapref
    i16 9, label %wrapref
    i16 135, label %wrapref
    i16 127, label %wrapref
    i16 348, label %wrapref
  ]

if.end309:                                        ; preds = %sw.bb283
  %tobool310 = icmp eq i32 %contextclass.1, 0
  br i1 %tobool310, label %if.then311, label %sw.epilog

if.then311:                                       ; preds = %if.end309
  %call312 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %arg.1.ph, i8* getelementptr inbounds ([7 x i8]* @.str132, i64 0, i64 0), i8* %call312, %struct.op* %o2.2.ph) #8
  br label %sw.epilog

sw.bb314:                                         ; preds = %again
  %op_type315 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %65 = load i16* %op_type315, align 2, !tbaa !4
  switch i16 %65, label %if.end325 [
    i16 125, label %wrapref
    i16 10, label %wrapref
  ]

if.end325:                                        ; preds = %sw.bb314
  %tobool326 = icmp eq i32 %contextclass.1, 0
  br i1 %tobool326, label %if.then327, label %sw.epilog

if.then327:                                       ; preds = %if.end325
  %call328 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %arg.1.ph, i8* getelementptr inbounds ([6 x i8]* @.str99, i64 0, i64 0), i8* %call328, %struct.op* %o2.2.ph) #8
  br label %sw.epilog

sw.bb330:                                         ; preds = %again
  %op_type331 = getelementptr inbounds %struct.op* %o2.2.ph, i64 0, i32 4
  %66 = load i16* %op_type331, align 2, !tbaa !4
  switch i16 %66, label %if.end341 [
    i16 134, label %wrapref
    i16 11, label %wrapref
  ]

if.end341:                                        ; preds = %sw.bb330
  %tobool342 = icmp eq i32 %contextclass.1, 0
  br i1 %tobool342, label %if.then343, label %sw.epilog

if.then343:                                       ; preds = %if.end341
  %call344 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call fastcc void @S_bad_type(i32 %arg.1.ph, i8* getelementptr inbounds ([5 x i8]* @.str101, i64 0, i64 0), i8* %call344, %struct.op* %o2.2.ph) #8
  br label %sw.epilog

wrapref:                                          ; preds = %sw.bb330, %sw.bb330, %sw.bb314, %sw.bb314, %sw.bb283, %sw.bb283, %sw.bb283, %sw.bb283, %sw.bb283, %sw.bb157, %sw.bb272, %sw.bb261
  %optional.0.ph554594 = phi i32 [ %optional.0.ph554592, %sw.bb330 ], [ %optional.0.ph554592, %sw.bb314 ], [ %optional.0.ph554592, %sw.bb283 ], [ %optional.0.ph554592, %sw.bb272 ], [ %optional.0.ph554592, %sw.bb261 ], [ %optional.0.ph554614, %sw.bb157 ], [ %optional.0.ph554592, %sw.bb283 ], [ %optional.0.ph554592, %sw.bb283 ], [ %optional.0.ph554592, %sw.bb283 ], [ %optional.0.ph554592, %sw.bb283 ], [ %optional.0.ph554592, %sw.bb314 ], [ %optional.0.ph554592, %sw.bb330 ]
  %contextclass.2 = phi i32 [ %contextclass.1, %sw.bb330 ], [ %contextclass.1, %sw.bb314 ], [ %contextclass.1, %sw.bb283 ], [ %contextclass.1, %sw.bb272 ], [ %contextclass.1, %sw.bb261 ], [ %contextclass.0.ph631, %sw.bb157 ], [ %contextclass.1, %sw.bb283 ], [ %contextclass.1, %sw.bb283 ], [ %contextclass.1, %sw.bb283 ], [ %contextclass.1, %sw.bb283 ], [ %contextclass.1, %sw.bb314 ], [ %contextclass.1, %sw.bb330 ]
  %e.2 = phi i8* [ %e.1, %sw.bb330 ], [ %e.1, %sw.bb314 ], [ %e.1, %sw.bb283 ], [ %e.1, %sw.bb272 ], [ %e.1, %sw.bb261 ], [ %e.0.ph632, %sw.bb157 ], [ %e.1, %sw.bb283 ], [ %e.1, %sw.bb283 ], [ %e.1, %sw.bb283 ], [ %e.1, %sw.bb283 ], [ %e.1, %sw.bb314 ], [ %e.1, %sw.bb330 ]
  %arg.2 = phi i32 [ %arg.1.ph, %sw.bb330 ], [ %arg.1.ph, %sw.bb314 ], [ %arg.1.ph, %sw.bb283 ], [ %arg.1.ph, %sw.bb272 ], [ %arg.1.ph, %sw.bb261 ], [ %inc159, %sw.bb157 ], [ %arg.1.ph, %sw.bb283 ], [ %arg.1.ph, %sw.bb283 ], [ %arg.1.ph, %sw.bb283 ], [ %arg.1.ph, %sw.bb283 ], [ %arg.1.ph, %sw.bb314 ], [ %arg.1.ph, %sw.bb330 ]
  %proto.3 = phi i8* [ %incdec.ptr232, %sw.bb330 ], [ %incdec.ptr232, %sw.bb314 ], [ %incdec.ptr232, %sw.bb283 ], [ %incdec.ptr232, %sw.bb272 ], [ %incdec.ptr232, %sw.bb261 ], [ %incdec.ptr158, %sw.bb157 ], [ %incdec.ptr232, %sw.bb283 ], [ %incdec.ptr232, %sw.bb283 ], [ %incdec.ptr232, %sw.bb283 ], [ %incdec.ptr232, %sw.bb283 ], [ %incdec.ptr232, %sw.bb314 ], [ %incdec.ptr232, %sw.bb330 ]
  %o2.3 = phi %struct.op* [ %o2.2.ph, %sw.bb330 ], [ %o2.2.ph, %sw.bb314 ], [ %o2.2.ph, %sw.bb283 ], [ %o2.2.ph, %sw.bb272 ], [ %o2.2.ph, %sw.bb261 ], [ %o2.0.ph636, %sw.bb157 ], [ %o2.2.ph, %sw.bb283 ], [ %o2.2.ph, %sw.bb283 ], [ %o2.2.ph, %sw.bb283 ], [ %o2.2.ph, %sw.bb283 ], [ %o2.2.ph, %sw.bb314 ], [ %o2.2.ph, %sw.bb330 ]
  %op_sibling346 = getelementptr inbounds %struct.op* %o2.3, i64 0, i32 1
  %67 = load %struct.op** %op_sibling346, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %op_sibling346, align 8, !tbaa !3
  %call348 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %o2.3) #8
  %op_sibling349 = getelementptr inbounds %struct.op* %call348, i64 0, i32 1
  store %struct.op* %67, %struct.op** %op_sibling349, align 8, !tbaa !3
  %op_sibling350 = getelementptr inbounds %struct.op* %prev.0.ph637, i64 0, i32 1
  store %struct.op* %call348, %struct.op** %op_sibling350, align 8, !tbaa !3
  %tobool351 = icmp eq i32 %contextclass.2, 0
  %tobool353 = icmp eq i8* %e.2, null
  %or.cond528 = or i1 %tobool351, %tobool353
  %add.ptr = getelementptr inbounds i8* %e.2, i64 1
  %contextclass.2. = select i1 %or.cond528, i32 %contextclass.2, i32 0
  %proto.3.add.ptr = select i1 %or.cond528, i8* %proto.3, i8* %add.ptr
  br label %sw.epilog

sw.epilog:                                        ; preds = %wrapref, %if.end267, %if.end278, %if.end309, %if.end325, %if.end341, %if.then343, %if.then327, %if.then311, %if.then280, %if.then269, %while.end
  %optional.0.ph554593 = phi i32 [ %optional.0.ph554592, %if.end341 ], [ %optional.0.ph554592, %if.then343 ], [ %optional.0.ph554592, %if.end325 ], [ %optional.0.ph554592, %if.then327 ], [ %optional.0.ph554592, %if.end309 ], [ %optional.0.ph554592, %if.then311 ], [ %optional.0.ph554592, %if.end278 ], [ %optional.0.ph554592, %if.then280 ], [ %optional.0.ph554592, %if.end267 ], [ %optional.0.ph554592, %if.then269 ], [ %optional.0.ph554592, %while.end ], [ %optional.0.ph554594, %wrapref ]
  %contextclass.3 = phi i32 [ %contextclass.1, %if.end341 ], [ 0, %if.then343 ], [ %contextclass.1, %if.end325 ], [ 0, %if.then327 ], [ %contextclass.1, %if.end309 ], [ 0, %if.then311 ], [ %contextclass.1, %if.end278 ], [ 0, %if.then280 ], [ %contextclass.1, %if.end267 ], [ 0, %if.then269 ], [ 0, %while.end ], [ %contextclass.2., %wrapref ]
  %e.3 = phi i8* [ %e.1, %if.end341 ], [ %e.1, %if.then343 ], [ %e.1, %if.end325 ], [ %e.1, %if.then327 ], [ %e.1, %if.end309 ], [ %e.1, %if.then311 ], [ %e.1, %if.end278 ], [ %e.1, %if.then280 ], [ %e.1, %if.end267 ], [ %e.1, %if.then269 ], [ %e.1, %while.end ], [ %e.2, %wrapref ]
  %arg.3 = phi i32 [ %arg.1.ph, %if.end341 ], [ %arg.1.ph, %if.then343 ], [ %arg.1.ph, %if.end325 ], [ %arg.1.ph, %if.then327 ], [ %arg.1.ph, %if.end309 ], [ %arg.1.ph, %if.then311 ], [ %arg.1.ph, %if.end278 ], [ %arg.1.ph, %if.then280 ], [ %arg.1.ph, %if.end267 ], [ %arg.1.ph, %if.then269 ], [ %arg.1.ph, %while.end ], [ %arg.2, %wrapref ]
  %proto.4 = phi i8* [ %incdec.ptr232, %if.end341 ], [ %incdec.ptr232, %if.then343 ], [ %incdec.ptr232, %if.end325 ], [ %incdec.ptr232, %if.then327 ], [ %incdec.ptr232, %if.end309 ], [ %incdec.ptr232, %if.then311 ], [ %incdec.ptr232, %if.end278 ], [ %incdec.ptr232, %if.then280 ], [ %incdec.ptr232, %if.end267 ], [ %incdec.ptr232, %if.then269 ], [ %incdec.ptr232, %while.end ], [ %proto.3.add.ptr, %wrapref ]
  %o2.4 = phi %struct.op* [ %o2.2.ph, %if.end341 ], [ %o2.2.ph, %if.then343 ], [ %o2.2.ph, %if.end325 ], [ %o2.2.ph, %if.then327 ], [ %o2.2.ph, %if.end309 ], [ %o2.2.ph, %if.then311 ], [ %o2.2.ph, %if.end278 ], [ %o2.2.ph, %if.then280 ], [ %o2.2.ph, %if.end267 ], [ %o2.2.ph, %if.then269 ], [ %o2.2.ph, %while.end ], [ %call348, %wrapref ]
  %tobool356 = icmp eq i32 %contextclass.3, 0
  br i1 %tobool356, label %if.end366, label %again.preheader

sw.bb359:                                         ; preds = %if.then128
  %incdec.ptr360 = getelementptr inbounds i8* %proto.1577, i64 1
  br label %while.body

oops:                                             ; preds = %if.then128, %if.then238, %again, %sw.bb234, %sw.bb248
  %optional.0.ph554591 = phi i32 [ %optional.0.ph554592, %sw.bb248 ], [ %optional.0.ph554592, %sw.bb234 ], [ %optional.0.ph554592, %again ], [ %optional.0.ph554592, %if.then238 ], [ %optional.0.ph554614, %if.then128 ]
  %contextclass.4 = phi i32 [ 0, %sw.bb248 ], [ %inc235, %sw.bb234 ], [ %contextclass.1, %again ], [ %inc235, %if.then238 ], [ %contextclass.0.ph631, %if.then128 ]
  %e.4 = phi i8* [ %e.1, %sw.bb248 ], [ %e.1, %sw.bb234 ], [ %e.1, %again ], [ %call239, %if.then238 ], [ %e.0.ph632, %if.then128 ]
  %arg.4 = phi i32 [ %arg.1.ph, %sw.bb248 ], [ %arg.1.ph, %sw.bb234 ], [ %arg.1.ph, %again ], [ %arg.1.ph, %if.then238 ], [ %arg.0.ph633, %if.then128 ]
  %proto.5 = phi i8* [ %incdec.ptr232, %sw.bb248 ], [ %incdec.ptr232, %sw.bb234 ], [ %incdec.ptr232, %again ], [ %incdec.ptr232, %if.then238 ], [ %proto.1577, %if.then128 ]
  %o2.5 = phi %struct.op* [ %o2.2.ph, %sw.bb248 ], [ %o2.2.ph, %sw.bb234 ], [ %o2.2.ph, %again ], [ %o2.2.ph, %if.then238 ], [ %o2.0.ph636, %if.then128 ]
  %call362 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str133, i64 0, i64 0), i8* %call362, %struct.cv* %cv.0) #7
  br label %if.end366

if.else364:                                       ; preds = %while.body
  %call365 = call %struct.op* @Perl_list(%struct.op* %o2.0.ph636) #8
  br label %if.end366

if.end366:                                        ; preds = %sw.bb139, %sw.bb139, %sw.epilog, %sw.bb133, %sw.bb136, %if.end226, %oops, %if.then151, %if.else364
  %optional.0.ph554590 = phi i32 [ %optional.0.ph554591, %oops ], [ %optional.0.ph554593, %sw.epilog ], [ %optional.0.ph554614, %if.end226 ], [ %optional.0.ph554614, %if.then151 ], [ %optional.0.ph554614, %sw.bb139 ], [ %optional.0.ph554614, %sw.bb136 ], [ %optional.0.ph554614, %sw.bb133 ], [ %optional.0.ph554614, %if.else364 ], [ %optional.0.ph554614, %sw.bb139 ]
  %contextclass.5 = phi i32 [ %contextclass.4, %oops ], [ 0, %sw.epilog ], [ %contextclass.0.ph631, %if.end226 ], [ %contextclass.0.ph631, %if.then151 ], [ %contextclass.0.ph631, %sw.bb139 ], [ %contextclass.0.ph631, %sw.bb136 ], [ %contextclass.0.ph631, %sw.bb133 ], [ %contextclass.0.ph631, %if.else364 ], [ %contextclass.0.ph631, %sw.bb139 ]
  %e.5 = phi i8* [ %e.4, %oops ], [ %e.3, %sw.epilog ], [ %e.0.ph632, %if.end226 ], [ %e.0.ph632, %if.then151 ], [ %e.0.ph632, %sw.bb139 ], [ %e.0.ph632, %sw.bb136 ], [ %e.0.ph632, %sw.bb133 ], [ %e.0.ph632, %if.else364 ], [ %e.0.ph632, %sw.bb139 ]
  %arg.5 = phi i32 [ %arg.4, %oops ], [ %arg.3, %sw.epilog ], [ %inc159, %if.end226 ], [ %inc141, %if.then151 ], [ %inc141, %sw.bb139 ], [ %inc138, %sw.bb136 ], [ %inc, %sw.bb133 ], [ %arg.0.ph633, %if.else364 ], [ %inc141, %sw.bb139 ]
  %proto.6 = phi i8* [ %proto.5, %oops ], [ %proto.4, %sw.epilog ], [ %incdec.ptr158, %if.end226 ], [ %incdec.ptr140, %if.then151 ], [ %incdec.ptr140, %sw.bb139 ], [ %proto.1577, %sw.bb136 ], [ %incdec.ptr134, %sw.bb133 ], [ null, %if.else364 ], [ %incdec.ptr140, %sw.bb139 ]
  %o2.6 = phi %struct.op* [ %o2.5, %oops ], [ %o2.4, %sw.epilog ], [ %o2.1, %if.end226 ], [ %o2.0.ph636, %if.then151 ], [ %o2.0.ph636, %sw.bb139 ], [ %o2.0.ph636, %sw.bb136 ], [ %o2.0.ph636, %sw.bb133 ], [ %o2.0.ph636, %if.else364 ], [ %o2.0.ph636, %sw.bb139 ]
  %call367 = call %struct.op* @Perl_mod(%struct.op* %o2.6, i32 166) #8
  %op_sibling368 = getelementptr inbounds %struct.op* %o2.6, i64 0, i32 1
  %68 = load %struct.op** %op_sibling368, align 8, !tbaa !3
  %cmp125 = icmp eq %struct.op* %68, %cvop.0
  %tobool127576613 = icmp ne i8* %proto.6, null
  br i1 %cmp125, label %while.end369, label %while.body.lr.ph.lr.ph

while.end369:                                     ; preds = %if.end366, %while.cond.preheader
  %tobool127576613.lcssa = phi i1 [ %tobool127576613630, %while.cond.preheader ], [ %tobool127576613, %if.end366 ]
  %proto.1.ph.lcssa = phi i8* [ %proto.0, %while.cond.preheader ], [ %proto.6, %if.end366 ]
  %optional.0.ph.lcssa = phi i32 [ 0, %while.cond.preheader ], [ %optional.0.ph554590, %if.end366 ]
  %tobool372 = icmp eq i32 %optional.0.ph.lcssa, 0
  %or.cond529 = and i1 %tobool127576613.lcssa, %tobool372
  br i1 %or.cond529, label %land.lhs.true373, label %return

land.lhs.true373:                                 ; preds = %while.end369
  %69 = load i8* %proto.1.ph.lcssa, align 1, !tbaa !1
  switch i8 %69, label %if.then388 [
    i8 0, label %return
    i8 64, label %return
    i8 37, label %return
    i8 59, label %return
  ]

if.then388:                                       ; preds = %land.lhs.true373
  %call389 = call fastcc i8* @S_gv_ename(%struct.gv* %namegv.0) #8
  %call.i530 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([28 x i8]* @.str142, i64 0, i64 0), i8* %call389) #7
  %call1.i531 = call i32 @Perl_yyerror(i8* %call.i530) #7
  br label %return

return:                                           ; preds = %while.end369, %land.lhs.true373, %land.lhs.true373, %land.lhs.true373, %land.lhs.true373, %if.then388, %sw.bb
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newSLICEOP(i32 %flags, %struct.op* %subscript, %struct.op* %listval) #0 {
entry:
  %call = tail call %struct.op* @Perl_force_list(%struct.op* %subscript) #8
  %call1 = tail call %struct.op* @Perl_list(%struct.op* %call) #8
  %call2 = tail call %struct.op* @Perl_force_list(%struct.op* %listval) #8
  %call3 = tail call %struct.op* @Perl_list(%struct.op* %call2) #8
  %call4 = tail call %struct.op* @Perl_newBINOP(i32 142, i32 %flags, %struct.op* %call1, %struct.op* %call3) #8
  ret %struct.op* %call4
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newASSIGNOP(i32 %flags, %struct.op* %left, i32 %optype, %struct.op* %right) #0 {
entry:
  %first.addr.i = alloca %struct.op*, align 8
  %other.addr.i = alloca %struct.op*, align 8
  %tobool = icmp eq i32 %optype, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %optype.off = add i32 %optype, -163
  %0 = icmp ult i32 %optype.off, 2
  %call = call %struct.op* @Perl_scalar(%struct.op* %left) #8
  %call3 = call %struct.op* @Perl_mod(%struct.op* %call, i32 %optype) #8
  %call4 = call %struct.op* @Perl_scalar(%struct.op* %right) #8
  br i1 %0, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %call5 = call %struct.op* @Perl_newUNOP(i32 36, i32 0, %struct.op* %call4) #8
  %1 = bitcast %struct.op** %first.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #4
  %2 = bitcast %struct.op** %other.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #4
  store %struct.op* %call3, %struct.op** %first.addr.i, align 8, !tbaa !3
  store %struct.op* %call5, %struct.op** %other.addr.i, align 8, !tbaa !3
  %call.i = call fastcc %struct.op* @S_new_logop(i32 %optype, i32 0, %struct.op** %first.addr.i, %struct.op** %other.addr.i) #7
  call void @llvm.lifetime.end(i64 8, i8* %1) #4
  call void @llvm.lifetime.end(i64 8, i8* %2) #4
  br label %return

if.else:                                          ; preds = %if.then
  %call10 = call %struct.op* @Perl_newBINOP(i32 %optype, i32 64, %struct.op* %call3, %struct.op* %call4) #8
  br label %return

if.end:                                           ; preds = %entry
  %call11 = call fastcc i32 @S_list_assignment(%struct.op* %left) #8
  %tobool12 = icmp eq i32 %call11, 0
  br i1 %tobool12, label %if.end288, label %if.then13

if.then13:                                        ; preds = %if.end
  store i32 0, i32* @PL_modcount, align 4, !tbaa !0
  store %struct.op* %right, %struct.op** @PL_eval_start, align 8, !tbaa !3
  %call14 = call %struct.op* @Perl_mod(%struct.op* %left, i32 37) #8
  %3 = load %struct.op** @PL_eval_start, align 8, !tbaa !3
  %tobool15 = icmp eq %struct.op* %3, null
  br i1 %tobool15, label %if.else17, label %if.then16

if.then16:                                        ; preds = %if.then13
  store %struct.op* null, %struct.op** @PL_eval_start, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %call14, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !4
  %.off = add i16 %4, -10
  %switch = icmp ult i16 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.end37

if.else17:                                        ; preds = %if.then13
  call void @Perl_op_free(%struct.op* %call14) #8
  call void @Perl_op_free(%struct.op* %right) #8
  br label %return

land.lhs.true:                                    ; preds = %if.then16
  %op_type26 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %5 = load i16* %op_type26, align 2, !tbaa !4
  %cmp28 = icmp eq i16 %5, 1
  br i1 %cmp28, label %land.lhs.true30, label %if.end37

land.lhs.true30:                                  ; preds = %land.lhs.true
  %op_private = getelementptr inbounds %struct.op* %call14, i64 0, i32 7
  %6 = load i8* %op_private, align 1, !tbaa !1
  %tobool32 = icmp slt i8 %6, 0
  br i1 %tobool32, label %if.then33, label %if.end37

if.then33:                                        ; preds = %land.lhs.true30
  call void @Perl_op_free(%struct.op* %right) #8
  %op_flags = getelementptr inbounds %struct.op* %call14, i64 0, i32 6
  %7 = load i8* %op_flags, align 1, !tbaa !1
  %and35 = and i8 %7, 111
  store i8 %and35, i8* %op_flags, align 1, !tbaa !1
  br label %return

if.end37:                                         ; preds = %if.then16, %land.lhs.true30, %land.lhs.true
  %call38 = call %struct.op* @Perl_force_list(%struct.op* %call14) #8
  %call39 = call %struct.op* @Perl_list(%struct.op* %call38) #8
  %call40 = call %struct.op* @Perl_force_list(%struct.op* %right) #8
  %call41 = call %struct.op* @Perl_list(%struct.op* %call40) #8
  %call42 = call %struct.op* @Perl_newBINOP(i32 37, i32 %flags, %struct.op* %call41, %struct.op* %call39) #8
  %shr409 = lshr i32 %flags, 8
  %conv43 = trunc i32 %shr409 to i8
  %op_private44 = getelementptr inbounds %struct.op* %call42, i64 0, i32 7
  store i8 %conv43, i8* %op_private44, align 1, !tbaa !1
  %8 = getelementptr inbounds %struct.op* %call39, i64 1, i32 0
  %curop.0415 = load %struct.op** %8, align 8
  %tobool45416 = icmp eq %struct.op* %curop.0415, null
  br i1 %tobool45416, label %for.end, label %for.body

for.body:                                         ; preds = %if.end37, %for.inc
  %curop.0417 = phi %struct.op* [ %curop.0, %for.inc ], [ %curop.0415, %if.end37 ]
  %op_type46 = getelementptr inbounds %struct.op* %curop.0417, i64 0, i32 4
  %9 = load i16* %op_type46, align 2, !tbaa !4
  %cmp48 = icmp eq i16 %9, 134
  br i1 %cmp48, label %land.lhs.true50, label %for.inc

land.lhs.true50:                                  ; preds = %for.body
  %10 = getelementptr inbounds %struct.op* %curop.0417, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !3
  %op_type52 = getelementptr inbounds %struct.op* %11, i64 0, i32 4
  %12 = load i16* %op_type52, align 2, !tbaa !4
  %cmp54 = icmp eq i16 %12, 7
  br i1 %cmp54, label %for.inc, label %if.then56

if.then56:                                        ; preds = %land.lhs.true50
  %or59 = or i8 %conv43, 32
  store i8 %or59, i8* %op_private44, align 1, !tbaa !1
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true50, %for.body
  %op_sibling = getelementptr inbounds %struct.op* %curop.0417, i64 0, i32 1
  %curop.0 = load %struct.op** %op_sibling, align 8
  %tobool45 = icmp eq %struct.op* %curop.0, null
  br i1 %tobool45, label %for.end, label %for.body

for.end:                                          ; preds = %if.end37, %for.inc, %if.then56
  %op_private62 = getelementptr inbounds %struct.op* %call14, i64 0, i32 7
  %13 = load i8* %op_private62, align 1, !tbaa !1
  %tobool65 = icmp slt i8 %13, 0
  br i1 %tobool65, label %if.end213, label %if.then66

if.then66:                                        ; preds = %for.end
  %14 = load i32* @PL_generation, align 4, !tbaa !0
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* @PL_generation, align 4, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %call42, i64 0, i32 0
  %15 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool67 = icmp eq %struct.op* %15, null
  br i1 %tobool67, label %cond.false, label %for.cond70.preheader

cond.false:                                       ; preds = %if.then66
  %call69 = call %struct.op* @Perl_linklist(%struct.op* %call42) #8
  br label %for.cond70.preheader

for.cond70.preheader:                             ; preds = %if.then66, %cond.false
  %curop.1.ph = phi %struct.op* [ %call69, %cond.false ], [ %15, %if.then66 ]
  %cmp71411 = icmp eq %struct.op* %curop.1.ph, %call42
  br i1 %cmp71411, label %if.end213, label %for.body73

for.body73:                                       ; preds = %for.cond70.preheader, %for.cond70.backedge
  %lastop.0413 = phi %struct.op* [ %curop.1412, %for.cond70.backedge ], [ %call42, %for.cond70.preheader ]
  %curop.1412 = phi %struct.op* [ %curop.1.be, %for.cond70.backedge ], [ %curop.1.ph, %for.cond70.preheader ]
  %op_type74 = getelementptr inbounds %struct.op* %curop.1412, i64 0, i32 4
  %16 = load i16* %op_type74, align 2, !tbaa !4
  %idxprom = zext i16 %16 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %17 = load i32* %arrayidx, align 4, !tbaa !0
  %and75 = and i32 %17, 64
  %tobool76 = icmp eq i32 %and75, 0
  br i1 %tobool76, label %if.end194, label %if.then77

if.then77:                                        ; preds = %for.body73
  switch i16 %16, label %if.then207 [
    i16 7, label %if.then82
    i16 9, label %if.then114
    i16 10, label %if.then114
    i16 11, label %if.then114
    i16 12, label %if.then114
    i16 13, label %if.then169
    i16 15, label %if.then157
    i16 125, label %if.then157
    i16 134, label %if.then157
    i16 14, label %if.then157
  ]

if.then82:                                        ; preds = %if.then77
  %op_sv = getelementptr inbounds %struct.op* %curop.1412, i64 1
  %18 = bitcast %struct.op* %op_sv to %struct.sv**
  %19 = load %struct.sv** %18, align 8, !tbaa !3
  %20 = bitcast %struct.sv* %19 to %struct.gv*
  %21 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %cmp83 = icmp eq %struct.gv* %20, %21
  br i1 %cmp83, label %if.then207, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %if.then82
  %sv_any = bitcast %struct.sv* %19 to %struct.xpvgv**
  %22 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %23 = getelementptr inbounds %struct.xpvgv* %22, i64 0, i32 1
  %24 = load i64* %23, align 8, !tbaa !5
  %conv86 = trunc i64 %24 to i32
  %25 = load i32* @PL_generation, align 4, !tbaa !0
  %cmp87 = icmp eq i32 %conv86, %25
  br i1 %cmp87, label %if.then207, label %if.end90

if.end90:                                         ; preds = %lor.lhs.false85
  %conv91 = sext i32 %25 to i64
  store i64 %conv91, i64* %23, align 8, !tbaa !5
  br label %if.end194

if.then114:                                       ; preds = %if.then77, %if.then77, %if.then77, %if.then77
  %op_targ = getelementptr inbounds %struct.op* %curop.1412, i64 0, i32 3
  %26 = load i64* %op_targ, align 8, !tbaa !5
  %27 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %sv_any115 = getelementptr inbounds %struct.av* %27, i64 0, i32 0
  %28 = load %struct.xpvav** %sv_any115, align 8, !tbaa !3
  %xav_array = getelementptr inbounds %struct.xpvav* %28, i64 0, i32 0
  %29 = load i8** %xav_array, align 8, !tbaa !3
  %30 = bitcast i8* %29 to %struct.sv**
  %arrayidx116 = getelementptr inbounds %struct.sv** %30, i64 %26
  %31 = load %struct.sv** %arrayidx116, align 8, !tbaa !3
  %sv_any117 = getelementptr inbounds %struct.sv* %31, i64 0, i32 0
  %32 = load i8** %sv_any117, align 8, !tbaa !3
  %xpv_cur118 = getelementptr inbounds i8* %32, i64 8
  %33 = bitcast i8* %xpv_cur118 to i64*
  %34 = load i64* %33, align 8, !tbaa !5
  %conv119 = trunc i64 %34 to i32
  %35 = load i32* @PL_generation, align 4, !tbaa !0
  %cmp120 = icmp eq i32 %conv119, %35
  br i1 %cmp120, label %if.then207, label %if.end123

if.end123:                                        ; preds = %if.then114
  %conv124 = sext i32 %35 to i64
  store i64 %conv124, i64* %33, align 8, !tbaa !5
  br label %if.end194

if.then157:                                       ; preds = %if.then77, %if.then77, %if.then77, %if.then77
  %op_type158 = getelementptr inbounds %struct.op* %lastop.0413, i64 0, i32 4
  %36 = load i16* %op_type158, align 2, !tbaa !4
  %cmp160 = icmp eq i16 %36, 7
  br i1 %cmp160, label %if.end194, label %if.then207

if.then169:                                       ; preds = %if.then77
  %op_pmreplroot = getelementptr inbounds %struct.op* %curop.1412, i64 1, i32 2
  %37 = load %struct.op* ()** %op_pmreplroot, align 8
  %tobool170 = icmp eq %struct.op* ()* %37, null
  br i1 %tobool170, label %if.end194, label %if.then171

if.then171:                                       ; preds = %if.then169
  %38 = bitcast %struct.op* ()* %37 to %struct.gv*
  %39 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %cmp174 = icmp eq %struct.gv* %38, %39
  br i1 %cmp174, label %if.then207, label %lor.lhs.false176

lor.lhs.false176:                                 ; preds = %if.then171
  %sv_any177 = bitcast %struct.op* ()* %37 to %struct.xpvgv**
  %40 = load %struct.xpvgv** %sv_any177, align 8, !tbaa !3
  %41 = getelementptr inbounds %struct.xpvgv* %40, i64 0, i32 1
  %42 = load i64* %41, align 8, !tbaa !5
  %conv179 = trunc i64 %42 to i32
  %43 = load i32* @PL_generation, align 4, !tbaa !0
  %cmp180 = icmp eq i32 %conv179, %43
  br i1 %cmp180, label %if.then207, label %if.end183

if.end183:                                        ; preds = %lor.lhs.false176
  %conv184 = sext i32 %43 to i64
  store i64 %conv184, i64* %41, align 8, !tbaa !5
  br label %if.end194

if.end194:                                        ; preds = %if.then157, %if.then169, %for.body73, %if.end90, %if.end183, %if.end123
  %op_next196 = getelementptr inbounds %struct.op* %curop.1412, i64 0, i32 0
  %44 = load %struct.op** %op_next196, align 8, !tbaa !3
  %tobool197 = icmp eq %struct.op* %44, null
  br i1 %tobool197, label %cond.false200, label %for.cond70.backedge

for.cond70.backedge:                              ; preds = %if.end194, %cond.false200
  %curop.1.be = phi %struct.op* [ %call201, %cond.false200 ], [ %44, %if.end194 ]
  %cmp71 = icmp eq %struct.op* %curop.1.be, %call42
  br i1 %cmp71, label %if.end213, label %for.body73

cond.false200:                                    ; preds = %if.end194
  %call201 = call %struct.op* @Perl_linklist(%struct.op* %curop.1412) #8
  br label %for.cond70.backedge

if.then207:                                       ; preds = %lor.lhs.false85, %if.then82, %if.then114, %lor.lhs.false176, %if.then171, %if.then157, %if.then77
  %45 = load i8* %op_private44, align 1, !tbaa !1
  %or210 = or i8 %45, 64
  store i8 %or210, i8* %op_private44, align 1, !tbaa !1
  br label %if.end213

if.end213:                                        ; preds = %for.cond70.preheader, %for.cond70.backedge, %if.then207, %for.end
  %tobool214 = icmp eq %struct.op* %right, null
  br i1 %tobool214, label %return, label %land.lhs.true215

land.lhs.true215:                                 ; preds = %if.end213
  %op_type216 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %46 = load i16* %op_type216, align 2, !tbaa !4
  %cmp218 = icmp eq i16 %46, 139
  br i1 %cmp218, label %if.then220, label %return

if.then220:                                       ; preds = %land.lhs.true215
  %47 = getelementptr inbounds %struct.op* %right, i64 1, i32 0
  %48 = load %struct.op** %47, align 8, !tbaa !3
  %tobool222 = icmp eq %struct.op* %48, null
  br i1 %tobool222, label %return, label %land.lhs.true223

land.lhs.true223:                                 ; preds = %if.then220
  %op_type224 = getelementptr inbounds %struct.op* %48, i64 0, i32 4
  %49 = load i16* %op_type224, align 2, !tbaa !4
  %cmp226 = icmp eq i16 %49, 13
  br i1 %cmp226, label %if.then228, label %return

if.then228:                                       ; preds = %land.lhs.true223
  %50 = load i16* %op_type, align 2, !tbaa !4
  %cmp231 = icmp eq i16 %50, 125
  br i1 %cmp231, label %land.lhs.true233, label %if.else267

land.lhs.true233:                                 ; preds = %if.then228
  %51 = load i8* %op_private62, align 1, !tbaa !1
  %tobool237 = icmp slt i8 %51, 0
  br i1 %tobool237, label %if.else267, label %land.lhs.true238

land.lhs.true238:                                 ; preds = %land.lhs.true233
  %52 = load i8* %op_private44, align 1, !tbaa !1
  %and241 = and i8 %52, 64
  %tobool242 = icmp eq i8 %and241, 0
  br i1 %tobool242, label %if.then243, label %if.else267

if.then243:                                       ; preds = %land.lhs.true238
  %53 = getelementptr inbounds %struct.op* %call14, i64 1, i32 0
  %54 = load %struct.op** %53, align 8, !tbaa !3
  %op_type245 = getelementptr inbounds %struct.op* %54, i64 0, i32 4
  %55 = load i16* %op_type245, align 2, !tbaa !4
  %cmp247 = icmp eq i16 %55, 7
  br i1 %cmp247, label %land.lhs.true249, label %return

land.lhs.true249:                                 ; preds = %if.then243
  %op_pmreplroot250 = getelementptr inbounds %struct.op* %48, i64 1, i32 2
  %56 = load %struct.op* ()** %op_pmreplroot250, align 8
  %tobool251 = icmp eq %struct.op* ()* %56, null
  br i1 %tobool251, label %if.then252, label %return

if.then252:                                       ; preds = %land.lhs.true249
  %op_sv253 = getelementptr inbounds %struct.op* %54, i64 1
  %57 = bitcast %struct.op* %op_sv253 to %struct.sv**
  %58 = load %struct.sv** %57, align 8, !tbaa !3
  %.c = bitcast %struct.sv* %58 to %struct.op* ()*
  store %struct.op* ()* %.c, %struct.op* ()** %op_pmreplroot250, align 8, !tbaa !3
  %59 = getelementptr inbounds %struct.op* %op_sv253, i64 0, i32 0
  store %struct.op* null, %struct.op** %59, align 8, !tbaa !3
  %op_pmflags = getelementptr inbounds %struct.op* %48, i64 2, i32 1
  %60 = bitcast %struct.op** %op_pmflags to i32*
  %61 = load i32* %60, align 4, !tbaa !0
  %or256 = or i32 %61, 2
  store i32 %or256, i32* %60, align 4, !tbaa !0
  %62 = getelementptr inbounds %struct.op* %call42, i64 1, i32 0
  %63 = load %struct.op** %62, align 8, !tbaa !3
  %64 = getelementptr inbounds %struct.op* %63, i64 1, i32 0
  %65 = load %struct.op** %64, align 8, !tbaa !3
  %op_sibling259 = getelementptr inbounds %struct.op* %65, i64 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling259, align 8, !tbaa !3
  %op_next260 = getelementptr inbounds %struct.op* %65, i64 0, i32 0
  %66 = load %struct.op** %op_next260, align 8, !tbaa !3
  %op_next261 = getelementptr inbounds %struct.op* %right, i64 0, i32 0
  store %struct.op* %66, %struct.op** %op_next261, align 8, !tbaa !3
  call void @Perl_op_free(%struct.op* %call42) #8
  %op_flags262 = getelementptr inbounds %struct.op* %right, i64 0, i32 6
  %67 = load i8* %op_flags262, align 1, !tbaa !1
  %and264 = and i8 %67, -4
  store i8 %and264, i8* %op_flags262, align 1, !tbaa !1
  br label %return

if.else267:                                       ; preds = %land.lhs.true238, %land.lhs.true233, %if.then228
  %68 = load i32* @PL_modcount, align 4, !tbaa !0
  %cmp268 = icmp slt i32 %68, 1073741823
  br i1 %cmp268, label %land.lhs.true270, label %return

land.lhs.true270:                                 ; preds = %if.else267
  %69 = getelementptr inbounds %struct.op* %right, i64 1, i32 1
  %70 = load %struct.op** %69, align 8, !tbaa !3
  %op_type271 = getelementptr inbounds %struct.op* %70, i64 0, i32 4
  %71 = load i16* %op_type271, align 2, !tbaa !4
  %cmp273 = icmp eq i16 %71, 5
  br i1 %cmp273, label %if.then275, label %return

if.then275:                                       ; preds = %land.lhs.true270
  %op_sv277 = getelementptr inbounds %struct.op* %70, i64 1
  %72 = bitcast %struct.op* %op_sv277 to %struct.sv**
  %73 = load %struct.sv** %72, align 8, !tbaa !3
  %sv_any278 = getelementptr inbounds %struct.sv* %73, i64 0, i32 0
  %74 = load i8** %sv_any278, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %74, i64 24
  %75 = bitcast i8* %xiv_iv to i64*
  %76 = load i64* %75, align 8, !tbaa !5
  %cmp279 = icmp eq i64 %76, 0
  br i1 %cmp279, label %if.then281, label %return

if.then281:                                       ; preds = %if.then275
  %add = add nsw i32 %68, 1
  %conv282 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %73, i64 %conv282) #7
  br label %return

if.end288:                                        ; preds = %if.end
  %tobool289 = icmp eq %struct.op* %right, null
  br i1 %tobool289, label %if.then290, label %if.end292

if.then290:                                       ; preds = %if.end288
  %call291 = call %struct.op* @Perl_newOP(i32 43, i32 0) #8
  br label %if.end292

if.end292:                                        ; preds = %if.end288, %if.then290
  %right.addr.0 = phi %struct.op* [ %right, %if.end288 ], [ %call291, %if.then290 ]
  %op_type293 = getelementptr inbounds %struct.op* %right.addr.0, i64 0, i32 4
  %77 = load i16* %op_type293, align 2, !tbaa !4
  %cmp295 = icmp eq i16 %77, 26
  br i1 %cmp295, label %if.then297, label %if.else306

if.then297:                                       ; preds = %if.end292
  %op_flags298 = getelementptr inbounds %struct.op* %right.addr.0, i64 0, i32 6
  %78 = load i8* %op_flags298, align 1, !tbaa !1
  %or300 = or i8 %78, 64
  store i8 %or300, i8* %op_flags298, align 1, !tbaa !1
  %call302 = call %struct.op* @Perl_scalar(%struct.op* %left) #8
  %call303 = call %struct.op* @Perl_mod(%struct.op* %call302, i32 36) #8
  %call304 = call %struct.op* @Perl_scalar(%struct.op* %right.addr.0) #8
  %call305 = call %struct.op* @Perl_newBINOP(i32 0, i32 %flags, %struct.op* %call303, %struct.op* %call304) #8
  br label %return

if.else306:                                       ; preds = %if.end292
  store %struct.op* %right.addr.0, %struct.op** @PL_eval_start, align 8, !tbaa !3
  %call307 = call %struct.op* @Perl_scalar(%struct.op* %right.addr.0) #8
  %call308 = call %struct.op* @Perl_scalar(%struct.op* %left) #8
  %call309 = call %struct.op* @Perl_mod(%struct.op* %call308, i32 36) #8
  %call310 = call %struct.op* @Perl_newBINOP(i32 36, i32 %flags, %struct.op* %call307, %struct.op* %call309) #8
  %79 = load %struct.op** @PL_eval_start, align 8, !tbaa !3
  %tobool311 = icmp eq %struct.op* %79, null
  br i1 %tobool311, label %if.else313, label %if.then312

if.then312:                                       ; preds = %if.else306
  store %struct.op* null, %struct.op** @PL_eval_start, align 8, !tbaa !3
  br label %return

if.else313:                                       ; preds = %if.else306
  call void @Perl_op_free(%struct.op* %call310) #8
  br label %return

return:                                           ; preds = %land.lhs.true215, %if.then243, %if.then275, %if.then281, %land.lhs.true270, %if.else267, %land.lhs.true223, %if.end213, %if.then220, %land.lhs.true249, %if.then312, %if.else313, %if.then297, %if.then252, %if.then33, %if.else17, %if.else, %if.then2
  %retval.0 = phi %struct.op* [ %call.i, %if.then2 ], [ %call10, %if.else ], [ %call14, %if.then33 ], [ %right, %if.then252 ], [ null, %if.else17 ], [ %call305, %if.then297 ], [ %call310, %if.then312 ], [ null, %if.else313 ], [ %call42, %land.lhs.true249 ], [ %call42, %if.then220 ], [ %call42, %if.end213 ], [ %call42, %land.lhs.true223 ], [ %call42, %if.else267 ], [ %call42, %land.lhs.true270 ], [ %call42, %if.then281 ], [ %call42, %if.then275 ], [ %call42, %if.then243 ], [ %call42, %land.lhs.true215 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newLOGOP(i32 %type, i32 %flags, %struct.op* %first, %struct.op* %other) #0 {
entry:
  %first.addr = alloca %struct.op*, align 8
  %other.addr = alloca %struct.op*, align 8
  store %struct.op* %first, %struct.op** %first.addr, align 8, !tbaa !3
  store %struct.op* %other, %struct.op** %other.addr, align 8, !tbaa !3
  %call = call fastcc %struct.op* @S_new_logop(i32 %type, i32 %flags, %struct.op** %first.addr, %struct.op** %other.addr) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @S_list_assignment(%struct.op* %o) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 4
  %tobool3 = icmp eq i8 %and, 0
  br i1 %tobool3, label %lor.lhs.false47, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %op_type6.phi.trans.insert = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %.pre = load i16* %op_type6.phi.trans.insert, align 2, !tbaa !4
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %.pr = phi i16 [ %.pre, %if.then4 ], [ %0, %if.end ]
  %o.addr.0 = phi %struct.op* [ %3, %if.then4 ], [ %o, %if.end ]
  switch i16 %.pr, label %lor.lhs.false47 [
    i16 162, label %if.then10
    i16 141, label %land.lhs.true31
  ]

if.then10:                                        ; preds = %if.end5
  %4 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %5, i64 0, i32 1
  %6 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %call = tail call fastcc i32 @S_list_assignment(%struct.op* %6) #8
  %7 = load %struct.op** %4, align 8, !tbaa !3
  %op_sibling13 = getelementptr inbounds %struct.op* %7, i64 0, i32 1
  %8 = load %struct.op** %op_sibling13, align 8, !tbaa !3
  %op_sibling14 = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %9 = load %struct.op** %op_sibling14, align 8, !tbaa !3
  %call15 = tail call fastcc i32 @S_list_assignment(%struct.op* %9) #8
  %tobool16.not = icmp eq i32 %call, 0
  %tobool18 = icmp eq i32 %call15, 0
  %or.cond = or i1 %tobool16.not, %tobool18
  br i1 %or.cond, label %if.end20, label %return

if.end20:                                         ; preds = %if.then10
  %10 = or i32 %call15, %call
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %return, label %if.then23

if.then23:                                        ; preds = %if.end20
  %call24 = tail call i32 @Perl_yyerror(i8* getelementptr inbounds ([39 x i8]* @.str152, i64 0, i64 0)) #7
  br label %return

land.lhs.true31:                                  ; preds = %if.end5
  %op_flags32 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 6
  %12 = load i8* %op_flags32, align 1, !tbaa !1
  %and34 = and i8 %12, 3
  %cmp35 = icmp eq i8 %and34, 2
  br i1 %cmp35, label %land.lhs.true37, label %if.end42

land.lhs.true37:                                  ; preds = %land.lhs.true31
  %op_private = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 7
  %13 = load i8* %op_private, align 1, !tbaa !1
  %tobool40 = icmp slt i8 %13, 0
  br i1 %tobool40, label %return, label %if.end42

if.end42:                                         ; preds = %land.lhs.true37, %land.lhs.true31
  br label %return

lor.lhs.false47:                                  ; preds = %land.lhs.true, %if.end5
  %o.addr.0118 = phi %struct.op* [ %o.addr.0, %if.end5 ], [ %o, %land.lhs.true ]
  %.pr117 = phi i16 [ %.pr, %if.end5 ], [ 0, %land.lhs.true ]
  %op_flags48.phi.trans.insert = getelementptr inbounds %struct.op* %o.addr.0118, i64 0, i32 6
  %.pre116 = load i8* %op_flags48.phi.trans.insert, align 1, !tbaa !1
  %and50 = and i8 %.pre116, 8
  %tobool51 = icmp eq i8 %and50, 0
  br i1 %tobool51, label %switch.early.test, label %return

switch.early.test:                                ; preds = %lor.lhs.false47
  switch i16 %.pr117, label %if.end84 [
    i16 136, label %return
    i16 134, label %return
    i16 128, label %return
    i16 125, label %return
    i16 10, label %return
    i16 11, label %return
  ]

if.end84:                                         ; preds = %switch.early.test
  br label %return

return:                                           ; preds = %if.end42, %lor.lhs.false47, %switch.early.test, %switch.early.test, %switch.early.test, %switch.early.test, %switch.early.test, %switch.early.test, %land.lhs.true37, %if.then23, %if.end20, %if.then10, %entry, %if.end84
  %retval.0 = phi i32 [ 0, %if.end84 ], [ 1, %entry ], [ 1, %if.then10 ], [ 0, %if.end20 ], [ 0, %if.then23 ], [ 0, %land.lhs.true37 ], [ 1, %switch.early.test ], [ 1, %if.end42 ], [ 1, %lor.lhs.false47 ], [ 1, %switch.early.test ], [ 1, %switch.early.test ], [ 1, %switch.early.test ], [ 1, %switch.early.test ], [ 1, %switch.early.test ]
  ret i32 %retval.0
}

; Function Attrs: optsize
declare void @Perl_sv_setiv(%struct.sv*, i64) #2

; Function Attrs: optsize
declare i32 @Perl_intro_my() #2

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.op* @S_new_logop(i32 %type, i32 %flags, %struct.op** nocapture %firstp, %struct.op** nocapture %otherp) #0 {
entry:
  %0 = load %struct.op** %firstp, align 8, !tbaa !3
  %1 = load %struct.op** %otherp, align 8, !tbaa !3
  %cmp = icmp eq i32 %type, 161
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %0) #8
  %call1 = tail call %struct.op* @Perl_scalar(%struct.op* %1) #8
  %call2 = tail call %struct.op* @Perl_newBINOP(i32 161, i32 %flags, %struct.op* %call, %struct.op* %call1) #8
  br label %return

if.end:                                           ; preds = %entry
  tail call fastcc void @S_scalarboolean(%struct.op* %0) #8
  %op_type = getelementptr inbounds %struct.op* %0, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %cmp4 = icmp eq i16 %2, 96
  br i1 %cmp4, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %if.end
  %op_flags = getelementptr inbounds %struct.op* %0, i64 0, i32 6
  %3 = load i8* %op_flags, align 1, !tbaa !1
  %tobool = icmp slt i8 %3, 0
  br i1 %tobool, label %if.then7, label %if.end24.thread

if.then7:                                         ; preds = %land.lhs.true
  %type.off = add i32 %type, -159
  %4 = icmp ult i32 %type.off, 2
  br i1 %4, label %if.then12, label %if.end24.thread

if.then12:                                        ; preds = %if.then7
  %cmp8 = icmp eq i32 %type, 159
  %. = select i1 %cmp8, i32 160, i32 159
  %5 = getelementptr inbounds %struct.op* %0, i64 1, i32 0
  %6 = load %struct.op** %5, align 8, !tbaa !3
  store %struct.op* %6, %struct.op** %firstp, align 8, !tbaa !3
  %op_next = getelementptr inbounds %struct.op* %0, i64 0, i32 0
  %7 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool17 = icmp eq %struct.op* %7, null
  br i1 %tobool17, label %if.end21, label %if.then18

if.then18:                                        ; preds = %if.then12
  %op_next20 = getelementptr inbounds %struct.op* %6, i64 0, i32 0
  store %struct.op* %7, %struct.op** %op_next20, align 8, !tbaa !3
  br label %if.end21

if.end21:                                         ; preds = %if.then12, %if.then18
  store %struct.op* null, %struct.op** %5, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %0) #8
  %op_type25.phi.trans.insert = getelementptr inbounds %struct.op* %6, i64 0, i32 4
  %.pre = load i16* %op_type25.phi.trans.insert, align 2, !tbaa !4
  br label %if.end24

if.end24.thread:                                  ; preds = %if.then7, %land.lhs.true
  %op_type25413 = getelementptr inbounds %struct.op* %0, i64 0, i32 4
  br label %if.else140

if.end24:                                         ; preds = %if.end21, %if.end
  %8 = phi i16 [ %.pre, %if.end21 ], [ %2, %if.end ]
  %first.0 = phi %struct.op* [ %6, %if.end21 ], [ %0, %if.end ]
  %type.addr.1 = phi i32 [ %., %if.end21 ], [ %type, %if.end ]
  %op_type25 = getelementptr inbounds %struct.op* %first.0, i64 0, i32 4
  %cmp27 = icmp eq i16 %8, 5
  br i1 %cmp27, label %if.then29, label %if.else140

if.then29:                                        ; preds = %if.end24
  %op_private = getelementptr inbounds %struct.op* %first.0, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !1
  %and31 = and i8 %9, 8
  %tobool32 = icmp eq i8 %and31, 0
  br i1 %tobool32, label %if.else34, label %if.then33

if.then33:                                        ; preds = %if.then29
  %op_sv.i = getelementptr inbounds %struct.op* %first.0, i64 1
  %10 = bitcast %struct.op* %op_sv.i to %struct.sv**
  %11 = load %struct.sv** %10, align 8, !tbaa !3
  %call.i = tail call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([53 x i8]* @.str155, i64 0, i64 0), %struct.sv* %11) #7
  tail call void @Perl_qerror(%struct.sv* %call.i) #7
  br label %if.end65

if.else34:                                        ; preds = %if.then29
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp35 = icmp eq %struct.sv* %13, null
  br i1 %cmp35, label %lor.lhs.false50, label %land.lhs.true37

land.lhs.true37:                                  ; preds = %if.else34
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings38 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings38, align 8, !tbaa !3
  %cmp39 = icmp eq %struct.sv* %15, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp39, label %lor.lhs.false50, label %land.lhs.true41

land.lhs.true41:                                  ; preds = %land.lhs.true37
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings42 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings42, align 8, !tbaa !3
  %cmp43 = icmp eq %struct.sv* %17, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp43, label %land.lhs.true58, label %lor.lhs.false45

lor.lhs.false45:                                  ; preds = %land.lhs.true41
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings46 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings46, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %19, i64 0, i32 0
  %20 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %20 to i8**
  %21 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %21, i64 7
  %22 = load i8* %arrayidx, align 1, !tbaa !1
  %and48 = and i8 %22, 16
  %tobool49 = icmp eq i8 %and48, 0
  br i1 %tobool49, label %lor.lhs.false50, label %land.lhs.true58

lor.lhs.false50:                                  ; preds = %lor.lhs.false45, %land.lhs.true37, %if.else34
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings51 = getelementptr inbounds %struct.cop* %23, i64 0, i32 14
  %24 = load %struct.sv** %cop_warnings51, align 8, !tbaa !3
  %cmp52 = icmp eq %struct.sv* %24, null
  br i1 %cmp52, label %land.lhs.true54, label %if.end65

land.lhs.true54:                                  ; preds = %lor.lhs.false50
  %25 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and56 = and i8 %25, 1
  %tobool57 = icmp eq i8 %and56, 0
  br i1 %tobool57, label %if.end65, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %lor.lhs.false45, %land.lhs.true54, %land.lhs.true41
  %26 = load i8* %op_private, align 1, !tbaa !1
  %and61 = and i8 %26, 64
  %tobool62 = icmp eq i8 %and61, 0
  br i1 %tobool62, label %if.end65, label %if.then63

if.then63:                                        ; preds = %land.lhs.true58
  tail call void (i32, i8*, ...)* @Perl_warner(i32 30, i8* getelementptr inbounds ([30 x i8]* @.str148, i64 0, i64 0)) #7
  br label %if.end65

if.end65:                                         ; preds = %land.lhs.true58, %land.lhs.true54, %lor.lhs.false50, %if.then63, %if.then33
  %cmp66 = icmp eq i32 %type.addr.1, 159
  %conv67 = zext i1 %cmp66 to i32
  %op_sv = getelementptr inbounds %struct.op* %first.0, i64 1
  %27 = bitcast %struct.op* %op_sv to %struct.sv**
  %28 = load %struct.sv** %27, align 8, !tbaa !3
  %tobool68 = icmp eq %struct.sv* %28, null
  br i1 %tobool68, label %cond.end115, label %cond.false

cond.false:                                       ; preds = %if.end65
  %sv_flags = getelementptr inbounds %struct.sv* %28, i64 0, i32 2
  %29 = load i32* %sv_flags, align 4, !tbaa !0
  %and70 = and i32 %29, 262144
  %tobool71 = icmp eq i32 %and70, 0
  br i1 %tobool71, label %cond.false86, label %cond.true72

cond.true72:                                      ; preds = %cond.false
  %sv_any74 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %30 = load i8** %sv_any74, align 8, !tbaa !3
  %31 = bitcast i8* %30 to %struct.xpv*
  store %struct.xpv* %31, %struct.xpv** @PL_Xpv, align 8, !tbaa !3
  %tobool75 = icmp eq i8* %30, null
  br i1 %tobool75, label %land.end85, label %land.rhs

land.rhs:                                         ; preds = %cond.true72
  %xpv_cur = getelementptr inbounds i8* %30, i64 8
  %32 = bitcast i8* %xpv_cur to i64*
  %33 = load i64* %32, align 8, !tbaa !5
  %cmp76 = icmp ugt i64 %33, 1
  br i1 %cmp76, label %land.end85, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %tobool79 = icmp eq i64 %33, 0
  br i1 %tobool79, label %land.end85, label %land.rhs80

land.rhs80:                                       ; preds = %lor.rhs
  %xpv_pv81 = bitcast i8* %30 to i8**
  %34 = load i8** %xpv_pv81, align 8, !tbaa !3
  %35 = load i8* %34, align 1, !tbaa !1
  %cmp83 = icmp ne i8 %35, 48
  br label %land.end85

land.end85:                                       ; preds = %lor.rhs, %cond.true72, %land.rhs, %land.rhs80
  %36 = phi i1 [ false, %cond.true72 ], [ true, %land.rhs ], [ false, %lor.rhs ], [ %cmp83, %land.rhs80 ]
  %cond = zext i1 %36 to i32
  br label %cond.end115

cond.false86:                                     ; preds = %cond.false
  %and89 = and i32 %29, 65536
  %tobool90 = icmp eq i32 %and89, 0
  br i1 %tobool90, label %cond.false96, label %cond.true91

cond.true91:                                      ; preds = %cond.false86
  %sv_any93 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %37 = load i8** %sv_any93, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %37, i64 24
  %38 = bitcast i8* %xiv_iv to i64*
  %39 = load i64* %38, align 8, !tbaa !5
  %cmp94 = icmp ne i64 %39, 0
  %conv95 = zext i1 %cmp94 to i32
  br label %cond.end115

cond.false96:                                     ; preds = %cond.false86
  %and99 = and i32 %29, 131072
  %tobool100 = icmp eq i32 %and99, 0
  br i1 %tobool100, label %cond.false106, label %cond.true101

cond.true101:                                     ; preds = %cond.false96
  %sv_any103 = getelementptr inbounds %struct.sv* %28, i64 0, i32 0
  %40 = load i8** %sv_any103, align 8, !tbaa !3
  %xnv_nv = getelementptr inbounds i8* %40, i64 32
  %41 = bitcast i8* %xnv_nv to double*
  %42 = load double* %41, align 8, !tbaa !6
  %cmp104 = fcmp une double %42, 0.000000e+00
  %conv105 = zext i1 %cmp104 to i32
  br label %cond.end115

cond.false106:                                    ; preds = %cond.false96
  %call108 = tail call signext i8 @Perl_sv_2bool(%struct.sv* %28) #7
  %conv109 = sext i8 %call108 to i32
  br label %cond.end115

cond.end115:                                      ; preds = %if.end65, %land.end85, %cond.true101, %cond.false106, %cond.true91
  %cond116 = phi i32 [ 0, %if.end65 ], [ %cond, %land.end85 ], [ %conv95, %cond.true91 ], [ %conv105, %cond.true101 ], [ %conv109, %cond.false106 ]
  %cmp117 = icmp eq i32 %conv67, %cond116
  br i1 %cmp117, label %if.then119, label %if.else129

if.then119:                                       ; preds = %cond.end115
  tail call void @Perl_op_free(%struct.op* %first.0) #8
  store %struct.op* null, %struct.op** %firstp, align 8, !tbaa !3
  %op_type120 = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %43 = load i16* %op_type120, align 2, !tbaa !4
  %cmp122 = icmp eq i16 %43, 5
  br i1 %cmp122, label %if.then124, label %return

if.then124:                                       ; preds = %if.then119
  %op_private125 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %44 = load i8* %op_private125, align 1, !tbaa !1
  %or = or i8 %44, 4
  store i8 %or, i8* %op_private125, align 1, !tbaa !1
  br label %return

if.else129:                                       ; preds = %cond.end115
  tail call void @Perl_op_free(%struct.op* %1) #8
  store %struct.op* null, %struct.op** %otherp, align 8, !tbaa !3
  %45 = load i16* %op_type25, align 2, !tbaa !4
  %cmp132 = icmp eq i16 %45, 5
  br i1 %cmp132, label %if.then134, label %return

if.then134:                                       ; preds = %if.else129
  %46 = load i8* %op_private, align 1, !tbaa !1
  %or137 = or i8 %46, 4
  store i8 %or137, i8* %op_private, align 1, !tbaa !1
  br label %return

if.else140:                                       ; preds = %if.end24.thread, %if.end24
  %op_type25418 = phi i16* [ %op_type25413, %if.end24.thread ], [ %op_type25, %if.end24 ]
  %type.addr.1417 = phi i32 [ %type, %if.end24.thread ], [ %type.addr.1, %if.end24 ]
  %first.0415 = phi %struct.op* [ %0, %if.end24.thread ], [ %first.0, %if.end24 ]
  %47 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings141 = getelementptr inbounds %struct.cop* %47, i64 0, i32 14
  %48 = load %struct.sv** %cop_warnings141, align 8, !tbaa !3
  %cmp142 = icmp eq %struct.sv* %48, null
  br i1 %cmp142, label %lor.lhs.false160, label %land.lhs.true144

land.lhs.true144:                                 ; preds = %if.else140
  %49 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings145 = getelementptr inbounds %struct.cop* %49, i64 0, i32 14
  %50 = load %struct.sv** %cop_warnings145, align 8, !tbaa !3
  %cmp146 = icmp eq %struct.sv* %50, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp146, label %lor.lhs.false160, label %land.lhs.true148

land.lhs.true148:                                 ; preds = %land.lhs.true144
  %51 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings149 = getelementptr inbounds %struct.cop* %51, i64 0, i32 14
  %52 = load %struct.sv** %cop_warnings149, align 8, !tbaa !3
  %cmp150 = icmp eq %struct.sv* %52, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp150, label %land.lhs.true168, label %lor.lhs.false152

lor.lhs.false152:                                 ; preds = %land.lhs.true148
  %53 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings153 = getelementptr inbounds %struct.cop* %53, i64 0, i32 14
  %54 = load %struct.sv** %cop_warnings153, align 8, !tbaa !3
  %sv_any154 = getelementptr inbounds %struct.sv* %54, i64 0, i32 0
  %55 = load i8** %sv_any154, align 8, !tbaa !3
  %xpv_pv155 = bitcast i8* %55 to i8**
  %56 = load i8** %xpv_pv155, align 8, !tbaa !3
  %arrayidx156 = getelementptr inbounds i8* %56, i64 3
  %57 = load i8* %arrayidx156, align 1, !tbaa !1
  %and158 = and i8 %57, 1
  %tobool159 = icmp eq i8 %and158, 0
  br i1 %tobool159, label %lor.lhs.false160, label %land.lhs.true168

lor.lhs.false160:                                 ; preds = %lor.lhs.false152, %land.lhs.true144, %if.else140
  %58 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings161 = getelementptr inbounds %struct.cop* %58, i64 0, i32 14
  %59 = load %struct.sv** %cop_warnings161, align 8, !tbaa !3
  %cmp162 = icmp eq %struct.sv* %59, null
  br i1 %cmp162, label %land.lhs.true164, label %if.end252

land.lhs.true164:                                 ; preds = %lor.lhs.false160
  %60 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and166 = and i8 %60, 1
  %tobool167 = icmp eq i8 %and166, 0
  br i1 %tobool167, label %if.end252, label %land.lhs.true168

land.lhs.true168:                                 ; preds = %lor.lhs.false152, %land.lhs.true164, %land.lhs.true148
  %op_flags169 = getelementptr inbounds %struct.op* %first.0415, i64 0, i32 6
  %61 = load i8* %op_flags169, align 1, !tbaa !1
  %and171 = and i8 %61, 4
  %tobool172 = icmp eq i8 %and171, 0
  br i1 %tobool172, label %if.end252, label %if.then173

if.then173:                                       ; preds = %land.lhs.true168
  %62 = getelementptr inbounds %struct.op* %first.0415, i64 1, i32 0
  %63 = load %struct.op** %62, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %63, i64 0, i32 1
  %64 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %65 = load i16* %op_type25418, align 2, !tbaa !4
  %conv176 = zext i16 %65 to i32
  switch i32 %conv176, label %if.end252 [
    i32 0, label %sw.bb
    i32 36, label %sw.bb197
  ]

sw.bb:                                            ; preds = %if.then173
  %tobool177 = icmp eq %struct.op* %64, null
  br i1 %tobool177, label %if.end252, label %land.lhs.true178

land.lhs.true178:                                 ; preds = %sw.bb
  %op_type179 = getelementptr inbounds %struct.op* %64, i64 0, i32 4
  %66 = load i16* %op_type179, align 2, !tbaa !4
  %cmp181 = icmp eq i16 %66, 26
  br i1 %cmp181, label %land.lhs.true183, label %if.end252

land.lhs.true183:                                 ; preds = %land.lhs.true178
  %op_flags184 = getelementptr inbounds %struct.op* %64, i64 0, i32 6
  %67 = load i8* %op_flags184, align 1, !tbaa !1
  %and186 = and i8 %67, 64
  %tobool187 = icmp eq i8 %and186, 0
  br i1 %tobool187, label %if.end252, label %land.lhs.true188

land.lhs.true188:                                 ; preds = %land.lhs.true183
  %op_flags189 = getelementptr inbounds %struct.op* %63, i64 0, i32 6
  %68 = load i8* %op_flags189, align 1, !tbaa !1
  %and191 = and i8 %68, 3
  %cmp192 = icmp eq i8 %and191, 2
  %.404 = select i1 %cmp192, i16 26, i16 0
  br label %sw.epilog

sw.bb197:                                         ; preds = %if.then173
  %op_type198 = getelementptr inbounds %struct.op* %63, i64 0, i32 4
  %69 = load i16* %op_type198, align 2, !tbaa !4
  switch i16 %69, label %lor.lhs.false215 [
    i16 276, label %if.then237
    i16 25, label %if.then237
    i16 0, label %land.lhs.true212
  ]

land.lhs.true212:                                 ; preds = %sw.bb197
  %op_targ = getelementptr inbounds %struct.op* %63, i64 0, i32 3
  %70 = load i64* %op_targ, align 8, !tbaa !5
  %cmp213 = icmp eq i64 %70, 25
  br i1 %cmp213, label %cond.true225, label %if.end252

lor.lhs.false215:                                 ; preds = %sw.bb197
  %cmp218 = icmp eq i16 %69, 129
  br i1 %cmp218, label %if.then237, label %if.end252

cond.true225:                                     ; preds = %land.lhs.true212
  %op_targ226 = getelementptr inbounds %struct.op* %63, i64 0, i32 3
  %71 = load i64* %op_targ226, align 8, !tbaa !5
  %conv227 = trunc i64 %71 to i16
  br label %sw.epilog

sw.epilog:                                        ; preds = %land.lhs.true188, %cond.true225
  %warnop.0 = phi i16 [ %.404, %land.lhs.true188 ], [ %conv227, %cond.true225 ]
  %tobool236 = icmp eq i16 %warnop.0, 0
  br i1 %tobool236, label %if.end252, label %if.then237

if.then237:                                       ; preds = %lor.lhs.false215, %sw.bb197, %sw.bb197, %sw.epilog
  %warnop.0410 = phi i16 [ %warnop.0, %sw.epilog ], [ %69, %sw.bb197 ], [ %69, %sw.bb197 ], [ 129, %lor.lhs.false215 ]
  %72 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %72, i64 0, i32 13
  %73 = load i32* %cop_line, align 4, !tbaa !0
  %74 = load i32* @PL_copline, align 4, !tbaa !0
  %75 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line238 = getelementptr inbounds %struct.cop* %75, i64 0, i32 13
  store i32 %74, i32* %cop_line238, align 4, !tbaa !0
  %idxprom = zext i16 %warnop.0410 to i64
  %arrayidx239 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %76 = load i8** %arrayidx239, align 8, !tbaa !3
  %cmp241 = icmp eq i16 %warnop.0410, 26
  br i1 %cmp241, label %lor.end247, label %lor.rhs243

lor.rhs243:                                       ; preds = %if.then237
  %cmp245 = icmp eq i16 %warnop.0410, 25
  %phitmp = select i1 %cmp245, i8* getelementptr inbounds ([11 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([12 x i8]* @.str151, i64 0, i64 0)
  br label %lor.end247

lor.end247:                                       ; preds = %lor.rhs243, %if.then237
  %77 = phi i8* [ getelementptr inbounds ([11 x i8]* @.str150, i64 0, i64 0), %if.then237 ], [ %phitmp, %lor.rhs243 ]
  tail call void (i32, i8*, ...)* @Perl_warner(i32 12, i8* getelementptr inbounds ([46 x i8]* @.str149, i64 0, i64 0), i8* %76, i8* %77) #7
  %78 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line249 = getelementptr inbounds %struct.cop* %78, i64 0, i32 13
  store i32 %73, i32* %cop_line249, align 4, !tbaa !0
  br label %if.end252

if.end252:                                        ; preds = %land.lhs.true212, %sw.bb, %land.lhs.true178, %land.lhs.true183, %lor.lhs.false215, %if.then173, %sw.epilog, %land.lhs.true168, %land.lhs.true164, %lor.lhs.false160, %lor.end247
  %tobool253 = icmp eq %struct.op* %1, null
  br i1 %tobool253, label %return, label %if.end255

if.end255:                                        ; preds = %if.end252
  %type.addr.1.off = add i32 %type.addr.1417, -163
  %79 = icmp ult i32 %type.addr.1.off, 2
  br i1 %79, label %if.then261, label %if.end266

if.then261:                                       ; preds = %if.end255
  %op_private262 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %80 = load i8* %op_private262, align 1, !tbaa !1
  %or264 = or i8 %80, 64
  store i8 %or264, i8* %op_private262, align 1, !tbaa !1
  br label %if.end266

if.end266:                                        ; preds = %if.end255, %if.then261
  %call267 = tail call i8* @Perl_safesysmalloc(i64 56) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call267, i8 0, i64 56, i32 1, i1 false)
  %conv268 = trunc i32 %type.addr.1417 to i16
  %op_type269 = getelementptr inbounds i8* %call267, i64 32
  %81 = bitcast i8* %op_type269 to i16*
  store i16 %conv268, i16* %81, align 2, !tbaa !4
  %idxprom270 = sext i32 %type.addr.1417 to i64
  %arrayidx271 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom270
  %82 = load %struct.op* ()** %arrayidx271, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call267, i64 16
  %83 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %82, %struct.op* ()** %83, align 8, !tbaa !3
  %op_first272 = getelementptr inbounds i8* %call267, i64 40
  %84 = bitcast i8* %op_first272 to %struct.op**
  store %struct.op* %first.0415, %struct.op** %84, align 8, !tbaa !3
  %or273 = or i32 %flags, 4
  %conv274 = trunc i32 %or273 to i8
  %85 = getelementptr inbounds i8* %call267, i64 36
  store i8 %conv274, i8* %85, align 1, !tbaa !1
  %op_next276 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %86 = load %struct.op** %op_next276, align 8, !tbaa !3
  %tobool277 = icmp eq %struct.op* %86, null
  br i1 %tobool277, label %cond.false280, label %cond.end282

cond.false280:                                    ; preds = %if.end266
  %call281 = tail call %struct.op* @Perl_linklist(%struct.op* %1) #8
  br label %cond.end282

cond.end282:                                      ; preds = %if.end266, %cond.false280
  %cond283 = phi %struct.op* [ %call281, %cond.false280 ], [ %86, %if.end266 ]
  %op_other = getelementptr inbounds i8* %call267, i64 48
  %87 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond283, %struct.op** %87, align 8, !tbaa !3
  %shr401 = lshr i32 %flags, 8
  %or284 = or i32 %shr401, 1
  %conv285 = trunc i32 %or284 to i8
  %88 = getelementptr inbounds i8* %call267, i64 37
  store i8 %conv285, i8* %88, align 1, !tbaa !1
  %op_next287 = getelementptr inbounds %struct.op* %first.0415, i64 0, i32 0
  %89 = load %struct.op** %op_next287, align 8, !tbaa !3
  %tobool288 = icmp eq %struct.op* %89, null
  br i1 %tobool288, label %cond.false291, label %cond.end293

cond.false291:                                    ; preds = %cond.end282
  %call292 = tail call %struct.op* @Perl_linklist(%struct.op* %first.0415) #8
  br label %cond.end293

cond.end293:                                      ; preds = %cond.end282, %cond.false291
  %cond294 = phi %struct.op* [ %call292, %cond.false291 ], [ %89, %cond.end282 ]
  %op_next295 = bitcast i8* %call267 to %struct.op**
  store %struct.op* %cond294, %struct.op** %op_next295, align 8, !tbaa !3
  %90 = bitcast i8* %call267 to %struct.op*
  store %struct.op* %90, %struct.op** %op_next287, align 8, !tbaa !3
  %op_sibling297 = getelementptr inbounds %struct.op* %first.0415, i64 0, i32 1
  store %struct.op* %1, %struct.op** %op_sibling297, align 8, !tbaa !3
  %91 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool298 = icmp eq i8* %91, null
  br i1 %tobool298, label %cond.false307, label %land.lhs.true299

land.lhs.true299:                                 ; preds = %cond.end293
  %arrayidx301 = getelementptr inbounds i8* %91, i64 %idxprom270
  %92 = load i8* %arrayidx301, align 1, !tbaa !1
  %tobool303 = icmp eq i8 %92, 0
  br i1 %tobool303, label %cond.false307, label %cond.true304

cond.true304:                                     ; preds = %land.lhs.true299
  tail call void @Perl_op_free(%struct.op* %90) #8
  %arrayidx306 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom270
  %93 = load i8** %arrayidx306, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %93) #7
  br label %cond.end311

cond.false307:                                    ; preds = %land.lhs.true299, %cond.end293
  %arrayidx309 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 %idxprom270
  %94 = load %struct.op* (%struct.op*)** %arrayidx309, align 8, !tbaa !3
  %call310 = tail call %struct.op* %94(%struct.op* %90) #7
  br label %cond.end311

cond.end311:                                      ; preds = %cond.false307, %cond.true304
  %call313 = tail call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %90) #8
  store %struct.op* %call313, %struct.op** %op_next276, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %if.end252, %if.else129, %if.then134, %if.then119, %if.then124, %cond.end311, %if.then
  %retval.0 = phi %struct.op* [ %call2, %if.then ], [ %call313, %cond.end311 ], [ %1, %if.then124 ], [ %1, %if.then119 ], [ %first.0, %if.then134 ], [ %first.0, %if.else129 ], [ %first.0415, %if.end252 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newCONDOP(i32 %flags, %struct.op* %first, %struct.op* %trueop, %struct.op* %falseop) #0 {
entry:
  %first.addr.i151 = alloca %struct.op*, align 8
  %other.addr.i152 = alloca %struct.op*, align 8
  %first.addr.i = alloca %struct.op*, align 8
  %other.addr.i = alloca %struct.op*, align 8
  %tobool = icmp eq %struct.op* %falseop, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.op** %first.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #4
  %1 = bitcast %struct.op** %other.addr.i to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #4
  store %struct.op* %first, %struct.op** %first.addr.i, align 8, !tbaa !3
  store %struct.op* %trueop, %struct.op** %other.addr.i, align 8, !tbaa !3
  %call.i = call fastcc %struct.op* @S_new_logop(i32 159, i32 0, %struct.op** %first.addr.i, %struct.op** %other.addr.i) #7
  call void @llvm.lifetime.end(i64 8, i8* %0) #4
  call void @llvm.lifetime.end(i64 8, i8* %1) #4
  br label %return

if.end:                                           ; preds = %entry
  %tobool1 = icmp eq %struct.op* %trueop, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %2 = bitcast %struct.op** %first.addr.i151 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #4
  %3 = bitcast %struct.op** %other.addr.i152 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #4
  store %struct.op* %first, %struct.op** %first.addr.i151, align 8, !tbaa !3
  store %struct.op* %falseop, %struct.op** %other.addr.i152, align 8, !tbaa !3
  %call.i153 = call fastcc %struct.op* @S_new_logop(i32 160, i32 0, %struct.op** %first.addr.i151, %struct.op** %other.addr.i152) #7
  call void @llvm.lifetime.end(i64 8, i8* %2) #4
  call void @llvm.lifetime.end(i64 8, i8* %3) #4
  br label %return

if.end4:                                          ; preds = %if.end
  call fastcc void @S_scalarboolean(%struct.op* %first) #8
  %op_type = getelementptr inbounds %struct.op* %first, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 5
  br i1 %cmp, label %if.then7, label %if.end60

if.then7:                                         ; preds = %if.end4
  %op_private = getelementptr inbounds %struct.op* %first, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %6 = and i8 %5, 72
  %7 = icmp eq i8 %6, 72
  %op_sv.i = getelementptr inbounds %struct.op* %first, i64 1
  %8 = bitcast %struct.op* %op_sv.i to %struct.sv**
  br i1 %7, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then7
  %9 = load %struct.sv** %8, align 8, !tbaa !3
  %call.i154 = call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([53 x i8]* @.str155, i64 0, i64 0), %struct.sv* %9) #7
  call void @Perl_qerror(%struct.sv* %call.i154) #7
  br label %if.end15

if.end15:                                         ; preds = %if.then7, %if.then14
  %10 = load %struct.sv** %8, align 8, !tbaa !3
  %tobool16 = icmp eq %struct.sv* %10, null
  br i1 %tobool16, label %if.else, label %cond.false

cond.false:                                       ; preds = %if.end15
  %sv_flags = getelementptr inbounds %struct.sv* %10, i64 0, i32 2
  %11 = load i32* %sv_flags, align 4, !tbaa !0
  %and18 = and i32 %11, 262144
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false34, label %cond.true20

cond.true20:                                      ; preds = %cond.false
  %sv_any = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !3
  %13 = bitcast i8* %12 to %struct.xpv*
  store %struct.xpv* %13, %struct.xpv** @PL_Xpv, align 8, !tbaa !3
  %tobool22 = icmp eq i8* %12, null
  br i1 %tobool22, label %if.else, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %cond.true20
  %xpv_cur = getelementptr inbounds i8* %12, i64 8
  %14 = bitcast i8* %xpv_cur to i64*
  %15 = load i64* %14, align 8, !tbaa !5
  %cmp24 = icmp ugt i64 %15, 1
  br i1 %cmp24, label %if.then59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %tobool27 = icmp eq i64 %15, 0
  br i1 %tobool27, label %if.else, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %12 to i8**
  %16 = load i8** %xpv_pv, align 8, !tbaa !3
  %17 = load i8* %16, align 1, !tbaa !1
  %cmp30 = icmp eq i8 %17, 48
  br i1 %cmp30, label %if.else, label %if.then59

cond.false34:                                     ; preds = %cond.false
  %and37 = and i32 %11, 65536
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %cond.false44, label %cond.true39

cond.true39:                                      ; preds = %cond.false34
  %sv_any41 = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %18 = load i8** %sv_any41, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %18, i64 24
  %19 = bitcast i8* %xiv_iv to i64*
  %20 = load i64* %19, align 8, !tbaa !5
  %cmp42 = icmp eq i64 %20, 0
  br i1 %cmp42, label %if.else, label %if.then59

cond.false44:                                     ; preds = %cond.false34
  %and47 = and i32 %11, 131072
  %tobool48 = icmp eq i32 %and47, 0
  br i1 %tobool48, label %cond.false54, label %cond.true49

cond.true49:                                      ; preds = %cond.false44
  %sv_any51 = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %21 = load i8** %sv_any51, align 8, !tbaa !3
  %xnv_nv = getelementptr inbounds i8* %21, i64 32
  %22 = bitcast i8* %xnv_nv to double*
  %23 = load double* %22, align 8, !tbaa !6
  %cmp52 = fcmp une double %23, 0.000000e+00
  br i1 %cmp52, label %if.then59, label %if.else

cond.false54:                                     ; preds = %cond.false44
  %call56 = call signext i8 @Perl_sv_2bool(%struct.sv* %10) #7
  %tobool58 = icmp eq i8 %call56, 0
  br i1 %tobool58, label %if.else, label %if.then59

if.then59:                                        ; preds = %land.lhs.true28, %cond.true39, %cond.false54, %land.lhs.true23, %cond.true49
  call void @Perl_op_free(%struct.op* %first) #8
  call void @Perl_op_free(%struct.op* %falseop) #8
  br label %return

if.else:                                          ; preds = %land.lhs.true28, %lor.lhs.false, %cond.true20, %cond.true39, %cond.false54, %if.end15, %cond.true49
  call void @Perl_op_free(%struct.op* %first) #8
  call void @Perl_op_free(%struct.op* %trueop) #8
  br label %return

if.end60:                                         ; preds = %if.end4
  %call61 = call i8* @Perl_safesysmalloc(i64 56) #7
  call void @llvm.memset.p0i8.i64(i8* %call61, i8 0, i64 56, i32 1, i1 false)
  %op_type62 = getelementptr inbounds i8* %call61, i64 32
  %24 = bitcast i8* %op_type62 to i16*
  store i16 162, i16* %24, align 2, !tbaa !4
  %25 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 162), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call61, i64 16
  %26 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %25, %struct.op* ()** %26, align 8, !tbaa !3
  %op_first = getelementptr inbounds i8* %call61, i64 40
  %27 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %first, %struct.op** %27, align 8, !tbaa !3
  %or = or i32 %flags, 4
  %conv63 = trunc i32 %or to i8
  %28 = getelementptr inbounds i8* %call61, i64 36
  store i8 %conv63, i8* %28, align 1, !tbaa !1
  %shr150 = lshr i32 %flags, 8
  %or64 = or i32 %shr150, 1
  %conv65 = trunc i32 %or64 to i8
  %29 = getelementptr inbounds i8* %call61, i64 37
  store i8 %conv65, i8* %29, align 1, !tbaa !1
  %op_next = getelementptr inbounds %struct.op* %trueop, i64 0, i32 0
  %30 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool67 = icmp eq %struct.op* %30, null
  br i1 %tobool67, label %cond.false70, label %cond.end

cond.false70:                                     ; preds = %if.end60
  %call71 = call %struct.op* @Perl_linklist(%struct.op* %trueop) #8
  br label %cond.end

cond.end:                                         ; preds = %if.end60, %cond.false70
  %cond = phi %struct.op* [ %call71, %cond.false70 ], [ %30, %if.end60 ]
  %op_other = getelementptr inbounds i8* %call61, i64 48
  %31 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond, %struct.op** %31, align 8, !tbaa !3
  %op_next72 = getelementptr inbounds %struct.op* %falseop, i64 0, i32 0
  %32 = load %struct.op** %op_next72, align 8, !tbaa !3
  %tobool73 = icmp eq %struct.op* %32, null
  br i1 %tobool73, label %cond.false76, label %cond.end78

cond.false76:                                     ; preds = %cond.end
  %call77 = call %struct.op* @Perl_linklist(%struct.op* %falseop) #8
  br label %cond.end78

cond.end78:                                       ; preds = %cond.end, %cond.false76
  %cond79 = phi %struct.op* [ %call77, %cond.false76 ], [ %32, %cond.end ]
  %op_next80 = bitcast i8* %call61 to %struct.op**
  store %struct.op* %cond79, %struct.op** %op_next80, align 8, !tbaa !3
  %33 = load i8** @PL_op_mask, align 8, !tbaa !3
  %tobool81 = icmp eq i8* %33, null
  br i1 %tobool81, label %cond.false86, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %cond.end78
  %arrayidx = getelementptr inbounds i8* %33, i64 162
  %34 = load i8* %arrayidx, align 1, !tbaa !1
  %tobool84 = icmp eq i8 %34, 0
  br i1 %tobool84, label %cond.false86, label %cond.true85

cond.true85:                                      ; preds = %land.lhs.true82
  %35 = bitcast i8* %call61 to %struct.op*
  call void @Perl_op_free(%struct.op* %35) #8
  %36 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_desc, i64 0, i64 162), align 8, !tbaa !3
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str33, i64 0, i64 0), i8* %36) #7
  br label %cond.end88

cond.false86:                                     ; preds = %land.lhs.true82, %cond.end78
  %37 = load %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*]* @PL_check, i64 0, i64 162), align 8, !tbaa !3
  %38 = bitcast i8* %call61 to %struct.op*
  %call87 = call %struct.op* %37(%struct.op* %38) #7
  br label %cond.end88

cond.end88:                                       ; preds = %cond.false86, %cond.true85
  %op_next90 = getelementptr inbounds %struct.op* %first, i64 0, i32 0
  %39 = load %struct.op** %op_next90, align 8, !tbaa !3
  %tobool91 = icmp eq %struct.op* %39, null
  br i1 %tobool91, label %cond.false94, label %cond.end96

cond.false94:                                     ; preds = %cond.end88
  %call95 = call %struct.op* @Perl_linklist(%struct.op* %first) #8
  br label %cond.end96

cond.end96:                                       ; preds = %cond.end88, %cond.false94
  %cond97 = phi %struct.op* [ %call95, %cond.false94 ], [ %39, %cond.end88 ]
  %40 = bitcast i8* %call61 to %struct.op*
  store %struct.op* %40, %struct.op** %op_next90, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %first, i64 0, i32 1
  store %struct.op* %trueop, %struct.op** %op_sibling, align 8, !tbaa !3
  %op_sibling99 = getelementptr inbounds %struct.op* %trueop, i64 0, i32 1
  store %struct.op* %falseop, %struct.op** %op_sibling99, align 8, !tbaa !3
  %call100 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %40) #8
  store %struct.op* %call100, %struct.op** %op_next72, align 8, !tbaa !3
  store %struct.op* %call100, %struct.op** %op_next, align 8, !tbaa !3
  %op_next103 = getelementptr inbounds %struct.op* %call100, i64 0, i32 0
  store %struct.op* %cond97, %struct.op** %op_next103, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %cond.end96, %if.else, %if.then59, %if.then2, %if.then
  %retval.0 = phi %struct.op* [ %trueop, %if.then59 ], [ %falseop, %if.else ], [ %call100, %cond.end96 ], [ %call.i153, %if.then2 ], [ %call.i, %if.then ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @S_scalarboolean(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 36
  br i1 %cmp, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_type2 = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %3 = load i16* %op_type2, align 2, !tbaa !4
  %cmp4 = icmp eq i16 %3, 5
  br i1 %cmp4, label %if.then, label %if.end33

if.then:                                          ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp6 = icmp eq %struct.sv* %5, null
  br i1 %cmp6, label %lor.lhs.false18, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %if.then
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings9 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings9, align 8, !tbaa !3
  %cmp10 = icmp eq %struct.sv* %7, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp10, label %lor.lhs.false18, label %land.lhs.true12

land.lhs.true12:                                  ; preds = %land.lhs.true8
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings13 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings13, align 8, !tbaa !3
  %cmp14 = icmp eq %struct.sv* %9, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp14, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true12
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings16 = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings16, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %11, i64 0, i32 0
  %12 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %12 to i8**
  %13 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %13, i64 7
  %14 = load i8* %arrayidx, align 1, !tbaa !1
  %and = and i8 %14, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false18, label %if.then26

lor.lhs.false18:                                  ; preds = %lor.lhs.false, %land.lhs.true8, %if.then
  %15 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings19 = getelementptr inbounds %struct.cop* %15, i64 0, i32 14
  %16 = load %struct.sv** %cop_warnings19, align 8, !tbaa !3
  %cmp20 = icmp eq %struct.sv* %16, null
  br i1 %cmp20, label %land.lhs.true22, label %if.end33

land.lhs.true22:                                  ; preds = %lor.lhs.false18
  %17 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and24 = and i8 %17, 1
  %tobool25 = icmp eq i8 %and24, 0
  br i1 %tobool25, label %if.end33, label %if.then26

if.then26:                                        ; preds = %lor.lhs.false, %land.lhs.true22, %land.lhs.true12
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %18, i64 0, i32 13
  %19 = load i32* %cop_line, align 4, !tbaa !0
  %20 = load i32* @PL_copline, align 4, !tbaa !0
  %cmp27 = icmp eq i32 %20, -1
  br i1 %cmp27, label %if.end, label %if.then29

if.then29:                                        ; preds = %if.then26
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line30 = getelementptr inbounds %struct.cop* %21, i64 0, i32 13
  store i32 %20, i32* %cop_line30, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then26, %if.then29
  tail call void (i32, i8*, ...)* @Perl_warner(i32 28, i8* getelementptr inbounds ([37 x i8]* @.str147, i64 0, i64 0)) #7
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line31 = getelementptr inbounds %struct.cop* %22, i64 0, i32 13
  store i32 %19, i32* %cop_line31, align 4, !tbaa !0
  br label %if.end33

if.end33:                                         ; preds = %land.lhs.true22, %lor.lhs.false18, %if.end, %land.lhs.true, %entry
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  ret void
}

; Function Attrs: optsize
declare signext i8 @Perl_sv_2bool(%struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newRANGE(i32 %flags, %struct.op* %left, %struct.op* %right) #0 {
entry:
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %op_type = getelementptr inbounds i8* %call, i64 32
  %0 = bitcast i8* %op_type to i16*
  store i16 156, i16* %0, align 2, !tbaa !4
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 156), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %2 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %1, %struct.op* ()** %2, align 8, !tbaa !3
  %op_first = getelementptr inbounds i8* %call, i64 40
  %3 = bitcast i8* %op_first to %struct.op**
  store %struct.op* %left, %struct.op** %3, align 8, !tbaa !3
  %4 = getelementptr inbounds i8* %call, i64 36
  store i8 4, i8* %4, align 1, !tbaa !1
  %op_next = getelementptr inbounds %struct.op* %left, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool = icmp eq %struct.op* %5, null
  br i1 %tobool, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = tail call %struct.op* @Perl_linklist(%struct.op* %left) #8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi %struct.op* [ %call2, %cond.false ], [ %5, %entry ]
  %op_next3 = getelementptr inbounds %struct.op* %right, i64 0, i32 0
  %6 = load %struct.op** %op_next3, align 8, !tbaa !3
  %tobool4 = icmp eq %struct.op* %6, null
  br i1 %tobool4, label %cond.false7, label %cond.end9

cond.false7:                                      ; preds = %cond.end
  %call8 = tail call %struct.op* @Perl_linklist(%struct.op* %right) #8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.end, %cond.false7
  %cond10 = phi %struct.op* [ %call8, %cond.false7 ], [ %6, %cond.end ]
  %op_other = getelementptr inbounds i8* %call, i64 48
  %7 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond10, %struct.op** %7, align 8, !tbaa !3
  %shr80 = lshr i32 %flags, 8
  %or = or i32 %shr80, 1
  %conv = trunc i32 %or to i8
  %8 = getelementptr inbounds i8* %call, i64 37
  store i8 %conv, i8* %8, align 1, !tbaa !1
  %op_sibling = getelementptr inbounds %struct.op* %left, i64 0, i32 1
  store %struct.op* %right, %struct.op** %op_sibling, align 8, !tbaa !3
  %9 = bitcast i8* %call to %struct.op*
  %op_next11 = bitcast i8* %call to %struct.op**
  store %struct.op* %9, %struct.op** %op_next11, align 8, !tbaa !3
  %call12 = tail call %struct.op* @Perl_newUNOP(i32 157, i32 %flags, %struct.op* %9) #8
  %call13 = tail call %struct.op* @Perl_newUNOP(i32 158, i32 0, %struct.op* %call12) #8
  %call14 = tail call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %call13) #8
  %call15 = tail call %struct.op* @Perl_linklist(%struct.op* %call13) #8
  store %struct.op* %cond, %struct.op** %op_next11, align 8, !tbaa !3
  store %struct.op* %call12, %struct.op** %op_next, align 8, !tbaa !3
  store %struct.op* %call13, %struct.op** %op_next3, align 8, !tbaa !3
  %call19 = tail call i64 @Perl_pad_alloc(i32 156, i32 1024) #7
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %10 = bitcast i8* %op_targ to i64*
  store i64 %call19, i64* %10, align 8, !tbaa !5
  %11 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds %struct.sv** %11, i64 %call19
  %12 = load %struct.sv** %arrayidx, align 8, !tbaa !3
  %call21 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %12, i32 6) #7
  %call22 = tail call i64 @Perl_pad_alloc(i32 156, i32 1024) #7
  %op_targ23 = getelementptr inbounds %struct.op* %call12, i64 0, i32 3
  store i64 %call22, i64* %op_targ23, align 8, !tbaa !5
  %13 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx25 = getelementptr inbounds %struct.sv** %13, i64 %call22
  %14 = load %struct.sv** %arrayidx25, align 8, !tbaa !3
  %call26 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %14, i32 6) #7
  %op_type27 = getelementptr inbounds %struct.op* %left, i64 0, i32 4
  %15 = load i16* %op_type27, align 2, !tbaa !4
  %cmp = icmp eq i16 %15, 5
  %conv31 = select i1 %cmp, i8 64, i8 0
  %op_private32 = getelementptr inbounds %struct.op* %call12, i64 0, i32 7
  store i8 %conv31, i8* %op_private32, align 1, !tbaa !1
  %op_type33 = getelementptr inbounds %struct.op* %right, i64 0, i32 4
  %16 = load i16* %op_type33, align 2, !tbaa !4
  %cmp35 = icmp eq i16 %16, 5
  %conv38 = select i1 %cmp35, i8 64, i8 0
  %op_private39 = getelementptr inbounds %struct.op* %call13, i64 0, i32 7
  store i8 %conv38, i8* %op_private39, align 1, !tbaa !1
  %op_next40 = getelementptr inbounds %struct.op* %call12, i64 0, i32 0
  store %struct.op* %call14, %struct.op** %op_next40, align 8, !tbaa !3
  %17 = load i8* %op_private32, align 1, !tbaa !1
  %tobool42 = icmp eq i8 %17, 0
  br i1 %tobool42, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end9
  %18 = load i8* %op_private39, align 1, !tbaa !1
  %tobool44 = icmp eq i8 %18, 0
  br i1 %tobool44, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end9
  %call45 = tail call %struct.op* @Perl_linklist(%struct.op* %call14) #8
  br label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  ret %struct.op* %call14
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newLOOPOP(i32 %flags, i32 %debuggable, %struct.op* %expr, %struct.op* %block) #0 {
entry:
  %expr.addr = alloca %struct.op*, align 8
  %listop = alloca %struct.op*, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8, !tbaa !3
  %tobool = icmp ne %struct.op* %block, null
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %block, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %tobool1 = icmp slt i8 %0, 0
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %op_type = getelementptr inbounds %struct.op* %block, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %1, 166
  %cmp6 = icmp eq i16 %1, 0
  %.cmp6 = or i1 %cmp, %cmp6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %2 = phi i1 [ false, %entry ], [ %.cmp6, %land.rhs ], [ false, %land.lhs.true ]
  %tobool8 = icmp eq %struct.op* %expr, null
  br i1 %tobool8, label %if.end139, label %if.then

if.then:                                          ; preds = %land.end
  %op_type11 = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  br i1 %2, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %if.then
  %3 = load i16* %op_type11, align 2, !tbaa !4
  %cmp13 = icmp eq i16 %3, 5
  br i1 %cmp13, label %land.lhs.true15, label %if.end

land.lhs.true15:                                  ; preds = %land.lhs.true10
  %op_sv = getelementptr inbounds %struct.op* %expr, i64 1
  %4 = bitcast %struct.op* %op_sv to %struct.sv**
  %5 = load %struct.sv** %4, align 8, !tbaa !3
  %tobool16 = icmp eq %struct.sv* %5, null
  br i1 %tobool16, label %return, label %cond.false

cond.false:                                       ; preds = %land.lhs.true15
  %sv_flags = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %6 = load i32* %sv_flags, align 4, !tbaa !0
  %and18 = and i32 %6, 262144
  %tobool19 = icmp eq i32 %and18, 0
  br i1 %tobool19, label %cond.false34, label %cond.true20

cond.true20:                                      ; preds = %cond.false
  %sv_any = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %7 = load i8** %sv_any, align 8, !tbaa !3
  %8 = bitcast i8* %7 to %struct.xpv*
  store %struct.xpv* %8, %struct.xpv** @PL_Xpv, align 8, !tbaa !3
  %tobool22 = icmp eq i8* %7, null
  br i1 %tobool22, label %return, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %cond.true20
  %xpv_cur = getelementptr inbounds i8* %7, i64 8
  %9 = bitcast i8* %xpv_cur to i64*
  %10 = load i64* %9, align 8, !tbaa !5
  %cmp24 = icmp ugt i64 %10, 1
  br i1 %cmp24, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %tobool27 = icmp eq i64 %10, 0
  br i1 %tobool27, label %return, label %land.lhs.true28

land.lhs.true28:                                  ; preds = %lor.lhs.false
  %xpv_pv = bitcast i8* %7 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !3
  %12 = load i8* %11, align 1, !tbaa !1
  %cmp30 = icmp eq i8 %12, 48
  br i1 %cmp30, label %return, label %if.end

cond.false34:                                     ; preds = %cond.false
  %and37 = and i32 %6, 65536
  %tobool38 = icmp eq i32 %and37, 0
  br i1 %tobool38, label %cond.false44, label %cond.true39

cond.true39:                                      ; preds = %cond.false34
  %sv_any41 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %13 = load i8** %sv_any41, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %13, i64 24
  %14 = bitcast i8* %xiv_iv to i64*
  %15 = load i64* %14, align 8, !tbaa !5
  %cmp42 = icmp eq i64 %15, 0
  br i1 %cmp42, label %return, label %if.end

cond.false44:                                     ; preds = %cond.false34
  %and47 = and i32 %6, 131072
  %tobool48 = icmp eq i32 %and47, 0
  br i1 %tobool48, label %cond.false54, label %cond.true49

cond.true49:                                      ; preds = %cond.false44
  %sv_any51 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %16 = load i8** %sv_any51, align 8, !tbaa !3
  %xnv_nv = getelementptr inbounds i8* %16, i64 32
  %17 = bitcast i8* %xnv_nv to double*
  %18 = load double* %17, align 8, !tbaa !6
  %cmp52 = fcmp une double %18, 0.000000e+00
  br i1 %cmp52, label %if.end, label %return

cond.false54:                                     ; preds = %cond.false44
  %call = call signext i8 @Perl_sv_2bool(%struct.sv* %5) #7
  %tobool57 = icmp eq i8 %call, 0
  br i1 %tobool57, label %return, label %if.end

if.end:                                           ; preds = %if.then, %cond.false54, %land.lhs.true28, %cond.true39, %land.lhs.true23, %cond.true49, %land.lhs.true10
  %19 = load i16* %op_type11, align 2, !tbaa !4
  switch i16 %19, label %if.else [
    i16 26, label %if.then76
    i16 25, label %if.then76
    i16 0, label %land.lhs.true73
  ]

land.lhs.true73:                                  ; preds = %if.end
  %op_targ = getelementptr inbounds %struct.op* %expr, i64 0, i32 3
  %20 = load i64* %op_targ, align 8, !tbaa !5
  %cmp74 = icmp eq i64 %20, 25
  br i1 %cmp74, label %if.then76, label %if.else

if.then76:                                        ; preds = %if.end, %if.end, %land.lhs.true73
  %21 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %22 = bitcast %struct.gv* %21 to %struct.sv*
  store %struct.sv* %22, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %21, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then76
  %23 = getelementptr inbounds %struct.gv* %21, i64 0, i32 1
  %24 = load i32* %23, align 4, !tbaa !0
  %inc.i = add i32 %24, 1
  store i32 %inc.i, i32* %23, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then76, %land.rhs.i
  %call.i205 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %22) #7
  %call1.i = call %struct.op* @Perl_newSVREF(%struct.op* %call.i205) #7
  %call78 = call %struct.op* @Perl_newASSIGNOP(i32 0, %struct.op* %call1.i, i32 0, %struct.op* %expr) #8
  %call79 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %call78) #8
  store %struct.op* %call79, %struct.op** %expr.addr, align 8, !tbaa !3
  br label %if.end139

if.else:                                          ; preds = %if.end, %land.lhs.true73
  %op_flags80 = getelementptr inbounds %struct.op* %expr, i64 0, i32 6
  %25 = load i8* %op_flags80, align 1, !tbaa !1
  %and82 = and i8 %25, 4
  %tobool83 = icmp eq i8 %and82, 0
  br i1 %tobool83, label %if.end139, label %if.then84

if.then84:                                        ; preds = %if.else
  %26 = getelementptr inbounds %struct.op* %expr, i64 1, i32 0
  %27 = load %struct.op** %26, align 8, !tbaa !3
  %tobool85 = icmp eq %struct.op* %27, null
  br i1 %tobool85, label %cond.end, label %cond.true86

cond.true86:                                      ; preds = %if.then84
  %op_sibling = getelementptr inbounds %struct.op* %27, i64 0, i32 1
  %28 = load %struct.op** %op_sibling, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %if.then84, %cond.true86
  %cond = phi %struct.op* [ %28, %cond.true86 ], [ null, %if.then84 ]
  %conv89 = zext i16 %19 to i32
  switch i32 %conv89, label %if.end139 [
    i32 0, label %sw.bb
    i32 36, label %sw.bb110
  ]

sw.bb:                                            ; preds = %cond.end
  %tobool90 = icmp eq %struct.op* %cond, null
  br i1 %tobool90, label %if.end139, label %land.lhs.true91

land.lhs.true91:                                  ; preds = %sw.bb
  %op_type92 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %29 = load i16* %op_type92, align 2, !tbaa !4
  %cmp94 = icmp eq i16 %29, 26
  br i1 %cmp94, label %land.lhs.true96, label %if.end139

land.lhs.true96:                                  ; preds = %land.lhs.true91
  %op_flags97 = getelementptr inbounds %struct.op* %cond, i64 0, i32 6
  %30 = load i8* %op_flags97, align 1, !tbaa !1
  %and99 = and i8 %30, 64
  %tobool100 = icmp eq i8 %and99, 0
  br i1 %tobool100, label %if.end139, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %land.lhs.true96
  %op_flags102 = getelementptr inbounds %struct.op* %27, i64 0, i32 6
  %31 = load i8* %op_flags102, align 1, !tbaa !1
  %and104 = and i8 %31, 3
  %cmp105 = icmp eq i8 %and104, 2
  br i1 %cmp105, label %if.then107, label %if.end139

if.then107:                                       ; preds = %land.lhs.true101
  %call108 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %expr) #8
  store %struct.op* %call108, %struct.op** %expr.addr, align 8, !tbaa !3
  br label %if.end139

sw.bb110:                                         ; preds = %cond.end
  %op_type111 = getelementptr inbounds %struct.op* %27, i64 0, i32 4
  %32 = load i16* %op_type111, align 2, !tbaa !4
  switch i16 %32, label %if.end139 [
    i16 276, label %if.then134
    i16 25, label %if.then134
    i16 0, label %land.lhs.true125
    i16 129, label %if.then134
  ]

land.lhs.true125:                                 ; preds = %sw.bb110
  %op_targ126 = getelementptr inbounds %struct.op* %27, i64 0, i32 3
  %33 = load i64* %op_targ126, align 8, !tbaa !5
  %cmp127 = icmp eq i64 %33, 25
  br i1 %cmp127, label %if.then134, label %if.end139

if.then134:                                       ; preds = %sw.bb110, %sw.bb110, %sw.bb110, %land.lhs.true125
  %call135 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %expr) #8
  store %struct.op* %call135, %struct.op** %expr.addr, align 8, !tbaa !3
  br label %if.end139

if.end139:                                        ; preds = %sw.bb110, %land.lhs.true125, %land.lhs.true96, %sw.bb, %if.else, %land.end, %Perl_newGVOP.exit, %cond.end, %if.then107, %land.lhs.true101, %land.lhs.true91, %if.then134
  br i1 %tobool, label %if.end143, label %if.then141

if.then141:                                       ; preds = %if.end139
  %call142 = call %struct.op* @Perl_newOP(i32 0, i32 0) #8
  br label %if.end143

if.end143:                                        ; preds = %if.then141, %if.end139
  %block.addr.0 = phi %struct.op* [ %block, %if.end139 ], [ %call142, %if.then141 ]
  %call144 = call %struct.op* @Perl_newOP(i32 176, i32 0) #8
  %call145 = call %struct.op* @Perl_append_elem(i32 173, %struct.op* %block.addr.0, %struct.op* %call144) #8
  store %struct.op* %call145, %struct.op** %listop, align 8, !tbaa !3
  %call146 = call fastcc %struct.op* @S_new_logop(i32 159, i32 0, %struct.op** %expr.addr, %struct.op** %listop) #8
  %34 = load %struct.op** %listop, align 8, !tbaa !3
  %tobool147 = icmp eq %struct.op* %34, null
  br i1 %tobool147, label %if.end157, label %if.then148

if.then148:                                       ; preds = %if.end143
  %op_next = getelementptr inbounds %struct.op* %call146, i64 0, i32 0
  %35 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool149 = icmp eq %struct.op* %35, null
  br i1 %tobool149, label %cond.false152, label %cond.end154

cond.false152:                                    ; preds = %if.then148
  %call153 = call %struct.op* @Perl_linklist(%struct.op* %call146) #8
  br label %cond.end154

cond.end154:                                      ; preds = %if.then148, %cond.false152
  %cond155 = phi %struct.op* [ %call153, %cond.false152 ], [ %35, %if.then148 ]
  %36 = getelementptr inbounds %struct.op* %34, i64 1, i32 1
  %37 = load %struct.op** %36, align 8, !tbaa !3
  %op_next156 = getelementptr inbounds %struct.op* %37, i64 0, i32 0
  store %struct.op* %cond155, %struct.op** %op_next156, align 8, !tbaa !3
  br label %if.end157

if.end157:                                        ; preds = %if.end143, %cond.end154
  %38 = phi %struct.op* [ null, %if.end143 ], [ %34, %cond.end154 ]
  %.not = xor i1 %2, true
  %cmp160 = icmp eq %struct.op* %call146, %38
  %or.cond = or i1 %cmp160, %.not
  br i1 %or.cond, label %if.end165, label %if.then162

if.then162:                                       ; preds = %if.end157
  %39 = getelementptr inbounds %struct.op* %call146, i64 1, i32 0
  %40 = load %struct.op** %39, align 8, !tbaa !3
  %41 = getelementptr inbounds %struct.op* %40, i64 1, i32 1
  %42 = load %struct.op** %41, align 8, !tbaa !3
  %op_next164 = getelementptr inbounds %struct.op* %call146, i64 0, i32 0
  store %struct.op* %42, %struct.op** %op_next164, align 8, !tbaa !3
  br label %if.end165

if.end165:                                        ; preds = %if.end157, %if.then162
  %cmp166 = icmp eq %struct.op* %call146, %38
  br i1 %cmp166, label %if.then168, label %if.end170

if.then168:                                       ; preds = %if.end165
  %call169 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %call146) #8
  br label %if.end170

if.end170:                                        ; preds = %if.then168, %if.end165
  %o.0 = phi %struct.op* [ %call169, %if.then168 ], [ %call146, %if.end165 ]
  %op_flags171 = getelementptr inbounds %struct.op* %o.0, i64 0, i32 6
  %43 = load i8* %op_flags171, align 1, !tbaa !1
  %conv172 = zext i8 %43 to i32
  %or = or i32 %conv172, %flags
  %conv173 = trunc i32 %or to i8
  store i8 %conv173, i8* %op_flags171, align 1, !tbaa !1
  %call174 = call %struct.op* @Perl_scope(%struct.op* %o.0) #8
  %op_flags175 = getelementptr inbounds %struct.op* %call174, i64 0, i32 6
  %44 = load i8* %op_flags175, align 1, !tbaa !1
  %or177 = or i8 %44, -128
  store i8 %or177, i8* %op_flags175, align 1, !tbaa !1
  br label %return

return:                                           ; preds = %cond.true49, %land.lhs.true15, %cond.false54, %cond.true39, %cond.true20, %lor.lhs.false, %land.lhs.true28, %if.end170
  %retval.0 = phi %struct.op* [ %call174, %if.end170 ], [ %block, %land.lhs.true28 ], [ %block, %lor.lhs.false ], [ %block, %cond.true20 ], [ %block, %cond.true39 ], [ %block, %cond.false54 ], [ %block, %land.lhs.true15 ], [ %block, %cond.true49 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newWHILEOP(i32 %flags, i32 %debuggable, %struct.loop* %loop, i32 %whileline, %struct.op* %expr, %struct.op* %block, %struct.op* %cont) #0 {
entry:
  %expr.addr = alloca %struct.op*, align 8
  %listop = alloca %struct.op*, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8, !tbaa !3
  %tobool = icmp eq %struct.op* %expr, null
  br i1 %tobool, label %if.end71, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %land.lhs.true17 [
    i16 26, label %if.then
    i16 25, label %if.then
    i16 0, label %land.lhs.true11
  ]

land.lhs.true11:                                  ; preds = %land.lhs.true
  %op_targ = getelementptr inbounds %struct.op* %expr, i64 0, i32 3
  %1 = load i64* %op_targ, align 8, !tbaa !5
  %cmp12 = icmp eq i64 %1, 25
  br i1 %cmp12, label %if.then, label %land.lhs.true17

if.then:                                          ; preds = %land.lhs.true, %land.lhs.true, %land.lhs.true11
  %2 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %3 = bitcast %struct.gv* %2 to %struct.sv*
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %2, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then
  %4 = getelementptr inbounds %struct.gv* %2, i64 0, i32 1
  %5 = load i32* %4, align 4, !tbaa !0
  %inc.i = add i32 %5, 1
  store i32 %inc.i, i32* %4, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then, %land.rhs.i
  %call.i262 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %3) #7
  %call1.i = call %struct.op* @Perl_newSVREF(%struct.op* %call.i262) #7
  %call14 = call %struct.op* @Perl_newASSIGNOP(i32 0, %struct.op* %call1.i, i32 0, %struct.op* %expr) #8
  %call15 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %call14) #8
  store %struct.op* %call15, %struct.op** %expr.addr, align 8, !tbaa !3
  br label %if.end71

land.lhs.true17:                                  ; preds = %land.lhs.true11, %land.lhs.true
  %op_flags = getelementptr inbounds %struct.op* %expr, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %6, 4
  %tobool19 = icmp eq i8 %and, 0
  br i1 %tobool19, label %if.end71, label %if.then20

if.then20:                                        ; preds = %land.lhs.true17
  %7 = getelementptr inbounds %struct.op* %expr, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !3
  %tobool21 = icmp eq %struct.op* %8, null
  br i1 %tobool21, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.then20
  %op_sibling = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %9 = load %struct.op** %op_sibling, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %if.then20, %cond.true
  %cond = phi %struct.op* [ %9, %cond.true ], [ null, %if.then20 ]
  %conv23 = zext i16 %0 to i32
  switch i32 %conv23, label %if.end71 [
    i32 0, label %sw.bb
    i32 36, label %sw.bb43
  ]

sw.bb:                                            ; preds = %cond.end
  %tobool24 = icmp eq %struct.op* %cond, null
  br i1 %tobool24, label %if.end71, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %sw.bb
  %op_type26 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %10 = load i16* %op_type26, align 2, !tbaa !4
  %cmp28 = icmp eq i16 %10, 26
  br i1 %cmp28, label %land.lhs.true30, label %if.end71

land.lhs.true30:                                  ; preds = %land.lhs.true25
  %op_flags31 = getelementptr inbounds %struct.op* %cond, i64 0, i32 6
  %11 = load i8* %op_flags31, align 1, !tbaa !1
  %and33 = and i8 %11, 64
  %tobool34 = icmp eq i8 %and33, 0
  br i1 %tobool34, label %if.end71, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %land.lhs.true30
  %op_flags36 = getelementptr inbounds %struct.op* %8, i64 0, i32 6
  %12 = load i8* %op_flags36, align 1, !tbaa !1
  %and38 = and i8 %12, 3
  %cmp39 = icmp eq i8 %and38, 2
  br i1 %cmp39, label %if.then41, label %if.end71

if.then41:                                        ; preds = %land.lhs.true35
  %call42 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %expr) #8
  store %struct.op* %call42, %struct.op** %expr.addr, align 8, !tbaa !3
  br label %if.end71

sw.bb43:                                          ; preds = %cond.end
  %op_type44 = getelementptr inbounds %struct.op* %8, i64 0, i32 4
  %13 = load i16* %op_type44, align 2, !tbaa !4
  switch i16 %13, label %if.end71 [
    i16 276, label %if.then67
    i16 25, label %if.then67
    i16 0, label %land.lhs.true58
    i16 129, label %if.then67
  ]

land.lhs.true58:                                  ; preds = %sw.bb43
  %op_targ59 = getelementptr inbounds %struct.op* %8, i64 0, i32 3
  %14 = load i64* %op_targ59, align 8, !tbaa !5
  %cmp60 = icmp eq i64 %14, 25
  br i1 %cmp60, label %if.then67, label %if.end71

if.then67:                                        ; preds = %sw.bb43, %sw.bb43, %sw.bb43, %land.lhs.true58
  %call68 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %expr) #8
  store %struct.op* %call68, %struct.op** %expr.addr, align 8, !tbaa !3
  br label %if.end71

if.end71:                                         ; preds = %sw.bb43, %land.lhs.true58, %entry, %land.lhs.true30, %sw.bb, %land.lhs.true17, %if.then67, %land.lhs.true25, %land.lhs.true35, %if.then41, %cond.end, %Perl_newGVOP.exit
  %15 = phi %struct.op* [ null, %entry ], [ %expr, %land.lhs.true30 ], [ %expr, %sw.bb ], [ %expr, %land.lhs.true17 ], [ %call68, %if.then67 ], [ %expr, %land.lhs.true25 ], [ %expr, %land.lhs.true35 ], [ %call42, %if.then41 ], [ %expr, %cond.end ], [ %call15, %Perl_newGVOP.exit ], [ %expr, %land.lhs.true58 ], [ %expr, %sw.bb43 ]
  %tobool72 = icmp eq %struct.op* %block, null
  br i1 %tobool72, label %if.end80, label %if.else75

if.else75:                                        ; preds = %if.end71
  %tobool76 = icmp eq %struct.op* %cont, null
  br i1 %tobool76, label %if.end90, label %if.end80.thread267

if.end80.thread267:                               ; preds = %if.else75
  %call78 = call %struct.op* @Perl_scope(%struct.op* %block) #8
  br label %if.then82

if.end80:                                         ; preds = %if.end71
  %call74 = call %struct.op* @Perl_newOP(i32 0, i32 0) #8
  %tobool81 = icmp eq %struct.op* %cont, null
  br i1 %tobool81, label %if.end90, label %if.then82

if.then82:                                        ; preds = %if.end80.thread267, %if.end80
  %block.addr.0269 = phi %struct.op* [ %call78, %if.end80.thread267 ], [ %call74, %if.end80 ]
  %op_next = getelementptr inbounds %struct.op* %cont, i64 0, i32 0
  %16 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool83 = icmp eq %struct.op* %16, null
  br i1 %tobool83, label %cond.false86, label %if.end90

cond.false86:                                     ; preds = %if.then82
  %call87 = call %struct.op* @Perl_linklist(%struct.op* %cont) #8
  br label %if.end90

if.end90:                                         ; preds = %if.else75, %cond.false86, %if.then82, %if.end80
  %block.addr.0266 = phi %struct.op* [ %call74, %if.end80 ], [ %block.addr.0269, %cond.false86 ], [ %block.addr.0269, %if.then82 ], [ %block, %if.else75 ]
  %next.0 = phi %struct.op* [ null, %if.end80 ], [ %call87, %cond.false86 ], [ %16, %if.then82 ], [ null, %if.else75 ]
  %tobool91 = icmp eq %struct.op* %15, null
  br i1 %tobool91, label %if.end98, label %if.then92

if.then92:                                        ; preds = %if.end90
  %call93 = call %struct.op* @Perl_newOP(i32 176, i32 0) #8
  %tobool94 = icmp eq %struct.op* %next.0, null
  %call93.next.0 = select i1 %tobool94, %struct.op* %call93, %struct.op* %next.0
  %call97 = call %struct.op* @Perl_append_elem(i32 173, %struct.op* %cont, %struct.op* %call93) #8
  br label %if.end98

if.end98:                                         ; preds = %if.end90, %if.then92
  %next.2 = phi %struct.op* [ %call93.next.0, %if.then92 ], [ %next.0, %if.end90 ]
  %cont.addr.0 = phi %struct.op* [ %call97, %if.then92 ], [ %cont, %if.end90 ]
  %17 = bitcast %struct.op* %block.addr.0266 to %struct.listop*
  %18 = bitcast %struct.op* %cont.addr.0 to %struct.listop*
  %call99 = call %struct.op* @Perl_append_list(i32 173, %struct.listop* %17, %struct.listop* %18) #8
  store %struct.op* %call99, %struct.op** %listop, align 8, !tbaa !3
  %op_next100 = getelementptr inbounds %struct.op* %call99, i64 0, i32 0
  %19 = load %struct.op** %op_next100, align 8, !tbaa !3
  %tobool101 = icmp eq %struct.op* %19, null
  br i1 %tobool101, label %cond.false104, label %cond.end106

cond.false104:                                    ; preds = %if.end98
  %call105 = call %struct.op* @Perl_linklist(%struct.op* %call99) #8
  br label %cond.end106

cond.end106:                                      ; preds = %if.end98, %cond.false104
  %cond107 = phi %struct.op* [ %call105, %cond.false104 ], [ %19, %if.end98 ]
  br i1 %tobool91, label %if.end187, label %if.then109

if.then109:                                       ; preds = %cond.end106
  store i32 %whileline, i32* @PL_copline, align 4, !tbaa !0
  %call110 = call %struct.op* @Perl_scalar(%struct.op* %call99) #8
  %call111 = call fastcc %struct.op* @S_new_logop(i32 159, i32 0, %struct.op** %expr.addr, %struct.op** %listop) #8
  %20 = load %struct.op** %expr.addr, align 8, !tbaa !3
  %cmp112 = icmp eq %struct.op* %call111, %20
  br i1 %cmp112, label %land.lhs.true114, label %if.end167

land.lhs.true114:                                 ; preds = %if.then109
  %op_type115 = getelementptr inbounds %struct.op* %call111, i64 0, i32 4
  %21 = load i16* %op_type115, align 2, !tbaa !4
  %cmp117 = icmp eq i16 %21, 5
  br i1 %cmp117, label %land.lhs.true119, label %if.end167

land.lhs.true119:                                 ; preds = %land.lhs.true114
  %op_sv = getelementptr inbounds %struct.op* %call111, i64 1
  %22 = bitcast %struct.op* %op_sv to %struct.sv**
  %23 = load %struct.sv** %22, align 8, !tbaa !3
  %tobool120 = icmp eq %struct.sv* %23, null
  br i1 %tobool120, label %if.then166, label %cond.false122

cond.false122:                                    ; preds = %land.lhs.true119
  %sv_flags = getelementptr inbounds %struct.sv* %23, i64 0, i32 2
  %24 = load i32* %sv_flags, align 4, !tbaa !0
  %and124 = and i32 %24, 262144
  %tobool125 = icmp eq i32 %and124, 0
  br i1 %tobool125, label %cond.false141, label %cond.true126

cond.true126:                                     ; preds = %cond.false122
  %sv_any = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %25 = load i8** %sv_any, align 8, !tbaa !3
  %26 = bitcast i8* %25 to %struct.xpv*
  store %struct.xpv* %26, %struct.xpv** @PL_Xpv, align 8, !tbaa !3
  %tobool128 = icmp eq i8* %25, null
  br i1 %tobool128, label %if.then166, label %land.lhs.true129

land.lhs.true129:                                 ; preds = %cond.true126
  %xpv_cur = getelementptr inbounds i8* %25, i64 8
  %27 = bitcast i8* %xpv_cur to i64*
  %28 = load i64* %27, align 8, !tbaa !5
  %cmp130 = icmp ugt i64 %28, 1
  br i1 %cmp130, label %if.end167, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %land.lhs.true129
  %tobool134 = icmp eq i64 %28, 0
  br i1 %tobool134, label %if.then166, label %land.lhs.true135

land.lhs.true135:                                 ; preds = %lor.lhs.false132
  %xpv_pv = bitcast i8* %25 to i8**
  %29 = load i8** %xpv_pv, align 8, !tbaa !3
  %30 = load i8* %29, align 1, !tbaa !1
  %cmp137 = icmp eq i8 %30, 48
  br i1 %cmp137, label %if.then166, label %if.end167

cond.false141:                                    ; preds = %cond.false122
  %and144 = and i32 %24, 65536
  %tobool145 = icmp eq i32 %and144, 0
  br i1 %tobool145, label %cond.false151, label %cond.true146

cond.true146:                                     ; preds = %cond.false141
  %sv_any148 = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %31 = load i8** %sv_any148, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %31, i64 24
  %32 = bitcast i8* %xiv_iv to i64*
  %33 = load i64* %32, align 8, !tbaa !5
  %cmp149 = icmp eq i64 %33, 0
  br i1 %cmp149, label %if.then166, label %if.end167

cond.false151:                                    ; preds = %cond.false141
  %and154 = and i32 %24, 131072
  %tobool155 = icmp eq i32 %and154, 0
  br i1 %tobool155, label %cond.false161, label %cond.true156

cond.true156:                                     ; preds = %cond.false151
  %sv_any158 = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %34 = load i8** %sv_any158, align 8, !tbaa !3
  %xnv_nv = getelementptr inbounds i8* %34, i64 32
  %35 = bitcast i8* %xnv_nv to double*
  %36 = load double* %35, align 8, !tbaa !6
  %cmp159 = fcmp une double %36, 0.000000e+00
  br i1 %cmp159, label %if.end167, label %if.then166

cond.false161:                                    ; preds = %cond.false151
  %call163 = call signext i8 @Perl_sv_2bool(%struct.sv* %23) #7
  %tobool165 = icmp eq i8 %call163, 0
  br i1 %tobool165, label %if.then166, label %if.end167

if.then166:                                       ; preds = %land.lhs.true135, %lor.lhs.false132, %cond.true126, %cond.true146, %cond.false161, %land.lhs.true119, %cond.true156
  call void @Perl_op_free(%struct.op* %call111) #8
  %37 = bitcast %struct.loop* %loop to %struct.op*
  call void @Perl_op_free(%struct.op* %37) #8
  br label %return

if.end167:                                        ; preds = %land.lhs.true135, %cond.true146, %cond.false161, %land.lhs.true129, %cond.true156, %land.lhs.true114, %if.then109
  %38 = load %struct.op** %listop, align 8, !tbaa !3
  %tobool168 = icmp eq %struct.op* %38, null
  br i1 %tobool168, label %if.end187, label %if.then169

if.then169:                                       ; preds = %if.end167
  %cmp170 = icmp eq %struct.op* %call111, %38
  br i1 %cmp170, label %cond.end182, label %cond.false173

cond.false173:                                    ; preds = %if.then169
  %op_next174 = getelementptr inbounds %struct.op* %call111, i64 0, i32 0
  %39 = load %struct.op** %op_next174, align 8, !tbaa !3
  %tobool175 = icmp eq %struct.op* %39, null
  br i1 %tobool175, label %cond.false178, label %cond.end182

cond.false178:                                    ; preds = %cond.false173
  %call179 = call %struct.op* @Perl_linklist(%struct.op* %call111) #8
  br label %cond.end182

cond.end182:                                      ; preds = %cond.false173, %if.then169, %cond.false178
  %cond183 = phi %struct.op* [ %call179, %cond.false178 ], [ %cond107, %if.then169 ], [ %39, %cond.false173 ]
  %40 = getelementptr inbounds %struct.op* %38, i64 1, i32 1
  %41 = load %struct.op** %40, align 8, !tbaa !3
  %op_next184 = getelementptr inbounds %struct.op* %41, i64 0, i32 0
  store %struct.op* %cond183, %struct.op** %op_next184, align 8, !tbaa !3
  br label %if.end187

if.end187:                                        ; preds = %cond.end106, %if.end167, %cond.end182
  %o.0 = phi %struct.op* [ %call111, %cond.end182 ], [ %call111, %if.end167 ], [ %call99, %cond.end106 ]
  %tobool188 = icmp eq %struct.loop* %loop, null
  br i1 %tobool188, label %if.then189, label %if.end193

if.then189:                                       ; preds = %if.end187
  %call190 = call i8* @Perl_safesysmalloc(i64 80) #7
  %42 = bitcast i8* %call190 to %struct.loop*
  call void @llvm.memset.p0i8.i64(i8* %call190, i8 0, i64 80, i32 1, i1 false)
  %op_type191 = getelementptr inbounds i8* %call190, i64 32
  %43 = bitcast i8* %op_type191 to i16*
  store i16 182, i16* %43, align 2, !tbaa !4
  %44 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 182), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call190, i64 16
  %45 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %44, %struct.op* ()** %45, align 8, !tbaa !3
  %46 = getelementptr inbounds i8* %call190, i64 37
  store i8 0, i8* %46, align 1, !tbaa !1
  %47 = bitcast i8* %call190 to %struct.op*
  %op_next192 = bitcast i8* %call190 to %struct.op**
  store %struct.op* %47, %struct.op** %op_next192, align 8, !tbaa !3
  br label %if.end193

if.end193:                                        ; preds = %if.end187, %if.then189
  %loop.addr.0 = phi %struct.loop* [ %loop, %if.end187 ], [ %42, %if.then189 ]
  %48 = bitcast %struct.loop* %loop.addr.0 to %struct.op*
  %call194 = call %struct.op* @Perl_newBINOP(i32 183, i32 0, %struct.op* %48, %struct.op* %o.0) #8
  %op_redoop = getelementptr inbounds %struct.loop* %loop.addr.0, i64 0, i32 10
  store %struct.op* %cond107, %struct.op** %op_redoop, align 8, !tbaa !3
  %op_lastop = getelementptr inbounds %struct.loop* %loop.addr.0, i64 0, i32 12
  store %struct.op* %call194, %struct.op** %op_lastop, align 8, !tbaa !3
  %op_private196 = getelementptr inbounds %struct.op* %call194, i64 0, i32 7
  %tobool199 = icmp eq %struct.op* %next.2, null
  %op_nextop202 = getelementptr inbounds %struct.loop* %loop.addr.0, i64 0, i32 11
  %call194.next.2 = select i1 %tobool199, %struct.op* %call194, %struct.op* %next.2
  store %struct.op* %call194.next.2, %struct.op** %op_nextop202, align 8, !tbaa !3
  %op_flags204 = getelementptr inbounds %struct.op* %call194, i64 0, i32 6
  %49 = load i8* %op_flags204, align 1, !tbaa !1
  %conv205 = zext i8 %49 to i32
  %or206 = or i32 %conv205, %flags
  %conv207 = trunc i32 %or206 to i8
  store i8 %conv207, i8* %op_flags204, align 1, !tbaa !1
  %shr261 = lshr i32 %flags, 8
  %50 = load i8* %op_private196, align 1, !tbaa !1
  %conv209 = zext i8 %50 to i32
  %or210 = or i32 %conv209, %shr261
  %conv211 = trunc i32 %or210 to i8
  store i8 %conv211, i8* %op_private196, align 1, !tbaa !1
  br label %return

return:                                           ; preds = %if.end193, %if.then166
  %retval.0 = phi %struct.op* [ %call194, %if.end193 ], [ null, %if.then166 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newFOROP(i32 %flags, i8* %label, i32 %forline, %struct.op* %sv, %struct.op* %expr, %struct.op* %block, %struct.op* %cont) #0 {
entry:
  %tobool = icmp eq %struct.op* %sv, null
  br i1 %tobool, label %if.else26, label %if.then

if.then:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %sv, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %if.else22 [
    i16 15, label %if.then2
    i16 9, label %if.then9
    i16 348, label %if.then19
  ]

if.then2:                                         ; preds = %if.then
  %op_private = getelementptr inbounds %struct.op* %sv, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %1, 16
  store i16 14, i16* %op_type, align 2, !tbaa !4
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 14), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %sv, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %if.end27

if.then9:                                         ; preds = %if.then
  %op_private10 = getelementptr inbounds %struct.op* %sv, i64 0, i32 7
  %3 = load i8* %op_private10, align 1, !tbaa !1
  %and12 = and i8 %3, -128
  %op_targ = getelementptr inbounds %struct.op* %sv, i64 0, i32 3
  %4 = load i64* %op_targ, align 8, !tbaa !5
  store i64 0, i64* %op_targ, align 8, !tbaa !5
  tail call void @Perl_op_free(%struct.op* %sv) #8
  br label %if.end27

if.then19:                                        ; preds = %if.then
  %op_targ20 = getelementptr inbounds %struct.op* %sv, i64 0, i32 3
  %5 = load i64* %op_targ20, align 8, !tbaa !5
  store i64 0, i64* %op_targ20, align 8, !tbaa !5
  tail call void @Perl_op_free(%struct.op* %sv) #8
  br label %if.end27

if.else22:                                        ; preds = %if.then
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %6 = load i8** %arrayidx, align 8, !tbaa !3
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([31 x i8]* @.str54, i64 0, i64 0), i8* %6) #7
  br label %if.end27

if.else26:                                        ; preds = %entry
  %7 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %8 = bitcast %struct.gv* %7 to %struct.sv*
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %7, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.else26
  %9 = getelementptr inbounds %struct.gv* %7, i64 0, i32 1
  %10 = load i32* %9, align 4, !tbaa !0
  %inc.i = add i32 %10, 1
  store i32 %inc.i, i32* %9, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.else26, %land.rhs.i
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %8) #7
  br label %if.end27

if.end27:                                         ; preds = %if.then2, %if.then19, %if.else22, %if.then9, %Perl_newGVOP.exit
  %iterpflags.0 = phi i8 [ %and, %if.then2 ], [ %and12, %if.then9 ], [ 0, %if.then19 ], [ 0, %if.else22 ], [ 0, %Perl_newGVOP.exit ]
  %iterflags.0 = phi i32 [ 0, %if.then2 ], [ 0, %if.then9 ], [ 128, %if.then19 ], [ 0, %if.else22 ], [ 0, %Perl_newGVOP.exit ]
  %padoff.0 = phi i64 [ 0, %if.then2 ], [ %4, %if.then9 ], [ %5, %if.then19 ], [ 0, %if.else22 ], [ 0, %Perl_newGVOP.exit ]
  %sv.addr.0 = phi %struct.op* [ %sv, %if.then2 ], [ null, %if.then9 ], [ null, %if.then19 ], [ %sv, %if.else22 ], [ %call.i, %Perl_newGVOP.exit ]
  %op_type28 = getelementptr inbounds %struct.op* %expr, i64 0, i32 4
  %11 = load i16* %op_type28, align 2, !tbaa !4
  switch i16 %11, label %if.else73 [
    i16 125, label %if.then36
    i16 10, label %if.then36
    i16 0, label %land.lhs.true
  ]

if.then36:                                        ; preds = %if.end27, %if.end27
  %call37 = tail call %struct.op* @Perl_ref(%struct.op* %expr, i32 181) #8
  %call38 = tail call %struct.op* @Perl_scalar(%struct.op* %call37) #8
  %call39 = tail call %struct.op* @Perl_force_list(%struct.op* %call38) #8
  %call40 = tail call %struct.op* @Perl_mod(%struct.op* %call39, i32 152) #8
  %or41 = or i32 %iterflags.0, 64
  br label %if.end77

land.lhs.true:                                    ; preds = %if.end27
  %op_flags = getelementptr inbounds %struct.op* %expr, i64 0, i32 6
  %12 = load i8* %op_flags, align 1, !tbaa !1
  %and48 = and i8 %12, 4
  %tobool49 = icmp eq i8 %and48, 0
  br i1 %tobool49, label %if.else73, label %land.lhs.true50

land.lhs.true50:                                  ; preds = %land.lhs.true
  %13 = getelementptr inbounds %struct.op* %expr, i64 1, i32 0
  %14 = load %struct.op** %13, align 8, !tbaa !3
  %op_type51 = getelementptr inbounds %struct.op* %14, i64 0, i32 4
  %15 = load i16* %op_type51, align 2, !tbaa !4
  %cmp53 = icmp eq i16 %15, 158
  br i1 %cmp53, label %if.then55, label %if.else73

if.then55:                                        ; preds = %land.lhs.true50
  %16 = getelementptr inbounds %struct.op* %14, i64 1, i32 0
  %17 = load %struct.op** %16, align 8, !tbaa !3
  %18 = getelementptr inbounds %struct.op* %17, i64 1, i32 0
  %19 = load %struct.op** %18, align 8, !tbaa !3
  %20 = getelementptr inbounds %struct.op* %19, i64 1, i32 0
  %21 = load %struct.op** %20, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %21, i64 0, i32 1
  %22 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %23 = getelementptr inbounds %struct.op* %19, i64 0, i32 6
  %24 = load i8* %23, align 1, !tbaa !1
  %and62 = and i8 %24, -5
  store i8 %and62, i8* %23, align 1, !tbaa !1
  store %struct.op* null, %struct.op** %20, align 8, !tbaa !3
  %call65 = tail call %struct.op* @Perl_newLISTOP(i32 141, i32 0, %struct.op* %21, %struct.op* %22) #8
  %op_next = getelementptr inbounds %struct.op* %19, i64 0, i32 0
  %25 = load %struct.op** %op_next, align 8, !tbaa !3
  %26 = getelementptr inbounds %struct.op* %call65, i64 1, i32 0
  %27 = load %struct.op** %26, align 8, !tbaa !3
  %op_next67 = getelementptr inbounds %struct.op* %27, i64 0, i32 0
  store %struct.op* %25, %struct.op** %op_next67, align 8, !tbaa !3
  %28 = getelementptr inbounds %struct.op* %19, i64 1, i32 1
  %29 = load %struct.op** %28, align 8, !tbaa !3
  %op_next68 = getelementptr inbounds %struct.op* %21, i64 0, i32 0
  store %struct.op* %29, %struct.op** %op_next68, align 8, !tbaa !3
  %op_next69 = getelementptr inbounds %struct.op* %22, i64 0, i32 0
  store %struct.op* %call65, %struct.op** %op_next69, align 8, !tbaa !3
  %30 = load %struct.op** %26, align 8, !tbaa !3
  %op_next71 = getelementptr inbounds %struct.op* %call65, i64 0, i32 0
  store %struct.op* %30, %struct.op** %op_next71, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %expr) #8
  tail call void @Perl_op_null(%struct.op* %call65) #8
  %or72 = or i32 %iterflags.0, 64
  br label %if.end77

if.else73:                                        ; preds = %if.end27, %land.lhs.true, %land.lhs.true50
  %call74 = tail call %struct.op* @Perl_force_list(%struct.op* %expr) #8
  %call75 = tail call %struct.op* @Perl_mod(%struct.op* %call74, i32 152) #8
  br label %if.end77

if.end77:                                         ; preds = %if.then55, %if.else73, %if.then36
  %iterflags.1 = phi i32 [ %or41, %if.then36 ], [ %or72, %if.then55 ], [ %iterflags.0, %if.else73 ]
  %expr.addr.0 = phi %struct.op* [ %call40, %if.then36 ], [ %call65, %if.then55 ], [ %call75, %if.else73 ]
  %call78 = tail call %struct.op* @Perl_scalar(%struct.op* %sv.addr.0) #8
  %call79 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %expr.addr.0, %struct.op* %call78) #8
  %call80 = tail call %struct.op* @Perl_convert(i32 180, i32 %iterflags.1, %struct.op* %call79) #8
  %call81 = tail call %struct.op* @Perl_list(%struct.op* %call80) #8
  %31 = getelementptr inbounds %struct.op* %call81, i64 0, i32 7
  store i8 %iterpflags.0, i8* %31, align 1, !tbaa !1
  %32 = bitcast %struct.op* %call81 to i8*
  %call84 = tail call i8* @Perl_safesysrealloc(i8* %32, i64 80) #7
  %33 = bitcast i8* %call84 to %struct.loop*
  %op_targ85 = getelementptr inbounds i8* %call84, i64 24
  %34 = bitcast i8* %op_targ85 to i64*
  store i64 %padoff.0, i64* %34, align 8, !tbaa !5
  %call86 = tail call %struct.op* @Perl_newOP(i32 181, i32 0) #8
  %call87 = tail call %struct.op* @Perl_newWHILEOP(i32 %flags, i32 undef, %struct.loop* %33, i32 %forline, %struct.op* %call86, %struct.op* %block, %struct.op* %cont) #8
  store i32 %forline, i32* @PL_copline, align 4, !tbaa !0
  %call88 = tail call %struct.op* @Perl_newSTATEOP(i32 0, i8* %label, %struct.op* %call87) #8
  ret %struct.op* %call88
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newLOOPEX(i32 %type, %struct.op* %label) #0 {
entry:
  %n_a = alloca i64, align 8
  %cmp = icmp eq i32 %type, 189
  %op_type = getelementptr inbounds %struct.op* %label, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  switch i16 %0, label %if.end37 [
    i16 5, label %cond.true
    i16 166, label %land.lhs.true29
  ]

if.then:                                          ; preds = %entry
  switch i16 %0, label %cond.end20 [
    i16 1, label %land.lhs.true
    i16 5, label %cond.true
  ]

land.lhs.true:                                    ; preds = %if.then
  %op_flags = getelementptr inbounds %struct.op* %label, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 8
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %cond.end20, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  %call = call %struct.op* @Perl_newOP(i32 %type, i32 128) #8
  br label %if.end

cond.true:                                        ; preds = %if.then, %lor.lhs.false
  %op_sv = getelementptr inbounds %struct.op* %label, i64 1
  %2 = bitcast %struct.op* %op_sv to %struct.sv**
  %3 = load %struct.sv** %2, align 8, !tbaa !3
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %3, i64 0, i32 2
  %4 = load i32* %sv_flags, align 4, !tbaa !0
  %and13 = and i32 %4, 262144
  %cmp14 = icmp eq i32 %and13, 0
  br i1 %cmp14, label %cond.false, label %cond.true16

cond.true16:                                      ; preds = %cond.true
  %sv_any = getelementptr inbounds %struct.sv* %3, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %5, i64 8
  %6 = bitcast i8* %xpv_cur to i64*
  %7 = load i64* %6, align 8, !tbaa !5
  store i64 %7, i64* %n_a, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %5 to i8**
  %8 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end20

cond.false:                                       ; preds = %cond.true
  %call18 = call i8* @Perl_sv_2pv_flags(%struct.sv* %3, i64* %n_a, i32 2) #7
  br label %cond.end20

cond.end20:                                       ; preds = %if.then, %land.lhs.true, %cond.true16, %cond.false
  %cond21 = phi i8* [ %8, %cond.true16 ], [ %call18, %cond.false ], [ getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), %land.lhs.true ], [ getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0), %if.then ]
  %call22 = call i8* @Perl_savepv(i8* %cond21) #7
  %call23 = call %struct.op* @Perl_newPVOP(i32 %type, i32 0, i8* %call22) #8
  br label %if.end

if.end:                                           ; preds = %cond.end20, %if.then8
  %o.0 = phi %struct.op* [ %call, %if.then8 ], [ %call23, %cond.end20 ]
  call void @Perl_op_free(%struct.op* %label) #8
  br label %if.end39

land.lhs.true29:                                  ; preds = %lor.lhs.false
  %op_flags30 = getelementptr inbounds %struct.op* %label, i64 0, i32 6
  %9 = load i8* %op_flags30, align 1, !tbaa !1
  %and32 = and i8 %9, 64
  %tobool33 = icmp eq i8 %and32, 0
  br i1 %tobool33, label %if.then34, label %if.end37

if.then34:                                        ; preds = %land.lhs.true29
  %call35 = call %struct.op* @Perl_mod(%struct.op* %label, i32 20) #8
  %call36 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call35) #8
  br label %if.end37

if.end37:                                         ; preds = %lor.lhs.false, %land.lhs.true29, %if.then34
  %label.addr.0 = phi %struct.op* [ %label, %land.lhs.true29 ], [ %call36, %if.then34 ], [ %label, %lor.lhs.false ]
  %call38 = call %struct.op* @Perl_newUNOP(i32 189, i32 64, %struct.op* %label.addr.0) #8
  br label %if.end39

if.end39:                                         ; preds = %if.end37, %if.end
  %o.1 = phi %struct.op* [ %o.0, %if.end ], [ %call38, %if.end37 ]
  %10 = load i32* @PL_hints, align 4, !tbaa !0
  %or = or i32 %10, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  ret %struct.op* %o.1
}

; Function Attrs: optsize
declare i8* @Perl_savepv(i8*) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_cv_undef(%struct.cv* %cv) #0 {
entry:
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %0 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 10
  %1 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !3
  %tobool = icmp eq void (%struct.cv*)* %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %xcv_root = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 9
  %2 = load %struct.op** %xcv_root, align 8, !tbaa !3
  %tobool2 = icmp eq %struct.op* %2, null
  br i1 %tobool2, label %if.end15, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %xcv_depth = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 14
  %3 = load i64* %xcv_depth, align 8, !tbaa !5
  %tobool4 = icmp eq i64 %3, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([30 x i8]* @.str55, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then5
  tail call void @Perl_push_scope() #7
  %4 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %add = add nsw i32 %4, 2
  %5 = load i32* @PL_savestack_max, align 4, !tbaa !0
  %cmp = icmp sgt i32 %add, %5
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  tail call void @Perl_savestack_grow() #7
  %.pre = load i32* @PL_savestack_ix, align 4, !tbaa !0
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %6 = phi i32 [ %.pre, %if.then6 ], [ %4, %if.end ]
  %7 = load %struct.av** @PL_comppad, align 8, !tbaa !3
  %8 = bitcast %struct.av* %7 to i8*
  %inc = add nsw i32 %6, 1
  %idxprom = sext i32 %6 to i64
  %9 = load %union.any** @PL_savestack, align 8, !tbaa !3
  %any_ptr = getelementptr inbounds %union.any* %9, i64 %idxprom, i32 0
  store i8* %8, i8** %any_ptr, align 8, !tbaa !3
  %inc8 = add nsw i32 %6, 2
  store i32 %inc8, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom9 = sext i32 %inc to i64
  %10 = load %union.any** @PL_savestack, align 8, !tbaa !3
  %arrayidx10 = getelementptr inbounds %union.any* %10, i64 %idxprom9
  %any_i32 = bitcast %union.any* %arrayidx10 to i32*
  store i32 33, i32* %any_i32, align 4, !tbaa !0
  store %struct.av* null, %struct.av** @PL_comppad, align 8, !tbaa !3
  store %struct.sv** null, %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %11 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_root12 = getelementptr inbounds %struct.xpvcv* %11, i64 0, i32 9
  %12 = load %struct.op** %xcv_root12, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %12) #8
  %13 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_root14 = getelementptr inbounds %struct.xpvcv* %13, i64 0, i32 9
  store %struct.op* null, %struct.op** %xcv_root14, align 8, !tbaa !3
  tail call void @Perl_pop_scope() #7
  %.pre76 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  br label %if.end15

if.end15:                                         ; preds = %land.lhs.true, %entry, %if.end7
  %14 = phi %struct.xpvcv* [ %0, %land.lhs.true ], [ %0, %entry ], [ %.pre76, %if.end7 ]
  %15 = getelementptr inbounds %struct.cv* %cv, i64 0, i32 2
  %16 = load i32* %15, align 4, !tbaa !0
  %and = and i32 %16, -67371009
  store i32 %and, i32* %15, align 4, !tbaa !0
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %14, i64 0, i32 12
  store %struct.gv* null, %struct.gv** %xcv_gv, align 8, !tbaa !3
  tail call void @Perl_pad_undef(%struct.cv* %cv) #7
  %sv_refcnt = getelementptr inbounds %struct.cv* %cv, i64 0, i32 1
  %17 = load i32* %sv_refcnt, align 4, !tbaa !0
  %tobool17 = icmp eq i32 %17, 0
  br i1 %tobool17, label %land.lhs.true18, label %if.end31

land.lhs.true18:                                  ; preds = %if.end15
  %18 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_outside = getelementptr inbounds %struct.xpvcv* %18, i64 0, i32 16
  %19 = load %struct.cv** %xcv_outside, align 8, !tbaa !3
  %tobool20 = icmp eq %struct.cv* %19, null
  br i1 %tobool20, label %if.end31, label %if.then21

if.then21:                                        ; preds = %land.lhs.true18
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %18, i64 0, i32 17
  %20 = load i16* %xcv_flags, align 2, !tbaa !4
  %and23 = and i16 %20, 1024
  %tobool24 = icmp eq i16 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.then21
  %21 = bitcast %struct.cv* %19 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %21) #7
  %.pre77 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  br label %if.end28

if.end28:                                         ; preds = %if.then21, %if.then25
  %22 = phi %struct.xpvcv* [ %18, %if.then21 ], [ %.pre77, %if.then25 ]
  %xcv_outside30 = getelementptr inbounds %struct.xpvcv* %22, i64 0, i32 16
  store %struct.cv* null, %struct.cv** %xcv_outside30, align 8, !tbaa !3
  br label %if.end31

if.end31:                                         ; preds = %if.end15, %land.lhs.true18, %if.end28
  %23 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_flags33 = getelementptr inbounds %struct.xpvcv* %23, i64 0, i32 17
  %24 = load i16* %xcv_flags33, align 2, !tbaa !4
  %and35 = and i16 %24, 512
  %tobool36 = icmp eq i16 %and35, 0
  br i1 %tobool36, label %if.end45, label %if.then37

if.then37:                                        ; preds = %if.end31
  %any_ptr39 = getelementptr inbounds %struct.xpvcv* %23, i64 0, i32 11, i32 0
  %25 = load i8** %any_ptr39, align 8, !tbaa !3
  %26 = bitcast i8* %25 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %26) #7
  %27 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_flags41 = getelementptr inbounds %struct.xpvcv* %27, i64 0, i32 17
  %28 = load i16* %xcv_flags41, align 2, !tbaa !4
  %and43 = and i16 %28, -513
  store i16 %and43, i16* %xcv_flags41, align 2, !tbaa !4
  br label %if.end45

if.end45:                                         ; preds = %if.end31, %if.then37
  %29 = phi %struct.xpvcv* [ %23, %if.end31 ], [ %27, %if.then37 ]
  %xcv_xsub47 = getelementptr inbounds %struct.xpvcv* %29, i64 0, i32 10
  %30 = load void (%struct.cv*)** %xcv_xsub47, align 8, !tbaa !3
  %tobool48 = icmp eq void (%struct.cv*)* %30, null
  br i1 %tobool48, label %if.end52, label %if.then49

if.then49:                                        ; preds = %if.end45
  store void (%struct.cv*)* null, void (%struct.cv*)** %xcv_xsub47, align 8, !tbaa !3
  %.pre78 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  br label %if.end52

if.end52:                                         ; preds = %if.end45, %if.then49
  %31 = phi %struct.xpvcv* [ %29, %if.end45 ], [ %.pre78, %if.then49 ]
  %xcv_flags54 = getelementptr inbounds %struct.xpvcv* %31, i64 0, i32 17
  %32 = load i16* %xcv_flags54, align 2, !tbaa !4
  %and56 = and i16 %32, 1024
  store i16 %and56, i16* %xcv_flags54, align 2, !tbaa !4
  ret void
}

; Function Attrs: optsize
declare void @Perl_push_scope() #2

; Function Attrs: optsize
declare void @Perl_pop_scope() #2

; Function Attrs: optsize
declare void @Perl_pad_undef(%struct.cv*) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_cv_ckproto(%struct.cv* %cv, %struct.gv* %gv, i8* %p) #0 {
entry:
  %tobool = icmp ne i8* %p, null
  %sv_flags = getelementptr inbounds %struct.cv* %cv, i64 0, i32 2
  %0 = load i32* %sv_flags, align 4, !tbaa !0
  %1 = and i32 %0, 262144
  %2 = icmp ne i32 %1, 0
  %cmp = xor i1 %tobool, %2
  br i1 %cmp, label %land.lhs.true6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  br i1 %tobool, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %lor.lhs.false
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %3 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xpv_pv = getelementptr inbounds %struct.xpvcv* %3, i64 0, i32 0
  %4 = load i8** %xpv_pv, align 8, !tbaa !3
  %call = tail call i32 @strcmp(i8* %p, i8* %4) #7
  %tobool5 = icmp eq i32 %call, 0
  br i1 %tobool5, label %if.end36, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true, %entry
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp7 = icmp eq %struct.sv* %6, null
  br i1 %cmp7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %land.lhs.true6
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings9 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings9, align 8, !tbaa !3
  %cmp10 = icmp eq %struct.sv* %8, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp10, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %9 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings12 = getelementptr inbounds %struct.cop* %9, i64 0, i32 14
  %10 = load %struct.sv** %cop_warnings12, align 8, !tbaa !3
  %cmp13 = icmp eq %struct.sv* %10, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp13, label %if.end36, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %lor.lhs.false11
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings15 = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings15, align 8, !tbaa !3
  %sv_any16 = getelementptr inbounds %struct.sv* %12, i64 0, i32 0
  %13 = load i8** %sv_any16, align 8, !tbaa !3
  %xpv_pv17 = bitcast i8* %13 to i8**
  %14 = load i8** %xpv_pv17, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %14, i64 8
  %15 = load i8* %arrayidx, align 1, !tbaa !1
  %and18 = and i8 %15, 64
  %tobool19 = icmp eq i8 %and18, 0
  br i1 %tobool19, label %if.end36, label %if.then

if.then:                                          ; preds = %land.lhs.true14, %lor.lhs.false8, %land.lhs.true6
  %call20 = tail call %struct.sv* @Perl_sv_newmortal() #7
  %tobool21 = icmp eq %struct.gv* %gv, null
  br i1 %tobool21, label %if.end.thread, label %if.end

if.end.thread:                                    ; preds = %if.then
  tail call void @Perl_sv_setpv(%struct.sv* %call20, i8* getelementptr inbounds ([20 x i8]* @.str56, i64 0, i64 0)) #7
  br label %if.end26

if.end:                                           ; preds = %if.then
  %call23 = tail call %struct.sv* @Perl_sv_newmortal() #7
  tail call void @Perl_gv_efullname4(%struct.sv* %call23, %struct.gv* %gv, i8* null, i8 signext 1) #7
  tail call void @Perl_sv_setpv(%struct.sv* %call20, i8* getelementptr inbounds ([20 x i8]* @.str56, i64 0, i64 0)) #7
  %tobool24 = icmp eq %struct.sv* %call23, null
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end
  tail call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call20, i8* getelementptr inbounds ([8 x i8]* @.str57, i64 0, i64 0), %struct.sv* %call23) #7
  br label %if.end26

if.end26:                                         ; preds = %if.end.thread, %if.end, %if.then25
  %16 = load i32* %sv_flags, align 4, !tbaa !0
  %and28 = and i32 %16, 262144
  %tobool29 = icmp eq i32 %and28, 0
  br i1 %tobool29, label %if.else, label %if.then30

if.then30:                                        ; preds = %if.end26
  tail call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call20, i8* getelementptr inbounds ([6 x i8]* @.str58, i64 0, i64 0), %struct.cv* %cv) #7
  br label %if.end31

if.else:                                          ; preds = %if.end26
  tail call void @Perl_sv_catpv(%struct.sv* %call20, i8* getelementptr inbounds ([7 x i8]* @.str59, i64 0, i64 0)) #7
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.then30
  tail call void @Perl_sv_catpv(%struct.sv* %call20, i8* getelementptr inbounds ([5 x i8]* @.str60, i64 0, i64 0)) #7
  br i1 %tobool, label %if.then33, label %if.else34

if.then33:                                        ; preds = %if.end31
  tail call void (%struct.sv*, i8*, ...)* @Perl_sv_catpvf(%struct.sv* %call20, i8* getelementptr inbounds ([5 x i8]* @.str61, i64 0, i64 0), i8* %p) #7
  br label %if.end35

if.else34:                                        ; preds = %if.end31
  tail call void @Perl_sv_catpv(%struct.sv* %call20, i8* getelementptr inbounds ([5 x i8]* @.str62, i64 0, i64 0)) #7
  br label %if.end35

if.end35:                                         ; preds = %if.else34, %if.then33
  tail call void (i32, i8*, ...)* @Perl_warner(i32 35, i8* getelementptr inbounds ([3 x i8]* @.str63, i64 0, i64 0), %struct.sv* %call20) #7
  br label %if.end36

if.end36:                                         ; preds = %land.lhs.true14, %lor.lhs.false11, %land.lhs.true, %if.end35, %lor.lhs.false
  ret void
}

; Function Attrs: optsize
declare %struct.sv* @Perl_sv_newmortal() #2

; Function Attrs: optsize
declare void @Perl_gv_efullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #2

; Function Attrs: optsize
declare void @Perl_sv_catpv(%struct.sv*, i8*) #2

; Function Attrs: nounwind optsize readonly uwtable
define %struct.sv* @Perl_cv_const_sv(%struct.cv* %cv) #5 {
entry:
  %tobool = icmp eq %struct.cv* %cv, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %0 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 17
  %1 = load i16* %xcv_flags, align 2, !tbaa !4
  %and = and i16 %1, 512
  %tobool1 = icmp eq i16 %and, 0
  br i1 %tobool1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %any_ptr = getelementptr inbounds %struct.xpvcv* %0, i64 0, i32 11, i32 0
  %2 = load i8** %any_ptr, align 8, !tbaa !3
  %3 = bitcast i8* %2 to %struct.sv*
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi %struct.sv* [ %3, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.sv* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.sv* @Perl_op_const_sv(%struct.op* %o, %struct.cv* %cv) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 173
  br i1 %cmp, label %land.lhs.true, label %for.body.lr.ph

land.lhs.true:                                    ; preds = %if.end
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %tobool2 = icmp eq %struct.op* %2, null
  br i1 %tobool2, label %for.cond.preheader, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !3
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then3, %land.lhs.true
  %o.addr.0.ph = phi %struct.op* [ %o, %land.lhs.true ], [ %3, %if.then3 ]
  %tobool6133 = icmp eq %struct.op* %o.addr.0.ph, null
  br i1 %tobool6133, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %if.end, %for.cond.preheader
  %o.addr.0.ph142 = phi %struct.op* [ %o.addr.0.ph, %for.cond.preheader ], [ %o, %if.end ]
  %tobool63 = icmp eq %struct.cv* %cv, null
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %sv.0135 = phi %struct.sv* [ null, %for.body.lr.ph ], [ %sv.2, %for.inc ]
  %o.addr.0134 = phi %struct.op* [ %o.addr.0.ph142, %for.body.lr.ph ], [ %22, %for.inc ]
  %op_type7 = getelementptr inbounds %struct.op* %o.addr.0134, i64 0, i32 4
  %4 = load i16* %op_type7, align 2, !tbaa !4
  %tobool8 = icmp ne %struct.sv* %sv.0135, null
  %op_next = getelementptr inbounds %struct.op* %o.addr.0134, i64 0, i32 0
  %5 = load %struct.op** %op_next, align 8, !tbaa !3
  %cmp10 = icmp eq %struct.op* %5, %o.addr.0134
  %or.cond144 = and i1 %tobool8, %cmp10
  br i1 %or.cond144, label %return, label %if.end13

if.end13:                                         ; preds = %for.body
  %op_next14 = getelementptr inbounds %struct.op* %o.addr.0134, i64 0, i32 0
  %cmp15 = icmp eq %struct.op* %5, %o.addr.0134
  br i1 %cmp15, label %if.end35, label %if.then17

if.then17:                                        ; preds = %if.end13
  switch i16 %4, label %if.end44 [
    i16 174, label %for.inc
    i16 0, label %for.inc
    i16 3, label %for.inc
    i16 175, label %for.inc
    i16 167, label %for.end
    i16 184, label %for.end
  ]

if.end35:                                         ; preds = %if.end13
  switch i16 %4, label %if.end44 [
    i16 167, label %for.end
    i16 184, label %for.end
  ]

if.end44:                                         ; preds = %if.then17, %if.end35
  br i1 %tobool8, label %return, label %if.end47

if.end47:                                         ; preds = %if.end44
  %cmp49 = icmp eq i16 %4, 5
  br i1 %cmp49, label %land.lhs.true51, label %if.else

land.lhs.true51:                                  ; preds = %if.end47
  %op_sv = getelementptr inbounds %struct.op* %o.addr.0134, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !3
  %tobool52 = icmp eq %struct.sv* %7, null
  br i1 %tobool52, label %if.else, label %for.inc

if.else:                                          ; preds = %land.lhs.true51, %if.end47
  %cmp56 = icmp eq i16 %4, 9
  %brmerge = or i1 %cmp56, %cmp49
  %brmerge.not = xor i1 %brmerge, true
  %or.cond = or i1 %tobool63, %brmerge.not
  br i1 %or.cond, label %return, label %if.then64

if.then64:                                        ; preds = %if.else
  %8 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_padlist = getelementptr inbounds %struct.xpvcv* %8, i64 0, i32 15
  %9 = load %struct.av** %xcv_padlist, align 8, !tbaa !3
  %sv_any65 = getelementptr inbounds %struct.av* %9, i64 0, i32 0
  %10 = load %struct.xpvav** %sv_any65, align 8, !tbaa !3
  %xav_array = getelementptr inbounds %struct.xpvav* %10, i64 0, i32 0
  %11 = load i8** %xav_array, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %11, i64 8
  %12 = bitcast i8* %arrayidx to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !3
  %tobool66 = icmp eq %struct.sv* %13, null
  br i1 %tobool66, label %return, label %cond.end

cond.end:                                         ; preds = %if.then64
  %op_targ = getelementptr inbounds %struct.op* %o.addr.0134, i64 0, i32 3
  %14 = load i64* %op_targ, align 8, !tbaa !5
  %sv_any72 = bitcast %struct.sv* %13 to %struct.xpvav**
  %15 = load %struct.xpvav** %sv_any72, align 8, !tbaa !3
  %xav_array73 = getelementptr inbounds %struct.xpvav* %15, i64 0, i32 0
  %16 = load i8** %xav_array73, align 8, !tbaa !3
  %17 = bitcast i8* %16 to %struct.sv**
  %arrayidx74 = getelementptr inbounds %struct.sv** %17, i64 %14
  %18 = load %struct.sv** %arrayidx74, align 8, !tbaa !3
  %tobool75 = icmp eq %struct.sv* %18, null
  br i1 %tobool75, label %return, label %if.end77

if.end77:                                         ; preds = %cond.end
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %8, i64 0, i32 17
  %19 = load i16* %xcv_flags, align 2, !tbaa !4
  %and = and i16 %19, 512
  %tobool80 = icmp eq i16 %and, 0
  br i1 %tobool80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %if.end77
  %call = tail call %struct.sv* @Perl_newSVsv(%struct.sv* %18) #7
  br label %if.end82

if.end82:                                         ; preds = %if.end77, %if.then81
  %sv.1 = phi %struct.sv* [ %call, %if.then81 ], [ %18, %if.end77 ]
  %sv_flags = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 2
  %20 = load i32* %sv_flags, align 4, !tbaa !0
  %and83 = and i32 %20, 8388608
  %tobool84 = icmp eq i32 %and83, 0
  br i1 %tobool84, label %land.lhs.true85, label %for.inc

land.lhs.true85:                                  ; preds = %if.end82
  %sv_refcnt = getelementptr inbounds %struct.sv* %sv.1, i64 0, i32 1
  %21 = load i32* %sv_refcnt, align 4, !tbaa !0
  %cmp86 = icmp ugt i32 %21, 1
  br i1 %cmp86, label %return, label %for.inc

for.inc:                                          ; preds = %land.lhs.true85, %if.end82, %land.lhs.true51, %if.then17, %if.then17, %if.then17, %if.then17
  %sv.2 = phi %struct.sv* [ %sv.0135, %if.then17 ], [ %sv.0135, %if.then17 ], [ %sv.0135, %if.then17 ], [ %sv.0135, %if.then17 ], [ %7, %land.lhs.true51 ], [ %sv.1, %if.end82 ], [ %sv.1, %land.lhs.true85 ]
  %22 = load %struct.op** %op_next14, align 8, !tbaa !3
  %tobool6 = icmp eq %struct.op* %22, null
  br i1 %tobool6, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %if.then17, %if.then17, %if.end35, %if.end35
  %sv.0.lcssa = phi %struct.sv* [ %sv.0135, %if.end35 ], [ %sv.0135, %if.end35 ], [ %sv.0135, %if.then17 ], [ %sv.0135, %if.then17 ], [ %sv.2, %for.inc ]
  %tobool94 = icmp eq %struct.sv* %sv.0.lcssa, null
  br i1 %tobool94, label %return, label %if.then95

if.then95:                                        ; preds = %for.end
  %sv_flags96 = getelementptr inbounds %struct.sv* %sv.0.lcssa, i64 0, i32 2
  %23 = load i32* %sv_flags96, align 4, !tbaa !0
  %or = or i32 %23, 8388608
  store i32 %or, i32* %sv_flags96, align 4, !tbaa !0
  br label %return

return:                                           ; preds = %for.body, %for.cond.preheader, %if.then64, %if.else, %land.lhs.true85, %cond.end, %if.end44, %if.then95, %for.end, %entry
  %retval.0 = phi %struct.sv* [ null, %entry ], [ null, %for.end ], [ %sv.0.lcssa, %if.then95 ], [ null, %if.then64 ], [ null, %if.else ], [ null, %land.lhs.true85 ], [ null, %cond.end ], [ null, %if.end44 ], [ null, %for.cond.preheader ], [ %sv.0135, %for.body ]
  ret %struct.sv* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define void @Perl_newMYSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @Perl_save_freeop(%struct.op* %o) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %tobool1 = icmp eq %struct.op* %proto, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  tail call void @Perl_save_freeop(%struct.op* %proto) #7
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then2
  %tobool4 = icmp eq %struct.op* %attrs, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end3
  tail call void @Perl_save_freeop(%struct.op* %attrs) #7
  br label %if.end6

if.end6:                                          ; preds = %if.end3, %if.then5
  %tobool7 = icmp eq %struct.op* %block, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  tail call void @Perl_save_freeop(%struct.op* %block) #7
  br label %if.end9

if.end9:                                          ; preds = %if.end6, %if.then8
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str64, i64 0, i64 0)) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.cv* @Perl_newSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %block) #0 {
entry:
  %call = tail call %struct.cv* @Perl_newATTRSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* null, %struct.op* %block) #8
  ret %struct.cv* %call
}

; Function Attrs: optsize
declare void @Perl_sv_setpvf(%struct.sv*, i8*, ...) #2

; Function Attrs: optsize
declare i32 @Perl_sv_cmp(%struct.sv*, %struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define internal void @const_sv_xsub(%struct.cv* nocapture %cv) #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  %1 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !3
  %2 = load i32** @PL_markstack_ptr, align 8, !tbaa !3
  %incdec.ptr = getelementptr inbounds i32* %2, i64 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8, !tbaa !3
  %3 = load i32* %2, align 4, !tbaa !0
  %idx.ext25 = zext i32 %3 to i64
  %add.ptr.idx = shl nuw i64 %idx.ext25, 32
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %0 to i64
  %4 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !3
  %sub.ptr.lhs.cast7 = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.lhs.cast1
  %cmp11 = icmp slt i64 %sub.ptr.sub9, 8
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %entry
  %call = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %0, i32 1) #7
  %.pre = load %struct.sv*** @PL_stack_base, align 8, !tbaa !3
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %entry
  %5 = phi %struct.sv** [ %.pre, %if.then13 ], [ %1, %entry ]
  %sv_any = getelementptr inbounds %struct.cv* %cv, i64 0, i32 0
  %6 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %any_ptr = getelementptr inbounds %struct.xpvcv* %6, i64 0, i32 11, i32 0
  %7 = load i8** %any_ptr, align 8, !tbaa !3
  %8 = bitcast i8* %7 to %struct.sv*
  %sext = add i64 %add.ptr.idx, 4294967296
  %idxprom = ashr exact i64 %sext, 32
  %arrayidx = getelementptr inbounds %struct.sv** %5, i64 %idxprom
  store %struct.sv* %8, %struct.sv** %arrayidx, align 8, !tbaa !3
  %9 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !3
  %add.ptr17 = getelementptr inbounds %struct.sv** %9, i64 %idxprom
  store %struct.sv** %add.ptr17, %struct.sv*** @PL_stack_sp, align 8, !tbaa !3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.cv* @Perl_newCONSTSUB(%struct.hv* %stash, i8* %name, %struct.sv* %sv) #0 {
entry:
  tail call void @Perl_push_scope() #7
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %0, i64 0, i32 13
  tail call void @Perl_save_I32(i32* %cop_line) #7
  %1 = load i32* @PL_copline, align 4, !tbaa !0
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 13
  store i32 %1, i32* %cop_line1, align 4, !tbaa !0
  %3 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %add = add nsw i32 %3, 3
  %4 = load i32* @PL_savestack_max, align 4, !tbaa !0
  %cmp = icmp sgt i32 %add, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @Perl_savestack_grow() #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32* @PL_hints, align 4, !tbaa !0
  %and = and i32 %5, 131072
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end9, label %if.then2

if.then2:                                         ; preds = %if.end
  %6 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.gv* %6, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 7
  %8 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %8, i64 0, i32 5
  %9 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %10 = bitcast %struct.hv* %9 to i8*
  %11 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom = sext i32 %11 to i64
  %12 = load %union.any** @PL_savestack, align 8, !tbaa !3
  %any_ptr = getelementptr inbounds %union.any* %12, i64 %idxprom, i32 0
  store i8* %10, i8** %any_ptr, align 8, !tbaa !3
  %13 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any3 = getelementptr inbounds %struct.gv* %13, i64 0, i32 0
  %14 = load %struct.xpvgv** %sv_any3, align 8, !tbaa !3
  %xgv_gp4 = getelementptr inbounds %struct.xpvgv* %14, i64 0, i32 7
  %15 = load %struct.gp** %xgv_gp4, align 8, !tbaa !3
  %gp_hv5 = getelementptr inbounds %struct.gp* %15, i64 0, i32 5
  %16 = load %struct.hv** %gp_hv5, align 8, !tbaa !3
  %call = tail call %struct.hv* @Perl_newHVhv(%struct.hv* %16) #7
  %17 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any6 = getelementptr inbounds %struct.gv* %17, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any6, align 8, !tbaa !3
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp7, align 8, !tbaa !3
  %gp_hv8 = getelementptr inbounds %struct.gp* %19, i64 0, i32 5
  store %struct.hv* %call, %struct.hv** %gp_hv8, align 8, !tbaa !3
  %.pre = load i32* @PL_hints, align 4, !tbaa !0
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then2
  %20 = phi i32 [ %.pre, %if.then2 ], [ %5, %if.end ]
  %21 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %inc10 = add nsw i32 %21, 1
  store i32 %inc10, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom11 = sext i32 %21 to i64
  %22 = load %union.any** @PL_savestack, align 8, !tbaa !3
  %arrayidx12 = getelementptr inbounds %union.any* %22, i64 %idxprom11
  %any_i32 = bitcast %union.any* %arrayidx12 to i32*
  store i32 %20, i32* %any_i32, align 4, !tbaa !0
  %23 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %inc13 = add nsw i32 %23, 1
  store i32 %inc13, i32* @PL_savestack_ix, align 4, !tbaa !0
  %idxprom14 = sext i32 %23 to i64
  %arrayidx15 = getelementptr inbounds %union.any* %22, i64 %idxprom14
  %any_i3216 = bitcast %union.any* %arrayidx15 to i32*
  store i32 27, i32* %any_i3216, align 4, !tbaa !0
  %24 = load i32* @PL_hints, align 4, !tbaa !0
  %and17 = and i32 %24, -257
  store i32 %and17, i32* @PL_hints, align 4, !tbaa !0
  %tobool18 = icmp eq %struct.hv* %stash, null
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.end9
  tail call void @Perl_save_sptr(%struct.sv** bitcast (%struct.hv** @PL_curstash to %struct.sv**)) #7
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_stash = getelementptr inbounds %struct.cop* %25, i64 0, i32 9
  %26 = bitcast %struct.hv** %cop_stash to %struct.sv**
  tail call void @Perl_save_sptr(%struct.sv** %26) #7
  store %struct.hv* %stash, %struct.hv** @PL_curstash, align 8, !tbaa !3
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_stash20 = getelementptr inbounds %struct.cop* %27, i64 0, i32 9
  store %struct.hv* %stash, %struct.hv** %cop_stash20, align 8, !tbaa !3
  br label %if.end21

if.end21:                                         ; preds = %if.end9, %if.then19
  %28 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv = getelementptr inbounds %struct.cop* %28, i64 0, i32 10
  %29 = load %struct.gv** %cop_filegv, align 8, !tbaa !3
  %tobool22 = icmp eq %struct.gv* %29, null
  br i1 %tobool22, label %cond.end38, label %cond.true

cond.true:                                        ; preds = %if.end21
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv23 = getelementptr inbounds %struct.cop* %30, i64 0, i32 10
  %31 = load %struct.gv** %cop_filegv23, align 8, !tbaa !3
  %sv_any24 = getelementptr inbounds %struct.gv* %31, i64 0, i32 0
  %32 = load %struct.xpvgv** %sv_any24, align 8, !tbaa !3
  %xgv_gp25 = getelementptr inbounds %struct.xpvgv* %32, i64 0, i32 7
  %33 = load %struct.gp** %xgv_gp25, align 8, !tbaa !3
  %gp_sv = getelementptr inbounds %struct.gp* %33, i64 0, i32 0
  %34 = load %struct.sv** %gp_sv, align 8, !tbaa !3
  %tobool26 = icmp eq %struct.sv* %34, null
  br i1 %tobool26, label %cond.end38, label %cond.true27

cond.true27:                                      ; preds = %cond.true
  %35 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %36 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv31 = getelementptr inbounds %struct.cop* %36, i64 0, i32 10
  %37 = load %struct.gv** %cop_filegv31, align 8, !tbaa !3
  %sv_any32 = getelementptr inbounds %struct.gv* %37, i64 0, i32 0
  %38 = load %struct.xpvgv** %sv_any32, align 8, !tbaa !3
  %xgv_gp33 = getelementptr inbounds %struct.xpvgv* %38, i64 0, i32 7
  %39 = load %struct.gp** %xgv_gp33, align 8, !tbaa !3
  %gp_sv34 = getelementptr inbounds %struct.gp* %39, i64 0, i32 0
  %40 = load %struct.sv** %gp_sv34, align 8, !tbaa !3
  %sv_any36 = getelementptr inbounds %struct.sv* %40, i64 0, i32 0
  %41 = load i8** %sv_any36, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %41 to i8**
  %42 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end38

cond.end38:                                       ; preds = %cond.true, %if.end21, %cond.true27
  %cond39 = phi i8* [ %42, %cond.true27 ], [ null, %if.end21 ], [ null, %cond.true ]
  %call40 = tail call i8* @Perl_savepv(i8* %cond39) #7
  %call41 = tail call %struct.cv* @Perl_newXS(i8* %name, void (%struct.cv*)* @const_sv_xsub, i8* %call40) #8
  %43 = bitcast %struct.sv* %sv to i8*
  %sv_any42 = getelementptr inbounds %struct.cv* %call41, i64 0, i32 0
  %44 = load %struct.xpvcv** %sv_any42, align 8, !tbaa !3
  %any_ptr43 = getelementptr inbounds %struct.xpvcv* %44, i64 0, i32 11, i32 0
  store i8* %43, i8** %any_ptr43, align 8, !tbaa !3
  %45 = load %struct.xpvcv** %sv_any42, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %45, i64 0, i32 17
  %46 = load i16* %xcv_flags, align 2, !tbaa !4
  %or = or i16 %46, 512
  store i16 %or, i16* %xcv_flags, align 2, !tbaa !4
  %47 = bitcast %struct.cv* %call41 to %struct.sv*
  tail call void @Perl_sv_setpv(%struct.sv* %47, i8* getelementptr inbounds ([1 x i8]* @.str35, i64 0, i64 0)) #7
  tail call void @Perl_pop_scope() #7
  ret %struct.cv* %call41
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @S_apply_attrs(%struct.hv* %stash, %struct.sv* %target, %struct.op* nocapture %attrs, i8 signext %for_my) #0 {
entry:
  tail call void @Perl_push_scope() #7
  tail call void @Perl_save_int(i32* @PL_expect) #7
  %tobool = icmp eq %struct.hv* %stash, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sv_any = getelementptr inbounds %struct.hv* %stash, i64 0, i32 0
  %0 = load %struct.xpvhv** %sv_any, align 8, !tbaa !3
  %xhv_name = getelementptr inbounds %struct.xpvhv* %0, i64 0, i32 10
  %1 = load i8** %xhv_name, align 8, !tbaa !3
  %call = tail call %struct.sv* @Perl_newSVpv(i8* %1, i64 0) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %stashsv.0 = phi %struct.sv* [ %call, %if.then ], [ @PL_sv_no, %entry ]
  %tobool1 = icmp eq i8 %for_my, 0
  br i1 %tobool1, label %if.else18, label %if.then2

if.then2:                                         ; preds = %if.end
  %2 = load %struct.gv** @PL_incgv, align 8, !tbaa !3
  %sv_any3 = getelementptr inbounds %struct.gv* %2, i64 0, i32 0
  %3 = load %struct.xpvgv** %sv_any3, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %3, i64 0, i32 7
  %4 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %4, i64 0, i32 5
  %5 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %tobool4 = icmp eq %struct.hv* %5, null
  br i1 %tobool4, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then2
  %call8 = tail call %struct.gv* @Perl_gv_HVadd(%struct.gv* %2) #7
  %sv_any9 = getelementptr inbounds %struct.gv* %call8, i64 0, i32 0
  %6 = load %struct.xpvgv** %sv_any9, align 8, !tbaa !3
  %xgv_gp10 = getelementptr inbounds %struct.xpvgv* %6, i64 0, i32 7
  %7 = load %struct.gp** %xgv_gp10, align 8, !tbaa !3
  %gp_hv11 = getelementptr inbounds %struct.gp* %7, i64 0, i32 5
  %8 = load %struct.hv** %gp_hv11, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %if.then2, %cond.false
  %cond = phi %struct.hv* [ %8, %cond.false ], [ %5, %if.then2 ]
  %call12 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %cond, i8* getelementptr inbounds ([14 x i8]* @.str146, i64 0, i64 0), i32 13, i32 0) #7
  %tobool13 = icmp eq %struct.sv** %call12, null
  br i1 %tobool13, label %if.else15, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %9 = load %struct.sv** %call12, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %9, @PL_sv_undef
  br i1 %cmp, label %if.else15, label %if.end26

if.else15:                                        ; preds = %land.lhs.true, %cond.end
  %call16 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str23, i64 0, i64 0), i64 10) #7
  tail call void (i32, %struct.sv*, %struct.sv*, ...)* @Perl_load_module(i32 2, %struct.sv* %call16, %struct.sv* null) #8
  br label %if.end26

if.else18:                                        ; preds = %if.end
  %call19 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str23, i64 0, i64 0), i64 10) #7
  %call20 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %stashsv.0) #8
  %call21 = tail call %struct.sv* @Perl_newRV(%struct.sv* %target) #7
  %call22 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call21) #8
  %call23 = tail call fastcc %struct.op* @S_dup_attrlist(%struct.op* %attrs) #8
  %call24 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call22, %struct.op* %call23) #8
  %call25 = tail call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call20, %struct.op* %call24) #8
  tail call void (i32, %struct.sv*, %struct.sv*, ...)* @Perl_load_module(i32 4, %struct.sv* %call19, %struct.sv* null, %struct.op* %call25) #8
  br label %if.end26

if.end26:                                         ; preds = %land.lhs.true, %if.else15, %if.else18
  tail call void @Perl_pop_scope() #7
  ret void
}

; Function Attrs: optsize
declare void @Perl_pad_fixup_inner_anons(%struct.av*, %struct.cv*, %struct.cv*) #2

; Function Attrs: nounwind optsize readonly
declare i8* @strrchr(i8*, i32) #1

; Function Attrs: optsize
declare void @Perl_pad_tidy(i32) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_newSV(i64) #2

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_HVadd(%struct.gv*) #2

; Function Attrs: optsize
declare signext i8 @Perl_hv_exists(%struct.hv*, i8*, i32) #2

; Function Attrs: optsize
declare %struct.av* @Perl_newAV() #2

; Function Attrs: optsize
declare void @Perl_av_push(%struct.av*, %struct.sv*) #2

; Function Attrs: optsize
declare void @Perl_call_list(i32, %struct.av*) #2

; Function Attrs: optsize
declare void @Perl_av_unshift(%struct.av*, i32) #2

; Function Attrs: optsize
declare %struct.sv** @Perl_av_store(%struct.av*, i32, %struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.cv* @Perl_newXS(i8* %name, void (%struct.cv*)* %subaddr, i8* %filename) #0 {
entry:
  %tobool = icmp ne i8* %name, null
  br i1 %tobool, label %cond.end6, label %cond.end6.thread

cond.end6.thread:                                 ; preds = %entry
  %0 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %tobool1 = icmp ne %struct.hv* %0, null
  %cond = select i1 %tobool1, i8* getelementptr inbounds ([9 x i8]* @.str66, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str67, i64 0, i64 0)
  %call = tail call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 2, i32 12) #7
  br label %if.else76

cond.end6:                                        ; preds = %entry
  %call284 = tail call %struct.gv* @Perl_gv_fetchpv(i8* %name, i32 2, i32 12) #7
  %sv_any = getelementptr inbounds %struct.gv* %call284, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_cv = getelementptr inbounds %struct.gp* %2, i64 0, i32 7
  %3 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool8 = icmp eq %struct.cv* %3, null
  br i1 %tobool8, label %if.else76, label %if.then

if.then:                                          ; preds = %cond.end6
  %gp_cvgen = getelementptr inbounds %struct.gp* %2, i64 0, i32 8
  %4 = load i32* %gp_cvgen, align 4, !tbaa !0
  %tobool11 = icmp eq i32 %4, 0
  br i1 %tobool11, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.then
  %5 = bitcast %struct.cv* %3 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %5) #7
  br label %if.else76

if.else:                                          ; preds = %if.then
  %sv_any13 = getelementptr inbounds %struct.cv* %3, i64 0, i32 0
  %6 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !3
  %xcv_root = getelementptr inbounds %struct.xpvcv* %6, i64 0, i32 9
  %7 = load %struct.op** %xcv_root, align 8, !tbaa !3
  %tobool14 = icmp eq %struct.op* %7, null
  br i1 %tobool14, label %lor.lhs.false, label %if.then20

lor.lhs.false:                                    ; preds = %if.else
  %xcv_xsub = getelementptr inbounds %struct.xpvcv* %6, i64 0, i32 10
  %8 = load void (%struct.cv*)** %xcv_xsub, align 8, !tbaa !3
  %tobool16 = icmp eq void (%struct.cv*)* %8, null
  br i1 %tobool16, label %lor.lhs.false17, label %if.then20

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 11
  %9 = load i8* %xgv_flags, align 1, !tbaa !1
  %and = and i8 %9, 4
  %tobool19 = icmp eq i8 %and, 0
  br i1 %tobool19, label %if.then75, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false17, %lor.lhs.false, %if.else
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %11, null
  br i1 %cmp, label %lor.lhs.false35, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then20
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings22 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings22, align 8, !tbaa !3
  %cmp23 = icmp eq %struct.sv* %13, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp23, label %lor.lhs.false35, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %land.lhs.true
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings26 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings26, align 8, !tbaa !3
  %cmp27 = icmp eq %struct.sv* %15, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp27, label %land.lhs.true43, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %land.lhs.true25
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings30 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings30, align 8, !tbaa !3
  %sv_any31 = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %18 = load i8** %sv_any31, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %18 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %19, i64 4
  %20 = load i8* %arrayidx, align 1, !tbaa !1
  %and33 = and i8 %20, 64
  %tobool34 = icmp eq i8 %and33, 0
  br i1 %tobool34, label %lor.lhs.false35, label %land.lhs.true43

lor.lhs.false35:                                  ; preds = %lor.lhs.false29, %land.lhs.true, %if.then20
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings36 = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings36, align 8, !tbaa !3
  %cmp37 = icmp eq %struct.sv* %22, null
  br i1 %cmp37, label %land.lhs.true39, label %if.end70

land.lhs.true39:                                  ; preds = %lor.lhs.false35
  %23 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and41 = and i8 %23, 1
  %tobool42 = icmp eq i8 %and41, 0
  br i1 %tobool42, label %if.end70, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %lor.lhs.false29, %land.lhs.true39, %land.lhs.true25
  %24 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !3
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %24, i64 0, i32 12
  %25 = load %struct.gv** %xcv_gv, align 8, !tbaa !3
  %tobool45 = icmp eq %struct.gv* %25, null
  br i1 %tobool45, label %if.then59, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %land.lhs.true43
  %sv_any49 = getelementptr inbounds %struct.gv* %25, i64 0, i32 0
  %26 = load %struct.xpvgv** %sv_any49, align 8, !tbaa !3
  %xgv_stash = getelementptr inbounds %struct.xpvgv* %26, i64 0, i32 10
  %27 = load %struct.hv** %xgv_stash, align 8, !tbaa !3
  %tobool50 = icmp eq %struct.hv* %27, null
  br i1 %tobool50, label %if.then59, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %land.lhs.true46
  %sv_any56 = getelementptr inbounds %struct.hv* %27, i64 0, i32 0
  %28 = load %struct.xpvhv** %sv_any56, align 8, !tbaa !3
  %xhv_name = getelementptr inbounds %struct.xpvhv* %28, i64 0, i32 10
  %29 = load i8** %xhv_name, align 8, !tbaa !3
  %call57 = tail call i32 @strcmp(i8* %29, i8* getelementptr inbounds ([8 x i8]* @.str79, i64 0, i64 0)) #7
  %tobool58 = icmp eq i32 %call57, 0
  br i1 %tobool58, label %if.end70, label %if.then59

if.then59:                                        ; preds = %land.lhs.true51, %land.lhs.true46, %land.lhs.true43
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %30, i64 0, i32 13
  %31 = load i32* %cop_line, align 4, !tbaa !0
  %32 = load i32* @PL_copline, align 4, !tbaa !0
  %cmp60 = icmp eq i32 %32, -1
  br i1 %cmp60, label %if.end, label %if.then62

if.then62:                                        ; preds = %if.then59
  %33 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line63 = getelementptr inbounds %struct.cop* %33, i64 0, i32 13
  store i32 %32, i32* %cop_line63, align 4, !tbaa !0
  br label %if.end

if.end:                                           ; preds = %if.then59, %if.then62
  %34 = load %struct.xpvcv** %sv_any13, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %34, i64 0, i32 17
  %35 = load i16* %xcv_flags, align 2, !tbaa !4
  %and66 = and i16 %35, 512
  %tobool67 = icmp ne i16 %and66, 0
  %cond68 = select i1 %tobool67, i8* getelementptr inbounds ([33 x i8]* @.str70, i64 0, i64 0), i8* getelementptr inbounds ([24 x i8]* @.str71, i64 0, i64 0)
  tail call void (i32, i8*, ...)* @Perl_warner(i32 19, i8* %cond68, i8* %name) #7
  %36 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line69 = getelementptr inbounds %struct.cop* %36, i64 0, i32 13
  store i32 %31, i32* %cop_line69, align 4, !tbaa !0
  br label %if.end70

if.end70:                                         ; preds = %land.lhs.true51, %land.lhs.true39, %if.end, %lor.lhs.false35
  %37 = bitcast %struct.cv* %3 to %struct.sv*
  tail call void @Perl_sv_free(%struct.sv* %37) #7
  br label %if.else76

if.then75:                                        ; preds = %lor.lhs.false17
  tail call void @Perl_cv_undef(%struct.cv* %3) #8
  br label %if.end88

if.else76:                                        ; preds = %cond.end6.thread, %cond.end6, %if.end70, %if.then12
  %call285288291 = phi %struct.gv* [ %call284, %if.then12 ], [ %call284, %if.end70 ], [ %call284, %cond.end6 ], [ %call, %cond.end6.thread ]
  %call77 = tail call %struct.sv* @Perl_newSV(i64 0) #7
  %38 = bitcast %struct.sv* %call77 to %struct.cv*
  %call78 = tail call signext i8 @Perl_sv_upgrade(%struct.sv* %call77, i32 12) #7
  br i1 %tobool, label %if.then80, label %if.end88

if.then80:                                        ; preds = %if.else76
  %sv_any81 = getelementptr inbounds %struct.gv* %call285288291, i64 0, i32 0
  %39 = load %struct.xpvgv** %sv_any81, align 8, !tbaa !3
  %xgv_gp82 = getelementptr inbounds %struct.xpvgv* %39, i64 0, i32 7
  %40 = load %struct.gp** %xgv_gp82, align 8, !tbaa !3
  %gp_cv83 = getelementptr inbounds %struct.gp* %40, i64 0, i32 7
  store %struct.cv* %38, %struct.cv** %gp_cv83, align 8, !tbaa !3
  %41 = load %struct.xpvgv** %sv_any81, align 8, !tbaa !3
  %xgv_gp85 = getelementptr inbounds %struct.xpvgv* %41, i64 0, i32 7
  %42 = load %struct.gp** %xgv_gp85, align 8, !tbaa !3
  %gp_cvgen86 = getelementptr inbounds %struct.gp* %42, i64 0, i32 8
  store i32 0, i32* %gp_cvgen86, align 4, !tbaa !0
  %43 = load i32* @PL_sub_generation, align 4, !tbaa !0
  %inc = add i32 %43, 1
  store i32 %inc, i32* @PL_sub_generation, align 4, !tbaa !0
  br label %if.end88

if.end88:                                         ; preds = %if.else76, %if.then80, %if.then75
  %call285288290 = phi %struct.gv* [ %call284, %if.then75 ], [ %call285288291, %if.then80 ], [ %call285288291, %if.else76 ]
  %cv.1 = phi %struct.cv* [ %3, %if.then75 ], [ %38, %if.then80 ], [ %38, %if.else76 ]
  %sv_any89 = getelementptr inbounds %struct.cv* %cv.1, i64 0, i32 0
  %44 = load %struct.xpvcv** %sv_any89, align 8, !tbaa !3
  %xcv_gv90 = getelementptr inbounds %struct.xpvcv* %44, i64 0, i32 12
  store %struct.gv* %call285288290, %struct.gv** %xcv_gv90, align 8, !tbaa !3
  %call91 = tail call %struct.gv* @Perl_gv_fetchfile(i8* %filename) #7
  %45 = load %struct.xpvcv** %sv_any89, align 8, !tbaa !3
  %xcv_file = getelementptr inbounds %struct.xpvcv* %45, i64 0, i32 13
  store i8* %filename, i8** %xcv_file, align 8, !tbaa !3
  %46 = load %struct.xpvcv** %sv_any89, align 8, !tbaa !3
  %xcv_xsub94 = getelementptr inbounds %struct.xpvcv* %46, i64 0, i32 10
  store void (%struct.cv*)* %subaddr, void (%struct.cv*)** %xcv_xsub94, align 8, !tbaa !3
  br i1 %tobool, label %if.then96, label %if.else230

if.then96:                                        ; preds = %if.end88
  %call97 = tail call i8* @strrchr(i8* %name, i32 58) #7
  %tobool98 = icmp eq i8* %call97, null
  %incdec.ptr = getelementptr inbounds i8* %call97, i64 1
  %s.0 = select i1 %tobool98, i8* %name, i8* %incdec.ptr
  %47 = load i8* %s.0, align 1, !tbaa !1
  switch i8 %47, label %done [
    i8 66, label %if.end118
    i8 69, label %if.end118
    i8 67, label %if.end118
    i8 73, label %if.end118
  ]

if.end118:                                        ; preds = %if.then96, %if.then96, %if.then96, %if.then96
  %call119 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([6 x i8]* @.str51, i64 0, i64 0)) #7
  %tobool120 = icmp eq i32 %call119, 0
  br i1 %tobool120, label %if.then121, label %if.else129

if.then121:                                       ; preds = %if.end118
  %48 = load %struct.av** @PL_beginav, align 8, !tbaa !3
  %tobool122 = icmp eq %struct.av* %48, null
  br i1 %tobool122, label %if.then123, label %if.end125

if.then123:                                       ; preds = %if.then121
  %call124 = tail call %struct.av* @Perl_newAV() #7
  store %struct.av* %call124, %struct.av** @PL_beginav, align 8, !tbaa !3
  br label %if.end125

if.end125:                                        ; preds = %if.then121, %if.then123
  %49 = phi %struct.av* [ %48, %if.then121 ], [ %call124, %if.then123 ]
  %50 = bitcast %struct.cv* %cv.1 to %struct.sv*
  tail call void @Perl_av_push(%struct.av* %49, %struct.sv* %50) #7
  %sv_any126 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %51 = load %struct.xpvgv** %sv_any126, align 8, !tbaa !3
  %xgv_gp127 = getelementptr inbounds %struct.xpvgv* %51, i64 0, i32 7
  %52 = load %struct.gp** %xgv_gp127, align 8, !tbaa !3
  %gp_cv128 = getelementptr inbounds %struct.gp* %52, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv128, align 8, !tbaa !3
  br label %done

if.else129:                                       ; preds = %if.end118
  %call130 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([4 x i8]* @.str74, i64 0, i64 0)) #7
  %tobool131 = icmp eq i32 %call130, 0
  br i1 %tobool131, label %if.then132, label %if.else141

if.then132:                                       ; preds = %if.else129
  %53 = load %struct.av** @PL_endav, align 8, !tbaa !3
  %tobool133 = icmp eq %struct.av* %53, null
  br i1 %tobool133, label %if.then134, label %if.end136

if.then134:                                       ; preds = %if.then132
  %call135 = tail call %struct.av* @Perl_newAV() #7
  store %struct.av* %call135, %struct.av** @PL_endav, align 8, !tbaa !3
  br label %if.end136

if.end136:                                        ; preds = %if.then132, %if.then134
  %54 = phi %struct.av* [ %53, %if.then132 ], [ %call135, %if.then134 ]
  tail call void @Perl_av_unshift(%struct.av* %54, i32 1) #7
  %55 = load %struct.av** @PL_endav, align 8, !tbaa !3
  %56 = bitcast %struct.cv* %cv.1 to %struct.sv*
  %call137 = tail call %struct.sv** @Perl_av_store(%struct.av* %55, i32 0, %struct.sv* %56) #7
  %sv_any138 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %57 = load %struct.xpvgv** %sv_any138, align 8, !tbaa !3
  %xgv_gp139 = getelementptr inbounds %struct.xpvgv* %57, i64 0, i32 7
  %58 = load %struct.gp** %xgv_gp139, align 8, !tbaa !3
  %gp_cv140 = getelementptr inbounds %struct.gp* %58, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv140, align 8, !tbaa !3
  br label %done

if.else141:                                       ; preds = %if.else129
  %call142 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([6 x i8]* @.str75, i64 0, i64 0)) #7
  %tobool143 = icmp eq i32 %call142, 0
  br i1 %tobool143, label %if.then144, label %if.else184

if.then144:                                       ; preds = %if.else141
  %59 = load %struct.av** @PL_checkav, align 8, !tbaa !3
  %tobool145 = icmp eq %struct.av* %59, null
  br i1 %tobool145, label %if.then146, label %if.end148

if.then146:                                       ; preds = %if.then144
  %call147 = tail call %struct.av* @Perl_newAV() #7
  store %struct.av* %call147, %struct.av** @PL_checkav, align 8, !tbaa !3
  br label %if.end148

if.end148:                                        ; preds = %if.then144, %if.then146
  %60 = load %struct.op** @PL_main_start, align 8, !tbaa !3
  %tobool149 = icmp eq %struct.op* %60, null
  br i1 %tobool149, label %if.end179, label %land.lhs.true150

land.lhs.true150:                                 ; preds = %if.end148
  %61 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings151 = getelementptr inbounds %struct.cop* %61, i64 0, i32 14
  %62 = load %struct.sv** %cop_warnings151, align 8, !tbaa !3
  %cmp152 = icmp eq %struct.sv* %62, null
  br i1 %cmp152, label %lor.lhs.false170, label %land.lhs.true154

land.lhs.true154:                                 ; preds = %land.lhs.true150
  %63 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings155 = getelementptr inbounds %struct.cop* %63, i64 0, i32 14
  %64 = load %struct.sv** %cop_warnings155, align 8, !tbaa !3
  %cmp156 = icmp eq %struct.sv* %64, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp156, label %lor.lhs.false170, label %land.lhs.true158

land.lhs.true158:                                 ; preds = %land.lhs.true154
  %65 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings159 = getelementptr inbounds %struct.cop* %65, i64 0, i32 14
  %66 = load %struct.sv** %cop_warnings159, align 8, !tbaa !3
  %cmp160 = icmp eq %struct.sv* %66, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp160, label %if.then178, label %lor.lhs.false162

lor.lhs.false162:                                 ; preds = %land.lhs.true158
  %67 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings163 = getelementptr inbounds %struct.cop* %67, i64 0, i32 14
  %68 = load %struct.sv** %cop_warnings163, align 8, !tbaa !3
  %sv_any164 = getelementptr inbounds %struct.sv* %68, i64 0, i32 0
  %69 = load i8** %sv_any164, align 8, !tbaa !3
  %xpv_pv165 = bitcast i8* %69 to i8**
  %70 = load i8** %xpv_pv165, align 8, !tbaa !3
  %arrayidx166 = getelementptr inbounds i8* %70, i64 11
  %71 = load i8* %arrayidx166, align 1, !tbaa !1
  %and168 = and i8 %71, 4
  %tobool169 = icmp eq i8 %and168, 0
  br i1 %tobool169, label %lor.lhs.false170, label %if.then178

lor.lhs.false170:                                 ; preds = %lor.lhs.false162, %land.lhs.true154, %land.lhs.true150
  %72 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings171 = getelementptr inbounds %struct.cop* %72, i64 0, i32 14
  %73 = load %struct.sv** %cop_warnings171, align 8, !tbaa !3
  %cmp172 = icmp eq %struct.sv* %73, null
  br i1 %cmp172, label %land.lhs.true174, label %if.end179

land.lhs.true174:                                 ; preds = %lor.lhs.false170
  %74 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and176 = and i8 %74, 1
  %tobool177 = icmp eq i8 %and176, 0
  br i1 %tobool177, label %if.end179, label %if.then178

if.then178:                                       ; preds = %lor.lhs.false162, %land.lhs.true174, %land.lhs.true158
  tail call void (i32, i8*, ...)* @Perl_warner(i32 45, i8* getelementptr inbounds ([28 x i8]* @.str76, i64 0, i64 0)) #7
  br label %if.end179

if.end179:                                        ; preds = %land.lhs.true174, %lor.lhs.false170, %if.end148, %if.then178
  %75 = load %struct.av** @PL_checkav, align 8, !tbaa !3
  tail call void @Perl_av_unshift(%struct.av* %75, i32 1) #7
  %76 = load %struct.av** @PL_checkav, align 8, !tbaa !3
  %77 = bitcast %struct.cv* %cv.1 to %struct.sv*
  %call180 = tail call %struct.sv** @Perl_av_store(%struct.av* %76, i32 0, %struct.sv* %77) #7
  %sv_any181 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %78 = load %struct.xpvgv** %sv_any181, align 8, !tbaa !3
  %xgv_gp182 = getelementptr inbounds %struct.xpvgv* %78, i64 0, i32 7
  %79 = load %struct.gp** %xgv_gp182, align 8, !tbaa !3
  %gp_cv183 = getelementptr inbounds %struct.gp* %79, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv183, align 8, !tbaa !3
  br label %done

if.else184:                                       ; preds = %if.else141
  %call185 = tail call i32 @strcmp(i8* %s.0, i8* getelementptr inbounds ([5 x i8]* @.str77, i64 0, i64 0)) #7
  %tobool186 = icmp eq i32 %call185, 0
  br i1 %tobool186, label %if.then187, label %done

if.then187:                                       ; preds = %if.else184
  %80 = load %struct.av** @PL_initav, align 8, !tbaa !3
  %tobool188 = icmp eq %struct.av* %80, null
  br i1 %tobool188, label %if.then189, label %if.end191

if.then189:                                       ; preds = %if.then187
  %call190 = tail call %struct.av* @Perl_newAV() #7
  store %struct.av* %call190, %struct.av** @PL_initav, align 8, !tbaa !3
  br label %if.end191

if.end191:                                        ; preds = %if.then187, %if.then189
  %81 = load %struct.op** @PL_main_start, align 8, !tbaa !3
  %tobool192 = icmp eq %struct.op* %81, null
  br i1 %tobool192, label %if.end222, label %land.lhs.true193

land.lhs.true193:                                 ; preds = %if.end191
  %82 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings194 = getelementptr inbounds %struct.cop* %82, i64 0, i32 14
  %83 = load %struct.sv** %cop_warnings194, align 8, !tbaa !3
  %cmp195 = icmp eq %struct.sv* %83, null
  br i1 %cmp195, label %lor.lhs.false213, label %land.lhs.true197

land.lhs.true197:                                 ; preds = %land.lhs.true193
  %84 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings198 = getelementptr inbounds %struct.cop* %84, i64 0, i32 14
  %85 = load %struct.sv** %cop_warnings198, align 8, !tbaa !3
  %cmp199 = icmp eq %struct.sv* %85, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp199, label %lor.lhs.false213, label %land.lhs.true201

land.lhs.true201:                                 ; preds = %land.lhs.true197
  %86 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings202 = getelementptr inbounds %struct.cop* %86, i64 0, i32 14
  %87 = load %struct.sv** %cop_warnings202, align 8, !tbaa !3
  %cmp203 = icmp eq %struct.sv* %87, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp203, label %if.then221, label %lor.lhs.false205

lor.lhs.false205:                                 ; preds = %land.lhs.true201
  %88 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings206 = getelementptr inbounds %struct.cop* %88, i64 0, i32 14
  %89 = load %struct.sv** %cop_warnings206, align 8, !tbaa !3
  %sv_any207 = getelementptr inbounds %struct.sv* %89, i64 0, i32 0
  %90 = load i8** %sv_any207, align 8, !tbaa !3
  %xpv_pv208 = bitcast i8* %90 to i8**
  %91 = load i8** %xpv_pv208, align 8, !tbaa !3
  %arrayidx209 = getelementptr inbounds i8* %91, i64 11
  %92 = load i8* %arrayidx209, align 1, !tbaa !1
  %and211 = and i8 %92, 4
  %tobool212 = icmp eq i8 %and211, 0
  br i1 %tobool212, label %lor.lhs.false213, label %if.then221

lor.lhs.false213:                                 ; preds = %lor.lhs.false205, %land.lhs.true197, %land.lhs.true193
  %93 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings214 = getelementptr inbounds %struct.cop* %93, i64 0, i32 14
  %94 = load %struct.sv** %cop_warnings214, align 8, !tbaa !3
  %cmp215 = icmp eq %struct.sv* %94, null
  br i1 %cmp215, label %land.lhs.true217, label %if.end222

land.lhs.true217:                                 ; preds = %lor.lhs.false213
  %95 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and219 = and i8 %95, 1
  %tobool220 = icmp eq i8 %and219, 0
  br i1 %tobool220, label %if.end222, label %if.then221

if.then221:                                       ; preds = %lor.lhs.false205, %land.lhs.true217, %land.lhs.true201
  tail call void (i32, i8*, ...)* @Perl_warner(i32 45, i8* getelementptr inbounds ([27 x i8]* @.str78, i64 0, i64 0)) #7
  br label %if.end222

if.end222:                                        ; preds = %land.lhs.true217, %lor.lhs.false213, %if.end191, %if.then221
  %96 = load %struct.av** @PL_initav, align 8, !tbaa !3
  %97 = bitcast %struct.cv* %cv.1 to %struct.sv*
  tail call void @Perl_av_push(%struct.av* %96, %struct.sv* %97) #7
  %sv_any223 = getelementptr inbounds %struct.gv* %call285288290, i64 0, i32 0
  %98 = load %struct.xpvgv** %sv_any223, align 8, !tbaa !3
  %xgv_gp224 = getelementptr inbounds %struct.xpvgv* %98, i64 0, i32 7
  %99 = load %struct.gp** %xgv_gp224, align 8, !tbaa !3
  %gp_cv225 = getelementptr inbounds %struct.gp* %99, i64 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv225, align 8, !tbaa !3
  br label %done

if.else230:                                       ; preds = %if.end88
  %100 = load %struct.xpvcv** %sv_any89, align 8, !tbaa !3
  %xcv_flags232 = getelementptr inbounds %struct.xpvcv* %100, i64 0, i32 17
  %101 = load i16* %xcv_flags232, align 2, !tbaa !4
  %or = or i16 %101, 4
  store i16 %or, i16* %xcv_flags232, align 2, !tbaa !4
  br label %done

done:                                             ; preds = %if.then96, %if.else184, %if.else230, %if.end136, %if.end222, %if.end179, %if.end125
  ret %struct.cv* %cv.1
}

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_fetchfile(i8*) #2

; Function Attrs: nounwind optsize uwtable
define void @Perl_newFORM(i32 %floor, %struct.op* %o, %struct.op* %block) #0 {
entry:
  %n_a = alloca i64, align 8
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !3
  store %struct.sv* %1, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %2, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %1, i64 0, i32 0
  %3 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %3, i64 8
  %4 = bitcast i8* %xpv_cur to i64*
  %5 = load i64* %4, align 8, !tbaa !5
  store i64 %5, i64* %n_a, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %3 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %if.end

cond.false:                                       ; preds = %if.then
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %1, i64* %n_a, i32 2) #7
  br label %if.end

if.end:                                           ; preds = %entry, %cond.true, %cond.false
  %name.0 = phi i8* [ %6, %cond.true ], [ %call, %cond.false ], [ getelementptr inbounds ([7 x i8]* @.str80, i64 0, i64 0), %entry ]
  %call2 = call %struct.gv* @Perl_gv_fetchpv(i8* %name.0, i32 1, i32 14) #7
  %sv_any3 = getelementptr inbounds %struct.gv* %call2, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any3, align 8, !tbaa !3
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 11
  %8 = load i8* %xgv_flags, align 1, !tbaa !1
  %or = or i8 %8, 2
  store i8 %or, i8* %xgv_flags, align 1, !tbaa !1
  %9 = load %struct.xpvgv** %sv_any3, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %9, i64 0, i32 7
  %10 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_form = getelementptr inbounds %struct.gp* %10, i64 0, i32 3
  %11 = load %struct.cv** %gp_form, align 8, !tbaa !3
  %tobool6 = icmp eq %struct.cv* %11, null
  br i1 %tobool6, label %if.end39, label %if.then7

if.then7:                                         ; preds = %if.end
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp8 = icmp eq %struct.sv* %13, null
  br i1 %cmp8, label %lor.lhs.false23, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then7
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings10 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings10, align 8, !tbaa !3
  %cmp11 = icmp eq %struct.sv* %15, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp11, label %lor.lhs.false23, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings14 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings14, align 8, !tbaa !3
  %cmp15 = icmp eq %struct.sv* %17, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp15, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true13
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings17 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings17, align 8, !tbaa !3
  %sv_any18 = getelementptr inbounds %struct.sv* %19, i64 0, i32 0
  %20 = load i8** %sv_any18, align 8, !tbaa !3
  %xpv_pv19 = bitcast i8* %20 to i8**
  %21 = load i8** %xpv_pv19, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %21, i64 4
  %22 = load i8* %arrayidx, align 1, !tbaa !1
  %and21 = and i8 %22, 64
  %tobool22 = icmp eq i8 %and21, 0
  br i1 %tobool22, label %lor.lhs.false23, label %if.then31

lor.lhs.false23:                                  ; preds = %lor.lhs.false, %land.lhs.true, %if.then7
  %23 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings24 = getelementptr inbounds %struct.cop* %23, i64 0, i32 14
  %24 = load %struct.sv** %cop_warnings24, align 8, !tbaa !3
  %cmp25 = icmp eq %struct.sv* %24, null
  br i1 %cmp25, label %land.lhs.true27, label %if.end38

land.lhs.true27:                                  ; preds = %lor.lhs.false23
  %25 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and29 = and i8 %25, 1
  %tobool30 = icmp eq i8 %and29, 0
  br i1 %tobool30, label %if.end38, label %if.then31

if.then31:                                        ; preds = %lor.lhs.false, %land.lhs.true27, %land.lhs.true13
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %26, i64 0, i32 13
  %27 = load i32* %cop_line, align 4, !tbaa !0
  %28 = load i32* @PL_copline, align 4, !tbaa !0
  %cmp32 = icmp eq i32 %28, -1
  br i1 %cmp32, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.then31
  %29 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line35 = getelementptr inbounds %struct.cop* %29, i64 0, i32 13
  store i32 %28, i32* %cop_line35, align 4, !tbaa !0
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %if.then34
  call void (i32, i8*, ...)* @Perl_warner(i32 19, i8* getelementptr inbounds ([20 x i8]* @.str81, i64 0, i64 0), i8* %name.0) #7
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line37 = getelementptr inbounds %struct.cop* %30, i64 0, i32 13
  store i32 %27, i32* %cop_line37, align 4, !tbaa !0
  br label %if.end38

if.end38:                                         ; preds = %land.lhs.true27, %if.end36, %lor.lhs.false23
  %31 = bitcast %struct.cv* %11 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %31) #7
  %.pre = load %struct.xpvgv** %sv_any3, align 8, !tbaa !3
  %xgv_gp41.phi.trans.insert = getelementptr inbounds %struct.xpvgv* %.pre, i64 0, i32 7
  %.pre120 = load %struct.gp** %xgv_gp41.phi.trans.insert, align 8, !tbaa !3
  br label %if.end39

if.end39:                                         ; preds = %if.end, %if.end38
  %32 = phi %struct.gp* [ %10, %if.end ], [ %.pre120, %if.end38 ]
  %33 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %gp_form42 = getelementptr inbounds %struct.gp* %32, i64 0, i32 3
  store %struct.cv* %33, %struct.cv** %gp_form42, align 8, !tbaa !3
  %sv_any43 = getelementptr inbounds %struct.cv* %33, i64 0, i32 0
  %34 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_gv = getelementptr inbounds %struct.xpvcv* %34, i64 0, i32 12
  store %struct.gv* %call2, %struct.gv** %xcv_gv, align 8, !tbaa !3
  %35 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv = getelementptr inbounds %struct.cop* %35, i64 0, i32 10
  %36 = load %struct.gv** %cop_filegv, align 8, !tbaa !3
  %tobool44 = icmp eq %struct.gv* %36, null
  br i1 %tobool44, label %cond.end65, label %cond.true45

cond.true45:                                      ; preds = %if.end39
  %37 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv46 = getelementptr inbounds %struct.cop* %37, i64 0, i32 10
  %38 = load %struct.gv** %cop_filegv46, align 8, !tbaa !3
  %sv_any47 = getelementptr inbounds %struct.gv* %38, i64 0, i32 0
  %39 = load %struct.xpvgv** %sv_any47, align 8, !tbaa !3
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv* %39, i64 0, i32 7
  %40 = load %struct.gp** %xgv_gp48, align 8, !tbaa !3
  %gp_sv = getelementptr inbounds %struct.gp* %40, i64 0, i32 0
  %41 = load %struct.sv** %gp_sv, align 8, !tbaa !3
  %tobool49 = icmp eq %struct.sv* %41, null
  br i1 %tobool49, label %cond.end65, label %cond.true51

cond.true51:                                      ; preds = %cond.true45
  %42 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %43 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_filegv55 = getelementptr inbounds %struct.cop* %43, i64 0, i32 10
  %44 = load %struct.gv** %cop_filegv55, align 8, !tbaa !3
  %sv_any56 = getelementptr inbounds %struct.gv* %44, i64 0, i32 0
  %45 = load %struct.xpvgv** %sv_any56, align 8, !tbaa !3
  %xgv_gp57 = getelementptr inbounds %struct.xpvgv* %45, i64 0, i32 7
  %46 = load %struct.gp** %xgv_gp57, align 8, !tbaa !3
  %gp_sv58 = getelementptr inbounds %struct.gp* %46, i64 0, i32 0
  %47 = load %struct.sv** %gp_sv58, align 8, !tbaa !3
  %sv_any62 = getelementptr inbounds %struct.sv* %47, i64 0, i32 0
  %48 = load i8** %sv_any62, align 8, !tbaa !3
  %xpv_pv63 = bitcast i8* %48 to i8**
  %49 = load i8** %xpv_pv63, align 8, !tbaa !3
  br label %cond.end65

cond.end65:                                       ; preds = %cond.true45, %if.end39, %cond.true51
  %cond66 = phi i8* [ %49, %cond.true51 ], [ null, %if.end39 ], [ null, %cond.true45 ]
  %50 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_file = getelementptr inbounds %struct.xpvcv* %50, i64 0, i32 13
  store i8* %cond66, i8** %xcv_file, align 8, !tbaa !3
  call void @Perl_pad_tidy(i32 2) #7
  %call68 = call %struct.op* @Perl_scalarseq(%struct.op* %block) #8
  %call69 = call %struct.op* @Perl_newUNOP(i32 207, i32 0, %struct.op* %call68) #8
  %51 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_root = getelementptr inbounds %struct.xpvcv* %51, i64 0, i32 9
  store %struct.op* %call69, %struct.op** %xcv_root, align 8, !tbaa !3
  %52 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_root72 = getelementptr inbounds %struct.xpvcv* %52, i64 0, i32 9
  %53 = load %struct.op** %xcv_root72, align 8, !tbaa !3
  %op_private = getelementptr inbounds %struct.op* %53, i64 0, i32 7
  %54 = load i8* %op_private, align 1, !tbaa !1
  %or74 = or i8 %54, 64
  store i8 %or74, i8* %op_private, align 1, !tbaa !1
  %55 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_root77 = getelementptr inbounds %struct.xpvcv* %55, i64 0, i32 9
  %56 = load %struct.op** %xcv_root77, align 8, !tbaa !3
  %op_targ = getelementptr inbounds %struct.op* %56, i64 0, i32 3
  store i64 1, i64* %op_targ, align 8, !tbaa !5
  %op_next = getelementptr inbounds %struct.op* %56, i64 0, i32 0
  %57 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool80 = icmp eq %struct.op* %57, null
  br i1 %tobool80, label %cond.false85, label %cond.end89

cond.false85:                                     ; preds = %cond.end65
  %call88 = call %struct.op* @Perl_linklist(%struct.op* %56) #8
  %.pre121 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  br label %cond.end89

cond.end89:                                       ; preds = %cond.end65, %cond.false85
  %58 = phi %struct.xpvcv* [ %.pre121, %cond.false85 ], [ %55, %cond.end65 ]
  %cond90 = phi %struct.op* [ %call88, %cond.false85 ], [ %57, %cond.end65 ]
  %xcv_start = getelementptr inbounds %struct.xpvcv* %58, i64 0, i32 8
  store %struct.op* %cond90, %struct.op** %xcv_start, align 8, !tbaa !3
  %59 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_root93 = getelementptr inbounds %struct.xpvcv* %59, i64 0, i32 9
  %60 = load %struct.op** %xcv_root93, align 8, !tbaa !3
  %op_next94 = getelementptr inbounds %struct.op* %60, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next94, align 8, !tbaa !3
  %61 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !3
  %62 = load %struct.xpvcv** %sv_any43, align 8, !tbaa !3
  %xcv_start96 = getelementptr inbounds %struct.xpvcv* %62, i64 0, i32 8
  %63 = load %struct.op** %xcv_start96, align 8, !tbaa !3
  call void %61(%struct.op* %63) #7
  call void @Perl_op_free(%struct.op* %o) #8
  store i32 -1, i32* @PL_copline, align 4, !tbaa !0
  %64 = load i32* @PL_savestack_ix, align 4, !tbaa !0
  %cmp97 = icmp sgt i32 %64, %floor
  br i1 %cmp97, label %if.then99, label %if.end100

if.then99:                                        ; preds = %cond.end89
  call void @Perl_leave_scope(i32 %floor) #7
  br label %if.end100

if.end100:                                        ; preds = %if.then99, %cond.end89
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newANONLIST(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_convert(i32 143, i32 0, %struct.op* %o) #8
  %call1 = tail call %struct.op* @Perl_list(%struct.op* %call) #8
  %call2 = tail call %struct.op* @Perl_mod(%struct.op* %call1, i32 20) #8
  %call3 = tail call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call2) #8
  ret %struct.op* %call3
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newANONHASH(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_convert(i32 144, i32 0, %struct.op* %o) #8
  %call1 = tail call %struct.op* @Perl_list(%struct.op* %call) #8
  %call2 = tail call %struct.op* @Perl_mod(%struct.op* %call1, i32 20) #8
  %call3 = tail call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call2) #8
  ret %struct.op* %call3
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newANONSUB(i32 %floor, %struct.op* %proto, %struct.op* %block) #0 {
entry:
  %call = tail call %struct.op* @Perl_newANONATTRSUB(i32 %floor, %struct.op* %proto, %struct.op* null, %struct.op* %block) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newANONATTRSUB(i32 %floor, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %call = tail call %struct.cv* @Perl_newATTRSUB(i32 %floor, %struct.op* null, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #8
  %0 = bitcast %struct.cv* %call to %struct.sv*
  %call1 = tail call %struct.op* @Perl_newSVOP(i32 18, i32 0, %struct.sv* %0) #8
  %call2 = tail call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call1) #8
  ret %struct.op* %call2
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_oopsAV(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 15, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  store i16 10, i16* %op_type, align 2, !tbaa !4
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 10), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %call = tail call %struct.op* @Perl_ref(%struct.op* %o, i32 125) #8
  br label %return

sw.bb2:                                           ; preds = %entry
  store i16 125, i16* %op_type, align 2, !tbaa !4
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !3
  %op_ppaddr4 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr4, align 8, !tbaa !3
  %call5 = tail call %struct.op* @Perl_ref(%struct.op* %o, i32 125) #8
  br label %return

sw.default:                                       ; preds = %entry
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %4, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings7 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings7, align 8, !tbaa !3
  %cmp8 = icmp eq %struct.sv* %6, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp8, label %if.then, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings11 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings11, align 8, !tbaa !3
  %cmp12 = icmp eq %struct.sv* %8, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp12, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false10
  %9 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings14 = getelementptr inbounds %struct.cop* %9, i64 0, i32 14
  %10 = load %struct.sv** %cop_warnings14, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %12, i64 6
  %13 = load i8* %arrayidx, align 1, !tbaa !1
  %and = and i8 %13, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %sw.default
  tail call void (i32, i8*, ...)* @Perl_warner(i32 24, i8* getelementptr inbounds ([13 x i8]* @.str82, i64 0, i64 0)) #7
  br label %return

return:                                           ; preds = %sw.bb2, %if.then, %lor.lhs.false10, %land.lhs.true, %sw.bb
  %retval.0 = phi %struct.op* [ %call, %sw.bb ], [ %o, %land.lhs.true ], [ %o, %lor.lhs.false10 ], [ %o, %if.then ], [ %o, %sw.bb2 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_oopsHV(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 15, label %sw.bb2
    i32 125, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry, %entry
  store i16 11, i16* %op_type, align 2, !tbaa !4
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 11), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %call = tail call %struct.op* @Perl_ref(%struct.op* %o, i32 134) #8
  br label %return

sw.bb2:                                           ; preds = %entry, %entry
  store i16 134, i16* %op_type, align 2, !tbaa !4
  %2 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 134), align 8, !tbaa !3
  %op_ppaddr4 = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr4, align 8, !tbaa !3
  %call5 = tail call %struct.op* @Perl_ref(%struct.op* %o, i32 134) #8
  br label %return

sw.default:                                       ; preds = %entry
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %4, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings7 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings7, align 8, !tbaa !3
  %cmp8 = icmp eq %struct.sv* %6, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp8, label %if.then, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings11 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings11, align 8, !tbaa !3
  %cmp12 = icmp eq %struct.sv* %8, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp12, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false10
  %9 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings14 = getelementptr inbounds %struct.cop* %9, i64 0, i32 14
  %10 = load %struct.sv** %cop_warnings14, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %10, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %11 to i8**
  %12 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %12, i64 6
  %13 = load i8* %arrayidx, align 1, !tbaa !1
  %and = and i8 %13, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %sw.default
  tail call void (i32, i8*, ...)* @Perl_warner(i32 24, i8* getelementptr inbounds ([13 x i8]* @.str83, i64 0, i64 0)) #7
  br label %return

return:                                           ; preds = %sw.bb2, %if.then, %lor.lhs.false10, %land.lhs.true, %sw.bb
  %retval.0 = phi %struct.op* [ %call, %sw.bb ], [ %o, %land.lhs.true ], [ %o, %lor.lhs.false10 ], [ %o, %if.then ], [ %o, %sw.bb2 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newAVREF(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %if.end33 [
    i16 12, label %if.then
    i16 125, label %land.lhs.true
    i16 10, label %land.lhs.true
  ]

if.then:                                          ; preds = %entry
  store i16 10, i16* %op_type, align 2, !tbaa !4
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 10), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %return

land.lhs.true:                                    ; preds = %entry, %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp11 = icmp eq %struct.sv* %3, null
  br i1 %cmp11, label %lor.lhs.false24, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings14 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings14, align 8, !tbaa !3
  %cmp15 = icmp eq %struct.sv* %5, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp15, label %lor.lhs.false24, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %land.lhs.true13
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings18 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings18, align 8, !tbaa !3
  %cmp19 = icmp eq %struct.sv* %7, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp19, label %if.then32, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %land.lhs.true17
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings22 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings22, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %10 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !3
  %12 = load i8* %11, align 1, !tbaa !1
  %and = and i8 %12, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false24, label %if.then32

lor.lhs.false24:                                  ; preds = %lor.lhs.false21, %land.lhs.true13, %land.lhs.true
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings25 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings25, align 8, !tbaa !3
  %cmp26 = icmp eq %struct.sv* %14, null
  br i1 %cmp26, label %land.lhs.true28, label %if.end33

land.lhs.true28:                                  ; preds = %lor.lhs.false24
  %15 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and30 = and i8 %15, 1
  %tobool31 = icmp eq i8 %and30, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %lor.lhs.false21, %land.lhs.true28, %land.lhs.true17
  tail call void (i32, i8*, ...)* @Perl_warner(i32 2, i8* getelementptr inbounds ([44 x i8]* @.str84, i64 0, i64 0)) #7
  br label %if.end33

if.end33:                                         ; preds = %entry, %land.lhs.true28, %lor.lhs.false24, %if.then32
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  %call34 = tail call %struct.op* @Perl_newUNOP(i32 125, i32 0, %struct.op* %call) #8
  br label %return

return:                                           ; preds = %if.end33, %if.then
  %retval.0 = phi %struct.op* [ %o, %if.then ], [ %call34, %if.end33 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newGVREF(i32 %type, %struct.op* %o) #0 {
entry:
  %0 = and i32 %type, -3
  %1 = icmp eq i32 %0, 152
  %cmp3 = icmp eq i32 %type, 150
  %or.cond6 = or i1 %1, %cmp3
  br i1 %or.cond6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %o) #8
  br label %return

if.end:                                           ; preds = %entry
  %call4 = tail call %struct.op* @Perl_newUNOP(i32 14, i32 16, %struct.op* %o) #8
  %call5 = tail call %struct.op* @Perl_ref(%struct.op* %call4, i32 %type) #8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %call5, %if.end ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newHVREF(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %0, label %if.end33 [
    i16 12, label %if.then
    i16 134, label %land.lhs.true
    i16 11, label %land.lhs.true
  ]

if.then:                                          ; preds = %entry
  store i16 11, i16* %op_type, align 2, !tbaa !4
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 11), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  br label %return

land.lhs.true:                                    ; preds = %entry, %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp11 = icmp eq %struct.sv* %3, null
  br i1 %cmp11, label %lor.lhs.false24, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings14 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings14, align 8, !tbaa !3
  %cmp15 = icmp eq %struct.sv* %5, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp15, label %lor.lhs.false24, label %land.lhs.true17

land.lhs.true17:                                  ; preds = %land.lhs.true13
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings18 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings18, align 8, !tbaa !3
  %cmp19 = icmp eq %struct.sv* %7, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp19, label %if.then32, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %land.lhs.true17
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings22 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings22, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %9, i64 0, i32 0
  %10 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %10 to i8**
  %11 = load i8** %xpv_pv, align 8, !tbaa !3
  %12 = load i8* %11, align 1, !tbaa !1
  %and = and i8 %12, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false24, label %if.then32

lor.lhs.false24:                                  ; preds = %lor.lhs.false21, %land.lhs.true13, %land.lhs.true
  %13 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings25 = getelementptr inbounds %struct.cop* %13, i64 0, i32 14
  %14 = load %struct.sv** %cop_warnings25, align 8, !tbaa !3
  %cmp26 = icmp eq %struct.sv* %14, null
  br i1 %cmp26, label %land.lhs.true28, label %if.end33

land.lhs.true28:                                  ; preds = %lor.lhs.false24
  %15 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and30 = and i8 %15, 1
  %tobool31 = icmp eq i8 %and30, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %lor.lhs.false21, %land.lhs.true28, %land.lhs.true17
  tail call void (i32, i8*, ...)* @Perl_warner(i32 2, i8* getelementptr inbounds ([42 x i8]* @.str85, i64 0, i64 0)) #7
  br label %if.end33

if.end33:                                         ; preds = %entry, %land.lhs.true28, %lor.lhs.false24, %if.then32
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  %call34 = tail call %struct.op* @Perl_newUNOP(i32 134, i32 0, %struct.op* %call) #8
  br label %return

return:                                           ; preds = %if.end33, %if.then
  %retval.0 = phi %struct.op* [ %o, %if.then ], [ %call34, %if.end33 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_oopsCV(%struct.op* %o) #0 {
entry:
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([17 x i8]* @.str86, i64 0, i64 0), i32 4843) #7
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_newCVREF(i32 %flags, %struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  %call1 = tail call %struct.op* @Perl_newUNOP(i32 17, i32 %flags, %struct.op* %call) #8
  ret %struct.op* %call1
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_anoncode(%struct.op* %o) #0 {
entry:
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %call = tail call i64 @Perl_pad_add_anon(%struct.sv* %1, i16 zeroext %2) #7
  %3 = getelementptr inbounds %struct.op* %o, i64 0, i32 3
  store i64 %call, i64* %3, align 8, !tbaa !5
  %4 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  store %struct.op* null, %struct.op** %4, align 8, !tbaa !3
  ret %struct.op* %o
}

; Function Attrs: optsize
declare i64 @Perl_pad_add_anon(%struct.sv*, i16 zeroext) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_bitop(%struct.op* %o) #0 {
entry:
  %0 = load i32* @PL_hints, align 4, !tbaa !0
  %conv = trunc i32 %0 to i8
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  store i8 %conv, i8* %op_private, align 1, !tbaa !1
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and2 = and i8 %1, 64
  %tobool = icmp eq i8 %and2, 0
  br i1 %tobool, label %land.lhs.true, label %if.end200

land.lhs.true:                                    ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %.off = add i16 %2, -91
  %switch = icmp ult i16 %.off, 3
  br i1 %switch, label %if.then, label %if.end200

if.then:                                          ; preds = %land.lhs.true
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %op_type14 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %6 = load i16* %op_type14, align 2, !tbaa !4
  %.off239 = add i16 %6, -70
  %switch240 = icmp ult i16 %.off239, 14
  br i1 %switch240, label %land.lhs.true83, label %lor.lhs.false89

land.lhs.true83:                                  ; preds = %if.then
  %op_flags84 = getelementptr inbounds %struct.op* %4, i64 0, i32 6
  %7 = load i8* %op_flags84, align 1, !tbaa !1
  %and86 = and i8 %7, 8
  %cmp87 = icmp eq i8 %and86, 0
  br i1 %cmp87, label %if.then165, label %lor.lhs.false89

lor.lhs.false89:                                  ; preds = %if.then, %land.lhs.true83
  %op_type90 = getelementptr inbounds %struct.op* %5, i64 0, i32 4
  %8 = load i16* %op_type90, align 2, !tbaa !4
  %.off241 = add i16 %8, -70
  %switch242 = icmp ult i16 %.off241, 14
  br i1 %switch242, label %land.lhs.true159, label %if.end200

land.lhs.true159:                                 ; preds = %lor.lhs.false89
  %op_flags160 = getelementptr inbounds %struct.op* %5, i64 0, i32 6
  %9 = load i8* %op_flags160, align 1, !tbaa !1
  %and162 = and i8 %9, 8
  %cmp163 = icmp eq i8 %and162, 0
  br i1 %cmp163, label %if.then165, label %if.end200

if.then165:                                       ; preds = %land.lhs.true159, %land.lhs.true83
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp166 = icmp eq %struct.sv* %11, null
  br i1 %cmp166, label %lor.lhs.false181, label %land.lhs.true168

land.lhs.true168:                                 ; preds = %if.then165
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings169 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings169, align 8, !tbaa !3
  %cmp170 = icmp eq %struct.sv* %13, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp170, label %lor.lhs.false181, label %land.lhs.true172

land.lhs.true172:                                 ; preds = %land.lhs.true168
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings173 = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings173, align 8, !tbaa !3
  %cmp174 = icmp eq %struct.sv* %15, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp174, label %if.then189, label %lor.lhs.false176

lor.lhs.false176:                                 ; preds = %land.lhs.true172
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings177 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings177, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %17, i64 0, i32 0
  %18 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %18 to i8**
  %19 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %19, i64 8
  %20 = load i8* %arrayidx, align 1, !tbaa !1
  %and179 = and i8 %20, 4
  %tobool180 = icmp eq i8 %and179, 0
  br i1 %tobool180, label %lor.lhs.false181, label %if.then189

lor.lhs.false181:                                 ; preds = %lor.lhs.false176, %land.lhs.true168, %if.then165
  %21 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings182 = getelementptr inbounds %struct.cop* %21, i64 0, i32 14
  %22 = load %struct.sv** %cop_warnings182, align 8, !tbaa !3
  %cmp183 = icmp eq %struct.sv* %22, null
  br i1 %cmp183, label %land.lhs.true185, label %if.end200

land.lhs.true185:                                 ; preds = %lor.lhs.false181
  %23 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and187 = and i8 %23, 1
  %tobool188 = icmp eq i8 %and187, 0
  br i1 %tobool188, label %if.end200, label %if.then189

if.then189:                                       ; preds = %lor.lhs.false176, %land.lhs.true185, %land.lhs.true172
  %24 = load i16* %op_type, align 2, !tbaa !4
  %cmp192 = icmp eq i16 %24, 93
  br i1 %cmp192, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.then189
  %cmp196 = icmp eq i16 %24, 91
  %cond = select i1 %cmp196, i32 38, i32 94
  br label %cond.end

cond.end:                                         ; preds = %if.then189, %cond.false
  %cond198 = phi i32 [ %cond, %cond.false ], [ 124, %if.then189 ]
  tail call void (i32, i8*, ...)* @Perl_warner(i32 33, i8* getelementptr inbounds ([51 x i8]* @.str87, i64 0, i64 0), i32 %cond198) #7
  br label %if.end200

if.end200:                                        ; preds = %lor.lhs.false89, %land.lhs.true, %land.lhs.true185, %entry, %land.lhs.true159, %cond.end, %lor.lhs.false181
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_concat(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %2, 66
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !1
  %and = and i8 %3, 16
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !3
  %op_flags = getelementptr inbounds %struct.op* %5, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !1
  %and6 = and i8 %6, 32
  %tobool7 = icmp eq i8 %and6, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %op_flags8 = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %7 = load i8* %op_flags8, align 1, !tbaa !1
  %or = or i8 %7, 64
  store i8 %or, i8* %op_flags8, align 1, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %if.then, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_spair(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end32, label %if.then

if.then:                                          ; preds = %entry
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %1 = load i16* %op_type, align 2, !tbaa !4
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %conv1 = zext i16 %1 to i32
  %call2 = tail call fastcc %struct.op* @S_modkids(%struct.op* %call, i32 %conv1) #8
  %2 = getelementptr inbounds %struct.op* %call2, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %4 = getelementptr inbounds %struct.op* %3, i64 1, i32 0
  %5 = load %struct.op** %4, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %5, i64 0, i32 1
  %6 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool4 = icmp eq %struct.op* %6, null
  br i1 %tobool4, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %op_sibling5 = getelementptr inbounds %struct.op* %6, i64 0, i32 1
  %7 = load %struct.op** %op_sibling5, align 8, !tbaa !3
  %tobool6 = icmp eq %struct.op* %7, null
  br i1 %tobool6, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %land.lhs.true
  %op_type7 = getelementptr inbounds %struct.op* %6, i64 0, i32 4
  %8 = load i16* %op_type7, align 2, !tbaa !4
  %idxprom = zext i16 %8 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %9 = load i32* %arrayidx, align 4, !tbaa !0
  %and8 = and i32 %9, 4
  %tobool9 = icmp eq i32 %and8, 0
  %cmp = icmp eq i16 %8, 10
  %or.cond = or i1 %tobool9, %cmp
  %cmp17 = icmp eq i16 %8, 11
  %or.cond53 = or i1 %or.cond, %cmp17
  %cmp22 = icmp eq i16 %8, 125
  %or.cond54 = or i1 %or.cond53, %cmp22
  %cmp27 = icmp eq i16 %8, 134
  %or.cond55 = or i1 %or.cond54, %cmp27
  br i1 %or.cond55, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false, %if.then
  tail call void @Perl_op_free(%struct.op* %5) #8
  store %struct.op* %6, %struct.op** %4, align 8, !tbaa !3
  br label %if.end32

if.end32:                                         ; preds = %entry, %if.end
  %o.addr.0 = phi %struct.op* [ %call2, %if.end ], [ %o, %entry ]
  %op_type33 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 4
  %10 = load i16* %op_type33, align 2, !tbaa !4
  %inc = add i16 %10, 1
  store i16 %inc, i16* %op_type33, align 2, !tbaa !4
  %idxprom34 = zext i16 %inc to i64
  %arrayidx35 = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom34
  %11 = load %struct.op* ()** %arrayidx35, align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 2
  store %struct.op* ()* %11, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %call36 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o.addr.0) #8
  br label %return

return:                                           ; preds = %land.lhs.true, %lor.lhs.false, %if.end32
  %retval.0 = phi %struct.op* [ %call36, %if.end32 ], [ %call2, %lor.lhs.false ], [ %call2, %land.lhs.true ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.op* @S_modkids(%struct.op* %o, i32 %type) #0 {
entry:
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool1 = icmp eq i8 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %kid.08 = load %struct.op** %1, align 8
  %tobool29 = icmp eq %struct.op* %kid.08, null
  br i1 %tobool29, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.010 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.08, %if.then ]
  %call = tail call %struct.op* @Perl_mod(%struct.op* %kid.010, i32 %type) #8
  %op_sibling = getelementptr inbounds %struct.op* %kid.010, i64 0, i32 1
  %kid.0 = load %struct.op** %op_sibling, align 8
  %tobool2 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool2, label %if.end, label %for.body

if.end:                                           ; preds = %if.then, %for.body, %land.lhs.true, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_fun(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %len = alloca i64, align 8
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %1 = load i32* %arrayidx, align 4, !tbaa !0
  %shr = lshr i32 %1, 13
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end12, label %if.then

if.then:                                          ; preds = %entry
  %and2 = and i32 %shr, 8
  %tobool3 = icmp eq i32 %and2, 0
  br i1 %tobool3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %shr4772 = lshr i32 %1, 17
  %tobool5 = icmp ne i32 %shr4772, 0
  %and8 = and i32 %shr4772, 8
  %tobool9 = icmp eq i32 %and8, 0
  %or.cond773 = and i1 %tobool5, %tobool9
  br i1 %or.cond773, label %if.then10, label %if.else

if.then10:                                        ; preds = %land.lhs.true
  %and11 = and i32 %shr, 524279
  br label %if.end12

if.else:                                          ; preds = %land.lhs.true, %if.then
  %call = call fastcc %struct.op* @S_no_fh_allowed(%struct.op* %o) #8
  br label %return

if.end12:                                         ; preds = %entry, %if.then10
  %oa.0 = phi i32 [ %and11, %if.then10 ], [ %shr, %entry ]
  %and15 = and i8 %2, 4
  %tobool16 = icmp eq i8 %and15, 0
  br i1 %tobool16, label %if.else566, label %if.then17

if.then17:                                        ; preds = %if.end12
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  %op_type19 = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type19, align 2, !tbaa !4
  switch i16 %5, label %if.end31 [
    i16 3, label %if.then29
    i16 0, label %land.lhs.true26
  ]

land.lhs.true26:                                  ; preds = %if.then17
  %op_targ = getelementptr inbounds %struct.op* %4, i64 0, i32 3
  %6 = load i64* %op_targ, align 8, !tbaa !5
  %cmp27 = icmp eq i64 %6, 3
  br i1 %cmp27, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.then17, %land.lhs.true26
  %op_sibling = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %7 = load %struct.op** %op_sibling, align 8, !tbaa !3
  br label %if.end31

if.end31:                                         ; preds = %if.then17, %if.then29, %land.lhs.true26
  %tokid.0 = phi %struct.op** [ %op_sibling, %if.then29 ], [ %3, %land.lhs.true26 ], [ %3, %if.then17 ]
  %kid.0 = phi %struct.op* [ %7, %if.then29 ], [ %4, %land.lhs.true26 ], [ %4, %if.then17 ]
  %tobool32 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool32, label %land.lhs.true33, label %while.cond.preheader

land.lhs.true33:                                  ; preds = %if.end31
  %and36 = and i32 %1, 128
  %tobool37 = icmp eq i32 %and36, 0
  br i1 %tobool37, label %while.cond.preheader, label %if.then38

if.then38:                                        ; preds = %land.lhs.true33
  %8 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %9 = bitcast %struct.gv* %8 to %struct.sv*
  store %struct.sv* %9, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i795 = icmp eq %struct.gv* %8, null
  br i1 %tobool.i795, label %Perl_newGVOP.exit799, label %land.rhs.i797

land.rhs.i797:                                    ; preds = %if.then38
  %10 = getelementptr inbounds %struct.gv* %8, i64 0, i32 1
  %11 = load i32* %10, align 4, !tbaa !0
  %inc.i796 = add i32 %11, 1
  store i32 %inc.i796, i32* %10, align 4, !tbaa !0
  br label %Perl_newGVOP.exit799

Perl_newGVOP.exit799:                             ; preds = %if.then38, %land.rhs.i797
  %call.i798 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %9) #7
  %call1.i = call %struct.op* @Perl_newSVREF(%struct.op* %call.i798) #7
  store %struct.op* %call1.i, %struct.op** %tokid.0, align 8, !tbaa !3
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %Perl_newGVOP.exit799, %if.end31, %land.lhs.true33
  %kid.1.ph = phi %struct.op* [ null, %land.lhs.true33 ], [ %kid.0, %if.end31 ], [ %call1.i, %Perl_newGVOP.exit799 ]
  %cmp56 = icmp eq i16 %0, 2
  %arrayidx166 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %op_private316 = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %12 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %while.cond.preheader, %sw.epilog
  %oa.1.ph = phi i32 [ %shr542, %sw.epilog ], [ %oa.0, %while.cond.preheader ]
  %numargs.0.ph = phi i32 [ %inc, %sw.epilog ], [ 0, %while.cond.preheader ]
  %tokid.1.ph = phi %struct.op** [ %op_sibling543, %sw.epilog ], [ %tokid.0, %while.cond.preheader ]
  %kid.1.ph815 = phi %struct.op* [ %167, %sw.epilog ], [ %kid.1.ph, %while.cond.preheader ]
  %not.tobool41 = icmp ne i32 %oa.1.ph, 0
  %and44 = and i32 %oa.1.ph, 7
  %cmp65 = icmp slt i32 %oa.1.ph, 16
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %sw.bb64
  %numargs.0 = phi i32 [ %inc, %sw.bb64 ], [ %numargs.0.ph, %while.cond.outer ]
  %kid.1 = phi %struct.op* [ null, %sw.bb64 ], [ %kid.1.ph815, %while.cond.outer ]
  %tobool42 = icmp ne %struct.op* %kid.1, null
  %.tobool42 = and i1 %tobool42, %not.tobool41
  br i1 %.tobool42, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %inc = add nsw i32 %numargs.0, 1
  %op_sibling43 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 1
  %13 = load %struct.op** %op_sibling43, align 8, !tbaa !3
  switch i32 %and44, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb64
    i32 3, label %sw.bb71
    i32 4, label %sw.bb185
    i32 5, label %sw.bb272
    i32 6, label %sw.bb278
    i32 7, label %sw.bb539
  ]

sw.bb:                                            ; preds = %while.body
  %cmp45 = icmp ne i32 %numargs.0, 0
  %tobool49 = icmp ugt i32 %oa.1.ph, 15
  %or.cond774 = or i1 %cmp45, %tobool49
  br i1 %or.cond774, label %if.end62, label %land.lhs.true50

land.lhs.true50:                                  ; preds = %sw.bb
  %op_type51 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  %14 = load i16* %op_type51, align 2, !tbaa !4
  %cmp53 = icmp ne i16 %14, 141
  %or.cond775 = or i1 %cmp53, %cmp56
  br i1 %or.cond775, label %if.end62, label %if.then58

if.then58:                                        ; preds = %land.lhs.true50
  %15 = load i8** %arrayidx166, align 8, !tbaa !3
  %call.i776 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([26 x i8]* @.str144, i64 0, i64 0), i8* %15) #7
  %call1.i777 = call i32 @Perl_yyerror(i8* %call.i776) #7
  br label %return

if.end62:                                         ; preds = %land.lhs.true50, %sw.bb
  %call63 = call %struct.op* @Perl_scalar(%struct.op* %kid.1) #8
  br label %sw.epilog

sw.bb64:                                          ; preds = %while.body
  br i1 %cmp65, label %while.cond, label %if.else68

if.else68:                                        ; preds = %sw.bb64
  %call69 = call %struct.op* @Perl_list(%struct.op* %kid.1) #8
  br label %sw.epilog

sw.bb71:                                          ; preds = %while.body
  switch i16 %0, label %if.end108 [
    i16 149, label %land.lhs.true77
    i16 146, label %land.lhs.true77
  ]

land.lhs.true77:                                  ; preds = %sw.bb71, %sw.bb71
  %tobool79 = icmp eq %struct.op* %13, null
  br i1 %tobool79, label %land.lhs.true80, label %if.end108

land.lhs.true80:                                  ; preds = %land.lhs.true77
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp81 = icmp eq %struct.sv* %17, null
  br i1 %cmp81, label %lor.lhs.false97, label %land.lhs.true83

land.lhs.true83:                                  ; preds = %land.lhs.true80
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings84 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings84, align 8, !tbaa !3
  %cmp85 = icmp eq %struct.sv* %19, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp85, label %lor.lhs.false97, label %land.lhs.true87

land.lhs.true87:                                  ; preds = %land.lhs.true83
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings88 = getelementptr inbounds %struct.cop* %20, i64 0, i32 14
  %21 = load %struct.sv** %cop_warnings88, align 8, !tbaa !3
  %cmp89 = icmp eq %struct.sv* %21, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp89, label %if.then105, label %lor.lhs.false91

lor.lhs.false91:                                  ; preds = %land.lhs.true87
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings92 = getelementptr inbounds %struct.cop* %22, i64 0, i32 14
  %23 = load %struct.sv** %cop_warnings92, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %23, i64 0, i32 0
  %24 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %24 to i8**
  %25 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx93 = getelementptr inbounds i8* %25, i64 7
  %26 = load i8* %arrayidx93, align 1, !tbaa !1
  %and95 = and i8 %26, 1
  %tobool96 = icmp eq i8 %and95, 0
  br i1 %tobool96, label %lor.lhs.false97, label %if.then105

lor.lhs.false97:                                  ; preds = %lor.lhs.false91, %land.lhs.true83, %land.lhs.true80
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings98 = getelementptr inbounds %struct.cop* %27, i64 0, i32 14
  %28 = load %struct.sv** %cop_warnings98, align 8, !tbaa !3
  %cmp99 = icmp eq %struct.sv* %28, null
  br i1 %cmp99, label %land.lhs.true101, label %if.end108

land.lhs.true101:                                 ; preds = %lor.lhs.false97
  %29 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and103 = and i8 %29, 1
  %tobool104 = icmp eq i8 %and103, 0
  br i1 %tobool104, label %if.end108, label %if.then105

if.then105:                                       ; preds = %lor.lhs.false91, %land.lhs.true101, %land.lhs.true87
  %30 = load i8** %arrayidx166, align 8, !tbaa !3
  call void (i32, i8*, ...)* @Perl_warner(i32 28, i8* getelementptr inbounds ([33 x i8]* @.str97, i64 0, i64 0), i8* %30) #7
  br label %if.end108

if.end108:                                        ; preds = %sw.bb71, %land.lhs.true101, %land.lhs.true77, %if.then105, %lor.lhs.false97
  %op_type109 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  %31 = load i16* %op_type109, align 2, !tbaa !4
  switch i16 %31, label %if.then179 [
    i16 5, label %land.lhs.true113
    i16 125, label %if.end183
    i16 10, label %if.end183
  ]

land.lhs.true113:                                 ; preds = %if.end108
  %op_private = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 7
  %32 = load i8* %op_private, align 1, !tbaa !1
  %and115 = and i8 %32, 64
  %tobool116 = icmp eq i8 %and115, 0
  br i1 %tobool116, label %if.then179, label %if.then117

if.then117:                                       ; preds = %land.lhs.true113
  %op_sv = getelementptr inbounds %struct.op* %kid.1, i64 1
  %33 = bitcast %struct.op* %op_sv to %struct.sv**
  %34 = load %struct.sv** %33, align 8, !tbaa !3
  store %struct.sv* %34, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %34, i64 0, i32 2
  %35 = load i32* %sv_flags, align 4, !tbaa !0
  %and118 = and i32 %35, 262144
  %cmp119 = icmp eq i32 %and118, 0
  br i1 %cmp119, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then117
  %sv_any121 = getelementptr inbounds %struct.sv* %34, i64 0, i32 0
  %36 = load i8** %sv_any121, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %36, i64 8
  %37 = bitcast i8* %xpv_cur to i64*
  %38 = load i64* %37, align 8, !tbaa !5
  store i64 %38, i64* %n_a, align 8, !tbaa !5
  %xpv_pv123 = bitcast i8* %36 to i8**
  %39 = load i8** %xpv_pv123, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.then117
  %call124 = call i8* @Perl_sv_2pv_flags(%struct.sv* %34, i64* %n_a, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %39, %cond.true ], [ %call124, %cond.false ]
  %call125 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 1, i32 10) #7
  %40 = bitcast %struct.gv* %call125 to %struct.sv*
  store %struct.sv* %40, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %call125, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %cond.end
  %41 = getelementptr inbounds %struct.gv* %call125, i64 0, i32 1
  %42 = load i32* %41, align 4, !tbaa !0
  %inc.i = add i32 %42, 1
  store i32 %inc.i, i32* %41, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %cond.end, %land.rhs.i
  %call.i778 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %40) #7
  %call127 = call %struct.op* @Perl_newAVREF(%struct.op* %call.i778) #8
  %43 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings128 = getelementptr inbounds %struct.cop* %43, i64 0, i32 14
  %44 = load %struct.sv** %cop_warnings128, align 8, !tbaa !3
  %cmp129 = icmp eq %struct.sv* %44, null
  br i1 %cmp129, label %lor.lhs.false155, label %land.lhs.true131

land.lhs.true131:                                 ; preds = %Perl_newGVOP.exit
  %45 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings132 = getelementptr inbounds %struct.cop* %45, i64 0, i32 14
  %46 = load %struct.sv** %cop_warnings132, align 8, !tbaa !3
  %cmp133 = icmp eq %struct.sv* %46, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp133, label %lor.lhs.false155, label %land.lhs.true135

land.lhs.true135:                                 ; preds = %land.lhs.true131
  %47 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings136 = getelementptr inbounds %struct.cop* %47, i64 0, i32 14
  %48 = load %struct.sv** %cop_warnings136, align 8, !tbaa !3
  %cmp137 = icmp eq %struct.sv* %48, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp137, label %if.then163, label %lor.lhs.false139

lor.lhs.false139:                                 ; preds = %land.lhs.true135
  %49 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings140 = getelementptr inbounds %struct.cop* %49, i64 0, i32 14
  %50 = load %struct.sv** %cop_warnings140, align 8, !tbaa !3
  %sv_any141 = getelementptr inbounds %struct.sv* %50, i64 0, i32 0
  %51 = load i8** %sv_any141, align 8, !tbaa !3
  %xpv_pv142 = bitcast i8* %51 to i8**
  %52 = load i8** %xpv_pv142, align 8, !tbaa !3
  %53 = load i8* %52, align 1, !tbaa !1
  %and145 = and i8 %53, 16
  %tobool146 = icmp eq i8 %and145, 0
  br i1 %tobool146, label %lor.lhs.false147, label %if.then163

lor.lhs.false147:                                 ; preds = %lor.lhs.false139
  %54 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings148 = getelementptr inbounds %struct.cop* %54, i64 0, i32 14
  %55 = load %struct.sv** %cop_warnings148, align 8, !tbaa !3
  %sv_any149 = getelementptr inbounds %struct.sv* %55, i64 0, i32 0
  %56 = load i8** %sv_any149, align 8, !tbaa !3
  %xpv_pv150 = bitcast i8* %56 to i8**
  %57 = load i8** %xpv_pv150, align 8, !tbaa !3
  %arrayidx151 = getelementptr inbounds i8* %57, i64 7
  %58 = load i8* %arrayidx151, align 1, !tbaa !1
  %and153 = and i8 %58, 1
  %tobool154 = icmp eq i8 %and153, 0
  br i1 %tobool154, label %lor.lhs.false155, label %if.then163

lor.lhs.false155:                                 ; preds = %lor.lhs.false147, %land.lhs.true131, %Perl_newGVOP.exit
  %59 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings156 = getelementptr inbounds %struct.cop* %59, i64 0, i32 14
  %60 = load %struct.sv** %cop_warnings156, align 8, !tbaa !3
  %cmp157 = icmp eq %struct.sv* %60, null
  br i1 %cmp157, label %land.lhs.true159, label %if.end167

land.lhs.true159:                                 ; preds = %lor.lhs.false155
  %61 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and161 = and i8 %61, 1
  %tobool162 = icmp eq i8 %and161, 0
  br i1 %tobool162, label %if.end167, label %if.then163

if.then163:                                       ; preds = %lor.lhs.false147, %lor.lhs.false139, %land.lhs.true159, %land.lhs.true135
  %conv164 = sext i32 %inc to i64
  %62 = load i8** %arrayidx166, align 8, !tbaa !3
  call void (i32, i8*, ...)* @Perl_warner(i32 7170, i8* getelementptr inbounds ([48 x i8]* @.str98, i64 0, i64 0), i8* %cond, i64 %conv164, i8* %62) #7
  br label %if.end167

if.end167:                                        ; preds = %land.lhs.true159, %if.then163, %lor.lhs.false155
  call void @Perl_op_free(%struct.op* %kid.1) #8
  %op_sibling168 = getelementptr inbounds %struct.op* %call127, i64 0, i32 1
  store %struct.op* %13, %struct.op** %op_sibling168, align 8, !tbaa !3
  store %struct.op* %call127, %struct.op** %tokid.1.ph, align 8, !tbaa !3
  br label %if.end183

if.then179:                                       ; preds = %if.end108, %land.lhs.true113
  %63 = load i8** %arrayidx166, align 8, !tbaa !3
  call fastcc void @S_bad_type(i32 %inc, i8* getelementptr inbounds ([6 x i8]* @.str99, i64 0, i64 0), i8* %63, %struct.op* %kid.1) #8
  br label %if.end183

if.end183:                                        ; preds = %if.end108, %if.end108, %if.then179, %if.end167
  %kid.2 = phi %struct.op* [ %call127, %if.end167 ], [ %kid.1, %if.then179 ], [ %kid.1, %if.end108 ], [ %kid.1, %if.end108 ]
  %call184 = call %struct.op* @Perl_mod(%struct.op* %kid.2, i32 %conv) #8
  br label %sw.epilog

sw.bb185:                                         ; preds = %while.body
  %op_type186 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  %64 = load i16* %op_type186, align 2, !tbaa !4
  switch i16 %64, label %if.then266 [
    i16 5, label %land.lhs.true190
    i16 134, label %if.end270
    i16 11, label %if.end270
  ]

land.lhs.true190:                                 ; preds = %sw.bb185
  %op_private191 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 7
  %65 = load i8* %op_private191, align 1, !tbaa !1
  %and193 = and i8 %65, 64
  %tobool194 = icmp eq i8 %and193, 0
  br i1 %tobool194, label %if.then266, label %if.then195

if.then195:                                       ; preds = %land.lhs.true190
  %op_sv197 = getelementptr inbounds %struct.op* %kid.1, i64 1
  %66 = bitcast %struct.op* %op_sv197 to %struct.sv**
  %67 = load %struct.sv** %66, align 8, !tbaa !3
  store %struct.sv* %67, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags198 = getelementptr inbounds %struct.sv* %67, i64 0, i32 2
  %68 = load i32* %sv_flags198, align 4, !tbaa !0
  %and199 = and i32 %68, 262144
  %cmp200 = icmp eq i32 %and199, 0
  br i1 %cmp200, label %cond.false207, label %cond.true202

cond.true202:                                     ; preds = %if.then195
  %sv_any203 = getelementptr inbounds %struct.sv* %67, i64 0, i32 0
  %69 = load i8** %sv_any203, align 8, !tbaa !3
  %xpv_cur204 = getelementptr inbounds i8* %69, i64 8
  %70 = bitcast i8* %xpv_cur204 to i64*
  %71 = load i64* %70, align 8, !tbaa !5
  store i64 %71, i64* %n_a, align 8, !tbaa !5
  %xpv_pv206 = bitcast i8* %69 to i8**
  %72 = load i8** %xpv_pv206, align 8, !tbaa !3
  br label %cond.end209

cond.false207:                                    ; preds = %if.then195
  %call208 = call i8* @Perl_sv_2pv_flags(%struct.sv* %67, i64* %n_a, i32 2) #7
  br label %cond.end209

cond.end209:                                      ; preds = %cond.false207, %cond.true202
  %cond210 = phi i8* [ %72, %cond.true202 ], [ %call208, %cond.false207 ]
  %call212 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond210, i32 1, i32 11) #7
  %73 = bitcast %struct.gv* %call212 to %struct.sv*
  store %struct.sv* %73, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i779 = icmp eq %struct.gv* %call212, null
  br i1 %tobool.i779, label %Perl_newGVOP.exit783, label %land.rhs.i781

land.rhs.i781:                                    ; preds = %cond.end209
  %74 = getelementptr inbounds %struct.gv* %call212, i64 0, i32 1
  %75 = load i32* %74, align 4, !tbaa !0
  %inc.i780 = add i32 %75, 1
  store i32 %inc.i780, i32* %74, align 4, !tbaa !0
  br label %Perl_newGVOP.exit783

Perl_newGVOP.exit783:                             ; preds = %cond.end209, %land.rhs.i781
  %call.i782 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %73) #7
  %call214 = call %struct.op* @Perl_newHVREF(%struct.op* %call.i782) #8
  %76 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings215 = getelementptr inbounds %struct.cop* %76, i64 0, i32 14
  %77 = load %struct.sv** %cop_warnings215, align 8, !tbaa !3
  %cmp216 = icmp eq %struct.sv* %77, null
  br i1 %cmp216, label %lor.lhs.false242, label %land.lhs.true218

land.lhs.true218:                                 ; preds = %Perl_newGVOP.exit783
  %78 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings219 = getelementptr inbounds %struct.cop* %78, i64 0, i32 14
  %79 = load %struct.sv** %cop_warnings219, align 8, !tbaa !3
  %cmp220 = icmp eq %struct.sv* %79, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp220, label %lor.lhs.false242, label %land.lhs.true222

land.lhs.true222:                                 ; preds = %land.lhs.true218
  %80 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings223 = getelementptr inbounds %struct.cop* %80, i64 0, i32 14
  %81 = load %struct.sv** %cop_warnings223, align 8, !tbaa !3
  %cmp224 = icmp eq %struct.sv* %81, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp224, label %if.then250, label %lor.lhs.false226

lor.lhs.false226:                                 ; preds = %land.lhs.true222
  %82 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings227 = getelementptr inbounds %struct.cop* %82, i64 0, i32 14
  %83 = load %struct.sv** %cop_warnings227, align 8, !tbaa !3
  %sv_any228 = getelementptr inbounds %struct.sv* %83, i64 0, i32 0
  %84 = load i8** %sv_any228, align 8, !tbaa !3
  %xpv_pv229 = bitcast i8* %84 to i8**
  %85 = load i8** %xpv_pv229, align 8, !tbaa !3
  %86 = load i8* %85, align 1, !tbaa !1
  %and232 = and i8 %86, 16
  %tobool233 = icmp eq i8 %and232, 0
  br i1 %tobool233, label %lor.lhs.false234, label %if.then250

lor.lhs.false234:                                 ; preds = %lor.lhs.false226
  %87 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings235 = getelementptr inbounds %struct.cop* %87, i64 0, i32 14
  %88 = load %struct.sv** %cop_warnings235, align 8, !tbaa !3
  %sv_any236 = getelementptr inbounds %struct.sv* %88, i64 0, i32 0
  %89 = load i8** %sv_any236, align 8, !tbaa !3
  %xpv_pv237 = bitcast i8* %89 to i8**
  %90 = load i8** %xpv_pv237, align 8, !tbaa !3
  %arrayidx238 = getelementptr inbounds i8* %90, i64 7
  %91 = load i8* %arrayidx238, align 1, !tbaa !1
  %and240 = and i8 %91, 1
  %tobool241 = icmp eq i8 %and240, 0
  br i1 %tobool241, label %lor.lhs.false242, label %if.then250

lor.lhs.false242:                                 ; preds = %lor.lhs.false234, %land.lhs.true218, %Perl_newGVOP.exit783
  %92 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings243 = getelementptr inbounds %struct.cop* %92, i64 0, i32 14
  %93 = load %struct.sv** %cop_warnings243, align 8, !tbaa !3
  %cmp244 = icmp eq %struct.sv* %93, null
  br i1 %cmp244, label %land.lhs.true246, label %if.end254

land.lhs.true246:                                 ; preds = %lor.lhs.false242
  %94 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and248 = and i8 %94, 1
  %tobool249 = icmp eq i8 %and248, 0
  br i1 %tobool249, label %if.end254, label %if.then250

if.then250:                                       ; preds = %lor.lhs.false234, %lor.lhs.false226, %land.lhs.true246, %land.lhs.true222
  %conv251 = sext i32 %inc to i64
  %95 = load i8** %arrayidx166, align 8, !tbaa !3
  call void (i32, i8*, ...)* @Perl_warner(i32 7170, i8* getelementptr inbounds ([49 x i8]* @.str100, i64 0, i64 0), i8* %cond210, i64 %conv251, i8* %95) #7
  br label %if.end254

if.end254:                                        ; preds = %land.lhs.true246, %if.then250, %lor.lhs.false242
  call void @Perl_op_free(%struct.op* %kid.1) #8
  %op_sibling255 = getelementptr inbounds %struct.op* %call214, i64 0, i32 1
  store %struct.op* %13, %struct.op** %op_sibling255, align 8, !tbaa !3
  store %struct.op* %call214, %struct.op** %tokid.1.ph, align 8, !tbaa !3
  br label %if.end270

if.then266:                                       ; preds = %sw.bb185, %land.lhs.true190
  %96 = load i8** %arrayidx166, align 8, !tbaa !3
  call fastcc void @S_bad_type(i32 %inc, i8* getelementptr inbounds ([5 x i8]* @.str101, i64 0, i64 0), i8* %96, %struct.op* %kid.1) #8
  br label %if.end270

if.end270:                                        ; preds = %sw.bb185, %sw.bb185, %if.then266, %if.end254
  %kid.3 = phi %struct.op* [ %call214, %if.end254 ], [ %kid.1, %if.then266 ], [ %kid.1, %sw.bb185 ], [ %kid.1, %sw.bb185 ]
  %call271 = call %struct.op* @Perl_mod(%struct.op* %kid.3, i32 %conv) #8
  br label %sw.epilog

sw.bb272:                                         ; preds = %while.body
  %call274 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %kid.1) #8
  store %struct.op* null, %struct.op** %op_sibling43, align 8, !tbaa !3
  %call276 = call %struct.op* @Perl_linklist(%struct.op* %kid.1) #8
  %op_next = getelementptr inbounds %struct.op* %call274, i64 0, i32 0
  store %struct.op* %call274, %struct.op** %op_next, align 8, !tbaa !3
  %op_sibling277 = getelementptr inbounds %struct.op* %call274, i64 0, i32 1
  store %struct.op* %13, %struct.op** %op_sibling277, align 8, !tbaa !3
  store %struct.op* %call274, %struct.op** %tokid.1.ph, align 8, !tbaa !3
  br label %sw.epilog

sw.bb278:                                         ; preds = %while.body
  %op_type279 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  %97 = load i16* %op_type279, align 2, !tbaa !4
  switch i16 %97, label %if.else326 [
    i16 7, label %if.end537
    i16 14, label %if.end537
    i16 5, label %land.lhs.true293
  ]

land.lhs.true293:                                 ; preds = %sw.bb278
  %op_private294 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 7
  %98 = load i8* %op_private294, align 1, !tbaa !1
  %and296 = and i8 %98, 64
  %tobool297 = icmp eq i8 %and296, 0
  br i1 %tobool297, label %if.else326.thread, label %if.then298

if.else326.thread:                                ; preds = %land.lhs.true293
  %99 = load i16* %op_type, align 2, !tbaa !4
  br label %if.else344

if.then298:                                       ; preds = %land.lhs.true293
  %op_sv300 = getelementptr inbounds %struct.op* %kid.1, i64 1
  %100 = bitcast %struct.op* %op_sv300 to %struct.sv**
  %101 = load %struct.sv** %100, align 8, !tbaa !3
  store %struct.sv* %101, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %sv_flags301 = getelementptr inbounds %struct.sv* %101, i64 0, i32 2
  %102 = load i32* %sv_flags301, align 4, !tbaa !0
  %and302 = and i32 %102, 262144
  %cmp303 = icmp eq i32 %and302, 0
  br i1 %cmp303, label %cond.false310, label %cond.true305

cond.true305:                                     ; preds = %if.then298
  %sv_any306 = getelementptr inbounds %struct.sv* %101, i64 0, i32 0
  %103 = load i8** %sv_any306, align 8, !tbaa !3
  %xpv_cur307 = getelementptr inbounds i8* %103, i64 8
  %104 = bitcast i8* %xpv_cur307 to i64*
  %105 = load i64* %104, align 8, !tbaa !5
  store i64 %105, i64* %n_a, align 8, !tbaa !5
  %xpv_pv309 = bitcast i8* %103 to i8**
  %106 = load i8** %xpv_pv309, align 8, !tbaa !3
  br label %cond.end312

cond.false310:                                    ; preds = %if.then298
  %call311 = call i8* @Perl_sv_2pv_flags(%struct.sv* %101, i64* %n_a, i32 2) #7
  br label %cond.end312

cond.end312:                                      ; preds = %cond.false310, %cond.true305
  %cond313 = phi i8* [ %106, %cond.true305 ], [ %call311, %cond.false310 ]
  %call314 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond313, i32 1, i32 15) #7
  %107 = bitcast %struct.gv* %call314 to %struct.sv*
  store %struct.sv* %107, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i784 = icmp eq %struct.gv* %call314, null
  br i1 %tobool.i784, label %Perl_newGVOP.exit788, label %land.rhs.i786

land.rhs.i786:                                    ; preds = %cond.end312
  %108 = getelementptr inbounds %struct.gv* %call314, i64 0, i32 1
  %109 = load i32* %108, align 4, !tbaa !0
  %inc.i785 = add i32 %109, 1
  store i32 %inc.i785, i32* %108, align 4, !tbaa !0
  br label %Perl_newGVOP.exit788

Perl_newGVOP.exit788:                             ; preds = %cond.end312, %land.rhs.i786
  %call.i787 = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %107) #7
  %110 = load i8* %op_private316, align 1, !tbaa !1
  %and318 = and i8 %110, 1
  %tobool319 = icmp eq i8 %and318, 0
  br i1 %tobool319, label %land.lhs.true320, label %if.end325

land.lhs.true320:                                 ; preds = %Perl_newGVOP.exit788
  %111 = load %struct.op** %12, align 8, !tbaa !3
  %cmp321 = icmp eq %struct.op* %kid.1, %111
  br i1 %cmp321, label %if.then323, label %if.end325

if.then323:                                       ; preds = %land.lhs.true320
  store %struct.op* %call.i787, %struct.op** %12, align 8, !tbaa !3
  br label %if.end325

if.end325:                                        ; preds = %Perl_newGVOP.exit788, %if.then323, %land.lhs.true320
  call void @Perl_op_free(%struct.op* %kid.1) #8
  br label %if.end535

if.else326:                                       ; preds = %sw.bb278
  %cmp329 = icmp eq i16 %97, 26
  %112 = load i16* %op_type, align 2, !tbaa !4
  br i1 %cmp329, label %if.then331, label %if.else344

if.then331:                                       ; preds = %if.else326
  %cmp334 = icmp eq i16 %112, 351
  br i1 %cmp334, label %cond.true336, label %cond.false338

cond.true336:                                     ; preds = %if.then331
  %call337 = call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end342

cond.false338:                                    ; preds = %if.then331
  %idxprom340 = zext i16 %112 to i64
  %arrayidx341 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom340
  %113 = load i8** %arrayidx341, align 8, !tbaa !3
  br label %cond.end342

cond.end342:                                      ; preds = %cond.false338, %cond.true336
  %cond343 = phi i8* [ %call337, %cond.true336 ], [ %113, %cond.false338 ]
  call fastcc void @S_bad_type(i32 %inc, i8* getelementptr inbounds ([7 x i8]* @.str102, i64 0, i64 0), i8* %cond343, %struct.op* %kid.1) #8
  br label %if.end535

if.else344:                                       ; preds = %if.else326.thread, %if.else326
  %114 = phi i16 [ %99, %if.else326.thread ], [ %112, %if.else326 ]
  %.pr807904 = phi i16 [ 5, %if.else326.thread ], [ %97, %if.else326 ]
  %conv.i = zext i16 %114 to i32
  switch i32 %conv.i, label %if.end526 [
    i32 193, label %sw.bb.i
    i32 224, label %sw.bb.i
    i32 210, label %sw.bb2.i
    i32 191, label %sw.bb2.i
    i32 203, label %sw.bb2.i
    i32 223, label %sw.bb2.i
    i32 275, label %sw.bb2.i
    i32 228, label %sw.bb2.i
  ]

sw.bb.i:                                          ; preds = %if.else344, %if.else344
  %switch.i = icmp ult i32 %numargs.0, 2
  br i1 %switch.i, label %if.then347, label %if.end526

sw.bb2.i:                                         ; preds = %if.else344, %if.else344, %if.else344, %if.else344, %if.else344, %if.else344
  %cmp3.i = icmp eq i32 %numargs.0, 0
  br i1 %cmp3.i, label %if.then347, label %if.end526

if.then347:                                       ; preds = %sw.bb.i, %sw.bb2.i
  store i64 0, i64* %len, align 8, !tbaa !5
  switch i16 %.pr807904, label %if.end526 [
    i16 9, label %if.then353
    i16 15, label %land.lhs.true383
    i16 127, label %if.then404
    i16 135, label %if.then404
  ]

if.then353:                                       ; preds = %if.then347
  %115 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %op_targ354 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 3
  %116 = load i64* %op_targ354, align 8, !tbaa !5
  %conv355 = trunc i64 %116 to i32
  %call356 = call %struct.sv** @Perl_av_fetch(%struct.av* %115, i32 %conv355, i32 0) #7
  %117 = load %struct.sv** %call356, align 8, !tbaa !3
  %sv_flags357 = getelementptr inbounds %struct.sv* %117, i64 0, i32 2
  %118 = load i32* %sv_flags357, align 4, !tbaa !0
  %and358 = and i32 %118, 262144
  %cmp359 = icmp eq i32 %and358, 0
  %119 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %120 = load i64* %op_targ354, align 8, !tbaa !5
  %conv363 = trunc i64 %120 to i32
  %call364 = call %struct.sv** @Perl_av_fetch(%struct.av* %119, i32 %conv363, i32 0) #7
  %121 = load %struct.sv** %call364, align 8, !tbaa !3
  br i1 %cmp359, label %cond.false367, label %cond.true361

cond.true361:                                     ; preds = %if.then353
  %sv_any365 = getelementptr inbounds %struct.sv* %121, i64 0, i32 0
  %122 = load i8** %sv_any365, align 8, !tbaa !3
  %xpv_pv366 = bitcast i8* %122 to i8**
  %123 = load i8** %xpv_pv366, align 8, !tbaa !3
  br label %cond.end372

cond.false367:                                    ; preds = %if.then353
  %call371 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %121) #7
  br label %cond.end372

cond.end372:                                      ; preds = %cond.false367, %cond.true361
  %cond373 = phi i8* [ %123, %cond.true361 ], [ %call371, %cond.false367 ]
  %tobool374 = icmp eq i8* %cond373, null
  br i1 %tobool374, label %if.end526, label %if.then375

if.then375:                                       ; preds = %cond.end372
  %call376 = call i64 @strlen(i8* %cond373) #7
  store i64 %call376, i64* %len, align 8, !tbaa !5
  br label %if.then510

land.lhs.true383:                                 ; preds = %if.then347
  %124 = getelementptr inbounds %struct.op* %kid.1, i64 1, i32 0
  %125 = load %struct.op** %124, align 8, !tbaa !3
  %op_type385 = getelementptr inbounds %struct.op* %125, i64 0, i32 4
  %126 = load i16* %op_type385, align 2, !tbaa !4
  %cmp387 = icmp eq i16 %126, 7
  br i1 %cmp387, label %if.end508, label %if.end526

if.then404:                                       ; preds = %if.then347, %if.then347
  %127 = getelementptr inbounds %struct.op* %kid.1, i64 1, i32 0
  %128 = load %struct.op** %127, align 8, !tbaa !3
  %tobool406 = icmp eq %struct.op* %128, null
  br i1 %tobool406, label %if.then503, label %if.then407

if.then407:                                       ; preds = %if.then404
  %cmp410 = icmp eq i16 %.pr807904, 127
  %cond412 = select i1 %cmp410, i8* getelementptr inbounds ([3 x i8]* @.str103, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8]* @.str104, i64 0, i64 0)
  %op_type413 = getelementptr inbounds %struct.op* %128, i64 0, i32 4
  %129 = load i16* %op_type413, align 2, !tbaa !4
  switch i16 %129, label %if.else443 [
    i16 125, label %land.lhs.true422
    i16 134, label %land.lhs.true422
  ]

land.lhs.true422:                                 ; preds = %if.then407, %if.then407
  %130 = getelementptr inbounds %struct.op* %128, i64 1, i32 0
  %131 = load %struct.op** %130, align 8, !tbaa !3
  %tobool424 = icmp eq %struct.op* %131, null
  br i1 %tobool424, label %land.lhs.true422.if.else443_crit_edge, label %land.lhs.true425

land.lhs.true422.if.else443_crit_edge:            ; preds = %land.lhs.true422
  %.pre = load i16* inttoptr (i64 32 to i16*), align 32, !tbaa !4
  br label %if.else443

land.lhs.true425:                                 ; preds = %land.lhs.true422
  %op_type426 = getelementptr inbounds %struct.op* %131, i64 0, i32 4
  %132 = load i16* %op_type426, align 2, !tbaa !4
  %cmp428 = icmp eq i16 %132, 7
  br i1 %cmp428, label %if.then430, label %if.else443

if.then430:                                       ; preds = %land.lhs.true425
  %op_sv432 = getelementptr inbounds %struct.op* %131, i64 1
  %133 = bitcast %struct.op* %op_sv432 to %struct.sv**
  %134 = load %struct.sv** %133, align 8, !tbaa !3
  %tobool433 = icmp eq %struct.sv* %134, null
  br i1 %tobool433, label %if.then503, label %if.then434

if.then434:                                       ; preds = %if.then430
  %sv_any435 = bitcast %struct.sv* %134 to %struct.xpvgv**
  %135 = load %struct.xpvgv** %sv_any435, align 8, !tbaa !3
  %xgv_name436 = getelementptr inbounds %struct.xpvgv* %135, i64 0, i32 8
  %136 = load i8** %xgv_name436, align 8, !tbaa !3
  %137 = load i8* %cond412, align 1, !tbaa !1
  %conv438 = sext i8 %137 to i32
  %arrayidx439 = getelementptr inbounds i8* %cond412, i64 1
  %138 = load i8* %arrayidx439, align 1, !tbaa !1
  %conv440 = sext i8 %138 to i32
  %call441 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8]* @.str105, i64 0, i64 0), i8* %136, i32 %conv438, i32 %conv440) #7
  br label %if.end483

if.else443:                                       ; preds = %land.lhs.true422.if.else443_crit_edge, %if.then407, %land.lhs.true425
  %139 = phi i16 [ %132, %land.lhs.true425 ], [ %.pre, %land.lhs.true422.if.else443_crit_edge ], [ %129, %if.then407 ]
  %op.0 = phi %struct.op* [ %131, %land.lhs.true425 ], [ null, %land.lhs.true422.if.else443_crit_edge ], [ %128, %if.then407 ]
  %.off = add i16 %139, -10
  %switch = icmp ult i16 %.off, 2
  br i1 %switch, label %if.then453, label %if.then503

if.then453:                                       ; preds = %if.else443
  %140 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %op_targ454 = getelementptr inbounds %struct.op* %op.0, i64 0, i32 3
  %141 = load i64* %op_targ454, align 8, !tbaa !5
  %conv455 = trunc i64 %141 to i32
  %call456 = call %struct.sv** @Perl_av_fetch(%struct.av* %140, i32 %conv455, i32 0) #7
  %142 = load %struct.sv** %call456, align 8, !tbaa !3
  %sv_flags457 = getelementptr inbounds %struct.sv* %142, i64 0, i32 2
  %143 = load i32* %sv_flags457, align 4, !tbaa !0
  %and458 = and i32 %143, 262144
  %cmp459 = icmp eq i32 %and458, 0
  %144 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %145 = load i64* %op_targ454, align 8, !tbaa !5
  %conv463 = trunc i64 %145 to i32
  %call464 = call %struct.sv** @Perl_av_fetch(%struct.av* %144, i32 %conv463, i32 0) #7
  %146 = load %struct.sv** %call464, align 8, !tbaa !3
  br i1 %cmp459, label %cond.false467, label %cond.true461

cond.true461:                                     ; preds = %if.then453
  %sv_any465 = getelementptr inbounds %struct.sv* %146, i64 0, i32 0
  %147 = load i8** %sv_any465, align 8, !tbaa !3
  %xpv_pv466 = bitcast i8* %147 to i8**
  %148 = load i8** %xpv_pv466, align 8, !tbaa !3
  br label %cond.end472

cond.false467:                                    ; preds = %if.then453
  %call471 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %146) #7
  br label %cond.end472

cond.end472:                                      ; preds = %cond.false467, %cond.true461
  %cond473 = phi i8* [ %148, %cond.true461 ], [ %call471, %cond.false467 ]
  %tobool474 = icmp eq i8* %cond473, null
  br i1 %tobool474, label %if.then503, label %if.then475

if.then475:                                       ; preds = %cond.end472
  %add.ptr = getelementptr inbounds i8* %cond473, i64 1
  %149 = load i8* %cond412, align 1, !tbaa !1
  %conv477 = sext i8 %149 to i32
  %arrayidx478 = getelementptr inbounds i8* %cond412, i64 1
  %150 = load i8* %arrayidx478, align 1, !tbaa !1
  %conv479 = sext i8 %150 to i32
  %call480 = call %struct.sv* (i8*, ...)* @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8]* @.str105, i64 0, i64 0), i8* %add.ptr, i32 %conv477, i32 %conv479) #7
  br label %if.end483

if.end483:                                        ; preds = %if.then475, %if.then434
  %tmpstr.0 = phi %struct.sv* [ %call441, %if.then434 ], [ %call480, %if.then475 ]
  %tobool484 = icmp eq %struct.sv* %tmpstr.0, null
  br i1 %tobool484, label %if.then503, label %if.then485

if.then485:                                       ; preds = %if.end483
  %sv_flags486 = getelementptr inbounds %struct.sv* %tmpstr.0, i64 0, i32 2
  %151 = load i32* %sv_flags486, align 4, !tbaa !0
  %and487 = and i32 %151, 262144
  %cmp488 = icmp eq i32 %and487, 0
  br i1 %cmp488, label %cond.false495, label %cond.true490

cond.true490:                                     ; preds = %if.then485
  %sv_any491 = getelementptr inbounds %struct.sv* %tmpstr.0, i64 0, i32 0
  %152 = load i8** %sv_any491, align 8, !tbaa !3
  %xpv_cur492 = getelementptr inbounds i8* %152, i64 8
  %153 = bitcast i8* %xpv_cur492 to i64*
  %154 = load i64* %153, align 8, !tbaa !5
  store i64 %154, i64* %len, align 8, !tbaa !5
  %xpv_pv494 = bitcast i8* %152 to i8**
  %155 = load i8** %xpv_pv494, align 8, !tbaa !3
  br label %if.end501

cond.false495:                                    ; preds = %if.then485
  %call496 = call i8* @Perl_sv_2pv_flags(%struct.sv* %tmpstr.0, i64* %len, i32 2) #7
  br label %if.end501

if.end501:                                        ; preds = %cond.true490, %cond.false495
  %cond498 = phi i8* [ %155, %cond.true490 ], [ %call496, %cond.false495 ]
  %call499 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %tmpstr.0) #7
  %tobool502 = icmp eq i8* %cond498, null
  br i1 %tobool502, label %if.then503, label %if.end504

if.then503:                                       ; preds = %if.else443, %cond.end472, %if.then430, %if.then404, %if.end483, %if.end501
  store i64 10, i64* %len, align 8, !tbaa !5
  br label %if.end504

if.end504:                                        ; preds = %if.end501, %if.then503
  %name348.1 = phi i8* [ %cond498, %if.end501 ], [ getelementptr inbounds ([11 x i8]* @.str106, i64 0, i64 0), %if.then503 ]
  %call505 = call %struct.op* @Perl_mod(%struct.op* %kid.1, i32 %conv) #8
  br label %if.then510

if.end508:                                        ; preds = %land.lhs.true383
  %op_sv391 = getelementptr inbounds %struct.op* %125, i64 1
  %156 = bitcast %struct.op* %op_sv391 to %struct.sv**
  %157 = load %struct.sv** %156, align 8, !tbaa !3
  %sv_any392 = bitcast %struct.sv* %157 to %struct.xpvgv**
  %158 = load %struct.xpvgv** %sv_any392, align 8, !tbaa !3
  %xgv_name = getelementptr inbounds %struct.xpvgv* %158, i64 0, i32 8
  %159 = load i8** %xgv_name, align 8, !tbaa !3
  %xgv_namelen = getelementptr inbounds %struct.xpvgv* %158, i64 0, i32 9
  %160 = load i64* %xgv_namelen, align 8, !tbaa !5
  store i64 %160, i64* %len, align 8, !tbaa !5
  %tobool509 = icmp eq i8* %159, null
  br i1 %tobool509, label %if.end526, label %if.then510

if.then510:                                       ; preds = %if.end504, %if.then375, %if.end508
  %name348.2814 = phi i8* [ %159, %if.end508 ], [ %cond373, %if.then375 ], [ %name348.1, %if.end504 ]
  %call511 = call i64 @Perl_pad_alloc(i32 14, i32 512) #7
  %161 = load %struct.sv*** @PL_curpad, align 8, !tbaa !3
  %arrayidx512 = getelementptr inbounds %struct.sv** %161, i64 %call511
  %162 = load %struct.sv** %arrayidx512, align 8, !tbaa !3
  %sv_flags513 = getelementptr inbounds %struct.sv* %162, i64 0, i32 2
  %163 = load i32* %sv_flags513, align 4, !tbaa !0
  %and514 = and i32 %163, 252
  %cmp515 = icmp eq i32 %and514, 0
  br i1 %cmp515, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.then510
  %call517 = call signext i8 @Perl_sv_upgrade(%struct.sv* %162, i32 4) #7
  br label %lor.end

lor.end:                                          ; preds = %if.then510, %lor.rhs
  %164 = load i8* %name348.2814, align 1, !tbaa !1
  %cmp521 = icmp eq i8 %164, 36
  br i1 %cmp521, label %if.end524, label %if.then523

if.then523:                                       ; preds = %lor.end
  call void @Perl_sv_setpvn(%struct.sv* %162, i8* getelementptr inbounds ([2 x i8]* @.str107, i64 0, i64 0), i64 1) #7
  br label %if.end524

if.end524:                                        ; preds = %lor.end, %if.then523
  %165 = load i64* %len, align 8, !tbaa !5
  call void @Perl_sv_catpvn_flags(%struct.sv* %162, i8* %name348.2814, i64 %165, i32 2) #7
  br label %if.end526

if.end526:                                        ; preds = %if.then347, %land.lhs.true383, %cond.end372, %sw.bb2.i, %sw.bb.i, %if.else344, %if.end508, %if.end524
  %flags.0 = phi i32 [ 0, %if.end524 ], [ 0, %if.end508 ], [ 128, %if.else344 ], [ 128, %sw.bb.i ], [ 128, %sw.bb2.i ], [ 0, %cond.end372 ], [ 0, %land.lhs.true383 ], [ 0, %if.then347 ]
  %priv.0 = phi i8 [ 96, %if.end524 ], [ 96, %if.end508 ], [ 0, %if.else344 ], [ 0, %sw.bb.i ], [ 0, %sw.bb2.i ], [ 96, %cond.end372 ], [ 96, %land.lhs.true383 ], [ 96, %if.then347 ]
  %targ.0 = phi i64 [ %call511, %if.end524 ], [ 0, %if.end508 ], [ 0, %if.else344 ], [ 0, %sw.bb.i ], [ 0, %sw.bb2.i ], [ 0, %cond.end372 ], [ 0, %land.lhs.true383 ], [ 0, %if.then347 ]
  store %struct.op* null, %struct.op** %op_sibling43, align 8, !tbaa !3
  %call528 = call %struct.op* @Perl_scalar(%struct.op* %kid.1) #8
  %call529 = call %struct.op* @Perl_newUNOP(i32 14, i32 %flags.0, %struct.op* %call528) #8
  %op_targ530 = getelementptr inbounds %struct.op* %call529, i64 0, i32 3
  store i64 %targ.0, i64* %op_targ530, align 8, !tbaa !5
  %op_private531 = getelementptr inbounds %struct.op* %call529, i64 0, i32 7
  %166 = load i8* %op_private531, align 1, !tbaa !1
  %or = or i8 %166, %priv.0
  store i8 %or, i8* %op_private531, align 1, !tbaa !1
  br label %if.end535

if.end535:                                        ; preds = %cond.end342, %if.end526, %if.end325
  %kid.4 = phi %struct.op* [ %call.i787, %if.end325 ], [ %kid.1, %cond.end342 ], [ %call529, %if.end526 ]
  %op_sibling536 = getelementptr inbounds %struct.op* %kid.4, i64 0, i32 1
  store %struct.op* %13, %struct.op** %op_sibling536, align 8, !tbaa !3
  store %struct.op* %kid.4, %struct.op** %tokid.1.ph, align 8, !tbaa !3
  br label %if.end537

if.end537:                                        ; preds = %sw.bb278, %sw.bb278, %if.end535
  %kid.5 = phi %struct.op* [ %kid.4, %if.end535 ], [ %kid.1, %sw.bb278 ], [ %kid.1, %sw.bb278 ]
  %call538 = call %struct.op* @Perl_scalar(%struct.op* %kid.5) #8
  br label %sw.epilog

sw.bb539:                                         ; preds = %while.body
  %call540 = call %struct.op* @Perl_scalar(%struct.op* %kid.1) #8
  %call541 = call %struct.op* @Perl_mod(%struct.op* %call540, i32 %conv) #8
  br label %sw.epilog

sw.epilog:                                        ; preds = %while.body, %sw.bb539, %if.end537, %sw.bb272, %if.end270, %if.end183, %if.else68, %if.end62
  %kid.6 = phi %struct.op* [ %kid.1, %sw.bb539 ], [ %kid.5, %if.end537 ], [ %call274, %sw.bb272 ], [ %kid.3, %if.end270 ], [ %kid.2, %if.end183 ], [ %kid.1, %if.else68 ], [ %kid.1, %if.end62 ], [ %kid.1, %while.body ]
  %shr542 = ashr i32 %oa.1.ph, 4
  %op_sibling543 = getelementptr inbounds %struct.op* %kid.6, i64 0, i32 1
  %167 = load %struct.op** %op_sibling543, align 8, !tbaa !3
  br label %while.cond.outer

while.end:                                        ; preds = %while.cond
  %168 = load i8* %op_private316, align 1, !tbaa !1
  %conv546 = zext i8 %168 to i32
  %or547 = or i32 %conv546, %numargs.0
  %conv548 = trunc i32 %or547 to i8
  store i8 %conv548, i8* %op_private316, align 1, !tbaa !1
  %tobool549 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool549, label %if.end564, label %if.then550

if.then550:                                       ; preds = %while.end
  %169 = load i16* %op_type, align 2, !tbaa !4
  %cmp553 = icmp eq i16 %169, 351
  br i1 %cmp553, label %cond.true555, label %cond.false557

cond.true555:                                     ; preds = %if.then550
  %call556 = call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end561

cond.false557:                                    ; preds = %if.then550
  %idxprom559 = zext i16 %169 to i64
  %arrayidx560 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom559
  %170 = load i8** %arrayidx560, align 8, !tbaa !3
  br label %cond.end561

cond.end561:                                      ; preds = %cond.false557, %cond.true555
  %cond562 = phi i8* [ %call556, %cond.true555 ], [ %170, %cond.false557 ]
  %call.i789 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([26 x i8]* @.str144, i64 0, i64 0), i8* %cond562) #7
  %call1.i790 = call i32 @Perl_yyerror(i8* %call.i789) #7
  br label %return

if.end564:                                        ; preds = %while.end
  %call565 = call %struct.op* @Perl_listkids(%struct.op* %o) #8
  br label %if.end575

if.else566:                                       ; preds = %if.end12
  %and569 = and i32 %1, 128
  %tobool570 = icmp eq i32 %and569, 0
  br i1 %tobool570, label %if.end575, label %if.then571

if.then571:                                       ; preds = %if.else566
  call void @Perl_op_free(%struct.op* %o) #8
  %171 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %172 = bitcast %struct.gv* %171 to %struct.sv*
  store %struct.sv* %172, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i800 = icmp eq %struct.gv* %171, null
  br i1 %tobool.i800, label %Perl_newGVOP.exit803, label %land.rhs.i802

land.rhs.i802:                                    ; preds = %if.then571
  %173 = getelementptr inbounds %struct.gv* %171, i64 0, i32 1
  %174 = load i32* %173, align 4, !tbaa !0
  %inc.i801 = add i32 %174, 1
  store i32 %inc.i801, i32* %173, align 4, !tbaa !0
  br label %Perl_newGVOP.exit803

Perl_newGVOP.exit803:                             ; preds = %if.then571, %land.rhs.i802
  %call.i = call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %172) #7
  %call1.i792 = call %struct.op* @Perl_newSVREF(%struct.op* %call.i) #7
  %call573 = call %struct.op* @Perl_newUNOP(i32 %conv, i32 0, %struct.op* %call1.i792) #8
  br label %return

if.end575:                                        ; preds = %if.else566, %if.end564
  %oa.2 = phi i32 [ %oa.1.ph, %if.end564 ], [ %oa.0, %if.else566 ]
  %tobool576 = icmp eq i32 %oa.2, 0
  br i1 %tobool576, label %return, label %while.cond578

while.cond578:                                    ; preds = %if.end575, %while.cond578
  %oa.3 = phi i32 [ %shr582, %while.cond578 ], [ %oa.2, %if.end575 ]
  %and579 = and i32 %oa.3, 8
  %tobool580 = icmp eq i32 %and579, 0
  %shr582 = ashr i32 %oa.3, 4
  br i1 %tobool580, label %while.end583, label %while.cond578

while.end583:                                     ; preds = %while.cond578
  switch i32 %oa.3, label %if.then588 [
    i32 2, label %return
    i32 0, label %return
  ]

if.then588:                                       ; preds = %while.end583
  %175 = load i16* %op_type, align 2, !tbaa !4
  %cmp591 = icmp eq i16 %175, 351
  br i1 %cmp591, label %cond.true593, label %cond.false595

cond.true593:                                     ; preds = %if.then588
  %call594 = call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end599

cond.false595:                                    ; preds = %if.then588
  %idxprom597 = zext i16 %175 to i64
  %arrayidx598 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom597
  %176 = load i8** %arrayidx598, align 8, !tbaa !3
  br label %cond.end599

cond.end599:                                      ; preds = %cond.false595, %cond.true593
  %cond600 = phi i8* [ %call594, %cond.true593 ], [ %176, %cond.false595 ]
  %call.i793 = call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([28 x i8]* @.str142, i64 0, i64 0), i8* %cond600) #7
  %call1.i794 = call i32 @Perl_yyerror(i8* %call.i793) #7
  br label %return

return:                                           ; preds = %if.end575, %while.end583, %while.end583, %cond.end599, %Perl_newGVOP.exit803, %cond.end561, %if.then58, %if.else
  %retval.0 = phi %struct.op* [ %call, %if.else ], [ %o, %if.then58 ], [ %o, %cond.end561 ], [ %o, %cond.end599 ], [ %call573, %Perl_newGVOP.exit803 ], [ %o, %while.end583 ], [ %o, %while.end583 ], [ %o, %if.end575 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_delete(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  store i8 0, i8* %op_private, align 1, !tbaa !1
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %3 = load i16* %op_type, align 2, !tbaa !4
  %conv1 = zext i16 %3 to i32
  switch i32 %conv1, label %sw.default [
    i32 128, label %sw.bb
    i32 136, label %sw.bb5
    i32 127, label %sw.bb10
    i32 135, label %sw.epilog
  ]

sw.bb:                                            ; preds = %if.then
  %or = or i8 %0, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  br label %sw.bb5

sw.bb5:                                           ; preds = %if.then, %sw.bb
  store i8 64, i8* %op_private, align 1, !tbaa !1
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.then
  %or13 = or i8 %0, -128
  store i8 %or13, i8* %op_flags, align 1, !tbaa !1
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %op_type15 = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %4 = load i16* %op_type15, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.default
  %call18 = tail call i8* @Perl_custom_op_desc(%struct.op* %call) #8
  br label %cond.end

cond.false:                                       ; preds = %sw.default
  %idxprom = zext i16 %4 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %5 = load i8** %arrayidx, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call18, %cond.true ], [ %5, %cond.false ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([52 x i8]* @.str88, i64 0, i64 0), i8* %cond) #7
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %sw.bb10, %if.then, %sw.bb5
  tail call void @Perl_op_null(%struct.op* %2) #8
  br label %if.end

if.end:                                           ; preds = %entry, %sw.epilog
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_die(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_eof(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %entry
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %op_type2 = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type2, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 1
  br i1 %cmp, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  tail call void @Perl_op_free(%struct.op* %o) #8
  %5 = load %struct.gv** @PL_argvgv, align 8, !tbaa !3
  %6 = bitcast %struct.gv* %5 to %struct.sv*
  store %struct.sv* %6, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %5, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then5
  %7 = getelementptr inbounds %struct.gv* %5, i64 0, i32 1
  %8 = load i32* %7, align 4, !tbaa !0
  %inc.i = add i32 %8, 1
  store i32 %inc.i, i32* %7, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then5, %land.rhs.i
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %6) #7
  %call6 = tail call %struct.op* @Perl_newUNOP(i32 %conv, i32 128, %struct.op* %call.i) #8
  br label %if.end

if.end:                                           ; preds = %Perl_newGVOP.exit, %if.then
  %o.addr.0 = phi %struct.op* [ %call6, %Perl_newGVOP.exit ], [ %o, %if.then ]
  %call7 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o.addr.0) #8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi %struct.op* [ %call7, %if.end ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_eval(%struct.op* %o) #0 {
entry:
  %0 = load i32* @PL_hints, align 4, !tbaa !0
  %or = or i32 %0, 256
  store i32 %or, i32* @PL_hints, align 4, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else22, label %if.then

if.then:                                          ; preds = %entry
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %and5 = and i8 %1, -5
  store i8 %and5, i8* %op_flags, align 1, !tbaa !1
  tail call void @Perl_op_null(%struct.op* %o) #8
  br label %if.end25

if.else:                                          ; preds = %if.then
  %4 = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %5 = load i16* %4, align 2, !tbaa !4
  switch i16 %5, label %if.else19 [
    i16 173, label %if.then13
    i16 1, label %if.then13
  ]

if.then13:                                        ; preds = %if.else, %if.else
  store %struct.op* null, %struct.op** %2, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %o) #8
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %op_type15 = getelementptr inbounds i8* %call, i64 32
  %6 = bitcast i8* %op_type15 to i16*
  store i16 313, i16* %6, align 2, !tbaa !4
  %7 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 313), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds i8* %call, i64 16
  %8 = bitcast i8* %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* %7, %struct.op* ()** %8, align 8, !tbaa !3
  %9 = getelementptr inbounds i8* %call, i64 37
  store i8 0, i8* %9, align 1, !tbaa !1
  %10 = bitcast i8* %call to %struct.op*
  %op_next = bitcast i8* %call to %struct.op**
  store %struct.op* %10, %struct.op** %op_next, align 8, !tbaa !3
  %call16 = tail call %struct.op* @Perl_prepend_elem(i32 173, %struct.op* %10, %struct.op* %3) #8
  %op_type17 = getelementptr inbounds %struct.op* %call16, i64 0, i32 4
  store i16 314, i16* %op_type17, align 2, !tbaa !4
  %11 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 314), align 8, !tbaa !3
  %op_ppaddr18 = getelementptr inbounds %struct.op* %call16, i64 0, i32 2
  store %struct.op* ()* %11, %struct.op* ()** %op_ppaddr18, align 8, !tbaa !3
  %op_other = getelementptr inbounds i8* %call, i64 48
  %12 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %call16, %struct.op** %12, align 8, !tbaa !3
  br label %return

if.else19:                                        ; preds = %if.else
  %call20 = tail call %struct.op* @Perl_scalar(%struct.op* %3) #8
  br label %if.end25

if.else22:                                        ; preds = %entry
  tail call void @Perl_op_free(%struct.op* %o) #8
  %13 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %14 = bitcast %struct.gv* %13 to %struct.sv*
  store %struct.sv* %14, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %13, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.else22
  %15 = getelementptr inbounds %struct.gv* %13, i64 0, i32 1
  %16 = load i32* %15, align 4, !tbaa !0
  %inc.i = add i32 %16, 1
  store i32 %inc.i, i32* %15, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.else22, %land.rhs.i
  %call.i49 = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %14) #7
  %call1.i = tail call %struct.op* @Perl_newSVREF(%struct.op* %call.i49) #7
  %call24 = tail call %struct.op* @Perl_newUNOP(i32 311, i32 0, %struct.op* %call1.i) #8
  br label %if.end25

if.end25:                                         ; preds = %if.then2, %if.else19, %Perl_newGVOP.exit
  %o.addr.0 = phi %struct.op* [ %o, %if.else19 ], [ %o, %if.then2 ], [ %call24, %Perl_newGVOP.exit ]
  %17 = load i32* @PL_hints, align 4, !tbaa !0
  %conv26 = zext i32 %17 to i64
  %op_targ = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 3
  store i64 %conv26, i64* %op_targ, align 8, !tbaa !5
  br label %return

return:                                           ; preds = %if.end25, %if.then13
  %retval.0 = phi %struct.op* [ %call16, %if.then13 ], [ %o.addr.0, %if.end25 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_exit(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_exec(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 14
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then
  tail call void @Perl_op_null(%struct.op* %3) #8
  br label %if.end5

if.else:                                          ; preds = %entry
  %call4 = tail call %struct.op* @Perl_listkids(%struct.op* %o) #8
  br label %if.end5

if.end5:                                          ; preds = %if.then, %if.then3, %if.else
  %o.addr.0 = phi %struct.op* [ %call, %if.then3 ], [ %call, %if.then ], [ %call4, %if.else ]
  ret %struct.op* %o.addr.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_exists(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end51, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %3 = load i16* %op_type, align 2, !tbaa !4
  switch i16 %3, label %if.then35 [
    i16 166, label %if.then3
    i16 127, label %if.then25
    i16 135, label %if.end50
  ]

if.then3:                                         ; preds = %if.then
  %op_type4 = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %4 = load i16* %op_type4, align 2, !tbaa !4
  %conv5 = zext i16 %4 to i32
  %call6 = tail call %struct.op* @Perl_ref(%struct.op* %2, i32 %conv5) #8
  %5 = load i16* %op_type, align 2, !tbaa !4
  %cmp9 = icmp eq i16 %5, 17
  %6 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool11 = icmp ne i32 %6, 0
  %or.cond = or i1 %cmp9, %tobool11
  br i1 %or.cond, label %if.end, label %if.then12

if.then12:                                        ; preds = %if.then3
  %7 = load i16* %op_type4, align 2, !tbaa !4
  %cmp15 = icmp eq i16 %7, 351
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then12
  %call17 = tail call i8* @Perl_custom_op_desc(%struct.op* %call) #8
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  %idxprom = zext i16 %7 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %8 = load i8** %arrayidx, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call17, %cond.true ], [ %8, %cond.false ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([37 x i8]* @.str89, i64 0, i64 0), i8* %cond) #7
  br label %if.end

if.end:                                           ; preds = %if.then3, %cond.end
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %9, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  br label %if.end50

if.then25:                                        ; preds = %if.then
  %or28 = or i8 %0, -128
  store i8 %or28, i8* %op_flags, align 1, !tbaa !1
  br label %if.end50

if.then35:                                        ; preds = %if.then
  %op_type36 = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  %10 = load i16* %op_type36, align 2, !tbaa !4
  %cmp38 = icmp eq i16 %10, 351
  br i1 %cmp38, label %cond.true40, label %cond.false42

cond.true40:                                      ; preds = %if.then35
  %call41 = tail call i8* @Perl_custom_op_desc(%struct.op* %call) #8
  br label %cond.end46

cond.false42:                                     ; preds = %if.then35
  %idxprom44 = zext i16 %10 to i64
  %arrayidx45 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom44
  %11 = load i8** %arrayidx45, align 8, !tbaa !3
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false42, %cond.true40
  %cond47 = phi i8* [ %call41, %cond.true40 ], [ %11, %cond.false42 ]
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([43 x i8]* @.str90, i64 0, i64 0), i8* %cond47) #7
  br label %if.end50

if.end50:                                         ; preds = %if.then, %if.then25, %cond.end46, %if.end
  tail call void @Perl_op_null(%struct.op* %2) #8
  br label %if.end51

if.end51:                                         ; preds = %entry, %if.end50
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_rvconst(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %2 = load i32* @PL_hints, align 4, !tbaa !0
  %and = and i32 %2, 2
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !1
  %conv = zext i8 %3 to i32
  %or = or i32 %conv, %and
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %op_private, align 1, !tbaa !1
  %4 = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %5 = load i16* %4, align 2, !tbaa !4
  %cmp = icmp eq i16 %5, 5
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %1, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %7, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !0
  %9 = and i32 %8, 8912896
  %10 = icmp eq i32 %9, 8912896
  br i1 %10, label %if.then8, label %if.end52

if.then8:                                         ; preds = %if.then
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %11 = load i8** %sv_any, align 8, !tbaa !3
  %xrv_rv = bitcast i8* %11 to %struct.sv**
  %12 = load %struct.sv** %xrv_rv, align 8, !tbaa !3
  %sv_flags9 = getelementptr inbounds %struct.sv* %12, i64 0, i32 2
  %13 = load i32* %sv_flags9, align 4, !tbaa !0
  %and10 = and i32 %13, 255
  %op_type11 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %14 = load i16* %op_type11, align 2, !tbaa !4
  %conv12 = zext i16 %14 to i32
  switch i32 %conv12, label %return [
    i32 15, label %sw.bb
    i32 125, label %sw.bb16
    i32 134, label %sw.bb21
    i32 17, label %sw.bb44
  ]

sw.bb:                                            ; preds = %if.then8
  %cmp13 = icmp ugt i32 %and10, 7
  %. = select i1 %cmp13, i8* getelementptr inbounds ([9 x i8]* @.str91, i64 0, i64 0), i8* null
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.then8
  %cmp17 = icmp eq i32 %and10, 10
  %.174 = select i1 %cmp17, i8* null, i8* getelementptr inbounds ([9 x i8]* @.str92, i64 0, i64 0)
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.then8
  switch i32 %and10, label %if.then50 [
    i32 11, label %return
    i32 10, label %if.then27
  ]

if.then27:                                        ; preds = %sw.bb21
  %15 = bitcast %struct.sv* %12 to %struct.av*
  %call = call %struct.sv** @Perl_av_fetch(%struct.av* %15, i32 0, i32 0) #7
  %tobool28 = icmp eq %struct.sv** %call, null
  br i1 %tobool28, label %if.then50, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %if.then27
  %16 = load %struct.sv** %call, align 8, !tbaa !3
  %sv_flags30 = getelementptr inbounds %struct.sv* %16, i64 0, i32 2
  %17 = load i32* %sv_flags30, align 4, !tbaa !0
  %and31 = and i32 %17, 524288
  %tobool32 = icmp eq i32 %and31, 0
  br i1 %tobool32, label %if.then50, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %land.lhs.true29
  %sv_any34 = getelementptr inbounds %struct.sv* %16, i64 0, i32 0
  %18 = load i8** %sv_any34, align 8, !tbaa !3
  %xrv_rv35 = bitcast i8* %18 to %struct.sv**
  %19 = load %struct.sv** %xrv_rv35, align 8, !tbaa !3
  %sv_flags36 = getelementptr inbounds %struct.sv* %19, i64 0, i32 2
  %20 = load i32* %sv_flags36, align 4, !tbaa !0
  %and37 = and i32 %20, 255
  %cmp38 = icmp eq i32 %and37, 11
  br i1 %cmp38, label %return, label %if.then50

sw.bb44:                                          ; preds = %if.then8
  %cmp45 = icmp eq i32 %and10, 12
  %.175 = select i1 %cmp45, i8* null, i8* getelementptr inbounds ([7 x i8]* @.str94, i64 0, i64 0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb44, %sw.bb16, %sw.bb
  %badtype.0 = phi i8* [ %., %sw.bb ], [ %.174, %sw.bb16 ], [ %.175, %sw.bb44 ]
  %tobool49 = icmp eq i8* %badtype.0, null
  br i1 %tobool49, label %return, label %if.then50

if.then50:                                        ; preds = %sw.bb21, %land.lhs.true29, %if.then27, %land.lhs.true33, %sw.epilog
  %badtype.0179 = phi i8* [ %badtype.0, %sw.epilog ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %land.lhs.true33 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %if.then27 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %land.lhs.true29 ], [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %sw.bb21 ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([29 x i8]* @.str95, i64 0, i64 0), i8* %badtype.0179) #7
  br label %return

if.end52:                                         ; preds = %if.then
  %and54 = and i32 %8, 262144
  %cmp55 = icmp eq i32 %and54, 0
  br i1 %cmp55, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end52
  %sv_any57 = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %21 = load i8** %sv_any57, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %21, i64 8
  %22 = bitcast i8* %xpv_cur to i64*
  %23 = load i64* %22, align 8, !tbaa !5
  store i64 %23, i64* %n_a, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %21 to i8**
  %24 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %if.end52
  %call59 = call i8* @Perl_sv_2pv_flags(%struct.sv* %7, i64* %n_a, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %24, %cond.true ], [ %call59, %cond.false ]
  %25 = load i32* @PL_hints, align 4, !tbaa !0
  %and60 = and i32 %25, 2
  %tobool61 = icmp eq i32 %and60, 0
  %.pre196 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  br i1 %tobool61, label %if.end77, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %cond.end
  %26 = load i8* %.pre196, align 1, !tbaa !1
  %and65 = and i8 %26, 64
  %tobool66 = icmp eq i8 %and65, 0
  br i1 %tobool66, label %if.end77, label %if.then67

if.then67:                                        ; preds = %land.lhs.true62
  %op_type68 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %27 = load i16* %op_type68, align 2, !tbaa !4
  %conv69 = zext i16 %27 to i32
  switch i32 %conv69, label %if.end77 [
    i32 15, label %if.then75
    i32 125, label %sw.bb71
    i32 134, label %sw.bb72
  ]

sw.bb71:                                          ; preds = %if.then67
  br label %if.then75

sw.bb72:                                          ; preds = %if.then67
  br label %if.then75

if.then75:                                        ; preds = %if.then67, %sw.bb72, %sw.bb71
  %badthing.0.ph = phi i8* [ getelementptr inbounds ([7 x i8]* @.str93, i64 0, i64 0), %sw.bb72 ], [ getelementptr inbounds ([9 x i8]* @.str92, i64 0, i64 0), %sw.bb71 ], [ getelementptr inbounds ([9 x i8]* @.str91, i64 0, i64 0), %if.then67 ]
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([63 x i8]* @.str96, i64 0, i64 0), i8* %cond, i8* %badthing.0.ph) #7
  br label %if.end77

if.end77:                                         ; preds = %cond.end, %land.lhs.true62, %if.then67, %if.then75
  %op_type78 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %28 = load i16* %op_type78, align 2, !tbaa !4
  %cmp80 = icmp eq i16 %28, 17
  %conv81 = zext i1 %cmp80 to i32
  %mul = shl nuw nsw i32 %conv81, 1
  %.pre = load i8* %.pre196, align 1, !tbaa !1
  br label %do.body

do.body:                                          ; preds = %land.rhs, %if.end77
  %29 = phi i8 [ %.pre, %if.end77 ], [ %32, %land.rhs ]
  %iscv.0 = phi i32 [ %mul, %if.end77 ], [ %inc, %land.rhs ]
  %and84 = lshr i8 %29, 4
  %and84.lobit = and i8 %and84, 1
  %30 = xor i8 %and84.lobit, 1
  %lnot.ext = zext i8 %30 to i32
  %or86 = or i32 %lnot.ext, %iscv.0
  %tobool87 = icmp ne i32 %iscv.0, 0
  br i1 %tobool87, label %cond.end111, label %cond.false89

cond.false89:                                     ; preds = %do.body
  %31 = load i16* %op_type78, align 2, !tbaa !4
  %cmp92 = icmp eq i16 %31, 15
  br i1 %cmp92, label %cond.end111, label %cond.false95

cond.false95:                                     ; preds = %cond.false89
  %cmp98 = icmp eq i16 %31, 125
  br i1 %cmp98, label %cond.end111, label %cond.false101

cond.false101:                                    ; preds = %cond.false95
  %cmp104 = icmp eq i16 %31, 134
  %cond106 = select i1 %cmp104, i32 11, i32 13
  br label %cond.end111

cond.end111:                                      ; preds = %cond.false89, %cond.false95, %cond.false101, %do.body
  %cond112 = phi i32 [ 12, %do.body ], [ 4, %cond.false89 ], [ %cond106, %cond.false101 ], [ 10, %cond.false95 ]
  %call113 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 %or86, i32 %cond112) #7
  %tobool114 = icmp eq %struct.gv* %call113, null
  br i1 %tobool114, label %land.lhs.true115, label %land.end131

land.lhs.true115:                                 ; preds = %cond.end111
  %32 = load i8* %.pre196, align 1, !tbaa !1
  %and118 = and i8 %32, 16
  %tobool119 = icmp eq i8 %and118, 0
  br i1 %tobool119, label %land.rhs, label %return

land.rhs:                                         ; preds = %land.lhs.true115
  %inc = add nsw i32 %iscv.0, 1
  br i1 %tobool87, label %return, label %do.body

land.end131:                                      ; preds = %cond.end111
  store i16 7, i16* %4, align 2, !tbaa !4
  %33 = load %struct.sv** %6, align 8, !tbaa !3
  call void @Perl_sv_free(%struct.sv* %33) #7
  %34 = bitcast %struct.gv* %call113 to %struct.sv*
  store %struct.sv* %34, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %35 = getelementptr inbounds %struct.gv* %call113, i64 0, i32 1
  %36 = load i32* %35, align 4, !tbaa !0
  %inc129 = add i32 %36, 1
  store i32 %inc129, i32* %35, align 4, !tbaa !0
  %37 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  %.c = bitcast %struct.gv* %call113 to %struct.op*
  store %struct.op* %.c, %struct.op** %37, align 8, !tbaa !3
  store i8 0, i8* %.pre196, align 1, !tbaa !1
  %38 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 7), align 8, !tbaa !3
  %39 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %38, %struct.op* ()** %39, align 8, !tbaa !3
  br label %return

return:                                           ; preds = %land.lhs.true115, %land.rhs, %sw.bb21, %land.lhs.true33, %if.then8, %entry, %land.end131, %if.then50, %sw.epilog
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.op* @S_no_fh_allowed(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = tail call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %1 = load i8** %arrayidx, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %1, %cond.false ]
  %call3 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([50 x i8]* @.str145, i64 0, i64 0), i8* %cond) #7
  %call4 = tail call i32 @Perl_yyerror(i8* %call3) #7
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @S_bad_type(i32 %n, i8* %t, i8* %name, %struct.op* nocapture %kid) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %kid, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = tail call i8* @Perl_custom_op_desc(%struct.op* %kid) #8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %idxprom = zext i16 %0 to i64
  %arrayidx = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %1 = load i8** %arrayidx, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %1, %cond.false ]
  %call3 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([41 x i8]* @.str143, i64 0, i64 0), i32 %n, i8* %name, i8* %t, i8* %cond) #7
  %call4 = tail call i32 @Perl_yyerror(i8* %call3) #7
  ret void
}

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVpvf(i8*, ...) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_glob(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %5 = bitcast %struct.gv* %4 to %struct.sv*
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i138 = icmp eq %struct.gv* %4, null
  br i1 %tobool.i138, label %Perl_newGVOP.exit142, label %land.rhs.i140

land.rhs.i140:                                    ; preds = %if.then
  %6 = getelementptr inbounds %struct.gv* %4, i64 0, i32 1
  %7 = load i32* %6, align 4, !tbaa !0
  %inc.i139 = add i32 %7, 1
  store i32 %inc.i139, i32* %6, align 4, !tbaa !0
  br label %Perl_newGVOP.exit142

Perl_newGVOP.exit142:                             ; preds = %if.then, %land.rhs.i140
  %call.i141 = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %5) #7
  %call1.i = tail call %struct.op* @Perl_newSVREF(%struct.op* %call.i141) #7
  %call3 = tail call %struct.op* @Perl_append_elem(i32 25, %struct.op* %call, %struct.op* %call1.i) #8
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry, %Perl_newGVOP.exit142
  %call4 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([5 x i8]* @.str108, i64 0, i64 0), i32 0, i32 12) #7
  %tobool5 = icmp eq %struct.gv* %call4, null
  br i1 %tobool5, label %if.then16, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %if.end
  %sv_any = getelementptr inbounds %struct.gv* %call4, i64 0, i32 0
  %8 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %8, i64 0, i32 7
  %9 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_cvgen = getelementptr inbounds %struct.gp* %9, i64 0, i32 8
  %10 = load i32* %gp_cvgen, align 4, !tbaa !0
  %tobool7 = icmp eq i32 %10, 0
  br i1 %tobool7, label %cond.false, label %if.then16

cond.false:                                       ; preds = %land.lhs.true6
  %gp_cv = getelementptr inbounds %struct.gp* %9, i64 0, i32 7
  %11 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool10 = icmp eq %struct.cv* %11, null
  br i1 %tobool10, label %if.then16, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %cond.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %8, i64 0, i32 11
  %12 = load i8* %xgv_flags, align 1, !tbaa !1
  %tobool15 = icmp slt i8 %12, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %cond.false, %land.lhs.true6, %if.end, %land.lhs.true11
  %call17 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([19 x i8]* @.str109, i64 0, i64 0), i32 0, i32 12) #7
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %land.lhs.true11
  %gv.0 = phi %struct.gv* [ %call17, %if.then16 ], [ %call4, %land.lhs.true11 ]
  %tobool19 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool19, label %if.then37, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.end18
  %sv_any21 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %13 = load %struct.xpvgv** %sv_any21, align 8, !tbaa !3
  %xgv_gp22 = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 7
  %14 = load %struct.gp** %xgv_gp22, align 8, !tbaa !3
  %gp_cvgen23 = getelementptr inbounds %struct.gp* %14, i64 0, i32 8
  %15 = load i32* %gp_cvgen23, align 4, !tbaa !0
  %tobool24 = icmp eq i32 %15, 0
  br i1 %tobool24, label %cond.false26, label %if.then37

cond.false26:                                     ; preds = %land.lhs.true20
  %gp_cv29 = getelementptr inbounds %struct.gp* %14, i64 0, i32 7
  %16 = load %struct.cv** %gp_cv29, align 8, !tbaa !3
  %tobool30 = icmp eq %struct.cv* %16, null
  br i1 %tobool30, label %if.then37, label %land.lhs.true31

land.lhs.true31:                                  ; preds = %cond.false26
  %xgv_flags33 = getelementptr inbounds %struct.xpvgv* %13, i64 0, i32 11
  %17 = load i8* %xgv_flags33, align 1, !tbaa !1
  %tobool36 = icmp slt i8 %17, 0
  br i1 %tobool36, label %if.end56, label %if.then37

if.then37:                                        ; preds = %cond.false26, %land.lhs.true20, %if.end18, %land.lhs.true31
  tail call void @Perl_push_scope() #7
  %call38 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8]* @.str110, i64 0, i64 0), i64 10) #7
  tail call void (i32, %struct.sv*, %struct.sv*, ...)* @Perl_load_module(i32 2, %struct.sv* %call38, %struct.sv* null, %struct.sv* null, %struct.sv* null) #8
  %call39 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([19 x i8]* @.str109, i64 0, i64 0), i32 0, i32 12) #7
  %call40 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([21 x i8]* @.str111, i64 0, i64 0), i32 0, i32 12) #7
  %sv_any41 = getelementptr inbounds %struct.gv* %call40, i64 0, i32 0
  %18 = load %struct.xpvgv** %sv_any41, align 8, !tbaa !3
  %xgv_gp42 = getelementptr inbounds %struct.xpvgv* %18, i64 0, i32 7
  %19 = load %struct.gp** %xgv_gp42, align 8, !tbaa !3
  %gp_cv43 = getelementptr inbounds %struct.gp* %19, i64 0, i32 7
  %20 = load %struct.cv** %gp_cv43, align 8, !tbaa !3
  %sv_any44 = getelementptr inbounds %struct.gv* %call39, i64 0, i32 0
  %21 = load %struct.xpvgv** %sv_any44, align 8, !tbaa !3
  %xgv_gp45 = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 7
  %22 = load %struct.gp** %xgv_gp45, align 8, !tbaa !3
  %gp_cv46 = getelementptr inbounds %struct.gp* %22, i64 0, i32 7
  store %struct.cv* %20, %struct.cv** %gp_cv46, align 8, !tbaa !3
  %23 = load %struct.xpvgv** %sv_any44, align 8, !tbaa !3
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv* %23, i64 0, i32 7
  %24 = load %struct.gp** %xgv_gp48, align 8, !tbaa !3
  %gp_cv49 = getelementptr inbounds %struct.gp* %24, i64 0, i32 7
  %25 = load %struct.cv** %gp_cv49, align 8, !tbaa !3
  %26 = bitcast %struct.cv* %25 to %struct.sv*
  store %struct.sv* %26, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool50 = icmp eq %struct.cv* %25, null
  br i1 %tobool50, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then37
  %27 = getelementptr inbounds %struct.cv* %25, i64 0, i32 1
  %28 = load i32* %27, align 4, !tbaa !0
  %inc = add i32 %28, 1
  store i32 %inc, i32* %27, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %if.then37, %land.rhs
  %29 = load %struct.xpvgv** %sv_any44, align 8, !tbaa !3
  %xgv_flags53 = getelementptr inbounds %struct.xpvgv* %29, i64 0, i32 11
  %30 = load i8* %xgv_flags53, align 1, !tbaa !1
  %or = or i8 %30, -128
  store i8 %or, i8* %xgv_flags53, align 1, !tbaa !1
  tail call void @Perl_pop_scope() #7
  br label %if.end56

if.end56:                                         ; preds = %land.end, %land.lhs.true31
  %gv.1 = phi %struct.gv* [ %call39, %land.end ], [ %gv.0, %land.lhs.true31 ]
  %tobool57 = icmp eq %struct.gv* %gv.1, null
  br i1 %tobool57, label %if.end94, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %if.end56
  %sv_any59 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 0
  %31 = load %struct.xpvgv** %sv_any59, align 8, !tbaa !3
  %xgv_gp60 = getelementptr inbounds %struct.xpvgv* %31, i64 0, i32 7
  %32 = load %struct.gp** %xgv_gp60, align 8, !tbaa !3
  %gp_cvgen61 = getelementptr inbounds %struct.gp* %32, i64 0, i32 8
  %33 = load i32* %gp_cvgen61, align 4, !tbaa !0
  %tobool62 = icmp eq i32 %33, 0
  br i1 %tobool62, label %cond.false64, label %if.end94

cond.false64:                                     ; preds = %land.lhs.true58
  %gp_cv67 = getelementptr inbounds %struct.gp* %32, i64 0, i32 7
  %34 = load %struct.cv** %gp_cv67, align 8, !tbaa !3
  %tobool68 = icmp eq %struct.cv* %34, null
  br i1 %tobool68, label %if.end94, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %cond.false64
  %xgv_flags71 = getelementptr inbounds %struct.xpvgv* %31, i64 0, i32 11
  %35 = load i8* %xgv_flags71, align 1, !tbaa !1
  %tobool74 = icmp slt i8 %35, 0
  br i1 %tobool74, label %Perl_newGVOP.exit, label %if.end94

Perl_newGVOP.exit:                                ; preds = %land.lhs.true69
  %36 = load i32* @PL_glob_index, align 4, !tbaa !0
  %inc76 = add nsw i32 %36, 1
  store i32 %inc76, i32* @PL_glob_index, align 4, !tbaa !0
  %conv77 = sext i32 %36 to i64
  %call78 = tail call %struct.sv* @Perl_newSViv(i64 %conv77) #7
  %call79 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call78) #8
  %call80 = tail call %struct.op* @Perl_append_elem(i32 25, %struct.op* %call, %struct.op* %call79) #8
  %op_type = getelementptr inbounds %struct.op* %call, i64 0, i32 4
  store i16 141, i16* %op_type, align 2, !tbaa !4
  %37 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 141), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %call, i64 0, i32 2
  store %struct.op* ()* %37, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %38 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %39 = load %struct.op** %38, align 8, !tbaa !3
  %op_type82 = getelementptr inbounds %struct.op* %39, i64 0, i32 4
  store i16 3, i16* %op_type82, align 2, !tbaa !4
  %40 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 3), align 8, !tbaa !3
  %op_ppaddr84 = getelementptr inbounds %struct.op* %39, i64 0, i32 2
  store %struct.op* ()* %40, %struct.op* ()** %op_ppaddr84, align 8, !tbaa !3
  %41 = load %struct.op** %38, align 8, !tbaa !3
  %op_targ = getelementptr inbounds %struct.op* %41, i64 0, i32 3
  store i64 0, i64* %op_targ, align 8, !tbaa !5
  %42 = bitcast %struct.gv* %gv.1 to %struct.sv*
  store %struct.sv* %42, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %43 = getelementptr inbounds %struct.gv* %gv.1, i64 0, i32 1
  %44 = load i32* %43, align 4, !tbaa !0
  %inc.i = add i32 %44, 1
  store i32 %inc.i, i32* %43, align 4, !tbaa !0
  %call.i132 = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %42) #7
  %call87 = tail call %struct.op* @Perl_newUNOP(i32 17, i32 0, %struct.op* %call.i132) #8
  %call88 = tail call %struct.op* @Perl_scalar(%struct.op* %call87) #8
  %call89 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call, %struct.op* %call88) #8
  %call90 = tail call %struct.op* @Perl_newUNOP(i32 166, i32 64, %struct.op* %call89) #8
  %call91 = tail call %struct.op* @Perl_ck_subr(%struct.op* %call90) #8
  %call92 = tail call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %call91) #8
  %op_targ93 = getelementptr inbounds %struct.op* %call92, i64 0, i32 3
  store i64 25, i64* %op_targ93, align 8, !tbaa !5
  br label %return

if.end94:                                         ; preds = %cond.false64, %land.lhs.true58, %if.end56, %land.lhs.true69
  %call95 = tail call %struct.gv* @Perl_newGVgen(i8* getelementptr inbounds ([5 x i8]* @.str112, i64 0, i64 0)) #7
  %call96 = tail call %struct.gv* @Perl_gv_IOadd(%struct.gv* %call95) #7
  %45 = bitcast %struct.gv* %call95 to %struct.sv*
  store %struct.sv* %45, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i133 = icmp eq %struct.gv* %call95, null
  br i1 %tobool.i133, label %Perl_newGVOP.exit137, label %land.rhs.i135

land.rhs.i135:                                    ; preds = %if.end94
  %46 = getelementptr inbounds %struct.gv* %call95, i64 0, i32 1
  %47 = load i32* %46, align 4, !tbaa !0
  %inc.i134 = add i32 %47, 1
  store i32 %inc.i134, i32* %46, align 4, !tbaa !0
  br label %Perl_newGVOP.exit137

Perl_newGVOP.exit137:                             ; preds = %if.end94, %land.rhs.i135
  %call.i136 = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %45) #7
  %call98 = tail call %struct.op* @Perl_append_elem(i32 25, %struct.op* %call, %struct.op* %call.i136) #8
  %call99 = tail call %struct.op* @Perl_scalarkids(%struct.op* %call) #8
  br label %return

return:                                           ; preds = %Perl_newGVOP.exit137, %Perl_newGVOP.exit
  %retval.0 = phi %struct.op* [ %call, %Perl_newGVOP.exit137 ], [ %call92, %Perl_newGVOP.exit ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_newSViv(i64) #2

; Function Attrs: optsize
declare %struct.gv* @Perl_newGVgen(i8*) #2

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_IOadd(%struct.gv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_grep(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 152
  %conv2 = select i1 %cmp, i16 153, i16 155
  %1 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 152), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %1, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %call = tail call i8* @Perl_safesysmalloc(i64 56) #7
  tail call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 56, i32 1, i1 false)
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  %call4 = tail call %struct.op* @Perl_ck_sort(%struct.op* %o) #8
  %3 = getelementptr inbounds %struct.op* %call4, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %op_next = getelementptr inbounds %struct.op* %5, i64 0, i32 0
  %6 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool5 = icmp eq %struct.op* %6, null
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([15 x i8]* @.str113, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %if.then6
  %7 = getelementptr inbounds %struct.op* %5, i64 1, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.cond, %if.end
  %kid.0 = phi %struct.op* [ %5, %if.end ], [ %k.0, %for.cond ]
  %k.0.in = phi %struct.op** [ %7, %if.end ], [ %op_next9, %for.cond ]
  %k.0 = load %struct.op** %k.0.in, align 8
  %tobool8 = icmp eq %struct.op* %k.0, null
  %op_next9 = getelementptr inbounds %struct.op* %k.0, i64 0, i32 0
  br i1 %tobool8, label %for.end, label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = bitcast i8* %call to %struct.op*
  %op_next10 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 0
  store %struct.op* %8, %struct.op** %op_next10, align 8, !tbaa !3
  %op_flags11 = getelementptr inbounds %struct.op* %call4, i64 0, i32 6
  %9 = load i8* %op_flags11, align 1, !tbaa !1
  %and13 = and i8 %9, -65
  store i8 %and13, i8* %op_flags11, align 1, !tbaa !1
  br label %if.end15

if.end15:                                         ; preds = %entry, %for.end
  %o.addr.0 = phi %struct.op* [ %call4, %for.end ], [ %o, %entry ]
  %10 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !3
  %op_sibling17 = getelementptr inbounds %struct.op* %11, i64 0, i32 1
  %12 = load %struct.op** %op_sibling17, align 8, !tbaa !3
  %conv18 = zext i16 %conv2 to i32
  br i1 %cmp, label %if.else, label %if.then21

if.then21:                                        ; preds = %if.end15
  %call22 = tail call %struct.op* @Perl_list(%struct.op* %12) #8
  br label %if.end24

if.else:                                          ; preds = %if.end15
  %call23 = tail call %struct.op* @Perl_scalar(%struct.op* %12) #8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then21
  %call25 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o.addr.0) #8
  %13 = load i32* @PL_error_count, align 4, !tbaa !0
  %tobool26 = icmp eq i32 %13, 0
  br i1 %tobool26, label %if.end28, label %return

if.end28:                                         ; preds = %if.end24
  %14 = getelementptr inbounds %struct.op* %call25, i64 1, i32 0
  %15 = load %struct.op** %14, align 8, !tbaa !3
  %op_sibling30 = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling30, align 8, !tbaa !3
  %op_type31 = getelementptr inbounds %struct.op* %16, i64 0, i32 4
  %17 = load i16* %op_type31, align 2, !tbaa !4
  %cmp33 = icmp eq i16 %17, 0
  br i1 %cmp33, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end28
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([15 x i8]* @.str113, i64 0, i64 0)) #7
  br label %if.end36

if.end36:                                         ; preds = %if.end28, %if.then35
  %18 = getelementptr inbounds %struct.op* %16, i64 1, i32 0
  %19 = load %struct.op** %18, align 8, !tbaa !3
  %op_type38 = getelementptr inbounds i8* %call, i64 32
  %20 = bitcast i8* %op_type38 to i16*
  store i16 %conv2, i16* %20, align 2, !tbaa !4
  %idxprom = zext i16 %conv2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 %idxprom
  %21 = load %struct.op* ()** %arrayidx, align 8, !tbaa !3
  %op_ppaddr39 = getelementptr inbounds i8* %call, i64 16
  %22 = bitcast i8* %op_ppaddr39 to %struct.op* ()**
  store %struct.op* ()* %21, %struct.op* ()** %22, align 8, !tbaa !3
  %call40 = tail call %struct.op* @Perl_listkids(%struct.op* %call25) #8
  %op_first41 = getelementptr inbounds i8* %call, i64 40
  %23 = bitcast i8* %op_first41 to %struct.op**
  store %struct.op* %call40, %struct.op** %23, align 8, !tbaa !3
  %24 = getelementptr inbounds i8* %call, i64 36
  %25 = load i8* %24, align 1, !tbaa !1
  %or = or i8 %25, 4
  store i8 %or, i8* %24, align 1, !tbaa !1
  %26 = getelementptr inbounds i8* %call, i64 37
  store i8 1, i8* %26, align 1, !tbaa !1
  %op_next45 = getelementptr inbounds %struct.op* %19, i64 0, i32 0
  %27 = load %struct.op** %op_next45, align 8, !tbaa !3
  %tobool46 = icmp eq %struct.op* %27, null
  br i1 %tobool46, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end36
  %call48 = tail call %struct.op* @Perl_linklist(%struct.op* %19) #8
  br label %cond.end

cond.end:                                         ; preds = %if.end36, %cond.false
  %cond49 = phi %struct.op* [ %call48, %cond.false ], [ %27, %if.end36 ]
  %op_other = getelementptr inbounds i8* %call, i64 48
  %28 = bitcast i8* %op_other to %struct.op**
  store %struct.op* %cond49, %struct.op** %28, align 8, !tbaa !3
  %call51 = tail call i64 @Perl_pad_alloc(i32 %conv18, i32 512) #7
  %op_targ = getelementptr inbounds i8* %call, i64 24
  %29 = bitcast i8* %op_targ to i64*
  store i64 %call51, i64* %29, align 8, !tbaa !5
  %30 = bitcast i8* %call to %struct.op*
  store %struct.op* %30, %struct.op** %op_next45, align 8, !tbaa !3
  %31 = load %struct.op** %14, align 8, !tbaa !3
  %op_sibling54 = getelementptr inbounds %struct.op* %31, i64 0, i32 1
  %32 = load %struct.op** %op_sibling54, align 8, !tbaa !3
  %tobool55 = icmp eq %struct.op* %32, null
  br i1 %tobool55, label %if.then58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %op_sibling56 = getelementptr inbounds %struct.op* %32, i64 0, i32 1
  %33 = load %struct.op** %op_sibling56, align 8, !tbaa !3
  %tobool57 = icmp eq %struct.op* %33, null
  br i1 %tobool57, label %if.then58, label %for.body76

if.then58:                                        ; preds = %lor.lhs.false, %cond.end
  %op_type59 = getelementptr inbounds %struct.op* %call25, i64 0, i32 4
  %34 = load i16* %op_type59, align 2, !tbaa !4
  %cmp61 = icmp eq i16 %34, 351
  br i1 %cmp61, label %cond.true63, label %cond.false65

cond.true63:                                      ; preds = %if.then58
  %call64 = tail call i8* @Perl_custom_op_desc(%struct.op* %call25) #8
  br label %cond.end69

cond.false65:                                     ; preds = %if.then58
  %idxprom67 = zext i16 %34 to i64
  %arrayidx68 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom67
  %35 = load i8** %arrayidx68, align 8, !tbaa !3
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false65, %cond.true63
  %cond70 = phi i8* [ %call64, %cond.true63 ], [ %35, %cond.false65 ]
  %call.i = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([28 x i8]* @.str142, i64 0, i64 0), i8* %cond70) #7
  %call1.i = tail call i32 @Perl_yyerror(i8* %call.i) #7
  br label %return

for.body76:                                       ; preds = %lor.lhs.false, %for.body76
  %kid.1124 = phi %struct.op* [ %36, %for.body76 ], [ %33, %lor.lhs.false ]
  %call77 = tail call %struct.op* @Perl_mod(%struct.op* %kid.1124, i32 152) #8
  %op_sibling79 = getelementptr inbounds %struct.op* %kid.1124, i64 0, i32 1
  %36 = load %struct.op** %op_sibling79, align 8, !tbaa !3
  %tobool75 = icmp eq %struct.op* %36, null
  br i1 %tobool75, label %return, label %for.body76

return:                                           ; preds = %for.body76, %if.end24, %cond.end69
  %retval.0 = phi %struct.op* [ %call25, %cond.end69 ], [ %call25, %if.end24 ], [ %30, %for.body76 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_sort(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 150
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %land.lhs.true
  %2 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %op_sibling.i = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %4 = load %struct.op** %op_sibling.i, align 8, !tbaa !3
  %call.i = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8]* @.str140, i64 0, i64 0), i32 1, i32 4) #7
  %sv_any.i = getelementptr inbounds %struct.gv* %call.i, i64 0, i32 0
  %5 = load %struct.xpvgv** %sv_any.i, align 8, !tbaa !3
  %xgv_flags.i = getelementptr inbounds %struct.xpvgv* %5, i64 0, i32 11
  %6 = load i8* %xgv_flags.i, align 1, !tbaa !1
  %or.i = or i8 %6, 2
  store i8 %or.i, i8* %xgv_flags.i, align 1, !tbaa !1
  %call3.i = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8]* @.str141, i64 0, i64 0), i32 1, i32 4) #7
  %sv_any4.i = getelementptr inbounds %struct.gv* %call3.i, i64 0, i32 0
  %7 = load %struct.xpvgv** %sv_any4.i, align 8, !tbaa !3
  %xgv_flags5.i = getelementptr inbounds %struct.xpvgv* %7, i64 0, i32 11
  %8 = load i8* %xgv_flags5.i, align 1, !tbaa !1
  %or7.i = or i8 %8, 2
  store i8 %or7.i, i8* %xgv_flags5.i, align 1, !tbaa !1
  %9 = getelementptr inbounds %struct.op* %4, i64 1, i32 0
  %10 = load %struct.op** %9, align 8, !tbaa !3
  %op_type.i = getelementptr inbounds %struct.op* %10, i64 0, i32 4
  %11 = load i16* %op_type.i, align 2, !tbaa !4
  %cmp.i = icmp eq i16 %11, 179
  br i1 %cmp.i, label %if.end13.i, label %if.end

if.end13.i:                                       ; preds = %if.end.i
  %12 = getelementptr inbounds %struct.op* %10, i64 1, i32 1
  %13 = load %struct.op** %12, align 8, !tbaa !3
  %op_type14.i = getelementptr inbounds %struct.op* %13, i64 0, i32 4
  %14 = load i16* %op_type14.i, align 2, !tbaa !4
  %conv15.i = zext i16 %14 to i32
  switch i32 %conv15.i, label %if.end [
    i32 82, label %sw.epilog.i
    i32 83, label %sw.epilog.i
    i32 90, label %sw.epilog.i
  ]

sw.epilog.i:                                      ; preds = %if.end13.i, %if.end13.i, %if.end13.i
  %15 = getelementptr inbounds %struct.op* %13, i64 1, i32 0
  %16 = load %struct.op** %15, align 8, !tbaa !3
  %op_type17.i = getelementptr inbounds %struct.op* %16, i64 0, i32 4
  %17 = load i16* %op_type17.i, align 2, !tbaa !4
  %cmp19.i = icmp eq i16 %17, 15
  br i1 %cmp19.i, label %if.end22.i, label %if.end

if.end22.i:                                       ; preds = %sw.epilog.i
  %18 = getelementptr inbounds %struct.op* %16, i64 1, i32 0
  %19 = load %struct.op** %18, align 8, !tbaa !3
  %op_type25.i = getelementptr inbounds %struct.op* %19, i64 0, i32 4
  %20 = load i16* %op_type25.i, align 2, !tbaa !4
  %cmp27.i = icmp eq i16 %20, 7
  br i1 %cmp27.i, label %if.end30.i, label %if.end

if.end30.i:                                       ; preds = %if.end22.i
  %op_sv.i = getelementptr inbounds %struct.op* %19, i64 1
  %21 = bitcast %struct.op* %op_sv.i to %struct.sv**
  %22 = load %struct.sv** %21, align 8, !tbaa !3
  %sv_any32.i = bitcast %struct.sv* %22 to %struct.xpvgv**
  %23 = load %struct.xpvgv** %sv_any32.i, align 8, !tbaa !3
  %xgv_stash.i = getelementptr inbounds %struct.xpvgv* %23, i64 0, i32 10
  %24 = load %struct.hv** %xgv_stash.i, align 8, !tbaa !3
  %25 = load %struct.hv** @PL_curstash, align 8, !tbaa !3
  %cmp33.i = icmp eq %struct.hv* %24, %25
  br i1 %cmp33.i, label %if.end36.i, label %if.end

if.end36.i:                                       ; preds = %if.end30.i
  %xgv_name.i = getelementptr inbounds %struct.xpvgv* %23, i64 0, i32 8
  %26 = load i8** %xgv_name.i, align 8, !tbaa !3
  %27 = load i8* %26, align 1, !tbaa !1
  switch i8 %27, label %if.end [
    i8 97, label %land.lhs.true.i
    i8 98, label %land.lhs.true48.i
  ]

land.lhs.true.i:                                  ; preds = %if.end36.i
  %arrayidx.i = getelementptr inbounds i8* %26, i64 1
  %28 = load i8* %arrayidx.i, align 1, !tbaa !1
  %cmp42.i = icmp eq i8 %28, 0
  br i1 %cmp42.i, label %if.end56.i, label %if.end

land.lhs.true48.i:                                ; preds = %if.end36.i
  %arrayidx49.i = getelementptr inbounds i8* %26, i64 1
  %29 = load i8* %arrayidx49.i, align 1, !tbaa !1
  %cmp51.i = icmp eq i8 %29, 0
  br i1 %cmp51.i, label %if.end56.i, label %if.end

if.end56.i:                                       ; preds = %land.lhs.true48.i, %land.lhs.true.i
  %descending.0.i = phi i32 [ 0, %land.lhs.true.i ], [ 1, %land.lhs.true48.i ]
  %30 = getelementptr inbounds %struct.op* %13, i64 1, i32 1
  %31 = load %struct.op** %30, align 8, !tbaa !3
  %op_type58.i = getelementptr inbounds %struct.op* %31, i64 0, i32 4
  %32 = load i16* %op_type58.i, align 2, !tbaa !4
  %cmp60.i = icmp eq i16 %32, 15
  br i1 %cmp60.i, label %if.end63.i, label %if.end

if.end63.i:                                       ; preds = %if.end56.i
  %33 = getelementptr inbounds %struct.op* %31, i64 1, i32 0
  %34 = load %struct.op** %33, align 8, !tbaa !3
  %op_type66.i = getelementptr inbounds %struct.op* %34, i64 0, i32 4
  %35 = load i16* %op_type66.i, align 2, !tbaa !4
  %cmp68.i = icmp eq i16 %35, 7
  br i1 %cmp68.i, label %if.end71.i, label %if.end

if.end71.i:                                       ; preds = %if.end63.i
  %op_sv73.i = getelementptr inbounds %struct.op* %34, i64 1
  %36 = bitcast %struct.op* %op_sv73.i to %struct.sv**
  %37 = load %struct.sv** %36, align 8, !tbaa !3
  %sv_any74.i = bitcast %struct.sv* %37 to %struct.xpvgv**
  %38 = load %struct.xpvgv** %sv_any74.i, align 8, !tbaa !3
  %xgv_stash75.i = getelementptr inbounds %struct.xpvgv* %38, i64 0, i32 10
  %39 = load %struct.hv** %xgv_stash75.i, align 8, !tbaa !3
  %cmp76.i = icmp eq %struct.hv* %39, %24
  br i1 %cmp76.i, label %if.end79.i, label %if.end

if.end79.i:                                       ; preds = %if.end71.i
  %xgv_name81.i = getelementptr inbounds %struct.xpvgv* %38, i64 0, i32 8
  %40 = load i8** %xgv_name81.i, align 8, !tbaa !3
  %tobool82.i = icmp ne i32 %descending.0.i, 0
  %41 = load i8* %40, align 1, !tbaa !1
  br i1 %tobool82.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.end79.i
  %cmp84.i = icmp eq i8 %41, 97
  br i1 %cmp84.i, label %land.lhs.true86.i, label %if.end

land.lhs.true86.i:                                ; preds = %cond.true.i
  %arrayidx87.i = getelementptr inbounds i8* %40, i64 1
  %42 = load i8* %arrayidx87.i, align 1, !tbaa !1
  %cmp89.i = icmp eq i8 %42, 0
  br i1 %cmp89.i, label %if.end100.i, label %if.end

cond.false.i:                                     ; preds = %if.end79.i
  %cmp92.i = icmp eq i8 %41, 98
  br i1 %cmp92.i, label %land.lhs.true94.i, label %if.end

land.lhs.true94.i:                                ; preds = %cond.false.i
  %arrayidx95.i = getelementptr inbounds i8* %40, i64 1
  %43 = load i8* %arrayidx95.i, align 1, !tbaa !1
  %cmp97.i = icmp eq i8 %43, 0
  br i1 %cmp97.i, label %if.end100.i, label %if.end

if.end100.i:                                      ; preds = %land.lhs.true94.i, %land.lhs.true86.i
  %44 = load i8* %op_flags, align 1, !tbaa !1
  %and103.i = and i8 %44, 63
  store i8 %and103.i, i8* %op_flags, align 1, !tbaa !1
  br i1 %tobool82.i, label %if.then106.i, label %if.end110.i

if.then106.i:                                     ; preds = %if.end100.i
  %op_private.i = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %45 = load i8* %op_private.i, align 1, !tbaa !1
  %or108.i = or i8 %45, 16
  store i8 %or108.i, i8* %op_private.i, align 1, !tbaa !1
  br label %if.end110.i

if.end110.i:                                      ; preds = %if.then106.i, %if.end100.i
  %46 = load i16* %op_type14.i, align 2, !tbaa !4
  %cmp113.i = icmp eq i16 %46, 82
  br i1 %cmp113.i, label %if.then115.i, label %if.end120.i

if.then115.i:                                     ; preds = %if.end110.i
  %op_private116.i = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %47 = load i8* %op_private116.i, align 1, !tbaa !1
  %or118.i = or i8 %47, 1
  store i8 %or118.i, i8* %op_private116.i, align 1, !tbaa !1
  %.pr171.i = load i16* %op_type14.i, align 2, !tbaa !4
  br label %if.end120.i

if.end120.i:                                      ; preds = %if.then115.i, %if.end110.i
  %48 = phi i16 [ %.pr171.i, %if.then115.i ], [ %46, %if.end110.i ]
  %cmp123.i = icmp eq i16 %48, 83
  br i1 %cmp123.i, label %if.then125.i, label %if.end130.i

if.then125.i:                                     ; preds = %if.end120.i
  %op_private126.i = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %49 = load i8* %op_private126.i, align 1, !tbaa !1
  %or128.i = or i8 %49, 3
  store i8 %or128.i, i8* %op_private126.i, align 1, !tbaa !1
  br label %if.end130.i

if.end130.i:                                      ; preds = %if.then125.i, %if.end120.i
  %50 = load %struct.op** %2, align 8, !tbaa !3
  %op_sibling132.i = getelementptr inbounds %struct.op* %50, i64 0, i32 1
  %51 = load %struct.op** %op_sibling132.i, align 8, !tbaa !3
  %op_sibling133.i = getelementptr inbounds %struct.op* %51, i64 0, i32 1
  %52 = load %struct.op** %op_sibling133.i, align 8, !tbaa !3
  store %struct.op* %52, %struct.op** %op_sibling132.i, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %51) #7
  br label %if.end

if.end:                                           ; preds = %entry, %land.lhs.true94.i, %cond.false.i, %land.lhs.true86.i, %cond.true.i, %if.end71.i, %if.end63.i, %if.end56.i, %land.lhs.true48.i, %land.lhs.true.i, %if.end36.i, %if.end30.i, %if.end22.i, %sw.epilog.i, %if.end13.i, %if.end.i, %if.end130.i, %land.lhs.true
  %53 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %54 = load %struct.op** %53, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %54, i64 0, i32 1
  %55 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %56 = load i8* %op_flags, align 1, !tbaa !1
  %and5 = and i8 %56, 64
  %tobool6 = icmp eq i8 %and5, 0
  br i1 %tobool6, label %if.end90, label %if.then7

if.then7:                                         ; preds = %if.end
  %57 = getelementptr inbounds %struct.op* %55, i64 1, i32 0
  %58 = load %struct.op** %57, align 8, !tbaa !3
  %op_type9 = getelementptr inbounds %struct.op* %58, i64 0, i32 4
  %59 = load i16* %op_type9, align 2, !tbaa !4
  switch i16 %59, label %if.end88 [
    i16 179, label %if.then17
    i16 178, label %if.then17
    i16 15, label %if.then86
    i16 9, label %if.then86
  ]

if.then17:                                        ; preds = %if.then7, %if.then7
  %call = tail call %struct.op* @Perl_linklist(%struct.op* %58) #8
  %60 = load i16* %op_type9, align 2, !tbaa !4
  switch i16 %60, label %if.end62 [
    i16 179, label %if.then22
    i16 178, label %if.then28
  ]

if.then22:                                        ; preds = %if.then17
  %op_next = getelementptr inbounds %struct.op* %58, i64 0, i32 0
  %61 = load %struct.op** %op_next, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %op_next, align 8, !tbaa !3
  br label %if.end62

if.then28:                                        ; preds = %if.then17
  %62 = load i16* %op_type, align 2, !tbaa !4
  %cmp31 = icmp eq i16 %62, 150
  br i1 %cmp31, label %if.then33, label %if.else57

if.then33:                                        ; preds = %if.then28
  tail call void @Perl_op_null(%struct.op* %58) #8
  %op_next34 = getelementptr inbounds %struct.op* %58, i64 0, i32 0
  store %struct.op* %58, %struct.op** %op_next34, align 8, !tbaa !3
  %63 = getelementptr inbounds %struct.op* %58, i64 1, i32 0
  %64 = load %struct.op** %63, align 8, !tbaa !3
  %k.0.in135 = getelementptr inbounds %struct.op* %64, i64 0, i32 0
  %k.0136 = load %struct.op** %k.0.in135, align 8
  %tobool37137 = icmp eq %struct.op* %k.0136, null
  br i1 %tobool37137, label %if.end59, label %for.body

for.body:                                         ; preds = %if.then33, %for.cond.backedge
  %k.0138 = phi %struct.op* [ %k.0, %for.cond.backedge ], [ %k.0136, %if.then33 ]
  %op_next38 = getelementptr inbounds %struct.op* %k.0138, i64 0, i32 0
  %65 = load %struct.op** %op_next38, align 8, !tbaa !3
  %cmp39 = icmp eq %struct.op* %65, %58
  br i1 %cmp39, label %for.cond.backedge.thread, label %if.else43

for.cond.backedge.thread:                         ; preds = %for.body
  store %struct.op* null, %struct.op** %op_next38, align 8, !tbaa !3
  br label %if.end59

if.else43:                                        ; preds = %for.body
  %op_type44 = getelementptr inbounds %struct.op* %k.0138, i64 0, i32 4
  %66 = load i16* %op_type44, align 2, !tbaa !4
  switch i16 %66, label %for.cond.backedge [
    i16 182, label %if.then53
    i16 180, label %if.then53
  ]

for.cond.backedge:                                ; preds = %if.else43, %if.then53
  %k.0 = phi %struct.op* [ %k.0.pre, %if.then53 ], [ %65, %if.else43 ]
  %tobool37 = icmp eq %struct.op* %k.0, null
  br i1 %tobool37, label %if.end59, label %for.body

if.then53:                                        ; preds = %if.else43, %if.else43
  %op_lastop = getelementptr inbounds %struct.op* %k.0138, i64 1, i32 4
  %67 = bitcast i16* %op_lastop to %struct.op**
  %68 = load %struct.op** %67, align 8, !tbaa !3
  %k.0.in.phi.trans.insert = getelementptr inbounds %struct.op* %68, i64 0, i32 0
  %k.0.pre = load %struct.op** %k.0.in.phi.trans.insert, align 8
  br label %for.cond.backedge

if.else57:                                        ; preds = %if.then28
  %op_next58 = getelementptr inbounds %struct.op* %58, i64 0, i32 0
  store %struct.op* null, %struct.op** %op_next58, align 8, !tbaa !3
  %.pre = getelementptr inbounds %struct.op* %58, i64 1, i32 0
  br label %if.end59

if.end59:                                         ; preds = %if.then33, %for.cond.backedge.thread, %for.cond.backedge, %if.else57
  %.pre-phi = phi %struct.op** [ %.pre, %if.else57 ], [ %63, %for.cond.backedge ], [ %63, %for.cond.backedge.thread ], [ %63, %if.then33 ]
  %69 = load %struct.op** %.pre-phi, align 8, !tbaa !3
  br label %if.end62

if.end62:                                         ; preds = %if.then17, %if.end59, %if.then22
  %k.2 = phi %struct.op* [ %61, %if.then22 ], [ %69, %if.end59 ], [ null, %if.then17 ]
  %70 = load void (%struct.op*)** @PL_peepp, align 8, !tbaa !3
  tail call void %70(%struct.op* %k.2) #7
  %71 = load i16* %op_type, align 2, !tbaa !4
  %cmp65 = icmp eq i16 %71, 150
  br i1 %cmp65, label %if.then67, label %if.else70

if.then67:                                        ; preds = %if.end62
  %call68 = tail call %struct.op* @Perl_scalar(%struct.op* %55) #8
  %op_next69 = getelementptr inbounds %struct.op* %call68, i64 0, i32 0
  store %struct.op* %call68, %struct.op** %op_next69, align 8, !tbaa !3
  br label %if.end72

if.else70:                                        ; preds = %if.end62
  %op_next71 = getelementptr inbounds %struct.op* %55, i64 0, i32 0
  store %struct.op* %k.2, %struct.op** %op_next71, align 8, !tbaa !3
  br label %if.end72

if.end72:                                         ; preds = %if.else70, %if.then67
  %72 = load i8* %op_flags, align 1, !tbaa !1
  %or = or i8 %72, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  br label %if.end88

if.then86:                                        ; preds = %if.then7, %if.then7
  tail call void @Perl_op_null(%struct.op* %55) #8
  br label %if.end88

if.end88:                                         ; preds = %if.then7, %if.then86, %if.end72
  %op_sibling89 = getelementptr inbounds %struct.op* %55, i64 0, i32 1
  %73 = load %struct.op** %op_sibling89, align 8, !tbaa !3
  br label %if.end90

if.end90:                                         ; preds = %if.end, %if.end88
  %firstkid.0 = phi %struct.op* [ %73, %if.end88 ], [ %55, %if.end ]
  %74 = load i16* %op_type, align 2, !tbaa !4
  %cmp93 = icmp eq i16 %74, 150
  br i1 %cmp93, label %if.then95, label %if.end97

if.then95:                                        ; preds = %if.end90
  %call96 = tail call %struct.op* @Perl_list(%struct.op* %firstkid.0) #8
  br label %if.end97

if.end97:                                         ; preds = %if.then95, %if.end90
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_index(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.end9, label %if.end

if.end:                                           ; preds = %if.then
  %op_sibling3 = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %4 = load %struct.op** %op_sibling3, align 8, !tbaa !3
  %tobool4 = icmp eq %struct.op* %4, null
  br i1 %tobool4, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %op_type = getelementptr inbounds %struct.op* %4, i64 0, i32 4
  %5 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %5, 5
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %land.lhs.true
  %op_sv = getelementptr inbounds %struct.op* %4, i64 1
  %6 = bitcast %struct.op* %op_sv to %struct.sv**
  %7 = load %struct.sv** %6, align 8, !tbaa !3
  tail call void @Perl_fbm_compile(%struct.sv* %7, i32 0) #7
  br label %if.end9

if.end9:                                          ; preds = %if.then, %if.end, %entry, %land.lhs.true, %if.then7
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  ret %struct.op* %call
}

; Function Attrs: optsize
declare void @Perl_fbm_compile(%struct.sv*, i32) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_lengthconst(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_lfun(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %conv = zext i16 %0 to i32
  %call1 = tail call fastcc %struct.op* @S_modkids(%struct.op* %call, i32 %conv) #8
  ret %struct.op* %call1
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_defined(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %1, i64 0, i32 14
  %2 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %2, null
  br i1 %cmp, label %lor.lhs.false22, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings3 = getelementptr inbounds %struct.cop* %3, i64 0, i32 14
  %4 = load %struct.sv** %cop_warnings3, align 8, !tbaa !3
  %cmp4 = icmp eq %struct.sv* %4, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp4, label %lor.lhs.false22, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true2
  %5 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings7 = getelementptr inbounds %struct.cop* %5, i64 0, i32 14
  %6 = load %struct.sv** %cop_warnings7, align 8, !tbaa !3
  %cmp8 = icmp eq %struct.sv* %6, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp8, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true6
  %7 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings10 = getelementptr inbounds %struct.cop* %7, i64 0, i32 14
  %8 = load %struct.sv** %cop_warnings10, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %9 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !3
  %11 = load i8* %10, align 1, !tbaa !1
  %and12 = and i8 %11, 16
  %tobool13 = icmp eq i8 %and12, 0
  br i1 %tobool13, label %lor.lhs.false14, label %if.then

lor.lhs.false14:                                  ; preds = %lor.lhs.false
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings15 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings15, align 8, !tbaa !3
  %sv_any16 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %14 = load i8** %sv_any16, align 8, !tbaa !3
  %xpv_pv17 = bitcast i8* %14 to i8**
  %15 = load i8** %xpv_pv17, align 8, !tbaa !3
  %arrayidx18 = getelementptr inbounds i8* %15, i64 7
  %16 = load i8* %arrayidx18, align 1, !tbaa !1
  %and20 = and i8 %16, 1
  %tobool21 = icmp eq i8 %and20, 0
  br i1 %tobool21, label %lor.lhs.false22, label %if.then

lor.lhs.false22:                                  ; preds = %lor.lhs.false14, %land.lhs.true2, %land.lhs.true
  %17 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings23 = getelementptr inbounds %struct.cop* %17, i64 0, i32 14
  %18 = load %struct.sv** %cop_warnings23, align 8, !tbaa !3
  %cmp24 = icmp eq %struct.sv* %18, null
  br i1 %cmp24, label %land.lhs.true26, label %if.end

land.lhs.true26:                                  ; preds = %lor.lhs.false22
  %19 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and28 = and i8 %19, 1
  %tobool29 = icmp eq i8 %and28, 0
  br i1 %tobool29, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false14, %lor.lhs.false, %land.lhs.true26, %land.lhs.true6
  %20 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %21 = load %struct.op** %20, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %21, i64 0, i32 4
  %22 = load i16* %op_type, align 2, !tbaa !4
  %conv30 = zext i16 %22 to i32
  switch i32 %conv30, label %if.end [
    i32 11, label %sw.bb31
    i32 10, label %sw.bb
    i32 37, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then, %if.then
  tail call void (i32, i8*, ...)* @Perl_warner(i32 7170, i8* getelementptr inbounds ([30 x i8]* @.str114, i64 0, i64 0)) #7
  tail call void (i32, i8*, ...)* @Perl_warner(i32 7170, i8* getelementptr inbounds ([46 x i8]* @.str115, i64 0, i64 0)) #7
  br label %if.end

sw.bb31:                                          ; preds = %if.then
  tail call void (i32, i8*, ...)* @Perl_warner(i32 7170, i8* getelementptr inbounds ([30 x i8]* @.str116, i64 0, i64 0)) #7
  tail call void (i32, i8*, ...)* @Perl_warner(i32 7170, i8* getelementptr inbounds ([46 x i8]* @.str115, i64 0, i64 0)) #7
  br label %if.end

if.end:                                           ; preds = %land.lhs.true26, %entry, %sw.bb, %sw.bb31, %if.then, %lor.lhs.false22
  %op_type.i = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %23 = load i16* %op_type.i, align 2, !tbaa !4
  %call.i = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #7
  %conv.i = zext i16 %23 to i32
  %call1.i = tail call %struct.op* @Perl_refkids(%struct.op* %call.i, i32 %conv.i) #7
  ret %struct.op* %call1.i
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_rfun(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %conv = zext i16 %0 to i32
  %call1 = tail call %struct.op* @Perl_refkids(%struct.op* %call, i32 %conv) #8
  ret %struct.op* %call1
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_listiob(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %tobool = icmp eq %struct.op* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call %struct.op* @Perl_force_list(%struct.op* %o) #8
  %2 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %o.addr.0 = phi %struct.op* [ %o, %entry ], [ %call, %if.then ]
  %kid.0 = phi %struct.op* [ %1, %entry ], [ %3, %if.then ]
  %op_type = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 3
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %op_sibling = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !3
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %kid.1 = phi %struct.op* [ %5, %if.then3 ], [ %kid.0, %if.end ]
  %tobool5 = icmp eq %struct.op* %kid.1, null
  br i1 %tobool5, label %if.then36, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %op_flags = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %6, 64
  %tobool7 = icmp eq i8 %and, 0
  %op_sibling12 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 1
  %7 = load %struct.op** %op_sibling12, align 8, !tbaa !3
  br i1 %tobool7, label %land.lhs.true11, label %if.end34

land.lhs.true11:                                  ; preds = %land.lhs.true
  %tobool13 = icmp eq %struct.op* %7, null
  br i1 %tobool13, label %if.then14, label %if.end41

if.then14:                                        ; preds = %land.lhs.true11
  %op_type15 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  %8 = load i16* %op_type15, align 2, !tbaa !4
  %cmp17 = icmp eq i16 %8, 5
  br i1 %cmp17, label %land.lhs.true19, label %if.end41

land.lhs.true19:                                  ; preds = %if.then14
  %op_private = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 7
  %9 = load i8* %op_private, align 1, !tbaa !1
  %and21 = and i8 %9, 64
  %tobool22 = icmp eq i8 %and21, 0
  br i1 %tobool22, label %if.end34, label %if.then23

if.then23:                                        ; preds = %land.lhs.true19
  %or = or i8 %6, 64
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  %call27 = tail call %struct.op* @Perl_scalar(%struct.op* %kid.1) #8
  %call28 = tail call %struct.op* @Perl_newUNOP(i32 14, i32 16, %struct.op* %call27) #8
  %10 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 0
  %11 = load %struct.op** %10, align 8, !tbaa !3
  %op_sibling30 = getelementptr inbounds %struct.op* %11, i64 0, i32 1
  store %struct.op* %call28, %struct.op** %op_sibling30, align 8, !tbaa !3
  %12 = getelementptr inbounds %struct.op* %o.addr.0, i64 1, i32 1
  store %struct.op* %call28, %struct.op** %12, align 8, !tbaa !3
  %op_sibling31 = getelementptr inbounds %struct.op* %call28, i64 0, i32 1
  %13 = load %struct.op** %op_sibling31, align 8, !tbaa !3
  br label %if.end34

if.end34:                                         ; preds = %land.lhs.true, %land.lhs.true19, %if.then23
  %kid.2 = phi %struct.op* [ %13, %if.then23 ], [ %kid.1, %land.lhs.true19 ], [ %7, %land.lhs.true ]
  %tobool35 = icmp eq %struct.op* %kid.2, null
  br i1 %tobool35, label %if.then36, label %if.end41

if.then36:                                        ; preds = %if.end4, %if.end34
  %op_type37 = getelementptr inbounds %struct.op* %o.addr.0, i64 0, i32 4
  %14 = load i16* %op_type37, align 2, !tbaa !4
  %conv38 = zext i16 %14 to i32
  %15 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %16 = bitcast %struct.gv* %15 to %struct.sv*
  store %struct.sv* %16, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %15, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then36
  %17 = getelementptr inbounds %struct.gv* %15, i64 0, i32 1
  %18 = load i32* %17, align 4, !tbaa !0
  %inc.i = add i32 %18, 1
  store i32 %inc.i, i32* %17, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then36, %land.rhs.i
  %call.i65 = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %16) #7
  %call1.i = tail call %struct.op* @Perl_newSVREF(%struct.op* %call.i65) #7
  %call40 = tail call %struct.op* @Perl_append_elem(i32 %conv38, %struct.op* %o.addr.0, %struct.op* %call1.i) #8
  br label %if.end41

if.end41:                                         ; preds = %if.then14, %land.lhs.true11, %if.end34, %Perl_newGVOP.exit
  %call42 = tail call %struct.op* @Perl_listkids(%struct.op* %o.addr.0) #8
  ret %struct.op* %call42
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_sassign(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %idxprom = zext i16 %2 to i64
  %arrayidx = getelementptr inbounds [0 x i32]* @PL_opargs, i64 0, i64 %idxprom
  %3 = load i32* %arrayidx, align 4, !tbaa !0
  %and = and i32 %3, 256
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end26, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %4 = load i8* %op_flags, align 1, !tbaa !1
  %and1 = and i8 %4, 64
  %tobool2 = icmp eq i8 %and1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end26

land.lhs.true3:                                   ; preds = %land.lhs.true
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %5 = load i8* %op_private, align 1, !tbaa !1
  %and5 = and i8 %5, 16
  %tobool6 = icmp eq i8 %and5, 0
  br i1 %tobool6, label %if.then, label %if.end26

if.then:                                          ; preds = %land.lhs.true3
  %op_sibling = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %6 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool7 = icmp eq %struct.op* %6, null
  br i1 %tobool7, label %if.end26, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %if.then
  %op_type9 = getelementptr inbounds %struct.op* %6, i64 0, i32 4
  %7 = load i16* %op_type9, align 2, !tbaa !4
  %cmp = icmp eq i16 %7, 9
  br i1 %cmp, label %land.lhs.true12, label %if.end26

land.lhs.true12:                                  ; preds = %land.lhs.true8
  %op_private13 = getelementptr inbounds %struct.op* %6, i64 0, i32 7
  %8 = load i8* %op_private13, align 1, !tbaa !1
  %tobool16 = icmp slt i8 %8, 0
  br i1 %tobool16, label %if.end26, label %if.then17

if.then17:                                        ; preds = %land.lhs.true12
  %op_targ = getelementptr inbounds %struct.op* %6, i64 0, i32 3
  %9 = load i64* %op_targ, align 8, !tbaa !5
  %op_targ18 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  store i64 %9, i64* %op_targ18, align 8, !tbaa !5
  store i64 0, i64* %op_targ, align 8, !tbaa !5
  %op_sibling20 = getelementptr inbounds %struct.op* %o, i64 0, i32 1
  %10 = load %struct.op** %op_sibling20, align 8, !tbaa !3
  store %struct.op* %10, %struct.op** %op_sibling, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %0, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %o) #8
  tail call void @Perl_op_free(%struct.op* %6) #8
  %11 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %11, 16
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  br label %return

if.end26:                                         ; preds = %if.then, %land.lhs.true3, %land.lhs.true, %entry, %land.lhs.true8, %land.lhs.true12
  %cmp29 = icmp eq i16 %2, 43
  br i1 %cmp29, label %if.then31, label %return

if.then31:                                        ; preds = %if.end26
  %op_sibling33 = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %12 = load %struct.op** %op_sibling33, align 8, !tbaa !3
  %tobool34 = icmp eq %struct.op* %12, null
  br i1 %tobool34, label %return, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %if.then31
  %op_type36 = getelementptr inbounds %struct.op* %12, i64 0, i32 4
  %13 = load i16* %op_type36, align 2, !tbaa !4
  %cmp38 = icmp eq i16 %13, 9
  br i1 %cmp38, label %land.lhs.true40, label %return

land.lhs.true40:                                  ; preds = %land.lhs.true35
  %op_private41 = getelementptr inbounds %struct.op* %12, i64 0, i32 7
  %14 = load i8* %op_private41, align 1, !tbaa !1
  %tobool44 = icmp slt i8 %14, 0
  br i1 %tobool44, label %if.then45, label %return

if.then45:                                        ; preds = %land.lhs.true40
  store %struct.op* null, %struct.op** %0, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %op_sibling33, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %o) #8
  tail call void @Perl_op_free(%struct.op* %1) #8
  br label %return

return:                                           ; preds = %if.end26, %land.lhs.true40, %land.lhs.true35, %if.then31, %if.then45, %if.then17
  %retval.0 = phi %struct.op* [ %12, %if.then45 ], [ %1, %if.then17 ], [ %o, %if.then31 ], [ %o, %land.lhs.true35 ], [ %o, %land.lhs.true40 ], [ %o, %if.end26 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_match(%struct.op* %o) #0 {
entry:
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %0 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %0, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_method(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %2 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %2, 5
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %op_sv = getelementptr inbounds %struct.op* %1, i64 1
  %3 = bitcast %struct.op* %op_sv to %struct.sv**
  %4 = load %struct.sv** %3, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %5 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %5 to i8**
  %6 = load i8** %xpv_pv, align 8, !tbaa !3
  %call = tail call i8* @strchr(i8* %6, i32 58) #7
  %tobool = icmp eq i8* %call, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.then
  %call4 = tail call i8* @strchr(i8* %6, i32 39) #7
  %tobool5 = icmp eq i8* %call4, null
  br i1 %tobool5, label %if.then6, label %return

if.then6:                                         ; preds = %lor.lhs.false
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !0
  %8 = and i32 %7, 9437184
  %9 = icmp eq i32 %8, 9437184
  br i1 %9, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.then6
  %xpv_cur = getelementptr inbounds i8* %5, i64 8
  %10 = bitcast i8* %xpv_cur to i64*
  %11 = load i64* %10, align 8, !tbaa !5
  %conv16 = trunc i64 %11 to i32
  %call17 = tail call %struct.sv* @Perl_newSVpvn_share(i8* %6, i32 %conv16, i32 0) #7
  br label %if.end

if.else:                                          ; preds = %if.then6
  %12 = getelementptr inbounds %struct.op* %op_sv, i64 0, i32 0
  store %struct.op* null, %struct.op** %12, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then12
  %sv.0 = phi %struct.sv* [ %4, %if.else ], [ %call17, %if.then12 ]
  %call19 = tail call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %sv.0) #8
  tail call void @Perl_op_free(%struct.op* %o) #8
  br label %return

return:                                           ; preds = %entry, %if.then, %lor.lhs.false, %if.end
  %retval.0 = phi %struct.op* [ %call19, %if.end ], [ %o, %lor.lhs.false ], [ %o, %if.then ], [ %o, %entry ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv* @Perl_newSVpvn_share(i8*, i32, i32) #2

; Function Attrs: nounwind optsize readnone uwtable
define %struct.op* @Perl_ck_null(%struct.op* %o) #3 {
entry:
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_open(%struct.op* %o) #0 {
entry:
  %0 = load %struct.gv** @PL_hintgv, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.gv* %0, i64 0, i32 0
  %1 = load %struct.xpvgv** %sv_any, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %1, i64 0, i32 7
  %2 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %2, i64 0, i32 5
  %3 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %tobool = icmp eq %struct.hv* %3, null
  br i1 %tobool, label %if.end41, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %3, i8* getelementptr inbounds ([8 x i8]* @.str117, i64 0, i64 0), i32 7, i32 0) #7
  %tobool1 = icmp eq %struct.sv** %call, null
  br i1 %tobool1, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %4 = load %struct.sv** %call, align 8, !tbaa !3
  %tobool2 = icmp eq %struct.sv* %4, null
  br i1 %tobool2, label %if.end16, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %call4 = tail call i32 @Perl_mode_from_discipline(%struct.sv* %4) #7
  br label %if.end16

if.end16:                                         ; preds = %land.lhs.true, %if.then, %if.then3
  %call17 = tail call %struct.sv** @Perl_hv_fetch(%struct.hv* %3, i8* getelementptr inbounds ([9 x i8]* @.str118, i64 0, i64 0), i32 8, i32 0) #7
  %tobool18 = icmp eq %struct.sv** %call17, null
  br i1 %tobool18, label %if.end41, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %if.end16
  %5 = load %struct.sv** %call17, align 8, !tbaa !3
  %tobool20 = icmp eq %struct.sv* %5, null
  br i1 %tobool20, label %if.end41, label %if.then21

if.then21:                                        ; preds = %land.lhs.true19
  %call22 = tail call i32 @Perl_mode_from_discipline(%struct.sv* %5) #7
  br label %if.end41

if.end41:                                         ; preds = %land.lhs.true19, %if.end16, %entry, %if.then21
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %6 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %6, 24
  br i1 %cmp, label %return, label %if.end45

if.end45:                                         ; preds = %if.end41
  %7 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %8 = load %struct.op** %7, align 8, !tbaa !3
  %9 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %10 = load %struct.op** %9, align 8, !tbaa !3
  %op_type47 = getelementptr inbounds %struct.op* %10, i64 0, i32 4
  %11 = load i16* %op_type47, align 2, !tbaa !4
  %cmp49 = icmp eq i16 %11, 5
  br i1 %cmp49, label %land.lhs.true51, label %if.end91

land.lhs.true51:                                  ; preds = %if.end45
  %op_private52 = getelementptr inbounds %struct.op* %10, i64 0, i32 7
  %12 = load i8* %op_private52, align 1, !tbaa !1
  %13 = and i8 %12, 72
  %14 = icmp eq i8 %13, 72
  br i1 %14, label %land.lhs.true61, label %if.end91

land.lhs.true61:                                  ; preds = %land.lhs.true51
  %op_sibling = getelementptr inbounds %struct.op* %8, i64 0, i32 1
  %15 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool62 = icmp eq %struct.op* %15, null
  br i1 %tobool62, label %if.end91, label %land.lhs.true63

land.lhs.true63:                                  ; preds = %land.lhs.true61
  %op_sibling64 = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling64, align 8, !tbaa !3
  %tobool65 = icmp eq %struct.op* %16, null
  br i1 %tobool65, label %if.end91, label %land.lhs.true66

land.lhs.true66:                                  ; preds = %land.lhs.true63
  %op_sv = getelementptr inbounds %struct.op* %16, i64 1
  %17 = bitcast %struct.op* %op_sv to %struct.sv**
  %18 = load %struct.sv** %17, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags, align 4, !tbaa !0
  %and67 = and i32 %19, 262144
  %tobool68 = icmp eq i32 %and67, 0
  br i1 %tobool68, label %if.end91, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %land.lhs.true66
  %sv_any71 = getelementptr inbounds %struct.sv* %18, i64 0, i32 0
  %20 = load i8** %sv_any71, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %20 to i8**
  %21 = load i8** %xpv_pv, align 8, !tbaa !3
  %tobool72 = icmp eq i8* %21, null
  br i1 %tobool72, label %if.end91, label %land.lhs.true73

land.lhs.true73:                                  ; preds = %land.lhs.true69
  %22 = load i8* %21, align 1, !tbaa !1
  %cmp75 = icmp eq i8 %22, 62
  br i1 %cmp75, label %land.lhs.true77, label %if.end91

land.lhs.true77:                                  ; preds = %land.lhs.true73
  %arrayidx78 = getelementptr inbounds i8* %21, i64 1
  %23 = load i8* %arrayidx78, align 1, !tbaa !1
  %cmp80 = icmp eq i8 %23, 38
  br i1 %cmp80, label %land.lhs.true82, label %if.end91

land.lhs.true82:                                  ; preds = %land.lhs.true77
  %op_sibling83 = getelementptr inbounds %struct.op* %16, i64 0, i32 1
  %24 = load %struct.op** %op_sibling83, align 8, !tbaa !3
  %cmp84 = icmp eq %struct.op* %10, %24
  br i1 %cmp84, label %if.then86, label %if.end91

if.then86:                                        ; preds = %land.lhs.true82
  %and89 = and i8 %12, -9
  store i8 %and89, i8* %op_private52, align 1, !tbaa !1
  br label %if.end91

if.end91:                                         ; preds = %land.lhs.true51, %land.lhs.true69, %land.lhs.true66, %land.lhs.true63, %land.lhs.true61, %if.then86, %land.lhs.true82, %land.lhs.true77, %land.lhs.true73, %if.end45
  %call92 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  br label %return

return:                                           ; preds = %if.end41, %if.end91
  %retval.0 = phi %struct.op* [ %call92, %if.end91 ], [ %o, %if.end41 ]
  ret %struct.op* %retval.0
}

; Function Attrs: optsize
declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i32, i32) #2

; Function Attrs: optsize
declare i32 @Perl_mode_from_discipline(%struct.sv*) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_repeat(%struct.op* %o) #0 {
entry:
  %0 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %1 = load %struct.op** %0, align 8, !tbaa !3
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %2 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %2, 8
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %o, i64 0, i32 7
  %3 = load i8* %op_private, align 1, !tbaa !1
  %or = or i8 %3, 64
  store i8 %or, i8* %op_private, align 1, !tbaa !1
  %call = tail call %struct.op* @Perl_force_list(%struct.op* %1) #8
  store %struct.op* %call, %struct.op** %0, align 8, !tbaa !3
  br label %if.end

if.else:                                          ; preds = %entry
  %call5 = tail call %struct.op* @Perl_scalar(%struct.op* %o) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_require(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end33, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %3 = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %4 = load i16* %3, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 5
  br i1 %cmp, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %if.then
  %5 = getelementptr inbounds %struct.op* %2, i64 0, i32 7
  %6 = load i8* %5, align 1, !tbaa !1
  %and4 = and i8 %6, 64
  %tobool5 = icmp eq i8 %and4, 0
  br i1 %tobool5, label %if.end33, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %op_sv = getelementptr inbounds %struct.op* %2, i64 1
  %7 = bitcast %struct.op* %op_sv to %struct.sv**
  %8 = load %struct.sv** %7, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %8, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %9 to i8**
  %10 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %for.cond

for.cond:                                         ; preds = %if.then15, %land.lhs.true11, %for.cond.for.inc_crit_edge, %if.then6
  %11 = phi %struct.sv* [ %8, %if.then6 ], [ %11, %for.cond.for.inc_crit_edge ], [ %11, %land.lhs.true11 ], [ %14, %if.then15 ]
  %s.0 = phi i8* [ %10, %if.then6 ], [ %incdec.ptr.pre, %for.cond.for.inc_crit_edge ], [ %arrayidx, %land.lhs.true11 ], [ %arrayidx, %if.then15 ]
  %12 = load i8* %s.0, align 1, !tbaa !1
  switch i8 %12, label %for.cond.for.inc_crit_edge [
    i8 0, label %for.end
    i8 58, label %land.lhs.true11
  ]

for.cond.for.inc_crit_edge:                       ; preds = %for.cond
  %incdec.ptr.pre = getelementptr inbounds i8* %s.0, i64 1
  br label %for.cond

land.lhs.true11:                                  ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8* %s.0, i64 1
  %13 = load i8* %arrayidx, align 1, !tbaa !1
  %cmp13 = icmp eq i8 %13, 58
  br i1 %cmp13, label %if.then15, label %for.cond

if.then15:                                        ; preds = %land.lhs.true11
  store i8 47, i8* %s.0, align 1, !tbaa !1
  %add.ptr16 = getelementptr inbounds i8* %s.0, i64 2
  %call = tail call i64 @strlen(i8* %add.ptr16) #7
  %add = add i64 %call, 1
  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %arrayidx, i8* %add.ptr16, i64 %add, i32 1, i1 false)
  %14 = load %struct.sv** %7, align 8, !tbaa !3
  %sv_any19 = getelementptr inbounds %struct.sv* %14, i64 0, i32 0
  %15 = load i8** %sv_any19, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %15, i64 8
  %16 = bitcast i8* %xpv_cur to i64*
  %17 = load i64* %16, align 8, !tbaa !5
  %dec = add i64 %17, -1
  store i64 %dec, i64* %16, align 8, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sv_flags = getelementptr inbounds %struct.sv* %11, i64 0, i32 2
  %18 = load i32* %sv_flags, align 4, !tbaa !0
  %and21 = and i32 %18, 8388608
  %tobool22 = icmp eq i32 %and21, 0
  br i1 %tobool22, label %if.else, label %if.then23

if.then23:                                        ; preds = %for.end
  %and26 = and i32 %18, -8388609
  store i32 %and26, i32* %sv_flags, align 4, !tbaa !0
  tail call void @Perl_sv_catpvn_flags(%struct.sv* %11, i8* getelementptr inbounds ([4 x i8]* @.str119, i64 0, i64 0), i64 3, i32 2) #7
  %19 = load %struct.sv** %7, align 8, !tbaa !3
  %sv_flags29 = getelementptr inbounds %struct.sv* %19, i64 0, i32 2
  %20 = load i32* %sv_flags29, align 4, !tbaa !0
  %or = or i32 %20, 8388608
  store i32 %or, i32* %sv_flags29, align 4, !tbaa !0
  br label %if.end33

if.else:                                          ; preds = %for.end
  tail call void @Perl_sv_catpvn_flags(%struct.sv* %11, i8* getelementptr inbounds ([4 x i8]* @.str119, i64 0, i64 0), i64 3, i32 2) #7
  br label %if.end33

if.end33:                                         ; preds = %land.lhs.true, %entry, %if.then, %if.else, %if.then23
  %call34 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([8 x i8]* @.str120, i64 0, i64 0), i32 0, i32 12) #7
  %tobool35 = icmp eq %struct.gv* %call34, null
  br i1 %tobool35, label %if.then47, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %if.end33
  %sv_any37 = getelementptr inbounds %struct.gv* %call34, i64 0, i32 0
  %21 = load %struct.xpvgv** %sv_any37, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 7
  %22 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_cvgen = getelementptr inbounds %struct.gp* %22, i64 0, i32 8
  %23 = load i32* %gp_cvgen, align 4, !tbaa !0
  %tobool38 = icmp eq i32 %23, 0
  br i1 %tobool38, label %cond.false, label %if.then47

cond.false:                                       ; preds = %land.lhs.true36
  %gp_cv = getelementptr inbounds %struct.gp* %22, i64 0, i32 7
  %24 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool41 = icmp eq %struct.cv* %24, null
  br i1 %tobool41, label %if.then47, label %land.lhs.true42

land.lhs.true42:                                  ; preds = %cond.false
  %xgv_flags = getelementptr inbounds %struct.xpvgv* %21, i64 0, i32 11
  %25 = load i8* %xgv_flags, align 1, !tbaa !1
  %tobool46 = icmp slt i8 %25, 0
  br i1 %tobool46, label %if.end49, label %if.then47

if.then47:                                        ; preds = %cond.false, %land.lhs.true36, %if.end33, %land.lhs.true42
  %call48 = tail call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([22 x i8]* @.str121, i64 0, i64 0), i32 0, i32 12) #7
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %land.lhs.true42
  %gv.0 = phi %struct.gv* [ %call48, %if.then47 ], [ %call34, %land.lhs.true42 ]
  %tobool50 = icmp eq %struct.gv* %gv.0, null
  br i1 %tobool50, label %if.end78, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %if.end49
  %sv_any52 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 0
  %26 = load %struct.xpvgv** %sv_any52, align 8, !tbaa !3
  %xgv_gp53 = getelementptr inbounds %struct.xpvgv* %26, i64 0, i32 7
  %27 = load %struct.gp** %xgv_gp53, align 8, !tbaa !3
  %gp_cvgen54 = getelementptr inbounds %struct.gp* %27, i64 0, i32 8
  %28 = load i32* %gp_cvgen54, align 4, !tbaa !0
  %tobool55 = icmp eq i32 %28, 0
  br i1 %tobool55, label %cond.false57, label %if.end78

cond.false57:                                     ; preds = %land.lhs.true51
  %gp_cv60 = getelementptr inbounds %struct.gp* %27, i64 0, i32 7
  %29 = load %struct.cv** %gp_cv60, align 8, !tbaa !3
  %tobool61 = icmp eq %struct.cv* %29, null
  br i1 %tobool61, label %if.end78, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %cond.false57
  %xgv_flags64 = getelementptr inbounds %struct.xpvgv* %26, i64 0, i32 11
  %30 = load i8* %xgv_flags64, align 1, !tbaa !1
  %tobool67 = icmp slt i8 %30, 0
  br i1 %tobool67, label %Perl_newGVOP.exit, label %if.end78

Perl_newGVOP.exit:                                ; preds = %land.lhs.true62
  %31 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %32 = load %struct.op** %31, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %31, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %o) #8
  %33 = bitcast %struct.gv* %gv.0 to %struct.sv*
  store %struct.sv* %33, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %34 = getelementptr inbounds %struct.gv* %gv.0, i64 0, i32 1
  %35 = load i32* %34, align 4, !tbaa !0
  %inc.i = add i32 %35, 1
  store i32 %inc.i, i32* %34, align 4, !tbaa !0
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %33) #7
  %call73 = tail call %struct.op* @Perl_newUNOP(i32 17, i32 0, %struct.op* %call.i) #8
  %call74 = tail call %struct.op* @Perl_scalar(%struct.op* %call73) #8
  %call75 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %32, %struct.op* %call74) #8
  %call76 = tail call %struct.op* @Perl_newUNOP(i32 166, i32 64, %struct.op* %call75) #8
  %call77 = tail call %struct.op* @Perl_ck_subr(%struct.op* %call76) #8
  br label %return

if.end78:                                         ; preds = %cond.false57, %land.lhs.true51, %if.end49, %land.lhs.true62
  %call79 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  br label %return

return:                                           ; preds = %if.end78, %Perl_newGVOP.exit
  %retval.0 = phi %struct.op* [ %call79, %if.end78 ], [ %call77, %Perl_newGVOP.exit ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) #4

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_return(%struct.op* %o) #0 {
entry:
  %0 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.cv* %0, i64 0, i32 0
  %1 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %1, i64 0, i32 17
  %2 = load i16* %xcv_flags, align 2, !tbaa !4
  %and = and i16 %2, 256
  %tobool = icmp eq i16 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %4 = load %struct.op** %3, align 8, !tbaa !3
  %kid.0.in6 = getelementptr inbounds %struct.op* %4, i64 0, i32 1
  %kid.07 = load %struct.op** %kid.0.in6, align 8
  %tobool18 = icmp eq %struct.op* %kid.07, null
  br i1 %tobool18, label %if.end, label %for.body

for.body:                                         ; preds = %if.then, %for.body
  %kid.09 = phi %struct.op* [ %kid.0, %for.body ], [ %kid.07, %if.then ]
  %call = tail call %struct.op* @Perl_mod(%struct.op* %kid.09, i32 168) #8
  %kid.0.in = getelementptr inbounds %struct.op* %kid.09, i64 0, i32 1
  %kid.0 = load %struct.op** %kid.0.in, align 8
  %tobool1 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool1, label %if.end, label %for.body

if.end:                                           ; preds = %if.then, %for.body, %entry
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_select(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end6, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %3 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool1 = icmp eq %struct.op* %3, null
  br i1 %tobool1, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %op_sibling2 = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %4 = load %struct.op** %op_sibling2, align 8, !tbaa !3
  %tobool3 = icmp eq %struct.op* %4, null
  br i1 %tobool3, label %if.end6, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  store i16 202, i16* %op_type, align 2, !tbaa !4
  %5 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 202), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  store %struct.op* ()* %5, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %call5 = tail call %struct.op* @Perl_fold_constants(%struct.op* %call) #8
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %if.then, %entry
  %call7 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %6 = getelementptr inbounds %struct.op* %call7, i64 1, i32 0
  %7 = load %struct.op** %6, align 8, !tbaa !3
  %op_sibling9 = getelementptr inbounds %struct.op* %7, i64 0, i32 1
  %8 = load %struct.op** %op_sibling9, align 8, !tbaa !3
  %tobool10 = icmp eq %struct.op* %8, null
  br i1 %tobool10, label %return, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %if.end6
  %op_type12 = getelementptr inbounds %struct.op* %8, i64 0, i32 4
  %9 = load i16* %op_type12, align 2, !tbaa !4
  %cmp = icmp eq i16 %9, 14
  br i1 %cmp, label %if.then15, label %return

if.then15:                                        ; preds = %land.lhs.true11
  %op_private = getelementptr inbounds %struct.op* %8, i64 0, i32 7
  %10 = load i8* %op_private, align 1, !tbaa !1
  %and17 = and i8 %10, -3
  store i8 %and17, i8* %op_private, align 1, !tbaa !1
  br label %return

return:                                           ; preds = %land.lhs.true11, %if.then15, %if.end6, %if.then4
  %retval.0 = phi %struct.op* [ %call5, %if.then4 ], [ %call7, %if.end6 ], [ %call7, %if.then15 ], [ %call7, %land.lhs.true11 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_shift(%struct.op* %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %conv = zext i16 %0 to i32
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %1, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @Perl_op_free(%struct.op* %o) #8
  %2 = load %struct.cv** @PL_compcv, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.cv* %2, i64 0, i32 0
  %3 = load %struct.xpvcv** %sv_any, align 8, !tbaa !3
  %xcv_flags = getelementptr inbounds %struct.xpvcv* %3, i64 0, i32 17
  %4 = load i16* %xcv_flags, align 2, !tbaa !4
  %and3 = and i16 %4, 16
  %tobool4 = icmp ne i16 %and3, 0
  %5 = load %struct.gv** @PL_argvgv, align 8, !tbaa !3
  %6 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %cond = select i1 %tobool4, %struct.gv* %5, %struct.gv* %6
  %7 = bitcast %struct.gv* %cond to %struct.sv*
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %cond, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then
  %8 = getelementptr inbounds %struct.gv* %cond, i64 0, i32 1
  %9 = load i32* %8, align 4, !tbaa !0
  %inc.i = add i32 %9, 1
  store i32 %inc.i, i32* %8, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then, %land.rhs.i
  %call.i = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %7) #7
  %call5 = tail call %struct.op* @Perl_scalar(%struct.op* %call.i) #8
  %call6 = tail call %struct.op* @Perl_newUNOP(i32 125, i32 0, %struct.op* %call5) #8
  %call7 = tail call %struct.op* @Perl_scalar(%struct.op* %call6) #8
  %call8 = tail call %struct.op* @Perl_newUNOP(i32 %conv, i32 0, %struct.op* %call7) #8
  br label %return

if.end:                                           ; preds = %entry
  %call9 = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %call10 = tail call fastcc %struct.op* @S_modkids(%struct.op* %call9, i32 %conv) #8
  %call11 = tail call %struct.op* @Perl_scalar(%struct.op* %call10) #8
  br label %return

return:                                           ; preds = %if.end, %Perl_newGVOP.exit
  %retval.0 = phi %struct.op* [ %call11, %if.end ], [ %call8, %Perl_newGVOP.exit ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_split(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 64
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call fastcc %struct.op* @S_no_fh_allowed(%struct.op* %o) #8
  br label %return

if.end:                                           ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %3 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %3, 0
  br i1 %cmp, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([16 x i8]* @.str122, i64 0, i64 0)) #7
  %.pre = load %struct.op** %1, align 8, !tbaa !3
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then3
  %4 = phi %struct.op* [ %2, %if.end ], [ %.pre, %if.then3 ]
  %op_sibling = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !3
  tail call void @Perl_op_free(%struct.op* %4) #8
  store %struct.op* %5, %struct.op** %1, align 8, !tbaa !3
  %tobool7 = icmp eq %struct.op* %5, null
  br i1 %tobool7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end4
  %call9 = tail call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([2 x i8]* @.str123, i64 0, i64 0), i64 1) #7
  %call10 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call9) #8
  store %struct.op* %call10, %struct.op** %1, align 8, !tbaa !3
  %6 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  store %struct.op* %call10, %struct.op** %6, align 8, !tbaa !3
  br label %if.end12

if.end12:                                         ; preds = %if.end4, %if.then8
  %kid.0 = phi %struct.op* [ %5, %if.end4 ], [ %call10, %if.then8 ]
  %op_type13 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 4
  %7 = load i16* %op_type13, align 2, !tbaa !4
  %cmp15 = icmp eq i16 %7, 31
  br i1 %cmp15, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %if.end12
  %op_flags17 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 6
  %8 = load i8* %op_flags17, align 1, !tbaa !1
  %and19 = and i8 %8, 64
  %tobool20 = icmp eq i8 %and19, 0
  br i1 %tobool20, label %if.end35, label %if.then21

if.then21:                                        ; preds = %lor.lhs.false, %if.end12
  %op_sibling22 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 1
  %9 = load %struct.op** %op_sibling22, align 8, !tbaa !3
  store %struct.op* null, %struct.op** %op_sibling22, align 8, !tbaa !3
  %call24 = tail call %struct.op* @Perl_newPMOP(i32 31, i32 128) #8
  %call25 = tail call %struct.op* @Perl_pmruntime(%struct.op* %call24, %struct.op* %kid.0, %struct.op* null) #8
  %10 = load %struct.op** %1, align 8, !tbaa !3
  %11 = getelementptr inbounds %struct.op* %o, i64 1, i32 1
  %12 = load %struct.op** %11, align 8, !tbaa !3
  %cmp28 = icmp eq %struct.op* %10, %12
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.then21
  store %struct.op* %call25, %struct.op** %11, align 8, !tbaa !3
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.then21
  store %struct.op* %call25, %struct.op** %1, align 8, !tbaa !3
  %op_sibling34 = getelementptr inbounds %struct.op* %call25, i64 0, i32 1
  store %struct.op* %9, %struct.op** %op_sibling34, align 8, !tbaa !3
  br label %if.end35

if.end35:                                         ; preds = %lor.lhs.false, %if.end32
  %kid.1 = phi %struct.op* [ %call25, %if.end32 ], [ %kid.0, %lor.lhs.false ]
  %op_type36 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 4
  store i16 13, i16* %op_type36, align 2, !tbaa !4
  %13 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 13), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 2
  store %struct.op* ()* %13, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %call37 = tail call %struct.op* @Perl_scalar(%struct.op* %kid.1) #8
  %14 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %14, i64 0, i32 14
  %15 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp38 = icmp eq %struct.sv* %15, null
  br i1 %cmp38, label %lor.lhs.false52, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end35
  %16 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings40 = getelementptr inbounds %struct.cop* %16, i64 0, i32 14
  %17 = load %struct.sv** %cop_warnings40, align 8, !tbaa !3
  %cmp41 = icmp eq %struct.sv* %17, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp41, label %lor.lhs.false52, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %land.lhs.true
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings44 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings44, align 8, !tbaa !3
  %cmp45 = icmp eq %struct.sv* %19, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp45, label %land.lhs.true60, label %lor.lhs.false47

lor.lhs.false47:                                  ; preds = %land.lhs.true43
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings48 = getelementptr inbounds %struct.cop* %20, i64 0, i32 14
  %21 = load %struct.sv** %cop_warnings48, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %21, i64 0, i32 0
  %22 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %22 to i8**
  %23 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %23, i64 5
  %24 = load i8* %arrayidx, align 1, !tbaa !1
  %and50 = and i8 %24, 1
  %tobool51 = icmp eq i8 %and50, 0
  br i1 %tobool51, label %lor.lhs.false52, label %land.lhs.true60

lor.lhs.false52:                                  ; preds = %lor.lhs.false47, %land.lhs.true, %if.end35
  %25 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings53 = getelementptr inbounds %struct.cop* %25, i64 0, i32 14
  %26 = load %struct.sv** %cop_warnings53, align 8, !tbaa !3
  %cmp54 = icmp eq %struct.sv* %26, null
  br i1 %cmp54, label %land.lhs.true56, label %if.end64

land.lhs.true56:                                  ; preds = %lor.lhs.false52
  %27 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and58 = and i8 %27, 1
  %tobool59 = icmp eq i8 %and58, 0
  br i1 %tobool59, label %if.end64, label %land.lhs.true60

land.lhs.true60:                                  ; preds = %lor.lhs.false47, %land.lhs.true56, %land.lhs.true43
  %op_pmflags = getelementptr inbounds %struct.op* %kid.1, i64 2, i32 1
  %28 = bitcast %struct.op** %op_pmflags to i32*
  %29 = load i32* %28, align 4, !tbaa !0
  %and61 = and i32 %29, 256
  %tobool62 = icmp eq i32 %and61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %land.lhs.true60
  tail call void (i32, i8*, ...)* @Perl_warner(i32 20, i8* getelementptr inbounds ([43 x i8]* @.str124, i64 0, i64 0)) #7
  br label %if.end64

if.end64:                                         ; preds = %land.lhs.true60, %land.lhs.true56, %if.then63, %lor.lhs.false52
  %op_sibling65 = getelementptr inbounds %struct.op* %kid.1, i64 0, i32 1
  %30 = load %struct.op** %op_sibling65, align 8, !tbaa !3
  %tobool66 = icmp eq %struct.op* %30, null
  br i1 %tobool66, label %if.then67, label %if.end70

if.then67:                                        ; preds = %if.end64
  %31 = load %struct.gv** @PL_defgv, align 8, !tbaa !3
  %32 = bitcast %struct.gv* %31 to %struct.sv*
  store %struct.sv* %32, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool.i = icmp eq %struct.gv* %31, null
  br i1 %tobool.i, label %Perl_newGVOP.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then67
  %33 = getelementptr inbounds %struct.gv* %31, i64 0, i32 1
  %34 = load i32* %33, align 4, !tbaa !0
  %inc.i = add i32 %34, 1
  store i32 %inc.i, i32* %33, align 4, !tbaa !0
  br label %Perl_newGVOP.exit

Perl_newGVOP.exit:                                ; preds = %if.then67, %land.rhs.i
  %call.i134 = tail call %struct.op* @Perl_newSVOP(i32 7, i32 0, %struct.sv* %32) #7
  %call1.i = tail call %struct.op* @Perl_newSVREF(%struct.op* %call.i134) #7
  %call69 = tail call %struct.op* @Perl_append_elem(i32 139, %struct.op* %o, %struct.op* %call1.i) #8
  %.pre135 = load %struct.op** %op_sibling65, align 8, !tbaa !3
  br label %if.end70

if.end70:                                         ; preds = %if.end64, %Perl_newGVOP.exit
  %35 = phi %struct.op* [ %30, %if.end64 ], [ %.pre135, %Perl_newGVOP.exit ]
  %call72 = tail call %struct.op* @Perl_scalar(%struct.op* %35) #8
  %op_sibling73 = getelementptr inbounds %struct.op* %35, i64 0, i32 1
  %36 = load %struct.op** %op_sibling73, align 8, !tbaa !3
  %tobool74 = icmp eq %struct.op* %36, null
  br i1 %tobool74, label %if.then75, label %if.end79

if.then75:                                        ; preds = %if.end70
  %call76 = tail call %struct.sv* @Perl_newSViv(i64 0) #7
  %call77 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call76) #8
  %call78 = tail call %struct.op* @Perl_append_elem(i32 139, %struct.op* %o, %struct.op* %call77) #8
  %.pre136 = load %struct.op** %op_sibling73, align 8, !tbaa !3
  br label %if.end79

if.end79:                                         ; preds = %if.end70, %if.then75
  %37 = phi %struct.op* [ %36, %if.end70 ], [ %.pre136, %if.then75 ]
  %call81 = tail call %struct.op* @Perl_scalar(%struct.op* %37) #8
  %op_sibling82 = getelementptr inbounds %struct.op* %37, i64 0, i32 1
  %38 = load %struct.op** %op_sibling82, align 8, !tbaa !3
  %tobool83 = icmp eq %struct.op* %38, null
  br i1 %tobool83, label %return, label %if.then84

if.then84:                                        ; preds = %if.end79
  %op_type85 = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %39 = load i16* %op_type85, align 2, !tbaa !4
  %cmp87 = icmp eq i16 %39, 351
  br i1 %cmp87, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then84
  %call89 = tail call i8* @Perl_custom_op_desc(%struct.op* %o) #8
  br label %cond.end

cond.false:                                       ; preds = %if.then84
  %idxprom = zext i16 %39 to i64
  %arrayidx91 = getelementptr inbounds [0 x i8*]* @PL_op_desc, i64 0, i64 %idxprom
  %40 = load i8** %arrayidx91, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call89, %cond.true ], [ %40, %cond.false ]
  %call.i132 = tail call i8* (i8*, ...)* @Perl_form(i8* getelementptr inbounds ([26 x i8]* @.str144, i64 0, i64 0), i8* %cond) #7
  %call1.i133 = tail call i32 @Perl_yyerror(i8* %call.i132) #7
  br label %return

return:                                           ; preds = %if.end79, %cond.end, %if.then
  %retval.0 = phi %struct.op* [ %call, %if.then ], [ %o, %cond.end ], [ %o, %if.end79 ]
  ret %struct.op* %retval.0
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_join(%struct.op* %o) #0 {
entry:
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %0, i64 0, i32 14
  %1 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp = icmp eq %struct.sv* %1, null
  br i1 %cmp, label %lor.lhs.false7, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings1, align 8, !tbaa !3
  %cmp2 = icmp eq %struct.sv* %3, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp2, label %lor.lhs.false7, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings4 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings4, align 8, !tbaa !3
  %cmp5 = icmp eq %struct.sv* %5, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true3
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings6 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings6, align 8, !tbaa !3
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %9, i64 7
  %10 = load i8* %arrayidx, align 1, !tbaa !1
  %and = and i8 %10, 1
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false7, label %if.then

lor.lhs.false7:                                   ; preds = %lor.lhs.false, %land.lhs.true, %entry
  %11 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings8 = getelementptr inbounds %struct.cop* %11, i64 0, i32 14
  %12 = load %struct.sv** %cop_warnings8, align 8, !tbaa !3
  %cmp9 = icmp eq %struct.sv* %12, null
  br i1 %cmp9, label %land.lhs.true11, label %if.end25

land.lhs.true11:                                  ; preds = %lor.lhs.false7
  %13 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and13 = and i8 %13, 1
  %tobool14 = icmp eq i8 %and13, 0
  br i1 %tobool14, label %if.end25, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true11, %land.lhs.true3
  %14 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %15 = load %struct.op** %14, align 8, !tbaa !3
  %op_sibling = getelementptr inbounds %struct.op* %15, i64 0, i32 1
  %16 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool15 = icmp eq %struct.op* %16, null
  br i1 %tobool15, label %if.end25, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %if.then
  %op_type = getelementptr inbounds %struct.op* %16, i64 0, i32 4
  %17 = load i16* %op_type, align 2, !tbaa !4
  %cmp18 = icmp eq i16 %17, 31
  br i1 %cmp18, label %if.then20, label %if.end25

if.then20:                                        ; preds = %land.lhs.true16
  %op_pmregexp = getelementptr inbounds %struct.op* %16, i64 2
  %18 = bitcast %struct.op* %op_pmregexp to %struct.regexp**
  %19 = load %struct.regexp** %18, align 8, !tbaa !3
  %tobool21 = icmp eq %struct.regexp* %19, null
  br i1 %tobool21, label %if.end, label %if.then22

if.then22:                                        ; preds = %if.then20
  %precomp = getelementptr inbounds %struct.regexp* %19, i64 0, i32 4
  %20 = load i8** %precomp, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.then20, %if.then22
  %pmstr.0 = phi i8* [ %20, %if.then22 ], [ getelementptr inbounds ([7 x i8]* @.str125, i64 0, i64 0), %if.then20 ]
  tail call void (i32, i8*, ...)* @Perl_warner(i32 28, i8* getelementptr inbounds ([40 x i8]* @.str126, i64 0, i64 0), i8* %pmstr.0, i8* %pmstr.0) #7
  br label %if.end25

if.end25:                                         ; preds = %if.then, %land.lhs.true11, %land.lhs.true16, %if.end, %lor.lhs.false7
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @S_gv_ename(%struct.gv* %gv) #0 {
entry:
  %n_a = alloca i64, align 8
  %call = call %struct.sv* @Perl_sv_newmortal() #7
  call void @Perl_gv_efullname4(%struct.sv* %call, %struct.gv* %gv, i8* null, i8 signext 1) #7
  %sv_flags = getelementptr inbounds %struct.sv* %call, i64 0, i32 2
  %0 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %0, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %sv_any = getelementptr inbounds %struct.sv* %call, i64 0, i32 0
  %1 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %1, i64 8
  %2 = bitcast i8* %xpv_cur to i64*
  %3 = load i64* %2, align 8, !tbaa !5
  store i64 %3, i64* %n_a, align 8, !tbaa !5
  %xpv_pv = bitcast i8* %1 to i8**
  %4 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call i8* @Perl_sv_2pv_flags(%struct.sv* %call, i64* %n_a, i32 2) #7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %4, %cond.true ], [ %call2, %cond.false ]
  ret i8* %cond
}

; Function Attrs: optsize
declare void @Perl_gv_fullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #2

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_svconst(%struct.op* %o) #0 {
entry:
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %0 = bitcast %struct.op* %op_sv to %struct.sv**
  %1 = load %struct.sv** %0, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %1, i64 0, i32 2
  %2 = load i32* %sv_flags, align 4, !tbaa !0
  %or = or i32 %2, 8388608
  store i32 %or, i32* %sv_flags, align 4, !tbaa !0
  ret %struct.op* %o
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_trunc(%struct.op* %o) #0 {
entry:
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end22, label %if.then

if.then:                                          ; preds = %entry
  %1 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %2 = load %struct.op** %1, align 8, !tbaa !3
  %3 = getelementptr inbounds %struct.op* %2, i64 0, i32 4
  %4 = load i16* %3, align 2, !tbaa !4
  %cmp = icmp eq i16 %4, 0
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %5 = getelementptr inbounds %struct.op* %2, i64 0, i32 1
  %6 = load %struct.op** %5, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %kid.0.in = phi %struct.op* [ %6, %if.then3 ], [ %2, %if.then ]
  %tobool4 = icmp eq %struct.op* %kid.0.in, null
  br i1 %tobool4, label %if.end22, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %7 = getelementptr inbounds %struct.op* %kid.0.in, i64 0, i32 4
  %8 = load i16* %7, align 2, !tbaa !4
  %cmp7 = icmp eq i16 %8, 5
  br i1 %cmp7, label %land.lhs.true9, label %if.end22

land.lhs.true9:                                   ; preds = %land.lhs.true
  %9 = getelementptr inbounds %struct.op* %kid.0.in, i64 0, i32 7
  %10 = load i8* %9, align 1, !tbaa !1
  %and11 = and i8 %10, 64
  %tobool12 = icmp eq i8 %and11, 0
  br i1 %tobool12, label %if.end22, label %if.then13

if.then13:                                        ; preds = %land.lhs.true9
  %or = or i8 %0, -128
  store i8 %or, i8* %op_flags, align 1, !tbaa !1
  %11 = load i8* %9, align 1, !tbaa !1
  %and19 = and i8 %11, -9
  store i8 %and19, i8* %9, align 1, !tbaa !1
  br label %if.end22

if.end22:                                         ; preds = %land.lhs.true9, %if.end, %entry, %land.lhs.true, %if.then13
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define %struct.op* @Perl_ck_substr(%struct.op* %o) #0 {
entry:
  %call = tail call %struct.op* @Perl_ck_fun(%struct.op* %o) #8
  %op_flags = getelementptr inbounds %struct.op* %call, i64 0, i32 6
  %0 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %0, 4
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %call, i64 0, i32 7
  %1 = load i8* %op_private, align 1, !tbaa !1
  %cmp = icmp eq i8 %1, 4
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true
  %2 = getelementptr inbounds %struct.op* %call, i64 1, i32 0
  %3 = load %struct.op** %2, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %3, i64 0, i32 4
  %4 = load i16* %op_type, align 2, !tbaa !4
  %cmp4 = icmp eq i16 %4, 0
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %op_sibling = getelementptr inbounds %struct.op* %3, i64 0, i32 1
  %5 = load %struct.op** %op_sibling, align 8, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %kid.0 = phi %struct.op* [ %5, %if.then6 ], [ %3, %if.then ]
  %tobool7 = icmp eq %struct.op* %kid.0, null
  br i1 %tobool7, label %if.end13, label %if.then8

if.then8:                                         ; preds = %if.end
  %op_flags9 = getelementptr inbounds %struct.op* %kid.0, i64 0, i32 6
  %6 = load i8* %op_flags9, align 1, !tbaa !1
  %or = or i8 %6, 32
  store i8 %or, i8* %op_flags9, align 1, !tbaa !1
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry, %if.then8, %land.lhs.true
  ret %struct.op* %call
}

; Function Attrs: nounwind optsize uwtable
define void @Perl_peep(%struct.op* %o) #0 {
entry:
  %n_a = alloca i64, align 8
  %keylen = alloca i64, align 8
  %keylen624 = alloca i64, align 8
  %tobool = icmp eq %struct.op* %o, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %op_seq = getelementptr inbounds %struct.op* %o, i64 0, i32 5
  %0 = load i16* %op_seq, align 2, !tbaa !4
  %tobool1 = icmp eq i16 %0, 0
  br i1 %tobool1, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %lor.lhs.false
  call void @Perl_push_scope() #7
  call void @Perl_save_op() #7
  call void @Perl_save_vptr(i8* bitcast (%struct.cop** @PL_curcop to i8*)) #7
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc1173
  %1 = phi %struct.op* [ %o, %for.body.lr.ph ], [ %427, %for.inc1173 ]
  %oldop.01525 = phi %struct.op* [ null, %for.body.lr.ph ], [ %oldop.1, %for.inc1173 ]
  %op_seq3 = getelementptr inbounds %struct.op* %1, i64 0, i32 5
  %2 = load i16* %op_seq3, align 2, !tbaa !4
  %tobool4 = icmp eq i16 %2, 0
  br i1 %tobool4, label %if.end6, label %for.end1175

if.end6:                                          ; preds = %for.body
  %3 = load i16* @PL_op_seqmax, align 2, !tbaa !4
  switch i16 %3, label %if.end12 [
    i16 0, label %if.then11
    i16 -1, label %if.then11
  ]

if.then11:                                        ; preds = %if.end6, %if.end6
  store i16 1, i16* @PL_op_seqmax, align 2, !tbaa !4
  br label %if.end12

if.end12:                                         ; preds = %if.end6, %if.then11
  %4 = phi i16 [ %3, %if.end6 ], [ 1, %if.then11 ]
  store %struct.op* %1, %struct.op** @PL_op, align 8, !tbaa !3
  %op_type = getelementptr inbounds %struct.op* %1, i64 0, i32 4
  %5 = load i16* %op_type, align 2, !tbaa !4
  %conv13 = zext i16 %5 to i32
  switch i32 %conv13, label %sw.default [
    i32 349, label %sw.bb
    i32 174, label %sw.bb
    i32 175, label %sw.bb
    i32 5, label %sw.bb15
    i32 66, label %sw.bb22
    i32 1, label %sw.bb53
    i32 0, label %sw.bb63
    i32 2, label %nothin
    i32 173, label %nothin
    i32 179, label %nothin
    i32 10, label %sw.bb96
    i32 7, label %sw.bb96
    i32 155, label %sw.bb322
    i32 153, label %sw.bb322
    i32 159, label %sw.bb322
    i32 160, label %sw.bb322
    i32 163, label %sw.bb322
    i32 164, label %sw.bb322
    i32 162, label %sw.bb322
    i32 156, label %sw.bb322
    i32 182, label %sw.bb333
    i32 180, label %sw.bb333
    i32 32, label %sw.bb369
    i32 31, label %sw.bb369
    i32 33, label %sw.bb369
    i32 285, label %sw.bb385
    i32 135, label %sw.bb455
    i32 136, label %sw.bb615
    i32 150, label %sw.bb777
    i32 151, label %sw.bb1011
  ]

sw.bb:                                            ; preds = %if.end12, %if.end12, %if.end12
  %6 = bitcast %struct.op* %1 to %struct.cop*
  store volatile %struct.cop* %6, %struct.cop** @PL_curcop, align 8, !tbaa !3
  %7 = load i16* @PL_op_seqmax, align 2, !tbaa !4
  %inc = add i16 %7, 1
  store i16 %inc, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %7, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

sw.bb15:                                          ; preds = %if.end12
  %8 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %9 = load i8* %8, align 1, !tbaa !1
  %and = and i8 %9, 8
  %tobool17 = icmp eq i8 %and, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %sw.bb15
  %op_sv.i = getelementptr inbounds %struct.op* %1, i64 1
  %10 = bitcast %struct.op* %op_sv.i to %struct.sv**
  %11 = load %struct.sv** %10, align 8, !tbaa !3
  %call.i = call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([53 x i8]* @.str155, i64 0, i64 0), %struct.sv* %11) #7
  call void @Perl_qerror(%struct.sv* %call.i) #7
  %.pre = load i16* @PL_op_seqmax, align 2, !tbaa !4
  br label %if.end19

if.end19:                                         ; preds = %sw.bb15, %if.then18
  %12 = phi i16 [ %4, %sw.bb15 ], [ %.pre, %if.then18 ]
  %inc20 = add i16 %12, 1
  store i16 %inc20, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %12, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

sw.bb22:                                          ; preds = %if.end12
  %op_next = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %13 = load %struct.op** %op_next, align 8, !tbaa !3
  %tobool23 = icmp eq %struct.op* %13, null
  br i1 %tobool23, label %ignore_optimization, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb22
  %op_type25 = getelementptr inbounds %struct.op* %13, i64 0, i32 4
  %14 = load i16* %op_type25, align 2, !tbaa !4
  %cmp27 = icmp eq i16 %14, 67
  br i1 %cmp27, label %if.then29, label %ignore_optimization

if.then29:                                        ; preds = %land.lhs.true
  %op_private31 = getelementptr inbounds %struct.op* %13, i64 0, i32 7
  %15 = load i8* %op_private31, align 1, !tbaa !1
  %and33 = and i8 %15, 16
  %tobool34 = icmp eq i8 %and33, 0
  br i1 %tobool34, label %if.end48, label %if.then35

if.then35:                                        ; preds = %if.then29
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %16 = load i8* %op_flags, align 1, !tbaa !1
  %and37 = and i8 %16, 64
  %tobool38 = icmp eq i8 %and37, 0
  br i1 %tobool38, label %if.else, label %ignore_optimization

if.else:                                          ; preds = %if.then35
  %op_targ = getelementptr inbounds %struct.op* %13, i64 0, i32 3
  %17 = load i64* %op_targ, align 8, !tbaa !5
  %op_targ41 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  store i64 %17, i64* %op_targ41, align 8, !tbaa !5
  store i64 0, i64* %op_targ, align 8, !tbaa !5
  %op_private44 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %18 = load i8* %op_private44, align 1, !tbaa !1
  %or = or i8 %18, 16
  store i8 %or, i8* %op_private44, align 1, !tbaa !1
  br label %if.end48

if.end48:                                         ; preds = %if.then29, %if.else
  call void @Perl_op_null(%struct.op* %13) #8
  %.pre1533 = load i16* @PL_op_seqmax, align 2, !tbaa !4
  br label %ignore_optimization

ignore_optimization:                              ; preds = %if.then35, %sw.bb22, %land.lhs.true, %if.end48
  %19 = phi i16 [ %4, %if.then35 ], [ %4, %sw.bb22 ], [ %4, %land.lhs.true ], [ %.pre1533, %if.end48 ]
  %inc51 = add i16 %19, 1
  store i16 %inc51, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %19, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

sw.bb53:                                          ; preds = %if.end12
  %op_flags54 = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %20 = load i8* %op_flags54, align 1, !tbaa !1
  %and56 = and i8 %20, 3
  %cmp57 = icmp eq i8 %and56, 3
  br i1 %cmp57, label %nothin, label %if.then59

if.then59:                                        ; preds = %sw.bb53
  %inc60 = add i16 %4, 1
  store i16 %inc60, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

sw.bb63:                                          ; preds = %if.end12
  %op_targ64 = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %21 = load i64* %op_targ64, align 8, !tbaa !5
  switch i64 %21, label %if.end76 [
    i64 174, label %if.then75
    i64 175, label %if.then75
    i64 349, label %if.then75
  ]

if.then75:                                        ; preds = %sw.bb63, %sw.bb63, %sw.bb63
  %22 = bitcast %struct.op* %1 to %struct.cop*
  store volatile %struct.cop* %22, %struct.cop** @PL_curcop, align 8, !tbaa !3
  br label %if.end76

if.end76:                                         ; preds = %sw.bb63, %if.then75
  %tobool77 = icmp eq %struct.op* %oldop.01525, null
  br i1 %tobool77, label %for.inc1173, label %land.lhs.true78

land.lhs.true78:                                  ; preds = %if.end76
  %op_next79 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %23 = load %struct.op** %op_next79, align 8, !tbaa !3
  %tobool80 = icmp eq %struct.op* %23, null
  br i1 %tobool80, label %for.inc1173, label %if.then81

if.then81:                                        ; preds = %land.lhs.true78
  %op_next83 = getelementptr inbounds %struct.op* %oldop.01525, i64 0, i32 0
  store %struct.op* %23, %struct.op** %op_next83, align 8, !tbaa !3
  br label %for.inc1173

nothin:                                           ; preds = %sw.bb53, %if.end12, %if.end12, %if.end12
  %tobool86 = icmp eq %struct.op* %oldop.01525, null
  br i1 %tobool86, label %if.end93, label %land.lhs.true87

land.lhs.true87:                                  ; preds = %nothin
  %op_next88 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %24 = load %struct.op** %op_next88, align 8, !tbaa !3
  %tobool89 = icmp eq %struct.op* %24, null
  br i1 %tobool89, label %if.end93, label %if.then90

if.then90:                                        ; preds = %land.lhs.true87
  %op_next92 = getelementptr inbounds %struct.op* %oldop.01525, i64 0, i32 0
  store %struct.op* %24, %struct.op** %op_next92, align 8, !tbaa !3
  br label %for.inc1173

if.end93:                                         ; preds = %land.lhs.true87, %nothin
  %inc94 = add i16 %4, 1
  store i16 %inc94, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

sw.bb96:                                          ; preds = %if.end12, %if.end12
  %cmp99 = icmp eq i16 %5, 10
  %op_next112.phi.trans.insert = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %.pre1545 = load %struct.op** %op_next112.phi.trans.insert, align 8, !tbaa !3
  br i1 %cmp99, label %if.then107.thread, label %lor.lhs.false101

if.then107.thread:                                ; preds = %sw.bb96
  br label %cond.end

lor.lhs.false101:                                 ; preds = %sw.bb96
  %op_type103 = getelementptr inbounds %struct.op* %.pre1545, i64 0, i32 4
  %25 = load i16* %op_type103, align 2, !tbaa !4
  switch i16 %25, label %if.else236 [
    i16 125, label %cond.false
    i16 15, label %if.then214
  ]

cond.false:                                       ; preds = %lor.lhs.false101
  %op_next114 = getelementptr inbounds %struct.op* %.pre1545, i64 0, i32 0
  %26 = load %struct.op** %op_next114, align 8, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %if.then107.thread, %cond.false
  %cond = phi %struct.op* [ %26, %cond.false ], [ %.pre1545, %if.then107.thread ]
  %op_next1121556 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %tobool115 = icmp eq %struct.op* %cond, null
  br i1 %tobool115, label %if.end205, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %cond.end
  %op_type117 = getelementptr inbounds %struct.op* %cond, i64 0, i32 4
  %27 = load i16* %op_type117, align 2, !tbaa !4
  %cmp119 = icmp eq i16 %27, 5
  br i1 %cmp119, label %land.lhs.true121, label %if.end205

land.lhs.true121:                                 ; preds = %land.lhs.true116
  %op_next122 = getelementptr inbounds %struct.op* %cond, i64 0, i32 0
  %28 = load %struct.op** %op_next122, align 8, !tbaa !3
  store %struct.op* %28, %struct.op** @PL_op, align 8, !tbaa !3
  %tobool123 = icmp eq %struct.op* %28, null
  br i1 %tobool123, label %if.end205, label %land.lhs.true124

land.lhs.true124:                                 ; preds = %land.lhs.true121
  %29 = load %struct.op** %op_next122, align 8, !tbaa !3
  %op_type126 = getelementptr inbounds %struct.op* %29, i64 0, i32 4
  %30 = load i16* %op_type126, align 2, !tbaa !4
  %cmp128 = icmp eq i16 %30, 127
  br i1 %cmp128, label %land.lhs.true130, label %if.end205

land.lhs.true130:                                 ; preds = %land.lhs.true124
  %op_private132 = getelementptr inbounds %struct.op* %29, i64 0, i32 7
  %31 = load i8* %op_private132, align 1, !tbaa !1
  %tobool135 = icmp ugt i8 %31, 7
  br i1 %tobool135, label %if.end205, label %land.lhs.true136

land.lhs.true136:                                 ; preds = %land.lhs.true130
  %op_sv = getelementptr inbounds %struct.op* %cond, i64 1
  %32 = bitcast %struct.op* %op_sv to %struct.sv**
  %33 = load %struct.sv** %32, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %33, i64 0, i32 2
  %34 = load i32* %sv_flags, align 4, !tbaa !0
  %and137 = and i32 %34, 65536
  %tobool138 = icmp eq i32 %and137, 0
  br i1 %tobool138, label %cond.false141, label %cond.true139

cond.true139:                                     ; preds = %land.lhs.true136
  %sv_any = getelementptr inbounds %struct.sv* %33, i64 0, i32 0
  %35 = load i8** %sv_any, align 8, !tbaa !3
  %xiv_iv = getelementptr inbounds i8* %35, i64 24
  %36 = bitcast i8* %xiv_iv to i64*
  %37 = load i64* %36, align 8, !tbaa !5
  br label %cond.end143

cond.false141:                                    ; preds = %land.lhs.true136
  %call = call i64 @Perl_sv_2iv(%struct.sv* %33) #7
  br label %cond.end143

cond.end143:                                      ; preds = %cond.false141, %cond.true139
  %cond144 = phi i64 [ %37, %cond.true139 ], [ %call, %cond.false141 ]
  %38 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_arybase = getelementptr inbounds %struct.cop* %38, i64 0, i32 12
  %39 = load i32* %cop_arybase, align 4, !tbaa !0
  %conv145 = sext i32 %39 to i64
  %sub = sub nsw i64 %cond144, %conv145
  %40 = icmp ult i64 %sub, 256
  br i1 %40, label %if.then151, label %if.end205

if.then151:                                       ; preds = %cond.end143
  %41 = getelementptr inbounds %struct.op* %cond, i64 0, i32 7
  %42 = load i8* %41, align 1, !tbaa !1
  %and154 = and i8 %42, 8
  %tobool155 = icmp eq i8 %and154, 0
  br i1 %tobool155, label %if.end157, label %if.then156

if.then156:                                       ; preds = %if.then151
  %43 = load %struct.sv** %32, align 8, !tbaa !3
  %call.i1489 = call %struct.sv* (i8*, ...)* @Perl_mess(i8* getelementptr inbounds ([53 x i8]* @.str155, i64 0, i64 0), %struct.sv* %43) #7
  call void @Perl_qerror(%struct.sv* %call.i1489) #7
  br label %if.end157

if.end157:                                        ; preds = %if.then151, %if.then156
  %44 = load i16* %op_type, align 2, !tbaa !4
  %cmp160 = icmp eq i16 %44, 7
  br i1 %cmp160, label %if.then162, label %if.end164

if.then162:                                       ; preds = %if.end157
  %45 = load %struct.op** %op_next1121556, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %45) #8
  br label %if.end164

if.end164:                                        ; preds = %if.then162, %if.end157
  %46 = load %struct.op** %op_next122, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %46) #8
  call void @Perl_op_null(%struct.op* %cond) #8
  %47 = load %struct.op** %op_next122, align 8, !tbaa !3
  %op_flags167 = getelementptr inbounds %struct.op* %47, i64 0, i32 6
  %48 = load i8* %op_flags167, align 1, !tbaa !1
  %and169 = and i8 %48, 32
  %op_flags170 = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %49 = load i8* %op_flags170, align 1, !tbaa !1
  %or172 = or i8 %49, %and169
  store i8 %or172, i8* %op_flags170, align 1, !tbaa !1
  %50 = load %struct.op** %op_next122, align 8, !tbaa !3
  %op_next175 = getelementptr inbounds %struct.op* %50, i64 0, i32 0
  %51 = load %struct.op** %op_next175, align 8, !tbaa !3
  store %struct.op* %51, %struct.op** %op_next1121556, align 8, !tbaa !3
  %52 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 126), align 8, !tbaa !3
  %op_ppaddr = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %52, %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %conv177 = trunc i64 %sub to i8
  %op_private178 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  store i8 %conv177, i8* %op_private178, align 1, !tbaa !1
  %53 = load i16* %op_type, align 2, !tbaa !4
  %cmp181 = icmp eq i16 %53, 7
  br i1 %cmp181, label %if.then183, label %if.else198

if.then183:                                       ; preds = %if.end164
  %op_sv184 = getelementptr inbounds %struct.op* %1, i64 1
  %54 = bitcast %struct.op* %op_sv184 to %struct.sv**
  %55 = load %struct.sv** %54, align 8, !tbaa !3
  %sv_any185 = bitcast %struct.sv* %55 to %struct.xpvgv**
  %56 = load %struct.xpvgv** %sv_any185, align 8, !tbaa !3
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %56, i64 0, i32 7
  %57 = load %struct.gp** %xgv_gp, align 8, !tbaa !3
  %gp_av = getelementptr inbounds %struct.gp* %57, i64 0, i32 4
  %58 = load %struct.av** %gp_av, align 8, !tbaa !3
  %tobool186 = icmp eq %struct.av* %58, null
  br i1 %tobool186, label %cond.false191, label %if.end203

cond.false191:                                    ; preds = %if.then183
  %59 = bitcast %struct.sv* %55 to %struct.gv*
  %call192 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %59) #7
  br label %if.end203

if.else198:                                       ; preds = %if.end164
  %or201 = or i8 %or172, -128
  store i8 %or201, i8* %op_flags170, align 1, !tbaa !1
  br label %if.end203

if.end203:                                        ; preds = %if.then183, %cond.false191, %if.else198
  store i16 126, i16* %op_type, align 2, !tbaa !4
  br label %if.end205

if.end205:                                        ; preds = %cond.end143, %land.lhs.true121, %cond.end, %if.end203, %land.lhs.true130, %land.lhs.true124, %land.lhs.true116
  %60 = load i16* @PL_op_seqmax, align 2, !tbaa !4
  %inc206 = add i16 %60, 1
  store i16 %inc206, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %60, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

if.then214:                                       ; preds = %lor.lhs.false101
  %op_private216 = getelementptr inbounds %struct.op* %.pre1545, i64 0, i32 7
  %61 = load i8* %op_private216, align 1, !tbaa !1
  %and218 = and i8 %61, 96
  %tobool219 = icmp eq i8 %and218, 0
  br i1 %tobool219, label %if.then220, label %if.end319

if.then220:                                       ; preds = %if.then214
  call void @Perl_op_null(%struct.op* %.pre1545) #8
  %62 = load %struct.op** %op_next112.phi.trans.insert, align 8, !tbaa !3
  %op_private223 = getelementptr inbounds %struct.op* %62, i64 0, i32 7
  %63 = load i8* %op_private223, align 1, !tbaa !1
  %and225 = and i8 %63, -112
  %op_private226 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %64 = load i8* %op_private226, align 1, !tbaa !1
  %or228 = or i8 %64, %and225
  store i8 %or228, i8* %op_private226, align 1, !tbaa !1
  %op_next231 = getelementptr inbounds %struct.op* %62, i64 0, i32 0
  %65 = load %struct.op** %op_next231, align 8, !tbaa !3
  store %struct.op* %65, %struct.op** %op_next112.phi.trans.insert, align 8, !tbaa !3
  store i16 6, i16* %op_type, align 2, !tbaa !4
  %66 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 6), align 8, !tbaa !3
  %op_ppaddr234 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %66, %struct.op* ()** %op_ppaddr234, align 8, !tbaa !3
  br label %if.end319

if.else236:                                       ; preds = %lor.lhs.false101
  %op_private237 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %67 = load i8* %op_private237, align 1, !tbaa !1
  %and239 = and i8 %67, 32
  %tobool240 = icmp eq i8 %and239, 0
  br i1 %tobool240, label %if.else287, label %land.lhs.true241

land.lhs.true241:                                 ; preds = %if.else236
  %68 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings = getelementptr inbounds %struct.cop* %68, i64 0, i32 14
  %69 = load %struct.sv** %cop_warnings, align 8, !tbaa !3
  %cmp242 = icmp eq %struct.sv* %69, null
  br i1 %cmp242, label %lor.lhs.false258, label %land.lhs.true244

land.lhs.true244:                                 ; preds = %land.lhs.true241
  %70 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings245 = getelementptr inbounds %struct.cop* %70, i64 0, i32 14
  %71 = load %struct.sv** %cop_warnings245, align 8, !tbaa !3
  %cmp246 = icmp eq %struct.sv* %71, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp246, label %lor.lhs.false258, label %land.lhs.true248

land.lhs.true248:                                 ; preds = %land.lhs.true244
  %72 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings249 = getelementptr inbounds %struct.cop* %72, i64 0, i32 14
  %73 = load %struct.sv** %cop_warnings249, align 8, !tbaa !3
  %cmp250 = icmp eq %struct.sv* %73, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp250, label %if.then266, label %lor.lhs.false252

lor.lhs.false252:                                 ; preds = %land.lhs.true248
  %74 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings253 = getelementptr inbounds %struct.cop* %74, i64 0, i32 14
  %75 = load %struct.sv** %cop_warnings253, align 8, !tbaa !3
  %sv_any254 = getelementptr inbounds %struct.sv* %75, i64 0, i32 0
  %76 = load i8** %sv_any254, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %76 to i8**
  %77 = load i8** %xpv_pv, align 8, !tbaa !3
  %arrayidx = getelementptr inbounds i8* %77, i64 8
  %78 = load i8* %arrayidx, align 1, !tbaa !1
  %and256 = and i8 %78, 64
  %tobool257 = icmp eq i8 %and256, 0
  br i1 %tobool257, label %lor.lhs.false258, label %if.then266

lor.lhs.false258:                                 ; preds = %lor.lhs.false252, %land.lhs.true244, %land.lhs.true241
  %79 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings259 = getelementptr inbounds %struct.cop* %79, i64 0, i32 14
  %80 = load %struct.sv** %cop_warnings259, align 8, !tbaa !3
  %cmp260 = icmp eq %struct.sv* %80, null
  br i1 %cmp260, label %land.lhs.true262, label %if.else287

land.lhs.true262:                                 ; preds = %lor.lhs.false258
  %81 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and264 = and i8 %81, 1
  %tobool265 = icmp eq i8 %and264, 0
  br i1 %tobool265, label %if.else287, label %if.then266

if.then266:                                       ; preds = %lor.lhs.false252, %land.lhs.true262, %land.lhs.true248
  %op_sv268 = getelementptr inbounds %struct.op* %1, i64 1
  %82 = bitcast %struct.op* %op_sv268 to %struct.sv**
  %83 = load %struct.sv** %82, align 8, !tbaa !3
  %84 = bitcast %struct.sv* %83 to %struct.gv*
  %85 = getelementptr inbounds %struct.sv* %83, i64 0, i32 2
  %86 = load i32* %85, align 4, !tbaa !0
  %and270 = and i32 %86, 255
  %cmp271 = icmp eq i32 %and270, 13
  br i1 %cmp271, label %land.lhs.true273, label %if.end319

land.lhs.true273:                                 ; preds = %if.then266
  %sv_any274 = bitcast %struct.sv* %83 to %struct.xpvgv**
  %87 = load %struct.xpvgv** %sv_any274, align 8, !tbaa !3
  %xgv_gp275 = getelementptr inbounds %struct.xpvgv* %87, i64 0, i32 7
  %88 = load %struct.gp** %xgv_gp275, align 8, !tbaa !3
  %gp_cv = getelementptr inbounds %struct.gp* %88, i64 0, i32 7
  %89 = load %struct.cv** %gp_cv, align 8, !tbaa !3
  %tobool276 = icmp eq %struct.cv* %89, null
  br i1 %tobool276, label %if.end319, label %land.lhs.true277

land.lhs.true277:                                 ; preds = %land.lhs.true273
  %sv_any281 = getelementptr inbounds %struct.cv* %89, i64 0, i32 0
  %90 = load %struct.xpvcv** %sv_any281, align 8, !tbaa !3
  %xpv_pv282 = getelementptr inbounds %struct.xpvcv* %90, i64 0, i32 0
  %91 = load i8** %xpv_pv282, align 8, !tbaa !3
  %tobool283 = icmp eq i8* %91, null
  br i1 %tobool283, label %if.end319, label %if.then284

if.then284:                                       ; preds = %land.lhs.true277
  %call285 = call %struct.sv* @Perl_sv_newmortal() #7
  call void @Perl_gv_efullname4(%struct.sv* %call285, %struct.gv* %84, i8* null, i8 signext 1) #7
  call void (i32, i8*, ...)* @Perl_warner(i32 35, i8* getelementptr inbounds ([41 x i8]* @.str134, i64 0, i64 0), %struct.sv* %call285) #7
  br label %if.end319

if.else287:                                       ; preds = %land.lhs.true262, %lor.lhs.false258, %if.else236
  %92 = load %struct.op** %op_next112.phi.trans.insert, align 8, !tbaa !3
  %op_type289 = getelementptr inbounds %struct.op* %92, i64 0, i32 4
  %93 = load i16* %op_type289, align 2, !tbaa !4
  %cmp291 = icmp eq i16 %93, 26
  br i1 %cmp291, label %land.lhs.true293, label %if.end319

land.lhs.true293:                                 ; preds = %if.else287
  %op_next295 = getelementptr inbounds %struct.op* %92, i64 0, i32 0
  %94 = load %struct.op** %op_next295, align 8, !tbaa !3
  %op_type296 = getelementptr inbounds %struct.op* %94, i64 0, i32 4
  %95 = load i16* %op_type296, align 2, !tbaa !4
  %cmp298 = icmp eq i16 %95, 66
  br i1 %cmp298, label %land.lhs.true300, label %if.end319

land.lhs.true300:                                 ; preds = %land.lhs.true293
  %op_flags303 = getelementptr inbounds %struct.op* %94, i64 0, i32 6
  %96 = load i8* %op_flags303, align 1, !tbaa !1
  %and305 = and i8 %96, 64
  %tobool306 = icmp eq i8 %and305, 0
  br i1 %tobool306, label %if.end319, label %if.then307

if.then307:                                       ; preds = %land.lhs.true300
  store i16 27, i16* %op_type, align 2, !tbaa !4
  %op_flags309 = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %97 = load i8* %op_flags309, align 1, !tbaa !1
  %or311 = or i8 %97, 64
  store i8 %or311, i8* %op_flags309, align 1, !tbaa !1
  %98 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 27), align 8, !tbaa !3
  %op_ppaddr313 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %98, %struct.op* ()** %op_ppaddr313, align 8, !tbaa !3
  %99 = load %struct.op** %op_next295, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %99) #8
  %100 = load %struct.op** %op_next112.phi.trans.insert, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %100) #8
  br label %if.end319

if.end319:                                        ; preds = %land.lhs.true300, %land.lhs.true293, %if.else287, %land.lhs.true277, %land.lhs.true273, %if.then266, %if.then214, %if.then284, %if.then307, %if.then220
  %101 = load i16* @PL_op_seqmax, align 2, !tbaa !4
  %inc320 = add i16 %101, 1
  store i16 %inc320, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %101, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

sw.bb322:                                         ; preds = %if.end12, %if.end12, %if.end12, %if.end12, %if.end12, %if.end12, %if.end12, %if.end12
  %inc323 = add i16 %4, 1
  store i16 %inc323, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %102 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %103 = load %struct.op** %102, align 8, !tbaa !3
  %op_type3251521 = getelementptr inbounds %struct.op* %103, i64 0, i32 4
  %104 = load i16* %op_type3251521, align 2, !tbaa !4
  %cmp3271522 = icmp eq i16 %104, 0
  br i1 %cmp3271522, label %while.body, label %while.end

while.body:                                       ; preds = %sw.bb322, %while.body
  %105 = phi %struct.op* [ %110, %while.body ], [ %103, %sw.bb322 ]
  %106 = phi %struct.op** [ %109, %while.body ], [ %102, %sw.bb322 ]
  %op_next330 = getelementptr inbounds %struct.op* %105, i64 0, i32 0
  %107 = load %struct.op** %op_next330, align 8, !tbaa !3
  store %struct.op* %107, %struct.op** %106, align 8, !tbaa !3
  %108 = load %struct.op** @PL_op, align 8, !tbaa !3
  %109 = getelementptr inbounds %struct.op* %108, i64 1, i32 1
  %110 = load %struct.op** %109, align 8, !tbaa !3
  %op_type325 = getelementptr inbounds %struct.op* %110, i64 0, i32 4
  %111 = load i16* %op_type325, align 2, !tbaa !4
  %cmp327 = icmp eq i16 %111, 0
  br i1 %cmp327, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %sw.bb322
  %.lcssa1520 = phi %struct.op* [ %103, %sw.bb322 ], [ %110, %while.body ]
  call void @Perl_peep(%struct.op* %.lcssa1520) #8
  br label %for.inc1173

sw.bb333:                                         ; preds = %if.end12, %if.end12
  %inc334 = add i16 %4, 1
  store i16 %inc334, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %op_redoop1505 = getelementptr inbounds %struct.op* %1, i64 1, i32 2
  %112 = load %struct.op* ()** %op_redoop1505, align 8
  %113 = bitcast %struct.op* ()* %112 to %struct.op*
  %op_type3371506 = getelementptr inbounds %struct.op* %113, i64 0, i32 4
  %114 = load i16* %op_type3371506, align 2, !tbaa !4
  %cmp3391507 = icmp eq i16 %114, 0
  br i1 %cmp3391507, label %while.body341, label %while.end345

while.body341:                                    ; preds = %sw.bb333, %while.body341
  %115 = phi %struct.op* ()* [ %118, %while.body341 ], [ %112, %sw.bb333 ]
  %op_redoop1508 = phi %struct.op* ()** [ %op_redoop, %while.body341 ], [ %op_redoop1505, %sw.bb333 ]
  %op_next343 = bitcast %struct.op* ()* %115 to %struct.op**
  %116 = load %struct.op** %op_next343, align 8, !tbaa !3
  %.c1485 = bitcast %struct.op* %116 to %struct.op* ()*
  store %struct.op* ()* %.c1485, %struct.op* ()** %op_redoop1508, align 8, !tbaa !3
  %117 = load %struct.op** @PL_op, align 8, !tbaa !3
  %op_redoop = getelementptr inbounds %struct.op* %117, i64 1, i32 2
  %118 = load %struct.op* ()** %op_redoop, align 8
  %119 = bitcast %struct.op* ()* %118 to %struct.op*
  %op_type337 = getelementptr inbounds %struct.op* %119, i64 0, i32 4
  %120 = load i16* %op_type337, align 2, !tbaa !4
  %cmp339 = icmp eq i16 %120, 0
  br i1 %cmp339, label %while.body341, label %while.end345

while.end345:                                     ; preds = %while.body341, %sw.bb333
  %.lcssa1504 = phi %struct.op* [ %113, %sw.bb333 ], [ %119, %while.body341 ]
  call void @Perl_peep(%struct.op* %.lcssa1504) #8
  %121 = load %struct.op** @PL_op, align 8, !tbaa !3
  %op_nextop1510 = getelementptr inbounds %struct.op* %121, i64 1, i32 3
  %122 = bitcast i64* %op_nextop1510 to %struct.op**
  %123 = load %struct.op** %122, align 8, !tbaa !3
  %op_type3481511 = getelementptr inbounds %struct.op* %123, i64 0, i32 4
  %124 = load i16* %op_type3481511, align 2, !tbaa !4
  %cmp3501512 = icmp eq i16 %124, 0
  br i1 %cmp3501512, label %while.body352, label %while.end356

while.body352:                                    ; preds = %while.end345, %while.body352
  %125 = phi %struct.op* [ %129, %while.body352 ], [ %123, %while.end345 ]
  %op_nextop1513 = phi i64* [ %op_nextop, %while.body352 ], [ %op_nextop1510, %while.end345 ]
  %op_next354 = getelementptr inbounds %struct.op* %125, i64 0, i32 0
  %126 = load %struct.op** %op_next354, align 8, !tbaa !3
  %.c1484 = ptrtoint %struct.op* %126 to i64
  store i64 %.c1484, i64* %op_nextop1513, align 8, !tbaa !3
  %127 = load %struct.op** @PL_op, align 8, !tbaa !3
  %op_nextop = getelementptr inbounds %struct.op* %127, i64 1, i32 3
  %128 = bitcast i64* %op_nextop to %struct.op**
  %129 = load %struct.op** %128, align 8, !tbaa !3
  %op_type348 = getelementptr inbounds %struct.op* %129, i64 0, i32 4
  %130 = load i16* %op_type348, align 2, !tbaa !4
  %cmp350 = icmp eq i16 %130, 0
  br i1 %cmp350, label %while.body352, label %while.end356

while.end356:                                     ; preds = %while.body352, %while.end345
  %.lcssa1509 = phi %struct.op* [ %123, %while.end345 ], [ %129, %while.body352 ]
  call void @Perl_peep(%struct.op* %.lcssa1509) #8
  %131 = load %struct.op** @PL_op, align 8, !tbaa !3
  %op_lastop1516 = getelementptr inbounds %struct.op* %131, i64 1, i32 4
  %132 = bitcast i16* %op_lastop1516 to %struct.op**
  %133 = load %struct.op** %132, align 8, !tbaa !3
  %op_type3591517 = getelementptr inbounds %struct.op* %133, i64 0, i32 4
  %134 = load i16* %op_type3591517, align 2, !tbaa !4
  %cmp3611518 = icmp eq i16 %134, 0
  br i1 %cmp3611518, label %while.body363, label %while.end367

while.body363:                                    ; preds = %while.end356, %while.body363
  %135 = phi %struct.op* [ %140, %while.body363 ], [ %133, %while.end356 ]
  %136 = phi %struct.op** [ %139, %while.body363 ], [ %132, %while.end356 ]
  %op_next365 = getelementptr inbounds %struct.op* %135, i64 0, i32 0
  %137 = load %struct.op** %op_next365, align 8, !tbaa !3
  store %struct.op* %137, %struct.op** %136, align 8, !tbaa !3
  %138 = load %struct.op** @PL_op, align 8, !tbaa !3
  %op_lastop = getelementptr inbounds %struct.op* %138, i64 1, i32 4
  %139 = bitcast i16* %op_lastop to %struct.op**
  %140 = load %struct.op** %139, align 8, !tbaa !3
  %op_type359 = getelementptr inbounds %struct.op* %140, i64 0, i32 4
  %141 = load i16* %op_type359, align 2, !tbaa !4
  %cmp361 = icmp eq i16 %141, 0
  br i1 %cmp361, label %while.body363, label %while.end367

while.end367:                                     ; preds = %while.body363, %while.end356
  %.lcssa1515 = phi %struct.op* [ %133, %while.end356 ], [ %140, %while.body363 ]
  call void @Perl_peep(%struct.op* %.lcssa1515) #8
  br label %for.inc1173

sw.bb369:                                         ; preds = %if.end12, %if.end12, %if.end12
  %inc370 = add i16 %4, 1
  store i16 %inc370, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %op_pmreplstart1502 = getelementptr inbounds %struct.op* %1, i64 1, i32 3
  %142 = bitcast i64* %op_pmreplstart1502 to %struct.op**
  %143 = load %struct.op** %142, align 8, !tbaa !3
  %tobool3731503 = icmp eq %struct.op* %143, null
  br i1 %tobool3731503, label %while.end383, label %land.end

land.end:                                         ; preds = %sw.bb369, %while.body379
  %144 = phi %struct.op* [ %148, %while.body379 ], [ %1, %sw.bb369 ]
  %145 = phi %struct.op* [ %150, %while.body379 ], [ %143, %sw.bb369 ]
  %op_type375 = getelementptr inbounds %struct.op* %145, i64 0, i32 4
  %146 = load i16* %op_type375, align 2, !tbaa !4
  %cmp377 = icmp eq i16 %146, 0
  br i1 %cmp377, label %while.body379, label %while.end383

while.body379:                                    ; preds = %land.end
  %op_pmreplstart380 = getelementptr inbounds %struct.op* %144, i64 1, i32 3
  %op_next381 = getelementptr inbounds %struct.op* %145, i64 0, i32 0
  %147 = load %struct.op** %op_next381, align 8, !tbaa !3
  %.c = ptrtoint %struct.op* %147 to i64
  store i64 %.c, i64* %op_pmreplstart380, align 8, !tbaa !3
  %148 = load %struct.op** @PL_op, align 8, !tbaa !3
  %op_pmreplstart = getelementptr inbounds %struct.op* %148, i64 1, i32 3
  %149 = bitcast i64* %op_pmreplstart to %struct.op**
  %150 = load %struct.op** %149, align 8, !tbaa !3
  %tobool373 = icmp eq %struct.op* %150, null
  br i1 %tobool373, label %while.end383, label %land.end

while.end383:                                     ; preds = %land.end, %sw.bb369, %while.body379
  %151 = phi %struct.op* [ null, %while.body379 ], [ null, %sw.bb369 ], [ %145, %land.end ]
  call void @Perl_peep(%struct.op* %151) #8
  br label %for.inc1173

sw.bb385:                                         ; preds = %if.end12
  %inc386 = add i16 %4, 1
  store i16 %inc386, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %152 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings388 = getelementptr inbounds %struct.cop* %152, i64 0, i32 14
  %153 = load %struct.sv** %cop_warnings388, align 8, !tbaa !3
  %cmp389 = icmp eq %struct.sv* %153, null
  br i1 %cmp389, label %lor.lhs.false407, label %land.lhs.true391

land.lhs.true391:                                 ; preds = %sw.bb385
  %154 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings392 = getelementptr inbounds %struct.cop* %154, i64 0, i32 14
  %155 = load %struct.sv** %cop_warnings392, align 8, !tbaa !3
  %cmp393 = icmp eq %struct.sv* %155, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp393, label %lor.lhs.false407, label %land.lhs.true395

land.lhs.true395:                                 ; preds = %land.lhs.true391
  %156 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings396 = getelementptr inbounds %struct.cop* %156, i64 0, i32 14
  %157 = load %struct.sv** %cop_warnings396, align 8, !tbaa !3
  %cmp397 = icmp eq %struct.sv* %157, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp397, label %land.lhs.true415, label %lor.lhs.false399

lor.lhs.false399:                                 ; preds = %land.lhs.true395
  %158 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings400 = getelementptr inbounds %struct.cop* %158, i64 0, i32 14
  %159 = load %struct.sv** %cop_warnings400, align 8, !tbaa !3
  %sv_any401 = getelementptr inbounds %struct.sv* %159, i64 0, i32 0
  %160 = load i8** %sv_any401, align 8, !tbaa !3
  %xpv_pv402 = bitcast i8* %160 to i8**
  %161 = load i8** %xpv_pv402, align 8, !tbaa !3
  %arrayidx403 = getelementptr inbounds i8* %161, i64 7
  %162 = load i8* %arrayidx403, align 1, !tbaa !1
  %and405 = and i8 %162, 1
  %tobool406 = icmp eq i8 %and405, 0
  br i1 %tobool406, label %lor.lhs.false407, label %land.lhs.true415

lor.lhs.false407:                                 ; preds = %lor.lhs.false399, %land.lhs.true391, %sw.bb385
  %163 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_warnings408 = getelementptr inbounds %struct.cop* %163, i64 0, i32 14
  %164 = load %struct.sv** %cop_warnings408, align 8, !tbaa !3
  %cmp409 = icmp eq %struct.sv* %164, null
  br i1 %cmp409, label %land.lhs.true411, label %for.inc1173

land.lhs.true411:                                 ; preds = %lor.lhs.false407
  %165 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and413 = and i8 %165, 1
  %tobool414 = icmp eq i8 %and413, 0
  br i1 %tobool414, label %for.inc1173, label %land.lhs.true415

land.lhs.true415:                                 ; preds = %lor.lhs.false399, %land.lhs.true411, %land.lhs.true395
  %op_next416 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %166 = load %struct.op** %op_next416, align 8, !tbaa !3
  %tobool417 = icmp eq %struct.op* %166, null
  br i1 %tobool417, label %for.inc1173, label %land.lhs.true418

land.lhs.true418:                                 ; preds = %land.lhs.true415
  %op_type420 = getelementptr inbounds %struct.op* %166, i64 0, i32 4
  %167 = load i16* %op_type420, align 2, !tbaa !4
  %cmp422 = icmp eq i16 %167, 174
  br i1 %cmp422, label %if.then424, label %for.inc1173

if.then424:                                       ; preds = %land.lhs.true418
  %op_sibling = getelementptr inbounds %struct.op* %166, i64 0, i32 1
  %168 = load %struct.op** %op_sibling, align 8, !tbaa !3
  %tobool426 = icmp eq %struct.op* %168, null
  br i1 %tobool426, label %for.inc1173, label %land.lhs.true427

land.lhs.true427:                                 ; preds = %if.then424
  %op_type430 = getelementptr inbounds %struct.op* %168, i64 0, i32 4
  %169 = load i16* %op_type430, align 2, !tbaa !4
  switch i16 %169, label %if.then448 [
    i16 190, label %for.inc1173
    i16 170, label %for.inc1173
    i16 171, label %for.inc1173
  ]

if.then448:                                       ; preds = %land.lhs.true427
  %170 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line = getelementptr inbounds %struct.cop* %170, i64 0, i32 13
  %171 = load i32* %cop_line, align 4, !tbaa !0
  %cop_line450 = getelementptr inbounds %struct.op* %166, i64 1, i32 4
  %172 = bitcast i16* %cop_line450 to i32*
  %173 = load i32* %172, align 4, !tbaa !0
  %174 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line451 = getelementptr inbounds %struct.cop* %174, i64 0, i32 13
  store i32 %173, i32* %cop_line451, align 4, !tbaa !0
  call void (i32, i8*, ...)* @Perl_warner(i32 7, i8* getelementptr inbounds ([33 x i8]* @.str135, i64 0, i64 0)) #7
  call void (i32, i8*, ...)* @Perl_warner(i32 7, i8* getelementptr inbounds ([51 x i8]* @.str136, i64 0, i64 0)) #7
  %175 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !3
  %cop_line452 = getelementptr inbounds %struct.cop* %175, i64 0, i32 13
  store i32 %171, i32* %cop_line452, align 4, !tbaa !0
  br label %for.inc1173

sw.bb455:                                         ; preds = %if.end12
  %inc457 = add i16 %4, 1
  store i16 %inc457, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %176 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %177 = load %struct.op** %176, align 8, !tbaa !3
  %op_type459 = getelementptr inbounds %struct.op* %177, i64 0, i32 4
  %178 = load i16* %op_type459, align 2, !tbaa !4
  %cmp461 = icmp eq i16 %178, 5
  br i1 %cmp461, label %if.end464, label %for.inc1173

if.end464:                                        ; preds = %sw.bb455
  %op_sv466 = getelementptr inbounds %struct.op* %177, i64 1
  %179 = bitcast %struct.op* %op_sv466 to %struct.sv**
  %180 = load %struct.sv** %179, align 8, !tbaa !3
  %sv_flags467 = getelementptr inbounds %struct.sv* %180, i64 0, i32 2
  %181 = load i32* %sv_flags467, align 4, !tbaa !0
  %182 = and i32 %181, 9437184
  %183 = icmp eq i32 %182, 9437184
  br i1 %183, label %if.end499, label %if.then474

if.then474:                                       ; preds = %if.end464
  %and476 = and i32 %181, 262144
  %cmp477 = icmp eq i32 %and476, 0
  br i1 %cmp477, label %cond.false483, label %cond.true479

cond.true479:                                     ; preds = %if.then474
  %sv_any480 = getelementptr inbounds %struct.sv* %180, i64 0, i32 0
  %184 = load i8** %sv_any480, align 8, !tbaa !3
  %xpv_cur = getelementptr inbounds i8* %184, i64 8
  %185 = bitcast i8* %xpv_cur to i64*
  %186 = load i64* %185, align 8, !tbaa !5
  store i64 %186, i64* %keylen, align 8, !tbaa !5
  %xpv_pv482 = bitcast i8* %184 to i8**
  %187 = load i8** %xpv_pv482, align 8, !tbaa !3
  br label %cond.end485

cond.false483:                                    ; preds = %if.then474
  %call484 = call i8* @Perl_sv_2pv_flags(%struct.sv* %180, i64* %keylen, i32 2) #7
  %.pre1538 = load i32* %sv_flags467, align 4, !tbaa !0
  %.pre1539 = load i64* %keylen, align 8, !tbaa !5
  br label %cond.end485

cond.end485:                                      ; preds = %cond.false483, %cond.true479
  %188 = phi i64 [ %186, %cond.true479 ], [ %.pre1539, %cond.false483 ]
  %189 = phi i32 [ %181, %cond.true479 ], [ %.pre1538, %cond.false483 ]
  %cond486 = phi i8* [ %187, %cond.true479 ], [ %call484, %cond.false483 ]
  %and488 = and i32 %189, 536870912
  %tobool489 = icmp eq i32 %and488, 0
  br i1 %tobool489, label %cond.end495, label %cond.true490

cond.true490:                                     ; preds = %cond.end485
  %sub492 = sub i64 0, %188
  %sext1482 = shl i64 %sub492, 32
  %conv493 = ashr exact i64 %sext1482, 32
  br label %cond.end495

cond.end495:                                      ; preds = %cond.end485, %cond.true490
  %cond496 = phi i64 [ %conv493, %cond.true490 ], [ %188, %cond.end485 ]
  %conv497 = trunc i64 %cond496 to i32
  %call498 = call %struct.sv* @Perl_newSVpvn_share(i8* %cond486, i32 %conv497, i32 0) #7
  call void @Perl_sv_free(%struct.sv* %180) #7
  %190 = getelementptr inbounds %struct.op* %op_sv466, i64 0, i32 0
  %call498.c = bitcast %struct.sv* %call498 to %struct.op*
  store %struct.op* %call498.c, %struct.op** %190, align 8, !tbaa !3
  br label %if.end499

if.end499:                                        ; preds = %if.end464, %cond.end495
  %op_private500 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %191 = load i8* %op_private500, align 1, !tbaa !1
  %tobool503 = icmp slt i8 %191, 0
  br i1 %tobool503, label %for.inc1173, label %if.end505

if.end505:                                        ; preds = %if.end499
  %192 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %193 = load %struct.op** %192, align 8, !tbaa !3
  %194 = getelementptr inbounds %struct.op* %193, i64 0, i32 4
  %195 = load i16* %194, align 2, !tbaa !4
  %cmp508 = icmp eq i16 %195, 134
  br i1 %cmp508, label %lor.lhs.false510, label %for.inc1173

lor.lhs.false510:                                 ; preds = %if.end505
  %196 = getelementptr inbounds %struct.op* %193, i64 1, i32 0
  %197 = load %struct.op** %196, align 8, !tbaa !3
  %op_type512 = getelementptr inbounds %struct.op* %197, i64 0, i32 4
  %198 = load i16* %op_type512, align 2, !tbaa !4
  %cmp514 = icmp eq i16 %198, 9
  br i1 %cmp514, label %if.end517, label %for.inc1173

if.end517:                                        ; preds = %lor.lhs.false510
  %199 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %op_targ519 = getelementptr inbounds %struct.op* %197, i64 0, i32 3
  %200 = load i64* %op_targ519, align 8, !tbaa !5
  %conv520 = trunc i64 %200 to i32
  %call521 = call %struct.sv** @Perl_av_fetch(%struct.av* %199, i32 %conv520, i32 1) #7
  %201 = load %struct.sv** %call521, align 8, !tbaa !3
  %sv_flags522 = getelementptr inbounds %struct.sv* %201, i64 0, i32 2
  %202 = load i32* %sv_flags522, align 4, !tbaa !0
  %and523 = and i32 %202, 1073741824
  %tobool524 = icmp eq i32 %and523, 0
  br i1 %tobool524, label %for.inc1173, label %if.end526

if.end526:                                        ; preds = %if.end517
  %sv_any527 = getelementptr inbounds %struct.sv* %201, i64 0, i32 0
  %203 = load i8** %sv_any527, align 8, !tbaa !3
  %xmg_stash = getelementptr inbounds i8* %203, i64 48
  %204 = bitcast i8* %xmg_stash to %struct.hv**
  %205 = load %struct.hv** %204, align 8, !tbaa !3
  %call528 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %205, i8* getelementptr inbounds ([7 x i8]* @.str137, i64 0, i64 0), i32 6, i32 0) #7
  %tobool529 = icmp eq %struct.sv** %call528, null
  br i1 %tobool529, label %for.inc1173, label %lor.lhs.false530

lor.lhs.false530:                                 ; preds = %if.end526
  %206 = load %struct.sv** %call528, align 8
  %sv_any531 = bitcast %struct.sv* %206 to %struct.xpvgv**
  %207 = load %struct.xpvgv** %sv_any531, align 8, !tbaa !3
  %xgv_gp532 = getelementptr inbounds %struct.xpvgv* %207, i64 0, i32 7
  %208 = load %struct.gp** %xgv_gp532, align 8, !tbaa !3
  %gp_hv = getelementptr inbounds %struct.gp* %208, i64 0, i32 5
  %209 = load %struct.hv** %gp_hv, align 8, !tbaa !3
  %tobool533 = icmp eq %struct.hv* %209, null
  br i1 %tobool533, label %for.inc1173, label %if.end535

if.end535:                                        ; preds = %lor.lhs.false530
  %210 = load %struct.sv** %179, align 8, !tbaa !3
  %sv_flags536 = getelementptr inbounds %struct.sv* %210, i64 0, i32 2
  %211 = load i32* %sv_flags536, align 4, !tbaa !0
  %and537 = and i32 %211, 262144
  %cmp538 = icmp eq i32 %and537, 0
  br i1 %cmp538, label %cond.false545, label %cond.true540

cond.true540:                                     ; preds = %if.end535
  %sv_any541 = getelementptr inbounds %struct.sv* %210, i64 0, i32 0
  %212 = load i8** %sv_any541, align 8, !tbaa !3
  %xpv_cur542 = getelementptr inbounds i8* %212, i64 8
  %213 = bitcast i8* %xpv_cur542 to i64*
  %214 = load i64* %213, align 8, !tbaa !5
  store i64 %214, i64* %keylen, align 8, !tbaa !5
  %xpv_pv544 = bitcast i8* %212 to i8**
  %215 = load i8** %xpv_pv544, align 8, !tbaa !3
  br label %cond.end547

cond.false545:                                    ; preds = %if.end535
  %call546 = call i8* @Perl_sv_2pv_flags(%struct.sv* %210, i64* %keylen, i32 2) #7
  %.pre1534 = load %struct.sv** %179, align 8, !tbaa !3
  %.pre1535 = load i64* %keylen, align 8, !tbaa !5
  %sv_flags552.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre1534, i64 0, i32 2
  %.pre1546 = load i32* %sv_flags552.phi.trans.insert, align 4, !tbaa !0
  br label %cond.end547

cond.end547:                                      ; preds = %cond.false545, %cond.true540
  %216 = phi i32 [ %211, %cond.true540 ], [ %.pre1546, %cond.false545 ]
  %217 = phi i64 [ %214, %cond.true540 ], [ %.pre1535, %cond.false545 ]
  %cond548 = phi i8* [ %215, %cond.true540 ], [ %call546, %cond.false545 ]
  %218 = load %struct.sv** %call528, align 8
  %sv_any549 = bitcast %struct.sv* %218 to %struct.xpvgv**
  %219 = load %struct.xpvgv** %sv_any549, align 8, !tbaa !3
  %xgv_gp550 = getelementptr inbounds %struct.xpvgv* %219, i64 0, i32 7
  %220 = load %struct.gp** %xgv_gp550, align 8, !tbaa !3
  %gp_hv551 = getelementptr inbounds %struct.gp* %220, i64 0, i32 5
  %221 = load %struct.hv** %gp_hv551, align 8, !tbaa !3
  %and553 = and i32 %216, 536870912
  %tobool554 = icmp eq i32 %and553, 0
  br i1 %tobool554, label %cond.end560, label %cond.true555

cond.true555:                                     ; preds = %cond.end547
  %sub557 = sub i64 0, %217
  %sext1481 = shl i64 %sub557, 32
  %conv558 = ashr exact i64 %sext1481, 32
  br label %cond.end560

cond.end560:                                      ; preds = %cond.end547, %cond.true555
  %cond561 = phi i64 [ %conv558, %cond.true555 ], [ %217, %cond.end547 ]
  %conv562 = trunc i64 %cond561 to i32
  %call563 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %221, i8* %cond548, i32 %conv562, i32 0) #7
  %tobool564 = icmp eq %struct.sv** %call563, null
  br i1 %tobool564, label %if.then565, label %if.end582

if.then565:                                       ; preds = %cond.end560
  %222 = load i32* %sv_flags522, align 4, !tbaa !0
  %and567 = and i32 %222, 262144
  %cmp568 = icmp eq i32 %and567, 0
  br i1 %cmp568, label %cond.false575, label %cond.true570

cond.true570:                                     ; preds = %if.then565
  %223 = load i8** %sv_any527, align 8, !tbaa !3
  %xpv_cur572 = getelementptr inbounds i8* %223, i64 8
  %224 = bitcast i8* %xpv_cur572 to i64*
  %225 = load i64* %224, align 8, !tbaa !5
  store i64 %225, i64* %n_a, align 8, !tbaa !5
  %xpv_pv574 = bitcast i8* %223 to i8**
  %226 = load i8** %xpv_pv574, align 8, !tbaa !3
  br label %cond.end577

cond.false575:                                    ; preds = %if.then565
  %call576 = call i8* @Perl_sv_2pv_flags(%struct.sv* %201, i64* %n_a, i32 2) #7
  %.pre1536 = load i8** %sv_any527, align 8, !tbaa !3
  br label %cond.end577

cond.end577:                                      ; preds = %cond.false575, %cond.true570
  %227 = phi i8* [ %223, %cond.true570 ], [ %.pre1536, %cond.false575 ]
  %cond578 = phi i8* [ %226, %cond.true570 ], [ %call576, %cond.false575 ]
  %xmg_stash580 = getelementptr inbounds i8* %227, i64 48
  %228 = bitcast i8* %xmg_stash580 to %struct.hv**
  %229 = load %struct.hv** %228, align 8, !tbaa !3
  %sv_any581 = getelementptr inbounds %struct.hv* %229, i64 0, i32 0
  %230 = load %struct.xpvhv** %sv_any581, align 8, !tbaa !3
  %xhv_name = getelementptr inbounds %struct.xpvhv* %230, i64 0, i32 10
  %231 = load i8** %xhv_name, align 8, !tbaa !3
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([57 x i8]* @.str138, i64 0, i64 0), i8* %cond548, i8* %cond578, i8* %231) #7
  br label %if.end582

if.end582:                                        ; preds = %cond.end560, %cond.end577
  %232 = load %struct.sv** %call563, align 8, !tbaa !3
  %sv_flags583 = getelementptr inbounds %struct.sv* %232, i64 0, i32 2
  %233 = load i32* %sv_flags583, align 4, !tbaa !0
  %and584 = and i32 %233, 65536
  %tobool585 = icmp eq i32 %and584, 0
  br i1 %tobool585, label %cond.false589, label %cond.true586

cond.true586:                                     ; preds = %if.end582
  %sv_any587 = getelementptr inbounds %struct.sv* %232, i64 0, i32 0
  %234 = load i8** %sv_any587, align 8, !tbaa !3
  %xiv_iv588 = getelementptr inbounds i8* %234, i64 24
  %235 = bitcast i8* %xiv_iv588 to i64*
  %236 = load i64* %235, align 8, !tbaa !5
  br label %cond.end591

cond.false589:                                    ; preds = %if.end582
  %call590 = call i64 @Perl_sv_2iv(%struct.sv* %232) #7
  br label %cond.end591

cond.end591:                                      ; preds = %cond.false589, %cond.true586
  %cond592 = phi i64 [ %236, %cond.true586 ], [ %call590, %cond.false589 ]
  %conv593 = trunc i64 %cond592 to i32
  %cmp594 = icmp slt i32 %conv593, 1
  br i1 %cmp594, label %if.then596, label %if.end597

if.then596:                                       ; preds = %cond.end591
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str139, i64 0, i64 0)) #7
  br label %if.end597

if.end597:                                        ; preds = %if.then596, %cond.end591
  store i16 125, i16* %194, align 2, !tbaa !4
  %237 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !3
  %238 = getelementptr inbounds %struct.op* %193, i64 0, i32 2
  store %struct.op* ()* %237, %struct.op* ()** %238, align 8, !tbaa !3
  store i16 127, i16* %op_type, align 2, !tbaa !4
  %239 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 127), align 8, !tbaa !3
  %op_ppaddr601 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %239, %struct.op* ()** %op_ppaddr601, align 8, !tbaa !3
  %sext1480 = shl i64 %cond592, 32
  %conv602 = ashr exact i64 %sext1480, 32
  %call603 = call %struct.sv* @Perl_newSViv(i64 %conv602) #7
  %240 = load %struct.sv** %179, align 8, !tbaa !3
  %sv_flags604 = getelementptr inbounds %struct.sv* %240, i64 0, i32 2
  %241 = load i32* %sv_flags604, align 4, !tbaa !0
  %and605 = and i32 %241, 8388608
  %tobool606 = icmp eq i32 %and605, 0
  %sv_flags613.phi.trans.insert = getelementptr inbounds %struct.sv* %call603, i64 0, i32 2
  %.pre1547 = load i32* %sv_flags613.phi.trans.insert, align 4, !tbaa !0
  br i1 %tobool606, label %if.end610, label %if.then607

if.then607:                                       ; preds = %if.end597
  %or609 = or i32 %.pre1547, 8388608
  store i32 %or609, i32* %sv_flags613.phi.trans.insert, align 4, !tbaa !0
  %.pre1537 = load i32* %sv_flags604, align 4, !tbaa !0
  br label %if.end610

if.end610:                                        ; preds = %if.end597, %if.then607
  %242 = phi i32 [ %or609, %if.then607 ], [ %.pre1547, %if.end597 ]
  %243 = phi i32 [ %.pre1537, %if.then607 ], [ %241, %if.end597 ]
  %and612 = and i32 %243, 1792
  %sv_flags613 = getelementptr inbounds %struct.sv* %call603, i64 0, i32 2
  %or614 = or i32 %242, %and612
  store i32 %or614, i32* %sv_flags613, align 4, !tbaa !0
  call void @Perl_sv_free(%struct.sv* %240) #7
  %244 = getelementptr inbounds %struct.op* %op_sv466, i64 0, i32 0
  %call603.c = bitcast %struct.sv* %call603 to %struct.op*
  store %struct.op* %call603.c, %struct.op** %244, align 8, !tbaa !3
  br label %for.inc1173

sw.bb615:                                         ; preds = %if.end12
  %inc625 = add i16 %4, 1
  store i16 %inc625, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %op_private627 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %245 = load i8* %op_private627, align 1, !tbaa !1
  %tobool630 = icmp slt i8 %245, 0
  br i1 %tobool630, label %for.inc1173, label %lor.lhs.false631

lor.lhs.false631:                                 ; preds = %sw.bb615
  %246 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %247 = load %struct.op** %246, align 8, !tbaa !3
  %op_sibling633 = getelementptr inbounds %struct.op* %247, i64 0, i32 1
  %248 = load %struct.op** %op_sibling633, align 8, !tbaa !3
  %op_type634 = getelementptr inbounds %struct.op* %248, i64 0, i32 4
  %249 = load i16* %op_type634, align 2, !tbaa !4
  %cmp636 = icmp eq i16 %249, 141
  br i1 %cmp636, label %if.end639, label %for.inc1173

if.end639:                                        ; preds = %lor.lhs.false631
  %250 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %251 = load %struct.op** %250, align 8, !tbaa !3
  %252 = getelementptr inbounds %struct.op* %251, i64 0, i32 4
  %253 = load i16* %252, align 2, !tbaa !4
  %cmp643 = icmp eq i16 %253, 134
  br i1 %cmp643, label %lor.lhs.false645, label %for.inc1173

lor.lhs.false645:                                 ; preds = %if.end639
  %254 = getelementptr inbounds %struct.op* %251, i64 1, i32 0
  %255 = load %struct.op** %254, align 8, !tbaa !3
  %op_type647 = getelementptr inbounds %struct.op* %255, i64 0, i32 4
  %256 = load i16* %op_type647, align 2, !tbaa !4
  %cmp649 = icmp eq i16 %256, 9
  br i1 %cmp649, label %if.end652, label %for.inc1173

if.end652:                                        ; preds = %lor.lhs.false645
  %257 = load %struct.av** @PL_comppad_name, align 8, !tbaa !3
  %op_targ654 = getelementptr inbounds %struct.op* %255, i64 0, i32 3
  %258 = load i64* %op_targ654, align 8, !tbaa !5
  %conv655 = trunc i64 %258 to i32
  %call656 = call %struct.sv** @Perl_av_fetch(%struct.av* %257, i32 %conv655, i32 1) #7
  %259 = load %struct.sv** %call656, align 8, !tbaa !3
  %sv_flags657 = getelementptr inbounds %struct.sv* %259, i64 0, i32 2
  %260 = load i32* %sv_flags657, align 4, !tbaa !0
  %and658 = and i32 %260, 1073741824
  %tobool659 = icmp eq i32 %and658, 0
  br i1 %tobool659, label %for.inc1173, label %if.end661

if.end661:                                        ; preds = %if.end652
  %sv_any662 = getelementptr inbounds %struct.sv* %259, i64 0, i32 0
  %261 = load i8** %sv_any662, align 8, !tbaa !3
  %xmg_stash663 = getelementptr inbounds i8* %261, i64 48
  %262 = bitcast i8* %xmg_stash663 to %struct.hv**
  %263 = load %struct.hv** %262, align 8, !tbaa !3
  %call664 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %263, i8* getelementptr inbounds ([7 x i8]* @.str137, i64 0, i64 0), i32 6, i32 0) #7
  %tobool665 = icmp eq %struct.sv** %call664, null
  br i1 %tobool665, label %for.inc1173, label %lor.lhs.false666

lor.lhs.false666:                                 ; preds = %if.end661
  %264 = load %struct.sv** %call664, align 8
  %sv_any667 = bitcast %struct.sv* %264 to %struct.xpvgv**
  %265 = load %struct.xpvgv** %sv_any667, align 8, !tbaa !3
  %xgv_gp668 = getelementptr inbounds %struct.xpvgv* %265, i64 0, i32 7
  %266 = load %struct.gp** %xgv_gp668, align 8, !tbaa !3
  %gp_hv669 = getelementptr inbounds %struct.gp* %266, i64 0, i32 5
  %267 = load %struct.hv** %gp_hv669, align 8, !tbaa !3
  %tobool670 = icmp eq %struct.hv* %267, null
  br i1 %tobool670, label %for.inc1173, label %if.end672

if.end672:                                        ; preds = %lor.lhs.false666
  %268 = load %struct.op** %246, align 8, !tbaa !3
  %op_sibling674 = getelementptr inbounds %struct.op* %268, i64 0, i32 1
  %269 = load %struct.op** %op_sibling674, align 8, !tbaa !3
  %270 = getelementptr inbounds %struct.op* %269, i64 1, i32 0
  %271 = load %struct.op** %270, align 8, !tbaa !3
  %op_sibling676 = getelementptr inbounds %struct.op* %271, i64 0, i32 1
  %272 = load %struct.op** %op_sibling676, align 8, !tbaa !3
  %273 = bitcast %struct.op* %272 to %struct.svop*
  %tobool6781497 = icmp eq %struct.op* %272, null
  br i1 %tobool6781497, label %for.inc1173.critedge, label %for.body679

for.body679:                                      ; preds = %if.end672, %for.inc
  %key_op.01498 = phi %struct.svop* [ %276, %for.inc ], [ %273, %if.end672 ]
  %op_type680 = getelementptr inbounds %struct.svop* %key_op.01498, i64 0, i32 4
  %274 = load i16* %op_type680, align 2, !tbaa !4
  %cmp682 = icmp eq i16 %274, 5
  br i1 %cmp682, label %for.inc, label %for.inc1173

for.inc:                                          ; preds = %for.body679
  %op_sibling686 = getelementptr inbounds %struct.svop* %key_op.01498, i64 0, i32 1
  %275 = load %struct.op** %op_sibling686, align 8, !tbaa !3
  %276 = bitcast %struct.op* %275 to %struct.svop*
  %tobool678 = icmp eq %struct.op* %275, null
  br i1 %tobool678, label %if.end689, label %for.body679

if.end689:                                        ; preds = %for.inc
  store i16 125, i16* %252, align 2, !tbaa !4
  %277 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !3
  %278 = getelementptr inbounds %struct.op* %251, i64 0, i32 2
  store %struct.op* ()* %277, %struct.op* ()** %278, align 8, !tbaa !3
  store i16 128, i16* %op_type, align 2, !tbaa !4
  %279 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 128), align 8, !tbaa !3
  %op_ppaddr693 = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %279, %struct.op* ()** %op_ppaddr693, align 8, !tbaa !3
  br i1 %tobool6781497, label %for.inc1173, label %for.body696

for.body696:                                      ; preds = %if.end689, %if.end769
  %key_op.11501 = phi %struct.svop* [ %312, %if.end769 ], [ %273, %if.end689 ]
  %op_sv697 = getelementptr inbounds %struct.svop* %key_op.11501, i64 0, i32 8
  %280 = load %struct.sv** %op_sv697, align 8, !tbaa !3
  %sv_flags698 = getelementptr inbounds %struct.sv* %280, i64 0, i32 2
  %281 = load i32* %sv_flags698, align 4, !tbaa !0
  %and699 = and i32 %281, 262144
  %cmp700 = icmp eq i32 %and699, 0
  br i1 %cmp700, label %cond.false707, label %cond.true702

cond.true702:                                     ; preds = %for.body696
  %sv_any703 = getelementptr inbounds %struct.sv* %280, i64 0, i32 0
  %282 = load i8** %sv_any703, align 8, !tbaa !3
  %xpv_cur704 = getelementptr inbounds i8* %282, i64 8
  %283 = bitcast i8* %xpv_cur704 to i64*
  %284 = load i64* %283, align 8, !tbaa !5
  store i64 %284, i64* %keylen624, align 8, !tbaa !5
  %xpv_pv706 = bitcast i8* %282 to i8**
  %285 = load i8** %xpv_pv706, align 8, !tbaa !3
  br label %cond.end709

cond.false707:                                    ; preds = %for.body696
  %call708 = call i8* @Perl_sv_2pv_flags(%struct.sv* %280, i64* %keylen624, i32 2) #7
  %.pre1540 = load %struct.sv** %op_sv697, align 8, !tbaa !3
  %.pre1541 = load i64* %keylen624, align 8, !tbaa !5
  %sv_flags714.phi.trans.insert = getelementptr inbounds %struct.sv* %.pre1540, i64 0, i32 2
  %.pre1548 = load i32* %sv_flags714.phi.trans.insert, align 4, !tbaa !0
  br label %cond.end709

cond.end709:                                      ; preds = %cond.false707, %cond.true702
  %286 = phi i32 [ %281, %cond.true702 ], [ %.pre1548, %cond.false707 ]
  %287 = phi i64 [ %284, %cond.true702 ], [ %.pre1541, %cond.false707 ]
  %cond710 = phi i8* [ %285, %cond.true702 ], [ %call708, %cond.false707 ]
  %288 = load %struct.sv** %call664, align 8
  %sv_any711 = bitcast %struct.sv* %288 to %struct.xpvgv**
  %289 = load %struct.xpvgv** %sv_any711, align 8, !tbaa !3
  %xgv_gp712 = getelementptr inbounds %struct.xpvgv* %289, i64 0, i32 7
  %290 = load %struct.gp** %xgv_gp712, align 8, !tbaa !3
  %gp_hv713 = getelementptr inbounds %struct.gp* %290, i64 0, i32 5
  %291 = load %struct.hv** %gp_hv713, align 8, !tbaa !3
  %and715 = and i32 %286, 536870912
  %tobool716 = icmp eq i32 %and715, 0
  br i1 %tobool716, label %cond.end722, label %cond.true717

cond.true717:                                     ; preds = %cond.end709
  %sub719 = sub i64 0, %287
  %sext1479 = shl i64 %sub719, 32
  %conv720 = ashr exact i64 %sext1479, 32
  br label %cond.end722

cond.end722:                                      ; preds = %cond.end709, %cond.true717
  %cond723 = phi i64 [ %conv720, %cond.true717 ], [ %287, %cond.end709 ]
  %conv724 = trunc i64 %cond723 to i32
  %call725 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %291, i8* %cond710, i32 %conv724, i32 0) #7
  %tobool726 = icmp eq %struct.sv** %call725, null
  br i1 %tobool726, label %if.then727, label %if.end745

if.then727:                                       ; preds = %cond.end722
  %292 = load i32* %sv_flags657, align 4, !tbaa !0
  %and729 = and i32 %292, 262144
  %cmp730 = icmp eq i32 %and729, 0
  br i1 %cmp730, label %cond.false737, label %cond.true732

cond.true732:                                     ; preds = %if.then727
  %293 = load i8** %sv_any662, align 8, !tbaa !3
  %xpv_cur734 = getelementptr inbounds i8* %293, i64 8
  %294 = bitcast i8* %xpv_cur734 to i64*
  %295 = load i64* %294, align 8, !tbaa !5
  store i64 %295, i64* %n_a, align 8, !tbaa !5
  %xpv_pv736 = bitcast i8* %293 to i8**
  %296 = load i8** %xpv_pv736, align 8, !tbaa !3
  br label %cond.end739

cond.false737:                                    ; preds = %if.then727
  %call738 = call i8* @Perl_sv_2pv_flags(%struct.sv* %259, i64* %n_a, i32 2) #7
  %.pre1542 = load i8** %sv_any662, align 8, !tbaa !3
  br label %cond.end739

cond.end739:                                      ; preds = %cond.false737, %cond.true732
  %297 = phi i8* [ %293, %cond.true732 ], [ %.pre1542, %cond.false737 ]
  %cond740 = phi i8* [ %296, %cond.true732 ], [ %call738, %cond.false737 ]
  %xmg_stash742 = getelementptr inbounds i8* %297, i64 48
  %298 = bitcast i8* %xmg_stash742 to %struct.hv**
  %299 = load %struct.hv** %298, align 8, !tbaa !3
  %sv_any743 = getelementptr inbounds %struct.hv* %299, i64 0, i32 0
  %300 = load %struct.xpvhv** %sv_any743, align 8, !tbaa !3
  %xhv_name744 = getelementptr inbounds %struct.xpvhv* %300, i64 0, i32 10
  %301 = load i8** %xhv_name744, align 8, !tbaa !3
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([57 x i8]* @.str138, i64 0, i64 0), i8* %cond710, i8* %cond740, i8* %301) #7
  br label %if.end745

if.end745:                                        ; preds = %cond.end722, %cond.end739
  %302 = load %struct.sv** %call725, align 8, !tbaa !3
  %sv_flags746 = getelementptr inbounds %struct.sv* %302, i64 0, i32 2
  %303 = load i32* %sv_flags746, align 4, !tbaa !0
  %and747 = and i32 %303, 65536
  %tobool748 = icmp eq i32 %and747, 0
  br i1 %tobool748, label %cond.false752, label %cond.true749

cond.true749:                                     ; preds = %if.end745
  %sv_any750 = getelementptr inbounds %struct.sv* %302, i64 0, i32 0
  %304 = load i8** %sv_any750, align 8, !tbaa !3
  %xiv_iv751 = getelementptr inbounds i8* %304, i64 24
  %305 = bitcast i8* %xiv_iv751 to i64*
  %306 = load i64* %305, align 8, !tbaa !5
  br label %cond.end754

cond.false752:                                    ; preds = %if.end745
  %call753 = call i64 @Perl_sv_2iv(%struct.sv* %302) #7
  br label %cond.end754

cond.end754:                                      ; preds = %cond.false752, %cond.true749
  %cond755 = phi i64 [ %306, %cond.true749 ], [ %call753, %cond.false752 ]
  %conv756 = trunc i64 %cond755 to i32
  %cmp757 = icmp slt i32 %conv756, 1
  br i1 %cmp757, label %if.then759, label %if.end760

if.then759:                                       ; preds = %cond.end754
  call void (i8*, ...)* @Perl_croak(i8* getelementptr inbounds ([41 x i8]* @.str139, i64 0, i64 0)) #7
  br label %if.end760

if.end760:                                        ; preds = %if.then759, %cond.end754
  %sext = shl i64 %cond755, 32
  %conv761 = ashr exact i64 %sext, 32
  %call762 = call %struct.sv* @Perl_newSViv(i64 %conv761) #7
  %307 = load %struct.sv** %op_sv697, align 8, !tbaa !3
  %sv_flags763 = getelementptr inbounds %struct.sv* %307, i64 0, i32 2
  %308 = load i32* %sv_flags763, align 4, !tbaa !0
  %and764 = and i32 %308, 8388608
  %tobool765 = icmp eq i32 %and764, 0
  %sv_flags772.phi.trans.insert = getelementptr inbounds %struct.sv* %call762, i64 0, i32 2
  %.pre1549 = load i32* %sv_flags772.phi.trans.insert, align 4, !tbaa !0
  br i1 %tobool765, label %if.end769, label %if.then766

if.then766:                                       ; preds = %if.end760
  %or768 = or i32 %.pre1549, 8388608
  store i32 %or768, i32* %sv_flags772.phi.trans.insert, align 4, !tbaa !0
  %.pre1543 = load i32* %sv_flags763, align 4, !tbaa !0
  br label %if.end769

if.end769:                                        ; preds = %if.end760, %if.then766
  %309 = phi i32 [ %or768, %if.then766 ], [ %.pre1549, %if.end760 ]
  %310 = phi i32 [ %.pre1543, %if.then766 ], [ %308, %if.end760 ]
  %and771 = and i32 %310, 1792
  %sv_flags772 = getelementptr inbounds %struct.sv* %call762, i64 0, i32 2
  %or773 = or i32 %309, %and771
  store i32 %or773, i32* %sv_flags772, align 4, !tbaa !0
  call void @Perl_sv_free(%struct.sv* %307) #7
  store %struct.sv* %call762, %struct.sv** %op_sv697, align 8, !tbaa !3
  %op_sibling775 = getelementptr inbounds %struct.svop* %key_op.11501, i64 0, i32 1
  %311 = load %struct.op** %op_sibling775, align 8, !tbaa !3
  %312 = bitcast %struct.op* %311 to %struct.svop*
  %tobool695 = icmp eq %struct.op* %311, null
  br i1 %tobool695, label %for.inc1173, label %for.body696

sw.bb777:                                         ; preds = %if.end12
  %313 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %314 = load %struct.op** %313, align 8, !tbaa !3
  %tobool779 = icmp eq %struct.op* %314, null
  br i1 %tobool779, label %for.inc1173, label %lor.lhs.false780

lor.lhs.false780:                                 ; preds = %sw.bb777
  %op_type781 = getelementptr inbounds %struct.op* %314, i64 0, i32 4
  %315 = load i16* %op_type781, align 2, !tbaa !4
  %cmp783 = icmp eq i16 %315, 3
  br i1 %cmp783, label %if.end786, label %for.inc1173

if.end786:                                        ; preds = %lor.lhs.false780
  %316 = getelementptr inbounds %struct.op* %1, i64 0, i32 1
  %317 = load %struct.op** %316, align 8, !tbaa !3
  %tobool788 = icmp eq %struct.op* %317, null
  br i1 %tobool788, label %if.then789, label %if.end822

if.then789:                                       ; preds = %if.end786
  %op_next790 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %318 = load %struct.op** %op_next790, align 8, !tbaa !3
  %op_type791 = getelementptr inbounds %struct.op* %318, i64 0, i32 4
  %319 = load i16* %op_type791, align 2, !tbaa !4
  %cmp793 = icmp eq i16 %319, 151
  br i1 %cmp793, label %land.lhs.true795, label %if.end822

land.lhs.true795:                                 ; preds = %if.then789
  %op_flags796 = getelementptr inbounds %struct.op* %318, i64 0, i32 6
  %320 = load i8* %op_flags796, align 1, !tbaa !1
  %and798 = and i8 %320, 3
  %cmp799 = icmp eq i8 %and798, 3
  br i1 %cmp799, label %if.then801, label %if.end822

if.then801:                                       ; preds = %land.lhs.true795
  %321 = getelementptr inbounds %struct.op* %318, i64 1, i32 0
  %322 = load %struct.op** %321, align 8, !tbaa !3
  %tobool803 = icmp eq %struct.op* %322, null
  br i1 %tobool803, label %if.end822, label %land.lhs.true804

land.lhs.true804:                                 ; preds = %if.then801
  %op_type805 = getelementptr inbounds %struct.op* %322, i64 0, i32 4
  %323 = load i16* %op_type805, align 2, !tbaa !4
  %cmp807 = icmp eq i16 %323, 3
  br i1 %cmp807, label %land.lhs.true809, label %if.end822

land.lhs.true809:                                 ; preds = %land.lhs.true804
  %324 = getelementptr inbounds %struct.op* %322, i64 0, i32 1
  %325 = load %struct.op** %324, align 8, !tbaa !3
  %cmp811 = icmp eq %struct.op* %325, %1
  br i1 %cmp811, label %if.then813, label %if.end822

if.then813:                                       ; preds = %land.lhs.true809
  %op_private814 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %326 = load i8* %op_private814, align 1, !tbaa !1
  %or816 = or i8 %326, 4
  store i8 %or816, i8* %op_private814, align 1, !tbaa !1
  call void @Perl_op_null(%struct.op* %318) #8
  %op_next818 = getelementptr inbounds %struct.op* %314, i64 0, i32 0
  %327 = load %struct.op** %op_next818, align 8, !tbaa !3
  %op_next819 = getelementptr inbounds %struct.op* %322, i64 0, i32 0
  store %struct.op* %327, %struct.op** %op_next819, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %314) #8
  %.pre1544 = load i16* @PL_op_seqmax, align 2, !tbaa !4
  br label %if.end822

if.end822:                                        ; preds = %if.then801, %if.end786, %if.then789, %land.lhs.true795, %if.then813, %land.lhs.true809, %land.lhs.true804
  %328 = phi i16 [ %4, %if.then801 ], [ %4, %if.end786 ], [ %4, %if.then789 ], [ %4, %land.lhs.true795 ], [ %.pre1544, %if.then813 ], [ %4, %land.lhs.true809 ], [ %4, %land.lhs.true804 ]
  %inc823 = add i16 %328, 1
  store i16 %inc823, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %328, i16* %op_seq3, align 2, !tbaa !4
  %329 = getelementptr inbounds %struct.op* %314, i64 0, i32 1
  %330 = load %struct.op** %329, align 8, !tbaa !3
  %tobool826 = icmp eq %struct.op* %330, null
  br i1 %tobool826, label %for.inc1173, label %if.end828

if.end828:                                        ; preds = %if.end822
  %op_type829 = getelementptr inbounds %struct.op* %330, i64 0, i32 4
  %331 = load i16* %op_type829, align 2, !tbaa !4
  %cmp831 = icmp eq i16 %331, 0
  br i1 %cmp831, label %if.end835, label %lor.lhs.false837

if.end835:                                        ; preds = %if.end828
  %332 = getelementptr inbounds %struct.op* %330, i64 0, i32 1
  %333 = load %struct.op** %332, align 8, !tbaa !3
  %tobool836 = icmp eq %struct.op* %333, null
  br i1 %tobool836, label %for.inc1173, label %if.end835.lor.lhs.false837_crit_edge

if.end835.lor.lhs.false837_crit_edge:             ; preds = %if.end835
  %op_type838.phi.trans.insert = getelementptr inbounds %struct.op* %333, i64 0, i32 4
  %.pre1550 = load i16* %op_type838.phi.trans.insert, align 2, !tbaa !4
  br label %lor.lhs.false837

lor.lhs.false837:                                 ; preds = %if.end835.lor.lhs.false837_crit_edge, %if.end828
  %334 = phi i16 [ %.pre1550, %if.end835.lor.lhs.false837_crit_edge ], [ %331, %if.end828 ]
  %oright.01492 = phi %struct.op* [ %333, %if.end835.lor.lhs.false837_crit_edge ], [ %330, %if.end828 ]
  switch i16 %334, label %for.inc1173 [
    i16 125, label %lor.lhs.false847
    i16 10, label %lor.lhs.false847
  ]

lor.lhs.false847:                                 ; preds = %lor.lhs.false837, %lor.lhs.false837
  %op_next848 = getelementptr inbounds %struct.op* %oright.01492, i64 0, i32 0
  %335 = load %struct.op** %op_next848, align 8, !tbaa !3
  %cmp849 = icmp eq %struct.op* %335, %1
  br i1 %cmp849, label %lor.lhs.false851, label %for.inc1173

lor.lhs.false851:                                 ; preds = %lor.lhs.false847
  %op_private852 = getelementptr inbounds %struct.op* %oright.01492, i64 0, i32 7
  %336 = load i8* %op_private852, align 1, !tbaa !1
  %tobool855 = icmp slt i8 %336, 0
  br i1 %tobool855, label %for.inc1173, label %if.end857

if.end857:                                        ; preds = %lor.lhs.false851
  %op_next858 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %337 = load %struct.op** %op_next858, align 8, !tbaa !3
  %tobool859 = icmp eq %struct.op* %337, null
  br i1 %tobool859, label %for.inc1173, label %lor.lhs.false860

lor.lhs.false860:                                 ; preds = %if.end857
  %op_type861 = getelementptr inbounds %struct.op* %337, i64 0, i32 4
  %338 = load i16* %op_type861, align 2, !tbaa !4
  %cmp863 = icmp eq i16 %338, 0
  br i1 %cmp863, label %if.end866, label %for.inc1173

if.end866:                                        ; preds = %lor.lhs.false860
  %op_next867 = getelementptr inbounds %struct.op* %337, i64 0, i32 0
  %339 = load %struct.op** %op_next867, align 8, !tbaa !3
  %tobool868 = icmp eq %struct.op* %339, null
  br i1 %tobool868, label %for.inc1173, label %lor.lhs.false869

lor.lhs.false869:                                 ; preds = %if.end866
  %op_type870 = getelementptr inbounds %struct.op* %339, i64 0, i32 4
  %340 = load i16* %op_type870, align 2, !tbaa !4
  %cmp872 = icmp eq i16 %340, 3
  br i1 %cmp872, label %if.end875, label %for.inc1173

if.end875:                                        ; preds = %lor.lhs.false869
  %op_next876 = getelementptr inbounds %struct.op* %339, i64 0, i32 0
  %341 = load %struct.op** %op_next876, align 8, !tbaa !3
  %tobool877 = icmp eq %struct.op* %341, null
  br i1 %tobool877, label %for.inc1173, label %land.lhs.true878

land.lhs.true878:                                 ; preds = %if.end875
  %op_type879 = getelementptr inbounds %struct.op* %341, i64 0, i32 4
  %342 = load i16* %op_type879, align 2, !tbaa !4
  %cmp881 = icmp eq i16 %342, 7
  br i1 %cmp881, label %if.end885, label %lor.lhs.false887

if.end885:                                        ; preds = %land.lhs.true878
  %op_next884 = getelementptr inbounds %struct.op* %341, i64 0, i32 0
  %343 = load %struct.op** %op_next884, align 8, !tbaa !3
  %tobool886 = icmp eq %struct.op* %343, null
  br i1 %tobool886, label %for.inc1173, label %if.end885.lor.lhs.false887_crit_edge

if.end885.lor.lhs.false887_crit_edge:             ; preds = %if.end885
  %op_type888.phi.trans.insert = getelementptr inbounds %struct.op* %343, i64 0, i32 4
  %.pre1551 = load i16* %op_type888.phi.trans.insert, align 2, !tbaa !4
  br label %lor.lhs.false887

lor.lhs.false887:                                 ; preds = %if.end885.lor.lhs.false887_crit_edge, %land.lhs.true878
  %344 = phi i16 [ %.pre1551, %if.end885.lor.lhs.false887_crit_edge ], [ %342, %land.lhs.true878 ]
  %o2.01496 = phi %struct.op* [ %343, %if.end885.lor.lhs.false887_crit_edge ], [ %341, %land.lhs.true878 ]
  switch i16 %344, label %for.inc1173 [
    i16 10, label %lor.lhs.false897
    i16 125, label %lor.lhs.false897
  ]

lor.lhs.false897:                                 ; preds = %lor.lhs.false887, %lor.lhs.false887
  %op_private898 = getelementptr inbounds %struct.op* %o2.01496, i64 0, i32 7
  %345 = load i8* %op_private898, align 1, !tbaa !1
  %tobool901 = icmp slt i8 %345, 0
  br i1 %tobool901, label %for.inc1173, label %if.end903

if.end903:                                        ; preds = %lor.lhs.false897
  %op_next904 = getelementptr inbounds %struct.op* %o2.01496, i64 0, i32 0
  %346 = load %struct.op** %op_next904, align 8, !tbaa !3
  %tobool905 = icmp eq %struct.op* %346, null
  br i1 %tobool905, label %for.inc1173, label %lor.lhs.false906

lor.lhs.false906:                                 ; preds = %if.end903
  %op_type907 = getelementptr inbounds %struct.op* %346, i64 0, i32 4
  %347 = load i16* %op_type907, align 2, !tbaa !4
  %cmp909 = icmp eq i16 %347, 0
  br i1 %cmp909, label %if.end912, label %for.inc1173

if.end912:                                        ; preds = %lor.lhs.false906
  %op_next913 = getelementptr inbounds %struct.op* %346, i64 0, i32 0
  %348 = load %struct.op** %op_next913, align 8, !tbaa !3
  %tobool914 = icmp eq %struct.op* %348, null
  br i1 %tobool914, label %for.inc1173, label %lor.lhs.false915

lor.lhs.false915:                                 ; preds = %if.end912
  %op_type916 = getelementptr inbounds %struct.op* %348, i64 0, i32 4
  %349 = load i16* %op_type916, align 2, !tbaa !4
  %cmp918 = icmp eq i16 %349, 37
  br i1 %cmp918, label %lor.lhs.false920, label %for.inc1173

lor.lhs.false920:                                 ; preds = %lor.lhs.false915
  %op_flags921 = getelementptr inbounds %struct.op* %348, i64 0, i32 6
  %350 = load i8* %op_flags921, align 1, !tbaa !1
  %and923 = and i8 %350, 3
  %cmp924 = icmp eq i8 %and923, 1
  br i1 %cmp924, label %if.end927, label %for.inc1173

if.end927:                                        ; preds = %lor.lhs.false920
  %351 = getelementptr inbounds %struct.op* %348, i64 1, i32 0
  %352 = load %struct.op** %351, align 8, !tbaa !3
  %tobool929 = icmp eq %struct.op* %352, null
  br i1 %tobool929, label %for.inc1173, label %lor.lhs.false930

lor.lhs.false930:                                 ; preds = %if.end927
  %op_type931 = getelementptr inbounds %struct.op* %352, i64 0, i32 4
  %353 = load i16* %op_type931, align 2, !tbaa !4
  %cmp933 = icmp eq i16 %353, 0
  br i1 %cmp933, label %if.end936, label %for.inc1173

if.end936:                                        ; preds = %lor.lhs.false930
  %354 = getelementptr inbounds %struct.op* %352, i64 1, i32 0
  %355 = load %struct.op** %354, align 8, !tbaa !3
  %tobool938 = icmp eq %struct.op* %355, null
  br i1 %tobool938, label %for.inc1173, label %lor.lhs.false939

lor.lhs.false939:                                 ; preds = %if.end936
  %op_type940 = getelementptr inbounds %struct.op* %355, i64 0, i32 4
  %356 = load i16* %op_type940, align 2, !tbaa !4
  %cmp942 = icmp eq i16 %356, 3
  br i1 %cmp942, label %if.end945, label %for.inc1173

if.end945:                                        ; preds = %lor.lhs.false939
  %op_sibling946 = getelementptr inbounds %struct.op* %355, i64 0, i32 1
  %357 = load %struct.op** %op_sibling946, align 8, !tbaa !3
  %cmp947 = icmp eq %struct.op* %357, %1
  br i1 %cmp947, label %if.end950, label %for.inc1173

if.end950:                                        ; preds = %if.end945
  %cmp953 = icmp eq i16 %344, 125
  br i1 %cmp953, label %if.then955, label %if.else978

if.then955:                                       ; preds = %if.end950
  %cmp958 = icmp eq i16 %334, 125
  br i1 %cmp958, label %lor.lhs.false960, label %for.inc1173

lor.lhs.false960:                                 ; preds = %if.then955
  %358 = getelementptr inbounds %struct.op* %oright.01492, i64 1, i32 0
  %359 = load %struct.op** %358, align 8, !tbaa !3
  %tobool962 = icmp eq %struct.op* %359, null
  br i1 %tobool962, label %for.inc1173, label %lor.lhs.false963

lor.lhs.false963:                                 ; preds = %lor.lhs.false960
  %op_type965 = getelementptr inbounds %struct.op* %359, i64 0, i32 4
  %360 = load i16* %op_type965, align 2, !tbaa !4
  %cmp967 = icmp eq i16 %360, 7
  br i1 %cmp967, label %lor.lhs.false969, label %for.inc1173

lor.lhs.false969:                                 ; preds = %lor.lhs.false963
  %361 = getelementptr inbounds %struct.op* %o2.01496, i64 1, i32 0
  %362 = load %struct.op** %361, align 8, !tbaa !3
  %op_sv971 = getelementptr inbounds %struct.op* %362, i64 1
  %363 = bitcast %struct.op* %op_sv971 to %struct.sv**
  %364 = load %struct.sv** %363, align 8, !tbaa !3
  %op_sv973 = getelementptr inbounds %struct.op* %359, i64 1
  %365 = bitcast %struct.op* %op_sv973 to %struct.sv**
  %366 = load %struct.sv** %365, align 8, !tbaa !3
  %cmp974 = icmp eq %struct.sv* %364, %366
  br i1 %cmp974, label %if.end990, label %for.inc1173

if.else978:                                       ; preds = %if.end950
  %cmp981 = icmp eq i16 %334, 10
  br i1 %cmp981, label %lor.lhs.false983, label %for.inc1173

lor.lhs.false983:                                 ; preds = %if.else978
  %op_targ984 = getelementptr inbounds %struct.op* %oright.01492, i64 0, i32 3
  %367 = load i64* %op_targ984, align 8, !tbaa !5
  %op_targ985 = getelementptr inbounds %struct.op* %o2.01496, i64 0, i32 3
  %368 = load i64* %op_targ985, align 8, !tbaa !5
  %cmp986 = icmp eq i64 %367, %368
  br i1 %cmp986, label %if.end990, label %for.inc1173

if.end990:                                        ; preds = %lor.lhs.false969, %lor.lhs.false983
  %op_flags991 = getelementptr inbounds %struct.op* %o2.01496, i64 0, i32 6
  %369 = load i8* %op_flags991, align 1, !tbaa !1
  %op_flags992 = getelementptr inbounds %struct.op* %oright.01492, i64 0, i32 6
  store i8 %369, i8* %op_flags992, align 1, !tbaa !1
  %op_private993 = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %370 = load i8* %op_private993, align 1, !tbaa !1
  %or995 = or i8 %370, 8
  store i8 %or995, i8* %op_private993, align 1, !tbaa !1
  %371 = load %struct.op** %op_next858, align 8, !tbaa !3
  %op_next998 = getelementptr inbounds %struct.op* %371, i64 0, i32 0
  %372 = load %struct.op** %op_next998, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %372) #8
  %op_next999 = getelementptr inbounds %struct.op* %372, i64 0, i32 0
  %373 = load %struct.op** %op_next999, align 8, !tbaa !3
  %op_type1000 = getelementptr inbounds %struct.op* %373, i64 0, i32 4
  %374 = load i16* %op_type1000, align 2, !tbaa !4
  %cmp1002 = icmp eq i16 %374, 7
  br i1 %cmp1002, label %if.then1004, label %if.end1006

if.then1004:                                      ; preds = %if.end990
  call void @Perl_op_null(%struct.op* %373) #8
  %op_next1005 = getelementptr inbounds %struct.op* %373, i64 0, i32 0
  %375 = load %struct.op** %op_next1005, align 8, !tbaa !3
  br label %if.end1006

if.end1006:                                       ; preds = %if.then1004, %if.end990
  %o2.1 = phi %struct.op* [ %375, %if.then1004 ], [ %373, %if.end990 ]
  call void @Perl_op_null(%struct.op* %o2.1) #8
  %op_next1007 = getelementptr inbounds %struct.op* %o2.1, i64 0, i32 0
  %376 = load %struct.op** %op_next1007, align 8, !tbaa !3
  %op_next1008 = getelementptr inbounds %struct.op* %376, i64 0, i32 0
  %377 = load %struct.op** %op_next1008, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %377) #8
  %op_next1009 = getelementptr inbounds %struct.op* %377, i64 0, i32 0
  %378 = load %struct.op** %op_next1009, align 8, !tbaa !3
  store %struct.op* %378, %struct.op** %op_next858, align 8, !tbaa !3
  br label %for.inc1173

sw.bb1011:                                        ; preds = %if.end12
  %inc1012 = add i16 %4, 1
  store i16 %inc1012, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  %op_next1014 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %379 = load %struct.op** %op_next1014, align 8, !tbaa !3
  %tobool1015 = icmp eq %struct.op* %379, null
  br i1 %tobool1015, label %for.inc1173, label %if.end1017

if.end1017:                                       ; preds = %sw.bb1011
  %380 = getelementptr inbounds %struct.op* %379, i64 0, i32 4
  %381 = load i16* %380, align 2, !tbaa !4
  %cmp1020 = icmp eq i16 %381, 0
  br i1 %cmp1020, label %if.then1022, label %if.end1027

if.then1022:                                      ; preds = %if.end1017
  %op_next1023 = getelementptr inbounds %struct.op* %379, i64 0, i32 0
  %382 = load %struct.op** %op_next1023, align 8, !tbaa !3
  %tobool1024 = icmp eq %struct.op* %382, null
  br i1 %tobool1024, label %for.inc1173, label %if.then1022.if.end1027_crit_edge

if.then1022.if.end1027_crit_edge:                 ; preds = %if.then1022
  %.phi.trans.insert = getelementptr inbounds %struct.op* %382, i64 0, i32 4
  %.pre1552 = load i16* %.phi.trans.insert, align 2, !tbaa !4
  br label %if.end1027

if.end1027:                                       ; preds = %if.then1022.if.end1027_crit_edge, %if.end1017
  %383 = phi i16 [ %.pre1552, %if.then1022.if.end1027_crit_edge ], [ %381, %if.end1017 ]
  %enter.0.in = phi %struct.op* [ %382, %if.then1022.if.end1027_crit_edge ], [ %379, %if.end1017 ]
  %cmp1030 = icmp eq i16 %383, 7
  br i1 %cmp1030, label %if.then1032, label %if.end1047

if.then1032:                                      ; preds = %if.end1027
  %op_next1033 = getelementptr inbounds %struct.op* %enter.0.in, i64 0, i32 0
  %384 = load %struct.op** %op_next1033, align 8, !tbaa !3
  %tobool1034 = icmp eq %struct.op* %384, null
  br i1 %tobool1034, label %for.inc1173, label %if.end1036

if.end1036:                                       ; preds = %if.then1032
  %385 = getelementptr inbounds %struct.op* %384, i64 0, i32 4
  %386 = load i16* %385, align 2, !tbaa !4
  %cmp1039 = icmp eq i16 %386, 14
  br i1 %cmp1039, label %if.then1041, label %if.end1047

if.then1041:                                      ; preds = %if.end1036
  %op_next1042 = getelementptr inbounds %struct.op* %384, i64 0, i32 0
  %387 = load %struct.op** %op_next1042, align 8, !tbaa !3
  %tobool1043 = icmp eq %struct.op* %387, null
  br i1 %tobool1043, label %for.inc1173, label %if.then1041.if.end1047_crit_edge

if.then1041.if.end1047_crit_edge:                 ; preds = %if.then1041
  %.phi.trans.insert1553 = getelementptr inbounds %struct.op* %387, i64 0, i32 4
  %.pre1554 = load i16* %.phi.trans.insert1553, align 2, !tbaa !4
  br label %if.end1047

if.end1047:                                       ; preds = %if.then1041.if.end1047_crit_edge, %if.end1036, %if.end1027
  %388 = phi i16 [ %.pre1554, %if.then1041.if.end1047_crit_edge ], [ %386, %if.end1036 ], [ %383, %if.end1027 ]
  %gvop.0 = phi %struct.op* [ %enter.0.in, %if.then1041.if.end1047_crit_edge ], [ %enter.0.in, %if.end1036 ], [ null, %if.end1027 ]
  %enter.1.in = phi %struct.op* [ %387, %if.then1041.if.end1047_crit_edge ], [ %384, %if.end1036 ], [ %enter.0.in, %if.end1027 ]
  %cmp1050 = icmp eq i16 %388, 180
  br i1 %cmp1050, label %if.end1053, label %for.inc1173

if.end1053:                                       ; preds = %if.end1047
  %op_next1054 = getelementptr inbounds %struct.op* %enter.1.in, i64 0, i32 0
  %389 = load %struct.op** %op_next1054, align 8, !tbaa !3
  %tobool1055 = icmp eq %struct.op* %389, null
  br i1 %tobool1055, label %for.inc1173, label %lor.lhs.false1056

lor.lhs.false1056:                                ; preds = %if.end1053
  %op_type1057 = getelementptr inbounds %struct.op* %389, i64 0, i32 4
  %390 = load i16* %op_type1057, align 2, !tbaa !4
  %cmp1059 = icmp eq i16 %390, 181
  br i1 %cmp1059, label %if.end1062, label %for.inc1173

if.end1062:                                       ; preds = %lor.lhs.false1056
  %391 = getelementptr inbounds %struct.op* %enter.1.in, i64 1, i32 0
  %392 = load %struct.op** %391, align 8, !tbaa !3
  %tobool1064 = icmp eq %struct.op* %392, null
  br i1 %tobool1064, label %for.inc1173, label %lor.lhs.false1065

lor.lhs.false1065:                                ; preds = %if.end1062
  %op_type1066 = getelementptr inbounds %struct.op* %392, i64 0, i32 4
  %393 = load i16* %op_type1066, align 2, !tbaa !4
  %cmp1068 = icmp eq i16 %393, 0
  br i1 %cmp1068, label %lor.lhs.false1070, label %for.inc1173

lor.lhs.false1070:                                ; preds = %lor.lhs.false1065
  %op_targ1071 = getelementptr inbounds %struct.op* %392, i64 0, i32 3
  %394 = load i64* %op_targ1071, align 8, !tbaa !5
  %cmp1072 = icmp eq i64 %394, 3
  br i1 %cmp1072, label %if.end1075, label %for.inc1173

if.end1075:                                       ; preds = %lor.lhs.false1070
  %op_sibling1076 = getelementptr inbounds %struct.op* %392, i64 0, i32 1
  %395 = load %struct.op** %op_sibling1076, align 8, !tbaa !3
  %tobool1077 = icmp eq %struct.op* %395, null
  br i1 %tobool1077, label %for.inc1173, label %lor.lhs.false1078

lor.lhs.false1078:                                ; preds = %if.end1075
  %396 = getelementptr inbounds %struct.op* %395, i64 0, i32 4
  %397 = load i16* %396, align 2, !tbaa !4
  %cmp1081 = icmp eq i16 %397, 0
  br i1 %cmp1081, label %lor.lhs.false1083, label %for.inc1173

lor.lhs.false1083:                                ; preds = %lor.lhs.false1078
  %398 = getelementptr inbounds %struct.op* %395, i64 0, i32 3
  %399 = load i64* %398, align 8, !tbaa !5
  %cmp1085 = icmp eq i64 %399, 141
  br i1 %cmp1085, label %if.end1088, label %for.inc1173

if.end1088:                                       ; preds = %lor.lhs.false1083
  %400 = getelementptr inbounds %struct.op* %395, i64 1, i32 1
  %401 = load %struct.op** %400, align 8, !tbaa !3
  %cmp1090 = icmp eq %struct.op* %401, %1
  br i1 %cmp1090, label %if.end1093, label %for.inc1173

if.end1093:                                       ; preds = %if.end1088
  %402 = getelementptr inbounds %struct.op* %395, i64 1, i32 0
  %403 = load %struct.op** %402, align 8, !tbaa !3
  %tobool1095 = icmp eq %struct.op* %403, null
  br i1 %tobool1095, label %for.inc1173, label %lor.lhs.false1096

lor.lhs.false1096:                                ; preds = %if.end1093
  %op_type1097 = getelementptr inbounds %struct.op* %403, i64 0, i32 4
  %404 = load i16* %op_type1097, align 2, !tbaa !4
  %cmp1099 = icmp eq i16 %404, 3
  br i1 %cmp1099, label %if.end1102, label %for.inc1173

if.end1102:                                       ; preds = %lor.lhs.false1096
  %op_sibling1103 = getelementptr inbounds %struct.op* %403, i64 0, i32 1
  %405 = load %struct.op** %op_sibling1103, align 8, !tbaa !3
  %cmp1104 = icmp eq %struct.op* %405, %1
  br i1 %cmp1104, label %if.end1107, label %for.inc1173

if.end1107:                                       ; preds = %if.end1102
  %406 = getelementptr inbounds %struct.op* %1, i64 1, i32 0
  %407 = load %struct.op** %406, align 8, !tbaa !3
  %tobool1109 = icmp eq %struct.op* %407, null
  br i1 %tobool1109, label %for.inc1173, label %lor.lhs.false1110

lor.lhs.false1110:                                ; preds = %if.end1107
  %op_type1111 = getelementptr inbounds %struct.op* %407, i64 0, i32 4
  %408 = load i16* %op_type1111, align 2, !tbaa !4
  %cmp1113 = icmp eq i16 %408, 3
  br i1 %cmp1113, label %if.end1116, label %for.inc1173

if.end1116:                                       ; preds = %lor.lhs.false1110
  %409 = getelementptr inbounds %struct.op* %1, i64 1, i32 1
  %410 = load %struct.op** %409, align 8, !tbaa !3
  %tobool1118 = icmp eq %struct.op* %410, null
  br i1 %tobool1118, label %for.inc1173, label %lor.lhs.false1119

lor.lhs.false1119:                                ; preds = %if.end1116
  %op_next1120 = getelementptr inbounds %struct.op* %410, i64 0, i32 0
  %411 = load %struct.op** %op_next1120, align 8, !tbaa !3
  %cmp1121 = icmp eq %struct.op* %411, %1
  br i1 %cmp1121, label %if.end1124, label %for.inc1173

if.end1124:                                       ; preds = %lor.lhs.false1119
  %op_sibling1125 = getelementptr inbounds %struct.op* %407, i64 0, i32 1
  %412 = load %struct.op** %op_sibling1125, align 8, !tbaa !3
  %tobool1126 = icmp eq %struct.op* %412, null
  br i1 %tobool1126, label %if.end1152, label %land.lhs.true1127

land.lhs.true1127:                                ; preds = %if.end1124
  %op_type1128 = getelementptr inbounds %struct.op* %412, i64 0, i32 4
  %413 = load i16* %op_type1128, align 2, !tbaa !4
  %cmp1130 = icmp eq i16 %413, 125
  br i1 %cmp1130, label %land.lhs.true1132, label %if.end1152

land.lhs.true1132:                                ; preds = %land.lhs.true1127
  %op_sibling1133 = getelementptr inbounds %struct.op* %412, i64 0, i32 1
  %414 = load %struct.op** %op_sibling1133, align 8, !tbaa !3
  %cmp1134 = icmp eq %struct.op* %414, null
  br i1 %cmp1134, label %land.lhs.true1136, label %if.end1152

land.lhs.true1136:                                ; preds = %land.lhs.true1132
  %op_flags1137 = getelementptr inbounds %struct.op* %412, i64 0, i32 6
  %415 = load i8* %op_flags1137, align 1, !tbaa !1
  %cmp1139 = icmp eq i8 %415, 7
  br i1 %cmp1139, label %land.lhs.true1141, label %if.end1152

land.lhs.true1141:                                ; preds = %land.lhs.true1136
  %416 = getelementptr inbounds %struct.op* %enter.1.in, i64 0, i32 6
  %417 = load i8* %416, align 1, !tbaa !1
  %cmp1144 = icmp eq i8 %417, 7
  br i1 %cmp1144, label %if.then1146, label %if.end1152

if.then1146:                                      ; preds = %land.lhs.true1141
  store i8 22, i8* %op_flags1137, align 1, !tbaa !1
  %418 = load i8* %416, align 1, !tbaa !1
  %or1150 = or i8 %418, 64
  store i8 %or1150, i8* %416, align 1, !tbaa !1
  br label %if.end1152

if.end1152:                                       ; preds = %if.end1124, %if.then1146, %land.lhs.true1141, %land.lhs.true1136, %land.lhs.true1132, %land.lhs.true1127
  %op_next1153 = getelementptr inbounds %struct.op* %407, i64 0, i32 0
  %419 = load %struct.op** %op_next1153, align 8, !tbaa !3
  %op_next1154 = getelementptr inbounds %struct.op* %403, i64 0, i32 0
  store %struct.op* %419, %struct.op** %op_next1154, align 8, !tbaa !3
  %op_flags1155 = getelementptr inbounds %struct.op* %407, i64 0, i32 6
  %420 = load i8* %op_flags1155, align 1, !tbaa !1
  %op_flags1156 = getelementptr inbounds %struct.op* %403, i64 0, i32 6
  store i8 %420, i8* %op_flags1156, align 1, !tbaa !1
  %tobool1157 = icmp eq %struct.op* %gvop.0, null
  %enter.1.in.gvop.0 = select i1 %tobool1157, %struct.op* %enter.1.in, %struct.op* %gvop.0
  store %struct.op* %enter.1.in.gvop.0, %struct.op** %op_next1120, align 8, !tbaa !3
  call void @Perl_op_null(%struct.op* %407) #8
  call void @Perl_op_null(%struct.op* %1) #8
  %421 = getelementptr inbounds %struct.op* %enter.1.in, i64 0, i32 7
  %422 = load i8* %421, align 1, !tbaa !1
  %or1165 = or i8 %422, 4
  store i8 %or1165, i8* %421, align 1, !tbaa !1
  %op_private1167 = getelementptr inbounds %struct.op* %389, i64 0, i32 7
  %423 = load i8* %op_private1167, align 1, !tbaa !1
  %or1169 = or i8 %423, 4
  store i8 %or1169, i8* %op_private1167, align 1, !tbaa !1
  br label %for.inc1173

sw.default:                                       ; preds = %if.end12
  %inc1171 = add i16 %4, 1
  store i16 %inc1171, i16* @PL_op_seqmax, align 2, !tbaa !4
  store i16 %4, i16* %op_seq3, align 2, !tbaa !4
  br label %for.inc1173

for.inc1173.critedge:                             ; preds = %if.end672
  store i16 125, i16* %252, align 2, !tbaa !4
  %424 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 125), align 8, !tbaa !3
  %425 = getelementptr inbounds %struct.op* %251, i64 0, i32 2
  store %struct.op* ()* %424, %struct.op* ()** %425, align 8, !tbaa !3
  store i16 128, i16* %op_type, align 2, !tbaa !4
  %426 = load %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*]* @PL_ppaddr, i64 0, i64 128), align 8, !tbaa !3
  %op_ppaddr693.c = getelementptr inbounds %struct.op* %1, i64 0, i32 2
  store %struct.op* ()* %426, %struct.op* ()** %op_ppaddr693.c, align 8, !tbaa !3
  br label %for.inc1173

for.inc1173:                                      ; preds = %for.inc1173.critedge, %if.end689, %if.end769, %for.body679, %lor.lhs.false851, %lor.lhs.false847, %lor.lhs.false837, %if.end835, %if.end822, %lor.lhs.false780, %sw.bb777, %lor.lhs.false666, %if.end661, %if.end652, %lor.lhs.false645, %if.end639, %lor.lhs.false631, %sw.bb615, %lor.lhs.false530, %if.end526, %if.end517, %lor.lhs.false510, %if.end505, %if.end499, %sw.bb455, %land.lhs.true411, %lor.lhs.false407, %if.end76, %if.end875, %sw.bb, %if.end19, %ignore_optimization, %if.then59, %if.end93, %if.end205, %if.end319, %while.end, %while.end367, %while.end383, %if.end610, %if.end1006, %if.end1152, %sw.default, %if.then448, %land.lhs.true418, %lor.lhs.false897, %sw.bb1011, %if.end1047, %if.end1053, %lor.lhs.false1056, %if.end1062, %lor.lhs.false1065, %lor.lhs.false1070, %if.end1075, %lor.lhs.false1078, %lor.lhs.false1083, %if.end1088, %if.end1093, %lor.lhs.false1096, %if.end1102, %if.end1107, %lor.lhs.false1110, %if.end1116, %lor.lhs.false1119, %if.then1032, %if.then1041, %if.then1022, %if.end857, %lor.lhs.false860, %if.end866, %lor.lhs.false869, %if.end885, %if.end903, %lor.lhs.false906, %if.end912, %lor.lhs.false915, %lor.lhs.false920, %if.end927, %lor.lhs.false930, %if.end936, %lor.lhs.false939, %if.end945, %if.else978, %lor.lhs.false983, %if.then955, %lor.lhs.false960, %lor.lhs.false963, %lor.lhs.false969, %land.lhs.true415, %if.then424, %land.lhs.true78, %land.lhs.true427, %land.lhs.true427, %land.lhs.true427, %lor.lhs.false887, %if.then90, %if.then81
  %oldop.1 = phi %struct.op* [ %oldop.01525, %if.then90 ], [ %oldop.01525, %if.then81 ], [ %1, %lor.lhs.false887 ], [ %1, %land.lhs.true427 ], [ %1, %land.lhs.true427 ], [ %1, %land.lhs.true427 ], [ %1, %land.lhs.true78 ], [ %1, %if.then424 ], [ %1, %land.lhs.true415 ], [ %1, %lor.lhs.false969 ], [ %1, %lor.lhs.false963 ], [ %1, %lor.lhs.false960 ], [ %1, %if.then955 ], [ %1, %lor.lhs.false983 ], [ %1, %if.else978 ], [ %1, %if.end945 ], [ %1, %lor.lhs.false939 ], [ %1, %if.end936 ], [ %1, %lor.lhs.false930 ], [ %1, %if.end927 ], [ %1, %lor.lhs.false920 ], [ %1, %lor.lhs.false915 ], [ %1, %if.end912 ], [ %1, %lor.lhs.false906 ], [ %1, %if.end903 ], [ %1, %if.end885 ], [ %1, %lor.lhs.false869 ], [ %1, %if.end866 ], [ %1, %lor.lhs.false860 ], [ %1, %if.end857 ], [ %1, %if.then1022 ], [ %1, %if.then1041 ], [ %1, %if.then1032 ], [ %1, %lor.lhs.false1119 ], [ %1, %if.end1116 ], [ %1, %lor.lhs.false1110 ], [ %1, %if.end1107 ], [ %1, %if.end1102 ], [ %1, %lor.lhs.false1096 ], [ %1, %if.end1093 ], [ %1, %if.end1088 ], [ %1, %lor.lhs.false1083 ], [ %1, %lor.lhs.false1078 ], [ %1, %if.end1075 ], [ %1, %lor.lhs.false1070 ], [ %1, %lor.lhs.false1065 ], [ %1, %if.end1062 ], [ %1, %lor.lhs.false1056 ], [ %1, %if.end1053 ], [ %1, %if.end1047 ], [ %1, %sw.bb1011 ], [ %1, %lor.lhs.false897 ], [ %1, %land.lhs.true418 ], [ %1, %if.then448 ], [ %1, %sw.default ], [ %1, %if.end1152 ], [ %1, %if.end1006 ], [ %1, %if.end610 ], [ %1, %while.end383 ], [ %1, %while.end367 ], [ %1, %while.end ], [ %1, %if.end319 ], [ %1, %if.end205 ], [ %1, %if.end93 ], [ %1, %if.then59 ], [ %1, %ignore_optimization ], [ %1, %if.end19 ], [ %1, %sw.bb ], [ %1, %if.end875 ], [ %1, %if.end76 ], [ %1, %lor.lhs.false407 ], [ %1, %land.lhs.true411 ], [ %1, %sw.bb455 ], [ %1, %if.end499 ], [ %1, %if.end505 ], [ %1, %lor.lhs.false510 ], [ %1, %if.end517 ], [ %1, %if.end526 ], [ %1, %lor.lhs.false530 ], [ %1, %sw.bb615 ], [ %1, %lor.lhs.false631 ], [ %1, %if.end639 ], [ %1, %lor.lhs.false645 ], [ %1, %if.end652 ], [ %1, %if.end661 ], [ %1, %lor.lhs.false666 ], [ %1, %sw.bb777 ], [ %1, %lor.lhs.false780 ], [ %1, %if.end822 ], [ %1, %if.end835 ], [ %1, %lor.lhs.false837 ], [ %1, %lor.lhs.false847 ], [ %1, %lor.lhs.false851 ], [ %1, %for.body679 ], [ %1, %if.end769 ], [ %1, %if.end689 ], [ %1, %for.inc1173.critedge ]
  %op_next1174 = getelementptr inbounds %struct.op* %1, i64 0, i32 0
  %427 = load %struct.op** %op_next1174, align 8, !tbaa !3
  %tobool2 = icmp eq %struct.op* %427, null
  br i1 %tobool2, label %for.end1175, label %for.body

for.end1175:                                      ; preds = %for.inc1173, %for.body
  call void @Perl_pop_scope() #7
  br label %return

return:                                           ; preds = %lor.lhs.false, %entry, %for.end1175
  ret void
}

; Function Attrs: optsize
declare void @Perl_save_op() #2

; Function Attrs: optsize
declare void @Perl_save_vptr(i8*) #2

; Function Attrs: optsize
declare %struct.gv* @Perl_gv_AVadd(%struct.gv*) #2

; Function Attrs: nounwind optsize uwtable
define i8* @Perl_custom_op_name(%struct.op* nocapture %o) #0 {
entry:
  %0 = load %struct.hv** @PL_custom_op_names, align 8, !tbaa !3
  %tobool = icmp eq %struct.hv* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_name, i64 0, i64 351), align 8, !tbaa !3
  br label %return

if.end:                                           ; preds = %entry
  %op_ppaddr = getelementptr inbounds %struct.op* %o, i64 0, i32 2
  %2 = load %struct.op* ()** %op_ppaddr, align 8, !tbaa !3
  %3 = ptrtoint %struct.op* ()* %2 to i64
  %call = tail call %struct.sv* @Perl_newSViv(i64 %3) #7
  %call1 = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call) #7
  %4 = load %struct.hv** @PL_custom_op_names, align 8, !tbaa !3
  %call2 = tail call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %4, %struct.sv* %call1, i32 0, i32 0) #7
  %tobool3 = icmp eq %struct.he* %call2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %5 = load i8** getelementptr inbounds ([0 x i8*]* @PL_op_name, i64 0, i64 351), align 8, !tbaa !3
  br label %return

if.end5:                                          ; preds = %if.end
  %hent_val = getelementptr inbounds %struct.he* %call2, i64 0, i32 2
  %6 = load %struct.sv** %hent_val, align 8, !tbaa !3
  %sv_flags = getelementptr inbounds %struct.sv* %6, i64 0, i32 2
  %7 = load i32* %sv_flags, align 4, !tbaa !0
  %and = and i32 %7, 262144
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end5
  %sv_any = getelementptr inbounds %struct.sv* %6, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !3
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !3
  br label %return

cond.false:                                       ; preds = %if.end5
  %call8 = tail call i8* @Perl_sv_2pv_nolen(%struct.sv* %6) #7
  br label %return

return:                                           ; preds = %cond.true, %cond.false, %if.then4, %if.then
  %retval.0 = phi i8* [ %5, %if.then4 ], [ %1, %if.then ], [ %9, %cond.true ], [ %call8, %cond.false ]
  ret i8* %retval.0
}

; Function Attrs: optsize
declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i32, i32) #2

; Function Attrs: optsize
declare void @Perl_save_int(i32*) #2

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.op* @S_dup_attrlist(%struct.op* nocapture %o) #0 {
entry:
  %op_type = getelementptr inbounds %struct.op* %o, i64 0, i32 4
  %0 = load i16* %op_type, align 2, !tbaa !4
  %cmp = icmp eq i16 %0, 5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %op_flags = getelementptr inbounds %struct.op* %o, i64 0, i32 6
  %1 = load i8* %op_flags, align 1, !tbaa !1
  %conv2 = zext i8 %1 to i32
  %op_sv = getelementptr inbounds %struct.op* %o, i64 1
  %2 = bitcast %struct.op* %op_sv to %struct.sv**
  %3 = load %struct.sv** %2, align 8, !tbaa !3
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool = icmp eq %struct.sv* %3, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then
  %sv_refcnt = getelementptr inbounds %struct.sv* %3, i64 0, i32 1
  %4 = load i32* %sv_refcnt, align 4, !tbaa !0
  %inc = add i32 %4, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !0
  br label %land.end

land.end:                                         ; preds = %if.then, %land.rhs
  %call = tail call %struct.op* @Perl_newSVOP(i32 5, i32 %conv2, %struct.sv* %3) #8
  br label %if.end22

if.else:                                          ; preds = %entry
  %5 = getelementptr inbounds %struct.op* %o, i64 1, i32 0
  %o.addr.031 = load %struct.op** %5, align 8
  %tobool432 = icmp eq %struct.op* %o.addr.031, null
  br i1 %tobool432, label %if.end22, label %for.body

for.body:                                         ; preds = %if.else, %for.inc
  %o.addr.034 = phi %struct.op* [ %o.addr.0, %for.inc ], [ %o.addr.031, %if.else ]
  %rop.033 = phi %struct.op* [ %rop.1, %for.inc ], [ null, %if.else ]
  %op_type5 = getelementptr inbounds %struct.op* %o.addr.034, i64 0, i32 4
  %6 = load i16* %op_type5, align 2, !tbaa !4
  %cmp7 = icmp eq i16 %6, 5
  br i1 %cmp7, label %if.then9, label %for.inc

if.then9:                                         ; preds = %for.body
  %op_flags10 = getelementptr inbounds %struct.op* %o.addr.034, i64 0, i32 6
  %7 = load i8* %op_flags10, align 1, !tbaa !1
  %conv11 = zext i8 %7 to i32
  %op_sv12 = getelementptr inbounds %struct.op* %o.addr.034, i64 1
  %8 = bitcast %struct.op* %op_sv12 to %struct.sv**
  %9 = load %struct.sv** %8, align 8, !tbaa !3
  store %struct.sv* %9, %struct.sv** @PL_Sv, align 8, !tbaa !3
  %tobool13 = icmp eq %struct.sv* %9, null
  br i1 %tobool13, label %land.end18, label %land.rhs14

land.rhs14:                                       ; preds = %if.then9
  %sv_refcnt15 = getelementptr inbounds %struct.sv* %9, i64 0, i32 1
  %10 = load i32* %sv_refcnt15, align 4, !tbaa !0
  %inc16 = add i32 %10, 1
  store i32 %inc16, i32* %sv_refcnt15, align 4, !tbaa !0
  br label %land.end18

land.end18:                                       ; preds = %if.then9, %land.rhs14
  %call20 = tail call %struct.op* @Perl_newSVOP(i32 5, i32 %conv11, %struct.sv* %9) #8
  %call21 = tail call %struct.op* @Perl_append_elem(i32 141, %struct.op* %rop.033, %struct.op* %call20) #8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %land.end18
  %rop.1 = phi %struct.op* [ %call21, %land.end18 ], [ %rop.033, %for.body ]
  %op_sibling = getelementptr inbounds %struct.op* %o.addr.034, i64 0, i32 1
  %o.addr.0 = load %struct.op** %op_sibling, align 8
  %tobool4 = icmp eq %struct.op* %o.addr.0, null
  br i1 %tobool4, label %if.end22, label %for.body

if.end22:                                         ; preds = %if.else, %for.inc, %land.end
  %rop.2 = phi %struct.op* [ %call, %land.end ], [ null, %if.else ], [ %rop.1, %for.inc ]
  ret %struct.op* %rop.2
}

; Function Attrs: optsize
declare void @Perl_qerror(%struct.sv*) #2

; Function Attrs: optsize
declare %struct.sv* @Perl_mess(i8*, ...) #2

; Function Attrs: nounwind readonly
declare i8* @memchr(i8*, i32, i64) #6

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #4

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #4

attributes #0 = { nounwind optsize uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind optsize readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { optsize "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind optsize readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }
attributes #5 = { nounwind optsize readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readonly }
attributes #7 = { nounwind optsize }
attributes #8 = { optsize }

!0 = metadata !{metadata !"int", metadata !1}
!1 = metadata !{metadata !"omnipotent char", metadata !2}
!2 = metadata !{metadata !"Simple C/C++ TBAA"}
!3 = metadata !{metadata !"any pointer", metadata !1}
!4 = metadata !{metadata !"short", metadata !1}
!5 = metadata !{metadata !"long", metadata !1}
!6 = metadata !{metadata !"double", metadata !1}
