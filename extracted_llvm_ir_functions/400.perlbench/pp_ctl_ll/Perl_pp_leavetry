define %struct.op* @Perl_pp_leavetry() #0 {
entry:
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.stackinfo** @PL_curstackinfo, align 8, !tbaa !0
  %si_cxix = getelementptr inbounds %struct.stackinfo* %1, i64 0, i32 2
  %2 = load i32* %si_cxix, align 4, !tbaa !3
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %si_cxix, align 4, !tbaa !3
  %idxprom = sext i32 %2 to i64
  %si_cxstack = getelementptr inbounds %struct.stackinfo* %1, i64 0, i32 1
  %3 = load %struct.context** %si_cxstack, align 8, !tbaa !0
  %4 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %blku_oldsp = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 0
  %5 = load i32* %blku_oldsp, align 4, !tbaa !3
  %idx.ext = sext i32 %5 to i64
  %add.ptr = getelementptr inbounds %struct.sv** %4, i64 %idx.ext
  %blku_oldcop = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 1
  %6 = load %struct.cop** %blku_oldcop, align 8, !tbaa !0
  store volatile %struct.cop* %6, %struct.cop** @PL_curcop, align 8, !tbaa !0
  %7 = load i32** @PL_markstack, align 8, !tbaa !0
  %blku_oldmarksp = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 3
  %8 = load i32* %blku_oldmarksp, align 4, !tbaa !3
  %idx.ext5 = sext i32 %8 to i64
  %add.ptr6 = getelementptr inbounds i32* %7, i64 %idx.ext5
  store i32* %add.ptr6, i32** @PL_markstack_ptr, align 8, !tbaa !0
  %blku_oldscopesp = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 4
  %9 = load i32* %blku_oldscopesp, align 4, !tbaa !3
  store i32 %9, i32* @PL_scopestack_ix, align 4, !tbaa !3
  %blku_oldretsp = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 2
  %10 = load i32* %blku_oldretsp, align 4, !tbaa !3
  store i32 %10, i32* @PL_retstack_ix, align 4, !tbaa !3
  %blku_oldpm = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 5
  %11 = load %struct.pmop** %blku_oldpm, align 8, !tbaa !0
  %blku_gimme = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 6
  %12 = load i8* %blku_gimme, align 1, !tbaa !1
  %blk_u = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 7
  %old_in_eval = bitcast %union.anon.1* %blk_u to i32*
  %13 = load i32* %old_in_eval, align 4, !tbaa !3
  store volatile i32 %13, i32* @PL_in_eval, align 4, !tbaa !3
  %14 = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 7, i32 0, i32 2
  %15 = load %struct.op** %14, align 8, !tbaa !0
  store %struct.op* %15, %struct.op** @PL_eval_root, align 8, !tbaa !0
  %old_namesv = getelementptr inbounds %struct.context* %3, i64 %idxprom, i32 1, i32 0, i32 7, i32 0, i32 1
  %16 = bitcast i32* %old_namesv to %struct.sv**
  %17 = load %struct.sv** %16, align 8, !tbaa !0
  %tobool = icmp eq %struct.sv* %17, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call %struct.sv* @Perl_sv_2mortal(%struct.sv* %17) #7
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %call34 = tail call %struct.op* @Perl_pop_return() #7
  store i8 0, i8* @PL_tainted, align 1, !tbaa !1
  %cmp = icmp eq i8 %12, -128
  br i1 %cmp, label %if.end74, label %if.else

if.else:                                          ; preds = %if.end
  %cmp37 = icmp eq i8 %12, 0
  %add.ptr.sum = add i64 %idx.ext, 1
  %add.ptr40 = getelementptr inbounds %struct.sv** %4, i64 %add.ptr.sum
  %cmp41 = icmp ugt %struct.sv** %add.ptr40, %0
  br i1 %cmp37, label %if.then39, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else
  br i1 %cmp41, label %if.end74, label %for.body

if.then39:                                        ; preds = %if.else
  br i1 %cmp41, label %if.else49, label %if.then43

if.then43:                                        ; preds = %if.then39
  %18 = load %struct.sv** %0, align 8, !tbaa !0
  %sv_flags = getelementptr inbounds %struct.sv* %18, i64 0, i32 2
  %19 = load i32* %sv_flags, align 4, !tbaa !3
  %and = and i32 %19, 2560
  %tobool44 = icmp eq i32 %and, 0
  br i1 %tobool44, label %if.else46, label %if.then45

if.then45:                                        ; preds = %if.then43
  store %struct.sv* %18, %struct.sv** %add.ptr40, align 8, !tbaa !0
  br label %if.end74

if.else46:                                        ; preds = %if.then43
  %call47 = tail call %struct.sv* @Perl_sv_mortalcopy(%struct.sv* %18) #7
  store %struct.sv* %call47, %struct.sv** %add.ptr40, align 8, !tbaa !0
  br label %if.end74

if.else49:                                        ; preds = %if.then39
  %20 = load %struct.sv*** @PL_stack_max, align 8, !tbaa !0
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %20 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %add.ptr40 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp50 = icmp slt i64 %sub.ptr.sub, 0
  br i1 %cmp50, label %if.then52, label %if.end61

if.then52:                                        ; preds = %if.else49
  %21 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %sub.ptr.rhs.cast54 = ptrtoint %struct.sv** %21 to i64
  %sub.ptr.sub55 = sub i64 %sub.ptr.rhs.cast, %sub.ptr.rhs.cast54
  %call58 = tail call %struct.sv** @Perl_stack_grow(%struct.sv** %0, %struct.sv** %add.ptr40, i32 0) #7
  %22 = load %struct.sv*** @PL_stack_base, align 8, !tbaa !0
  %23 = shl i64 %sub.ptr.sub55, 29
  %idx.ext59 = ashr i64 %23, 32
  %add.ptr60 = getelementptr inbounds %struct.sv** %22, i64 %idx.ext59
  br label %if.end61

if.end61:                                         ; preds = %if.then52, %if.else49
  %mark.0 = phi %struct.sv** [ %add.ptr60, %if.then52 ], [ %add.ptr40, %if.else49 ]
  store %struct.sv* @PL_sv_undef, %struct.sv** %mark.0, align 8, !tbaa !0
  br label %if.end74

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %mark.2107 = phi %struct.sv** [ %incdec.ptr, %for.inc ], [ %add.ptr40, %for.cond.preheader ]
  %24 = load %struct.sv** %mark.2107, align 8, !tbaa !0
  %sv_flags67 = getelementptr inbounds %struct.sv* %24, i64 0, i32 2
  %25 = load i32* %sv_flags67, align 4, !tbaa !3
  %and68 = and i32 %25, 2560
  %tobool69 = icmp eq i32 %and68, 0
  br i1 %tobool69, label %if.then70, label %for.inc

if.then70:                                        ; preds = %for.body
  %call71 = tail call %struct.sv* @Perl_sv_mortalcopy(%struct.sv* %24) #7
  store %struct.sv* %call71, %struct.sv** %mark.2107, align 8, !tbaa !0
  store i8 0, i8* @PL_tainted, align 1, !tbaa !1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then70
  %incdec.ptr = getelementptr inbounds %struct.sv** %mark.2107, i64 1
  %cmp65 = icmp ugt %struct.sv** %incdec.ptr, %0
  br i1 %cmp65, label %if.end74, label %for.body

if.end74:                                         ; preds = %for.cond.preheader, %for.inc, %if.end61, %if.else46, %if.then45, %if.end
  %sp.0 = phi %struct.sv** [ %add.ptr, %if.end ], [ %add.ptr40, %if.then45 ], [ %add.ptr40, %if.else46 ], [ %mark.0, %if.end61 ], [ %0, %for.inc ], [ %0, %for.cond.preheader ]
  store %struct.pmop* %11, %struct.pmop** @PL_curpm, align 8, !tbaa !0
  tail call void @Perl_pop_scope() #7
  %26 = load %struct.gv** @PL_errgv, align 8, !tbaa !0
  %sv_any = getelementptr inbounds %struct.gv* %26, i64 0, i32 0
  %27 = load %struct.xpvgv** %sv_any, align 8, !tbaa !0
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %27, i64 0, i32 7
  %28 = load %struct.gp** %xgv_gp, align 8, !tbaa !0
  %gp_sv = getelementptr inbounds %struct.gp* %28, i64 0, i32 0
  %29 = load %struct.sv** %gp_sv, align 8, !tbaa !0
  tail call void @Perl_sv_setpv(%struct.sv* %29, i8* getelementptr inbounds ([1 x i8]* @.str11, i64 0, i64 0)) #7
  store %struct.sv** %sp.0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  ret %struct.op* %call34
}
