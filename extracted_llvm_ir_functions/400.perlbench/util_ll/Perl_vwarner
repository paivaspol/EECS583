define void @Perl_vwarner(i32 %err, i8* %pat, [1 x %struct.__va_list_tag]* %args) #0 {
entry:
  %msglen = alloca i64, align 8
  %0 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings = getelementptr inbounds %struct.cop* %0, i64 0, i32 14
  %1 = load %struct.sv** %cop_warnings, align 8, !tbaa !2
  %cmp = icmp eq %struct.sv* %1, null
  br i1 %cmp, label %if.else, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings1 = getelementptr inbounds %struct.cop* %2, i64 0, i32 14
  %3 = load %struct.sv** %cop_warnings1, align 8, !tbaa !2
  %cmp2 = icmp eq %struct.sv* %3, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp2, label %if.else, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %4 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings4 = getelementptr inbounds %struct.cop* %4, i64 0, i32 14
  %5 = load %struct.sv** %cop_warnings4, align 8, !tbaa !2
  %cmp5 = icmp eq %struct.sv* %5, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp5, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false3
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings6 = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings6, align 8, !tbaa !2
  %sv_any = getelementptr inbounds %struct.sv* %7, i64 0, i32 0
  %8 = load i8** %sv_any, align 8, !tbaa !2
  %xpv_pv = bitcast i8* %8 to i8**
  %9 = load i8** %xpv_pv, align 8, !tbaa !2
  %10 = load i8* %9, align 1, !tbaa !0
  %and = and i8 %10, 2
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false7, label %if.then

lor.lhs.false7:                                   ; preds = %land.lhs.true
  %and8 = shl i32 %err, 1
  %11 = lshr i32 %err, 2
  %div = and i32 %11, 63
  %idxprom = zext i32 %div to i64
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings9 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings9, align 8, !tbaa !2
  %sv_any10 = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %14 = load i8** %sv_any10, align 8, !tbaa !2
  %xpv_pv11 = bitcast i8* %14 to i8**
  %15 = load i8** %xpv_pv11, align 8, !tbaa !2
  %arrayidx12 = getelementptr inbounds i8* %15, i64 %idxprom
  %16 = load i8* %arrayidx12, align 1, !tbaa !0
  %conv13 = sext i8 %16 to i32
  %add117 = and i32 %and8, 6
  %rem = or i32 %add117, 1
  %shl = shl i32 1, %rem
  %and17 = and i32 %conv13, %shl
  %tobool18 = icmp eq i32 %and17, 0
  br i1 %tobool18, label %lor.lhs.false19, label %if.then

lor.lhs.false19:                                  ; preds = %lor.lhs.false7
  %17 = lshr i32 %err, 7
  %mul21 = lshr i32 %err, 10
  %div23 = and i32 %mul21, 63
  %idxprom24 = zext i32 %div23 to i64
  %18 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings25 = getelementptr inbounds %struct.cop* %18, i64 0, i32 14
  %19 = load %struct.sv** %cop_warnings25, align 8, !tbaa !2
  %sv_any26 = getelementptr inbounds %struct.sv* %19, i64 0, i32 0
  %20 = load i8** %sv_any26, align 8, !tbaa !2
  %xpv_pv27 = bitcast i8* %20 to i8**
  %21 = load i8** %xpv_pv27, align 8, !tbaa !2
  %arrayidx28 = getelementptr inbounds i8* %21, i64 %idxprom24
  %22 = load i8* %arrayidx28, align 1, !tbaa !0
  %conv29 = sext i8 %22 to i32
  %add22118 = and i32 %17, 6
  %rem34 = or i32 %add22118, 1
  %shl35 = shl i32 1, %rem34
  %and36 = and i32 %conv29, %shl35
  %tobool37 = icmp eq i32 %and36, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then

lor.lhs.false38:                                  ; preds = %lor.lhs.false19
  %23 = lshr i32 %err, 15
  %mul41 = lshr i32 %err, 18
  %div43 = and i32 %mul41, 63
  %idxprom44 = zext i32 %div43 to i64
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings45 = getelementptr inbounds %struct.cop* %24, i64 0, i32 14
  %25 = load %struct.sv** %cop_warnings45, align 8, !tbaa !2
  %sv_any46 = getelementptr inbounds %struct.sv* %25, i64 0, i32 0
  %26 = load i8** %sv_any46, align 8, !tbaa !2
  %xpv_pv47 = bitcast i8* %26 to i8**
  %27 = load i8** %xpv_pv47, align 8, !tbaa !2
  %arrayidx48 = getelementptr inbounds i8* %27, i64 %idxprom44
  %28 = load i8* %arrayidx48, align 1, !tbaa !0
  %conv49 = sext i8 %28 to i32
  %add42119 = and i32 %23, 6
  %rem54 = or i32 %add42119, 1
  %shl55 = shl i32 1, %rem54
  %and56 = and i32 %conv49, %shl55
  %tobool57 = icmp eq i32 %and56, 0
  br i1 %tobool57, label %lor.lhs.false58, label %if.then

lor.lhs.false58:                                  ; preds = %lor.lhs.false38
  %29 = lshr i32 %err, 23
  %div63 = lshr i32 %err, 26
  %idxprom64 = zext i32 %div63 to i64
  %30 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !2
  %cop_warnings65 = getelementptr inbounds %struct.cop* %30, i64 0, i32 14
  %31 = load %struct.sv** %cop_warnings65, align 8, !tbaa !2
  %sv_any66 = getelementptr inbounds %struct.sv* %31, i64 0, i32 0
  %32 = load i8** %sv_any66, align 8, !tbaa !2
  %xpv_pv67 = bitcast i8* %32 to i8**
  %33 = load i8** %xpv_pv67, align 8, !tbaa !2
  %arrayidx68 = getelementptr inbounds i8* %33, i64 %idxprom64
  %34 = load i8* %arrayidx68, align 1, !tbaa !0
  %conv69 = sext i8 %34 to i32
  %add62120 = and i32 %29, 6
  %rem74 = or i32 %add62120, 1
  %shl75 = shl i32 1, %rem74
  %and76 = and i32 %conv69, %shl75
  %tobool77 = icmp eq i32 %and76, 0
  br i1 %tobool77, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false58, %lor.lhs.false38, %lor.lhs.false19, %lor.lhs.false7, %land.lhs.true
  %call = call %struct.sv* @Perl_vmess(i8* %pat, [1 x %struct.__va_list_tag]* %args) #9
  %sv_flags = getelementptr inbounds %struct.sv* %call, i64 0, i32 2
  %35 = load i32* %sv_flags, align 4, !tbaa !3
  %and78 = and i32 %35, 262144
  %cmp79 = icmp eq i32 %and78, 0
  br i1 %cmp79, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %sv_any81 = getelementptr inbounds %struct.sv* %call, i64 0, i32 0
  %36 = load i8** %sv_any81, align 8, !tbaa !2
  %xpv_cur = getelementptr inbounds i8* %36, i64 8
  %37 = bitcast i8* %xpv_cur to i64*
  %38 = load i64* %37, align 8, !tbaa !4
  store i64 %38, i64* %msglen, align 8, !tbaa !4
  %xpv_pv83 = bitcast i8* %36 to i8**
  %39 = load i8** %xpv_pv83, align 8, !tbaa !2
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call84 = call i8* @Perl_sv_2pv_flags(%struct.sv* %call, i64* %msglen, i32 2) #8
  %.pre = load i32* %sv_flags, align 4, !tbaa !3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %40 = phi i32 [ %35, %cond.true ], [ %.pre, %cond.false ]
  %cond = phi i8* [ %39, %cond.true ], [ %call84, %cond.false ]
  %and86 = and i32 %40, 536870912
  %41 = load %struct.sv** @PL_diehook, align 8, !tbaa !2
  %tobool87 = icmp eq %struct.sv* %41, null
  br i1 %tobool87, label %if.end, label %if.then88

if.then88:                                        ; preds = %cond.end
  %42 = load i64* %msglen, align 8, !tbaa !4
  call void @S_vdie_common(i8* %cond, i64 %42, i32 %and86) #9
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then88
  %43 = load volatile i32* @PL_in_eval, align 4, !tbaa !3
  %tobool89 = icmp eq i32 %43, 0
  %44 = load i64* %msglen, align 8, !tbaa !4
  br i1 %tobool89, label %if.end99, label %if.then90

if.then90:                                        ; preds = %if.end
  %call91 = call %struct.op* @Perl_die_where(i8* %cond, i64 %44) #8
  store %struct.op* %call91, %struct.op** @PL_restartop, align 8, !tbaa !2
  %45 = load %struct.gv** @PL_errgv, align 8, !tbaa !2
  %sv_any92 = getelementptr inbounds %struct.gv* %45, i64 0, i32 0
  %46 = load %struct.xpvgv** %sv_any92, align 8, !tbaa !2
  %xgv_gp = getelementptr inbounds %struct.xpvgv* %46, i64 0, i32 7
  %47 = load %struct.gp** %xgv_gp, align 8, !tbaa !2
  %gp_sv = getelementptr inbounds %struct.gp* %47, i64 0, i32 0
  %48 = load %struct.sv** %gp_sv, align 8, !tbaa !2
  %sv_flags93 = getelementptr inbounds %struct.sv* %48, i64 0, i32 2
  %49 = load i32* %sv_flags93, align 4, !tbaa !3
  %or = or i32 %49, %and86
  store i32 %or, i32* %sv_flags93, align 4, !tbaa !3
  %50 = load %struct.jmpenv** @PL_top_env, align 8, !tbaa !2
  %je_prev = getelementptr inbounds %struct.jmpenv* %50, i64 0, i32 1
  %51 = load %struct.jmpenv** %je_prev, align 8, !tbaa !2
  %tobool94 = icmp eq %struct.jmpenv* %51, null
  br i1 %tobool94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %if.then90
  %arraydecay = getelementptr inbounds %struct.jmpenv* %50, i64 0, i32 0, i64 0
  call void @siglongjmp(%struct.__jmp_buf_tag* %arraydecay, i32 3) #10
  unreachable

if.end96:                                         ; preds = %if.then90
  %call97 = call %struct._PerlIO** @Perl_PerlIO_stderr() #8
  %call98 = call i32 (%struct._PerlIO**, i8*, ...)* @PerlIO_printf(%struct._PerlIO** %call97, i8* getelementptr inbounds ([16 x i8]* @.str9, i64 0, i64 0)) #8
  call void @exit(i32 1) #10
  unreachable

if.end99:                                         ; preds = %if.end
  %conv100 = trunc i64 %44 to i32
  call void @Perl_write_to_stderr(i8* %cond, i32 %conv100) #9
  call void @Perl_my_failure_exit() #8
  br label %if.end101

if.else:                                          ; preds = %lor.lhs.false58, %lor.lhs.false3, %lor.lhs.false, %entry
  call void @Perl_vwarn(i8* %pat, [1 x %struct.__va_list_tag]* %args) #9
  br label %if.end101

if.end101:                                        ; preds = %if.else, %if.end99
  ret void
}
