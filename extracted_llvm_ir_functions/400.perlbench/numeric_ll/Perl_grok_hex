define i64 @Perl_grok_hex(i8* %start, i64* nocapture %len_p, i32* nocapture %flags, double* %result) #1 {
entry:
  %0 = load i64* %len_p, align 8, !tbaa !0
  %1 = load i32* %flags, align 4, !tbaa !3
  %conv = and i32 %1, 1
  %and1 = and i32 %1, 2
  %tobool = icmp ne i32 %and1, 0
  %cmp = icmp eq i64 %0, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %for.cond.preheader, label %if.then3

if.then3:                                         ; preds = %entry
  %2 = load i8* %start, align 1, !tbaa !1
  %cmp5 = icmp eq i8 %2, 120
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.then3
  %incdec.ptr = getelementptr inbounds i8* %start, i64 1
  %dec = add i64 %0, -1
  br label %for.cond.preheader

if.else:                                          ; preds = %if.then3
  %cmp8 = icmp ugt i64 %0, 1
  %cmp12 = icmp eq i8 %2, 48
  %or.cond208 = and i1 %cmp8, %cmp12
  br i1 %or.cond208, label %land.lhs.true14, label %for.cond.preheader

land.lhs.true14:                                  ; preds = %if.else
  %arrayidx15 = getelementptr inbounds i8* %start, i64 1
  %3 = load i8* %arrayidx15, align 1, !tbaa !1
  %cmp17 = icmp eq i8 %3, 120
  br i1 %cmp17, label %if.then19, label %for.cond.preheader

if.then19:                                        ; preds = %land.lhs.true14
  %add.ptr = getelementptr inbounds i8* %start, i64 2
  %sub = add i64 %0, -2
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.else, %land.lhs.true14, %if.then19, %if.then7, %entry
  %len.0.ph = phi i64 [ %0, %entry ], [ %dec, %if.then7 ], [ %sub, %if.then19 ], [ %0, %land.lhs.true14 ], [ %0, %if.else ]
  %s.0.ph = phi i8* [ %start, %entry ], [ %incdec.ptr, %if.then7 ], [ %add.ptr, %if.then19 ], [ %start, %land.lhs.true14 ], [ %start, %if.else ]
  %tobool24222 = icmp eq i64 %len.0.ph, 0
  br i1 %tobool24222, label %if.end157.thread, label %land.rhs.lr.ph

if.end157.thread:                                 ; preds = %for.cond.preheader
  %sub.ptr.lhs.cast158262 = ptrtoint i8* %s.0.ph to i64
  %sub.ptr.rhs.cast159263 = ptrtoint i8* %start to i64
  %sub.ptr.sub160264 = sub i64 %sub.ptr.lhs.cast158262, %sub.ptr.rhs.cast159263
  store i64 %sub.ptr.sub160264, i64* %len_p, align 8, !tbaa !0
  br label %if.then162

land.rhs.lr.ph:                                   ; preds = %for.cond.preheader
  %tobool69 = icmp eq i32 %conv, 0
  br label %land.rhs

land.rhs:                                         ; preds = %for.inc, %land.rhs.lr.ph
  %dec23229.in = phi i64 [ %len.0.ph, %land.rhs.lr.ph ], [ %len.1, %for.inc ]
  %overflowed.0228 = phi i8 [ 0, %land.rhs.lr.ph ], [ %overflowed.2, %for.inc ]
  %s.0227 = phi i8* [ %s.0.ph, %land.rhs.lr.ph ], [ %incdec.ptr116, %for.inc ]
  %value_nv.0226 = phi double [ 0.000000e+00, %land.rhs.lr.ph ], [ %value_nv.2, %for.inc ]
  %value.0224 = phi i64 [ 0, %land.rhs.lr.ph ], [ %value.1, %for.inc ]
  %dec23229 = add i64 %dec23229.in, -1
  %4 = load i8* %s.0227, align 1, !tbaa !1
  %tobool26 = icmp eq i8 %4, 0
  br i1 %tobool26, label %for.end, label %for.body

for.body:                                         ; preds = %land.rhs
  %conv25 = sext i8 %4 to i32
  %5 = load i8** @PL_hexdigit, align 8, !tbaa !4
  %call = tail call i8* @strchr(i8* %5, i32 %conv25) #5
  %tobool28 = icmp eq i8* %call, null
  br i1 %tobool28, label %if.end61, label %redo

redo:                                             ; preds = %for.body, %if.then79
  %len.1 = phi i64 [ %dec23229, %for.body ], [ %dec80, %if.then79 ]
  %s.1 = phi i8* [ %s.0227, %for.body ], [ %arrayidx71, %if.then79 ]
  %hexdigit.0 = phi i8* [ %call, %for.body ], [ %call77, %if.then79 ]
  %tobool30 = icmp eq i8 %overflowed.0228, 0
  br i1 %tobool30, label %if.then31, label %if.end55

if.then31:                                        ; preds = %redo
  %cmp32 = icmp ult i64 %value.0224, 1152921504606846976
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.then31
  %shl = shl i64 %value.0224, 4
  %sub.ptr.lhs.cast = ptrtoint i8* %hexdigit.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %and35 = and i64 %sub.ptr.sub, 15
  %or = or i64 %and35, %shl
  br label %for.inc

if.end36:                                         ; preds = %if.then31
  %6 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings = getelementptr inbounds %struct.cop* %6, i64 0, i32 14
  %7 = load %struct.sv** %cop_warnings, align 8, !tbaa !4
  %cmp37 = icmp eq %struct.sv* %7, null
  br i1 %cmp37, label %if.then52, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end36
  %8 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings39 = getelementptr inbounds %struct.cop* %8, i64 0, i32 14
  %9 = load %struct.sv** %cop_warnings39, align 8, !tbaa !4
  %cmp40 = icmp eq %struct.sv* %9, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp40, label %if.then52, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %lor.lhs.false
  %10 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings43 = getelementptr inbounds %struct.cop* %10, i64 0, i32 14
  %11 = load %struct.sv** %cop_warnings43, align 8, !tbaa !4
  %cmp44 = icmp eq %struct.sv* %11, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp44, label %if.end53, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %lor.lhs.false42
  %12 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings47 = getelementptr inbounds %struct.cop* %12, i64 0, i32 14
  %13 = load %struct.sv** %cop_warnings47, align 8, !tbaa !4
  %sv_any = getelementptr inbounds %struct.sv* %13, i64 0, i32 0
  %14 = load i8** %sv_any, align 8, !tbaa !4
  %xpv_pv = bitcast i8* %14 to i8**
  %15 = load i8** %xpv_pv, align 8, !tbaa !4
  %arrayidx48 = getelementptr inbounds i8* %15, i64 3
  %16 = load i8* %arrayidx48, align 1, !tbaa !1
  %and50 = and i8 %16, 64
  %tobool51 = icmp eq i8 %and50, 0
  br i1 %tobool51, label %if.end53, label %if.then52

if.then52:                                        ; preds = %land.lhs.true46, %lor.lhs.false, %if.end36
  tail call void (i32, i8*, ...)* @Perl_warner(i32 15, i8* getelementptr inbounds ([39 x i8]* @.str3, i64 0, i64 0)) #5
  br label %if.end53

if.end53:                                         ; preds = %land.lhs.true46, %lor.lhs.false42, %if.then52
  %conv54 = uitofp i64 %value.0224 to double
  %.pre = load i8** @PL_hexdigit, align 8, !tbaa !4
  br label %if.end55

if.end55:                                         ; preds = %redo, %if.end53
  %17 = phi i8* [ %5, %redo ], [ %.pre, %if.end53 ]
  %value_nv.1 = phi double [ %value_nv.0226, %redo ], [ %conv54, %if.end53 ]
  %overflowed.1 = phi i8 [ %overflowed.0228, %redo ], [ 1, %if.end53 ]
  %mul = fmul double %value_nv.1, 1.600000e+01
  %sub.ptr.lhs.cast56 = ptrtoint i8* %hexdigit.0 to i64
  %sub.ptr.rhs.cast57 = ptrtoint i8* %17 to i64
  %sub.ptr.sub58 = sub i64 %sub.ptr.lhs.cast56, %sub.ptr.rhs.cast57
  %and59 = and i64 %sub.ptr.sub58, 15
  %conv60 = sitofp i64 %and59 to double
  %add = fadd double %mul, %conv60
  br label %for.inc

if.end61:                                         ; preds = %for.body
  %cmp63 = icmp ne i8 %4, 95
  %tobool66 = icmp eq i64 %dec23229, 0
  %or.cond209 = or i1 %cmp63, %tobool66
  %or.cond210 = or i1 %or.cond209, %tobool69
  br i1 %or.cond210, label %if.end82, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %if.end61
  %arrayidx71 = getelementptr inbounds i8* %s.0227, i64 1
  %18 = load i8* %arrayidx71, align 1, !tbaa !1
  %tobool73 = icmp eq i8 %18, 0
  br i1 %tobool73, label %if.end82, label %land.lhs.true74

land.lhs.true74:                                  ; preds = %land.lhs.true70
  %conv72 = sext i8 %18 to i32
  %call77 = tail call i8* @strchr(i8* %5, i32 %conv72) #5
  %tobool78 = icmp eq i8* %call77, null
  br i1 %tobool78, label %if.end82, label %if.then79

if.then79:                                        ; preds = %land.lhs.true74
  %dec80 = add i64 %dec23229.in, -2
  br label %redo

if.end82:                                         ; preds = %land.lhs.true74, %land.lhs.true70, %if.end61
  %19 = load i32* %flags, align 4, !tbaa !3
  %and83 = and i32 %19, 4
  %tobool84 = icmp eq i32 %and83, 0
  br i1 %tobool84, label %land.lhs.true85, label %for.end

land.lhs.true85:                                  ; preds = %if.end82
  %20 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings86 = getelementptr inbounds %struct.cop* %20, i64 0, i32 14
  %21 = load %struct.sv** %cop_warnings86, align 8, !tbaa !4
  %cmp87 = icmp eq %struct.sv* %21, null
  br i1 %cmp87, label %lor.lhs.false105, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %land.lhs.true85
  %22 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings90 = getelementptr inbounds %struct.cop* %22, i64 0, i32 14
  %23 = load %struct.sv** %cop_warnings90, align 8, !tbaa !4
  %cmp91 = icmp eq %struct.sv* %23, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp91, label %lor.lhs.false105, label %land.lhs.true93

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings94 = getelementptr inbounds %struct.cop* %24, i64 0, i32 14
  %25 = load %struct.sv** %cop_warnings94, align 8, !tbaa !4
  %cmp95 = icmp eq %struct.sv* %25, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp95, label %if.then113, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %land.lhs.true93
  %26 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings98 = getelementptr inbounds %struct.cop* %26, i64 0, i32 14
  %27 = load %struct.sv** %cop_warnings98, align 8, !tbaa !4
  %sv_any99 = getelementptr inbounds %struct.sv* %27, i64 0, i32 0
  %28 = load i8** %sv_any99, align 8, !tbaa !4
  %xpv_pv100 = bitcast i8* %28 to i8**
  %29 = load i8** %xpv_pv100, align 8, !tbaa !4
  %arrayidx101 = getelementptr inbounds i8* %29, i64 7
  %30 = load i8* %arrayidx101, align 1, !tbaa !1
  %and103 = and i8 %30, 64
  %tobool104 = icmp eq i8 %and103, 0
  br i1 %tobool104, label %lor.lhs.false105, label %if.then113

lor.lhs.false105:                                 ; preds = %lor.lhs.false97, %land.lhs.true89, %land.lhs.true85
  %31 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings106 = getelementptr inbounds %struct.cop* %31, i64 0, i32 14
  %32 = load %struct.sv** %cop_warnings106, align 8, !tbaa !4
  %cmp107 = icmp eq %struct.sv* %32, null
  br i1 %cmp107, label %land.lhs.true109, label %for.end

land.lhs.true109:                                 ; preds = %lor.lhs.false105
  %33 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and111 = and i8 %33, 1
  %tobool112 = icmp eq i8 %and111, 0
  br i1 %tobool112, label %for.end, label %if.then113

if.then113:                                       ; preds = %lor.lhs.false97, %land.lhs.true109, %land.lhs.true93
  %34 = load i8* %s.0227, align 1, !tbaa !1
  %conv114 = sext i8 %34 to i32
  tail call void (i32, i8*, ...)* @Perl_warner(i32 31, i8* getelementptr inbounds ([39 x i8]* @.str4, i64 0, i64 0), i32 %conv114) #5
  br label %for.end

for.inc:                                          ; preds = %if.end55, %if.then34
  %value.1 = phi i64 [ %value.0224, %if.end55 ], [ %or, %if.then34 ]
  %value_nv.2 = phi double [ %add, %if.end55 ], [ %value_nv.0226, %if.then34 ]
  %overflowed.2 = phi i8 [ %overflowed.1, %if.end55 ], [ 0, %if.then34 ]
  %incdec.ptr116 = getelementptr inbounds i8* %s.1, i64 1
  %tobool24 = icmp eq i64 %len.1, 0
  br i1 %tobool24, label %for.end, label %land.rhs

for.end:                                          ; preds = %land.rhs, %for.inc, %land.lhs.true109, %if.end82, %lor.lhs.false105, %if.then113
  %overflowed.0220 = phi i8 [ %overflowed.0228, %land.lhs.true109 ], [ %overflowed.0228, %if.end82 ], [ %overflowed.0228, %lor.lhs.false105 ], [ %overflowed.0228, %if.then113 ], [ %overflowed.0228, %land.rhs ], [ %overflowed.2, %for.inc ]
  %s.0218 = phi i8* [ %s.0227, %land.lhs.true109 ], [ %s.0227, %if.end82 ], [ %s.0227, %lor.lhs.false105 ], [ %s.0227, %if.then113 ], [ %s.0227, %land.rhs ], [ %incdec.ptr116, %for.inc ]
  %value_nv.0216 = phi double [ %value_nv.0226, %land.lhs.true109 ], [ %value_nv.0226, %if.end82 ], [ %value_nv.0226, %lor.lhs.false105 ], [ %value_nv.0226, %if.then113 ], [ %value_nv.0226, %land.rhs ], [ %value_nv.2, %for.inc ]
  %value.0214 = phi i64 [ %value.0224, %land.lhs.true109 ], [ %value.0224, %if.end82 ], [ %value.0224, %lor.lhs.false105 ], [ %value.0224, %if.then113 ], [ %value.0224, %land.rhs ], [ %value.1, %for.inc ]
  %tobool118 = icmp ne i8 %overflowed.0220, 0
  %cmp120 = fcmp ogt double %value_nv.0216, 0x41EFFFFFFFE00000
  %or.cond211 = and i1 %tobool118, %cmp120
  br i1 %or.cond211, label %if.then127, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %for.end
  %tobool123 = icmp eq i8 %overflowed.0220, 0
  %cmp125 = icmp ugt i64 %value.0214, 4294967295
  %or.cond212 = and i1 %tobool123, %cmp125
  br i1 %or.cond212, label %if.then127, label %if.end157

if.then127:                                       ; preds = %lor.lhs.false122, %for.end
  %35 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings128 = getelementptr inbounds %struct.cop* %35, i64 0, i32 14
  %36 = load %struct.sv** %cop_warnings128, align 8, !tbaa !4
  %cmp129 = icmp eq %struct.sv* %36, null
  br i1 %cmp129, label %lor.lhs.false147, label %land.lhs.true131

land.lhs.true131:                                 ; preds = %if.then127
  %37 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings132 = getelementptr inbounds %struct.cop* %37, i64 0, i32 14
  %38 = load %struct.sv** %cop_warnings132, align 8, !tbaa !4
  %cmp133 = icmp eq %struct.sv* %38, inttoptr (i64 32 to %struct.sv*)
  br i1 %cmp133, label %lor.lhs.false147, label %land.lhs.true135

land.lhs.true135:                                 ; preds = %land.lhs.true131
  %39 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings136 = getelementptr inbounds %struct.cop* %39, i64 0, i32 14
  %40 = load %struct.sv** %cop_warnings136, align 8, !tbaa !4
  %cmp137 = icmp eq %struct.sv* %40, inttoptr (i64 16 to %struct.sv*)
  br i1 %cmp137, label %if.then155, label %lor.lhs.false139

lor.lhs.false139:                                 ; preds = %land.lhs.true135
  %41 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings140 = getelementptr inbounds %struct.cop* %41, i64 0, i32 14
  %42 = load %struct.sv** %cop_warnings140, align 8, !tbaa !4
  %sv_any141 = getelementptr inbounds %struct.sv* %42, i64 0, i32 0
  %43 = load i8** %sv_any141, align 8, !tbaa !4
  %xpv_pv142 = bitcast i8* %43 to i8**
  %44 = load i8** %xpv_pv142, align 8, !tbaa !4
  %arrayidx143 = getelementptr inbounds i8* %44, i64 4
  %45 = load i8* %arrayidx143, align 1, !tbaa !1
  %and145 = and i8 %45, 4
  %tobool146 = icmp eq i8 %and145, 0
  br i1 %tobool146, label %lor.lhs.false147, label %if.then155

lor.lhs.false147:                                 ; preds = %lor.lhs.false139, %land.lhs.true131, %if.then127
  %46 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !4
  %cop_warnings148 = getelementptr inbounds %struct.cop* %46, i64 0, i32 14
  %47 = load %struct.sv** %cop_warnings148, align 8, !tbaa !4
  %cmp149 = icmp eq %struct.sv* %47, null
  br i1 %cmp149, label %land.lhs.true151, label %if.end157

land.lhs.true151:                                 ; preds = %lor.lhs.false147
  %48 = load i8* @PL_dowarn, align 1, !tbaa !1
  %and153 = and i8 %48, 1
  %tobool154 = icmp eq i8 %and153, 0
  br i1 %tobool154, label %if.end157, label %if.then155

if.then155:                                       ; preds = %lor.lhs.false139, %land.lhs.true151, %land.lhs.true135
  tail call void (i32, i8*, ...)* @Perl_warner(i32 17, i8* getelementptr inbounds ([45 x i8]* @.str5, i64 0, i64 0)) #5
  br label %if.end157

if.end157:                                        ; preds = %land.lhs.true151, %lor.lhs.false122, %lor.lhs.false147, %if.then155
  %sub.ptr.lhs.cast158 = ptrtoint i8* %s.0218 to i64
  %sub.ptr.rhs.cast159 = ptrtoint i8* %start to i64
  %sub.ptr.sub160 = sub i64 %sub.ptr.lhs.cast158, %sub.ptr.rhs.cast159
  store i64 %sub.ptr.sub160, i64* %len_p, align 8, !tbaa !0
  %tobool161 = icmp eq i8 %overflowed.0220, 0
  br i1 %tobool161, label %if.then162, label %if.end163

if.then162:                                       ; preds = %if.end157.thread, %if.end157
  %value.0214256266 = phi i64 [ 0, %if.end157.thread ], [ %value.0214, %if.end157 ]
  store i32 0, i32* %flags, align 4, !tbaa !3
  br label %return

if.end163:                                        ; preds = %if.end157
  store i32 2, i32* %flags, align 4, !tbaa !3
  %tobool164 = icmp eq double* %result, null
  br i1 %tobool164, label %return, label %if.then165

if.then165:                                       ; preds = %if.end163
  store double %value_nv.0216, double* %result, align 8, !tbaa !5
  br label %return

return:                                           ; preds = %if.then165, %if.end163, %if.then162
  %retval.0 = phi i64 [ %value.0214256266, %if.then162 ], [ -1, %if.end163 ], [ -1, %if.then165 ]
  ret i64 %retval.0
}
