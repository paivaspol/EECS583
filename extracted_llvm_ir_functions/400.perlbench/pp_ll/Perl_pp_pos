define %struct.op* @Perl_pp_pos() #0 {
entry:
  %i = alloca i32, align 4
  %0 = load %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %1 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_targ = getelementptr inbounds %struct.op* %1, i64 0, i32 3
  %2 = load i64* %op_targ, align 8, !tbaa !3
  %3 = load %struct.sv*** @PL_curpad, align 8, !tbaa !0
  %arrayidx = getelementptr inbounds %struct.sv** %3, i64 %2
  %4 = load %struct.sv** %arrayidx, align 8, !tbaa !0
  %5 = load %struct.sv** %0, align 8, !tbaa !0
  %op_flags = getelementptr inbounds %struct.op* %1, i64 0, i32 6
  %6 = load i8* %op_flags, align 1, !tbaa !1
  %and = and i8 %6, 32
  %tobool = icmp eq i8 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %op_private = getelementptr inbounds %struct.op* %1, i64 0, i32 7
  %7 = load i8* %op_private, align 1, !tbaa !1
  %and2 = and i8 %7, 8
  %tobool3 = icmp eq i8 %and2, 0
  br i1 %tobool3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call = call i32 @Perl_is_lvalue_sub() #7
  %tobool4 = icmp eq i32 %call, 0
  br i1 %tobool4, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  %sv_flags = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %8 = load i32* %sv_flags, align 4, !tbaa !4
  %and5 = and i32 %8, 255
  %cmp = icmp ult i32 %and5, 9
  br i1 %cmp, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %call8 = call signext i8 @Perl_sv_upgrade(%struct.sv* %4, i32 9) #7
  call void @Perl_sv_magic(%struct.sv* %4, %struct.sv* null, i32 46, i8* null, i32 0) #7
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then
  %sv_any = getelementptr inbounds %struct.sv* %4, i64 0, i32 0
  %9 = load i8** %sv_any, align 8, !tbaa !0
  %10 = getelementptr inbounds i8* %9, i64 80
  store i8 46, i8* %10, align 1, !tbaa !1
  %11 = load i8** %sv_any, align 8, !tbaa !0
  %xlv_targ = getelementptr inbounds i8* %11, i64 72
  %12 = bitcast i8* %xlv_targ to %struct.sv**
  %13 = load %struct.sv** %12, align 8, !tbaa !0
  %cmp10 = icmp eq %struct.sv* %13, %5
  br i1 %cmp10, label %if.end24, label %if.then12

if.then12:                                        ; preds = %if.end
  %tobool15 = icmp eq %struct.sv* %13, null
  br i1 %tobool15, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.then12
  call void @Perl_sv_free(%struct.sv* %13) #7
  br label %if.end19

if.end19:                                         ; preds = %if.then12, %if.then16
  store %struct.sv* %5, %struct.sv** @PL_Sv, align 8, !tbaa !0
  %tobool20 = icmp eq %struct.sv* %5, null
  br i1 %tobool20, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end19
  %sv_refcnt = getelementptr inbounds %struct.sv* %5, i64 0, i32 1
  %14 = load i32* %sv_refcnt, align 4, !tbaa !4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %sv_refcnt, align 4, !tbaa !4
  br label %land.end

land.end:                                         ; preds = %if.end19, %land.rhs
  %15 = load i8** %sv_any, align 8, !tbaa !0
  %xlv_targ23 = getelementptr inbounds i8* %15, i64 72
  %16 = bitcast i8* %xlv_targ23 to %struct.sv**
  store %struct.sv* %5, %struct.sv** %16, align 8, !tbaa !0
  br label %if.end24

if.end24:                                         ; preds = %if.end, %land.end
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %17 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next = getelementptr inbounds %struct.op* %17, i64 0, i32 0
  br label %return

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %sv_flags26 = getelementptr inbounds %struct.sv* %5, i64 0, i32 2
  %18 = load i32* %sv_flags26, align 4, !tbaa !4
  %and27 = and i32 %18, 255
  %cmp28 = icmp ugt i32 %and27, 6
  br i1 %cmp28, label %land.lhs.true30, label %if.end61

land.lhs.true30:                                  ; preds = %if.else
  %sv_any31 = getelementptr inbounds %struct.sv* %5, i64 0, i32 0
  %19 = load i8** %sv_any31, align 8, !tbaa !0
  %xmg_magic = getelementptr inbounds i8* %19, i64 40
  %20 = bitcast i8* %xmg_magic to %struct.magic**
  %21 = load %struct.magic** %20, align 8, !tbaa !0
  %tobool32 = icmp eq %struct.magic* %21, null
  br i1 %tobool32, label %if.end61, label %if.then33

if.then33:                                        ; preds = %land.lhs.true30
  %call34 = call %struct.magic* @Perl_mg_find(%struct.sv* %5, i32 103) #7
  %tobool35 = icmp eq %struct.magic* %call34, null
  br i1 %tobool35, label %if.end61, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %if.then33
  %mg_len = getelementptr inbounds %struct.magic* %call34, i64 0, i32 7
  %22 = load i32* %mg_len, align 4, !tbaa !4
  %cmp37 = icmp sgt i32 %22, -1
  br i1 %cmp37, label %if.then39, label %if.end61

if.then39:                                        ; preds = %land.lhs.true36
  store i32 %22, i32* %i, align 4, !tbaa !4
  %23 = load i32* %sv_flags26, align 4, !tbaa !4
  %and42 = and i32 %23, 536870912
  %tobool43 = icmp eq i32 %and42, 0
  br i1 %tobool43, label %if.end50, label %land.lhs.true44

land.lhs.true44:                                  ; preds = %if.then39
  %24 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %op_private45 = getelementptr inbounds %struct.cop* %24, i64 0, i32 7
  %25 = load i8* %op_private45, align 1, !tbaa !1
  %and47 = and i8 %25, 8
  %tobool48 = icmp eq i8 %and47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true44
  call void @Perl_sv_pos_b2u(%struct.sv* %5, i32* %i) #7
  br label %if.end50

if.end50:                                         ; preds = %land.lhs.true44, %if.then39, %if.then49
  %26 = load i32* %i, align 4, !tbaa !4
  %27 = load volatile %struct.cop** @PL_curcop, align 8, !tbaa !0
  %cop_arybase = getelementptr inbounds %struct.cop* %27, i64 0, i32 12
  %28 = load i32* %cop_arybase, align 4, !tbaa !4
  %add = add nsw i32 %28, %26
  %conv51 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %4, i64 %conv51) #7
  %sv_flags52 = getelementptr inbounds %struct.sv* %4, i64 0, i32 2
  %29 = load i32* %sv_flags52, align 4, !tbaa !4
  %and53 = and i32 %29, 16384
  %tobool54 = icmp eq i32 %and53, 0
  br i1 %tobool54, label %if.end57, label %if.then55

if.then55:                                        ; preds = %if.end50
  %call56 = call i32 @Perl_mg_set(%struct.sv* %4) #7
  br label %if.end57

if.end57:                                         ; preds = %if.end50, %if.then55
  store %struct.sv* %4, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %30 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next59 = getelementptr inbounds %struct.op* %30, i64 0, i32 0
  br label %return

if.end61:                                         ; preds = %if.then33, %land.lhs.true30, %land.lhs.true36, %if.else
  store %struct.sv* @PL_sv_undef, %struct.sv** %0, align 8, !tbaa !0
  store %struct.sv** %0, %struct.sv*** @PL_stack_sp, align 8, !tbaa !0
  %31 = load %struct.op** @PL_op, align 8, !tbaa !0
  %op_next63 = getelementptr inbounds %struct.op* %31, i64 0, i32 0
  br label %return

return:                                           ; preds = %if.end61, %if.end57, %if.end24
  %retval.0.in = phi %struct.op** [ %op_next, %if.end24 ], [ %op_next59, %if.end57 ], [ %op_next63, %if.end61 ]
  %retval.0 = load %struct.op** %retval.0.in, align 8
  ret %struct.op* %retval.0
}
