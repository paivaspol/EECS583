define i32 @IVcompress(i32 %size1, i32* %x1, i32* %y1, i32 %size2, i32* %x2, i32* %y2) #0 {
entry:
  %cmp = icmp slt i32 %size1, 1
  %cmp1 = icmp slt i32 %size2, 1
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %return, label %if.else

if.else:                                          ; preds = %entry
  %cmp2 = icmp eq i32* %x1, null
  %cmp4 = icmp eq i32* %y1, null
  %or.cond133 = or i1 %cmp2, %cmp4
  %cmp6 = icmp eq i32* %x2, null
  %or.cond134 = or i1 %or.cond133, %cmp6
  %cmp8 = icmp eq i32* %y2, null
  %or.cond135 = or i1 %or.cond134, %cmp8
  br i1 %or.cond135, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.else
  %0 = load %struct._IO_FILE** @stderr, align 8, !tbaa !0
  %call = tail call i32 (%struct._IO_FILE*, i8*, ...)* @fprintf(%struct._IO_FILE* %0, i8* getelementptr inbounds ([103 x i8]* @.str, i64 0, i64 0), i32 %size1, i32* %x1, i32* %y1, i32 %size2, i32* %x2, i32* %y2) #6
  tail call void @exit(i32 -1) #7
  unreachable

if.end10:                                         ; preds = %if.else
  %call11 = tail call double* @DVinit(i32 %size1, double 0.000000e+00) #6
  %cmp12141 = icmp sgt i32 %size1, 1
  br i1 %cmp12141, label %for.body, label %for.end

for.body:                                         ; preds = %if.end10, %for.body
  %indvars.iv144 = phi i64 [ %indvars.iv.next145, %for.body ], [ 1, %if.end10 ]
  %arrayidx = getelementptr inbounds i32* %x1, i64 %indvars.iv144
  %1 = load i32* %arrayidx, align 4, !tbaa !3
  %2 = add nsw i64 %indvars.iv144, -1
  %arrayidx14 = getelementptr inbounds i32* %x1, i64 %2
  %3 = load i32* %arrayidx14, align 4, !tbaa !3
  %sub15 = sub nsw i32 %1, %3
  %conv = sitofp i32 %sub15 to double
  %arrayidx17 = getelementptr inbounds i32* %y1, i64 %indvars.iv144
  %4 = load i32* %arrayidx17, align 4, !tbaa !3
  %arrayidx20 = getelementptr inbounds i32* %y1, i64 %2
  %5 = load i32* %arrayidx20, align 4, !tbaa !3
  %sub21 = sub nsw i32 %4, %5
  %conv22 = sitofp i32 %sub21 to double
  %mul = fmul double %conv, %conv
  %mul23 = fmul double %conv22, %conv22
  %add = fadd double %mul, %mul23
  %call24 = tail call double @sqrt(double %add) #6
  %arrayidx27 = getelementptr inbounds double* %call11, i64 %2
  store double %call24, double* %arrayidx27, align 8, !tbaa !4
  %indvars.iv.next145 = add i64 %indvars.iv144, 1
  %lftr.wideiv147 = trunc i64 %indvars.iv.next145 to i32
  %exitcond148 = icmp eq i32 %lftr.wideiv147, %size1
  br i1 %exitcond148, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %if.end10
  %call28 = tail call double @DVsum(i32 %size1, double* %call11) #6
  %sub29 = add nsw i32 %size2, -2
  %conv30 = sitofp i32 %sub29 to double
  %div = fdiv double %call28, %conv30
  %6 = load i32* %x1, align 4, !tbaa !3
  store i32 %6, i32* %x2, align 4, !tbaa !3
  %7 = load i32* %y1, align 4, !tbaa !3
  store i32 %7, i32* %y2, align 4, !tbaa !3
  %sub41 = add i32 %size1, -1
  %cmp42136 = icmp sgt i32 %sub41, 1
  br i1 %cmp42136, label %for.body44, label %for.end64

for.body44:                                       ; preds = %for.end, %for.inc62
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc62 ], [ 1, %for.end ]
  %i.0138 = phi i32 [ %i.1, %for.inc62 ], [ 1, %for.end ]
  %path.0137 = phi double [ %path.1, %for.inc62 ], [ 0.000000e+00, %for.end ]
  %8 = add nsw i64 %indvars.iv, -1
  %arrayidx47 = getelementptr inbounds double* %call11, i64 %8
  %9 = load double* %arrayidx47, align 8, !tbaa !4
  %add48 = fadd double %path.0137, %9
  %cmp49 = fcmp ult double %add48, %div
  br i1 %cmp49, label %for.inc62, label %if.then51

if.then51:                                        ; preds = %for.body44
  %arrayidx53 = getelementptr inbounds i32* %x1, i64 %indvars.iv
  %10 = load i32* %arrayidx53, align 4, !tbaa !3
  %idxprom54 = sext i32 %i.0138 to i64
  %arrayidx55 = getelementptr inbounds i32* %x2, i64 %idxprom54
  store i32 %10, i32* %arrayidx55, align 4, !tbaa !3
  %arrayidx57 = getelementptr inbounds i32* %y1, i64 %indvars.iv
  %11 = load i32* %arrayidx57, align 4, !tbaa !3
  %arrayidx59 = getelementptr inbounds i32* %y2, i64 %idxprom54
  store i32 %11, i32* %arrayidx59, align 4, !tbaa !3
  %inc60 = add nsw i32 %i.0138, 1
  br label %for.inc62

for.inc62:                                        ; preds = %for.body44, %if.then51
  %path.1 = phi double [ 0.000000e+00, %if.then51 ], [ %add48, %for.body44 ]
  %i.1 = phi i32 [ %inc60, %if.then51 ], [ %i.0138, %for.body44 ]
  %indvars.iv.next = add i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %sub41
  br i1 %exitcond, label %for.end64, label %for.body44

for.end64:                                        ; preds = %for.inc62, %for.end
  %i.0.lcssa = phi i32 [ 1, %for.end ], [ %i.1, %for.inc62 ]
  %idxprom66 = sext i32 %sub41 to i64
  %arrayidx67 = getelementptr inbounds i32* %x1, i64 %idxprom66
  %12 = load i32* %arrayidx67, align 4, !tbaa !3
  %idxprom68 = sext i32 %i.0.lcssa to i64
  %arrayidx69 = getelementptr inbounds i32* %x2, i64 %idxprom68
  store i32 %12, i32* %arrayidx69, align 4, !tbaa !3
  %arrayidx72 = getelementptr inbounds i32* %y1, i64 %idxprom66
  %13 = load i32* %arrayidx72, align 4, !tbaa !3
  %arrayidx74 = getelementptr inbounds i32* %y2, i64 %idxprom68
  store i32 %13, i32* %arrayidx74, align 4, !tbaa !3
  %inc75 = add nsw i32 %i.0.lcssa, 1
  tail call void @DVfree(double* %call11) #6
  br label %return

return:                                           ; preds = %entry, %for.end64
  %retval.0 = phi i32 [ %inc75, %for.end64 ], [ 0, %entry ]
  ret i32 %retval.0
}
