define %struct.arc* @primal_bea_mpp(i64 %m, %struct.arc* %arcs, %struct.arc* readnone %stop_arcs, i64* nocapture %red_cost_of_bea) #1 {
  tail call void @llvm.dbg.value(metadata i64 %m, i64 0, metadata !70, metadata !94), !dbg !159
  tail call void @llvm.dbg.value(metadata %struct.arc* %arcs, i64 0, metadata !71, metadata !94), !dbg !160
  tail call void @llvm.dbg.value(metadata %struct.arc* %stop_arcs, i64 0, metadata !72, metadata !94), !dbg !161
  tail call void @llvm.dbg.value(metadata i64* %red_cost_of_bea, i64 0, metadata !73, metadata !94), !dbg !162
  %.b = load i1* @initialize, align 1
  br i1 %.b, label %.preheader, label %vector.body, !dbg !163

vector.body:                                      ; preds = %0, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 1, %0 ], !dbg !164
  %1 = getelementptr inbounds [351 x %struct.basket]* @basket, i64 0, i64 %index, !dbg !169
  %2 = insertelement <2 x %struct.basket*> undef, %struct.basket* %1, i32 0, !dbg !169
  %3 = add i64 %index, 1, !dbg !169
  %4 = getelementptr inbounds [351 x %struct.basket]* @basket, i64 0, i64 %3, !dbg !169
  %5 = insertelement <2 x %struct.basket*> %2, %struct.basket* %4, i32 1, !dbg !169
  %6 = getelementptr inbounds [351 x %struct.basket*]* @perm, i64 0, i64 %index, !dbg !170
  %7 = bitcast %struct.basket** %6 to <2 x %struct.basket*>*, !dbg !171
  store <2 x %struct.basket*> %5, <2 x %struct.basket*>* %7, align 8, !dbg !171, !tbaa !121
  %index.next = add i64 %index, 2, !dbg !164
  %8 = icmp eq i64 %index.next, 351, !dbg !164
  br i1 %8, label %middle.block, label %vector.body, !dbg !164, !llvm.loop !172

.preheader:                                       ; preds = %0
  %9 = load i64* @basket_size, align 8
  %10 = icmp slt i64 %9, 2, !dbg !175
  br i1 %10, label %.critedge, label %.lr.ph8, !dbg !179

middle.block:                                     ; preds = %vector.body
  %11 = add nsw i64 %m, -1, !dbg !180
  %12 = sdiv i64 %11, 300, !dbg !181
  %13 = add nsw i64 %12, 1, !dbg !182
  store i64 %13, i64* @nr_group, align 8, !dbg !183, !tbaa !184
  store i64 0, i64* @group_pos, align 8, !dbg !185, !tbaa !184
  store i64 0, i64* @basket_size, align 8, !dbg !186, !tbaa !184
  store i1 true, i1* @initialize, align 1
  br label %57, !dbg !187

.lr.ph8:                                          ; preds = %.preheader, %.thread
  %14 = phi i64 [ %53, %.thread ], [ %9, %.preheader ]
  %next.07 = phi i64 [ %next.1, %.thread ], [ 0, %.preheader ]
  %i.16 = phi i64 [ %54, %.thread ], [ 2, %.preheader ]
  %15 = getelementptr inbounds [351 x %struct.basket*]* @perm, i64 0, i64 %i.16, !dbg !188
  %16 = load %struct.basket** %15, align 8, !dbg !188, !tbaa !121
  %17 = getelementptr inbounds %struct.basket* %16, i64 0, i32 0, !dbg !190
  %18 = load %struct.arc** %17, align 8, !dbg !190, !tbaa !191
  tail call void @llvm.dbg.value(metadata %struct.arc* %18, i64 0, metadata !77, metadata !94), !dbg !192
  %19 = getelementptr inbounds %struct.arc* %18, i64 0, i32 0, !dbg !193
  %20 = load i64* %19, align 8, !dbg !193, !tbaa !194
  %21 = getelementptr inbounds %struct.arc* %18, i64 0, i32 1, !dbg !195
  %22 = load %struct.node** %21, align 8, !dbg !195, !tbaa !196
  %23 = getelementptr inbounds %struct.node* %22, i64 0, i32 0, !dbg !197
  %24 = load i64* %23, align 8, !dbg !197, !tbaa !198
  %25 = sub nsw i64 %20, %24, !dbg !200
  %26 = getelementptr inbounds %struct.arc* %18, i64 0, i32 2, !dbg !201
  %27 = load %struct.node** %26, align 8, !dbg !201, !tbaa !202
  %28 = getelementptr inbounds %struct.node* %27, i64 0, i32 0, !dbg !203
  %29 = load i64* %28, align 8, !dbg !203, !tbaa !198
  %30 = add nsw i64 %29, %25, !dbg !204
  tail call void @llvm.dbg.value(metadata i64 %30, i64 0, metadata !78, metadata !94), !dbg !205
  %31 = icmp slt i64 %30, 0, !dbg !206
  br i1 %31, label %32, label %36, !dbg !208

; <label>:32                                      ; preds = %.lr.ph8
  %33 = getelementptr inbounds %struct.arc* %18, i64 0, i32 3, !dbg !209
  %34 = load i32* %33, align 4, !dbg !209, !tbaa !100
  %35 = icmp eq i32 %34, 1, !dbg !210
  br i1 %35, label %42, label %.thread, !dbg !211

; <label>:36                                      ; preds = %.lr.ph8
  %37 = icmp sgt i64 %30, 0, !dbg !212
  br i1 %37, label %38, label %.thread, !dbg !213

; <label>:38                                      ; preds = %36
  %39 = getelementptr inbounds %struct.arc* %18, i64 0, i32 3, !dbg !214
  %40 = load i32* %39, align 4, !dbg !214, !tbaa !100
  %41 = icmp eq i32 %40, 2, !dbg !215
  br i1 %41, label %42, label %.thread, !dbg !216

; <label>:42                                      ; preds = %38, %32
  %43 = add nsw i64 %next.07, 1, !dbg !217
  tail call void @llvm.dbg.value(metadata i64 %43, i64 0, metadata !75, metadata !94), !dbg !219
  %44 = getelementptr inbounds [351 x %struct.basket*]* @perm, i64 0, i64 %43, !dbg !220
  %45 = load %struct.basket** %44, align 8, !dbg !220, !tbaa !121
  %46 = getelementptr inbounds %struct.basket* %45, i64 0, i32 0, !dbg !221
  store %struct.arc* %18, %struct.arc** %46, align 8, !dbg !222, !tbaa !191
  %47 = load %struct.basket** %44, align 8, !dbg !223, !tbaa !121
  %48 = getelementptr inbounds %struct.basket* %47, i64 0, i32 1, !dbg !224
  store i64 %30, i64* %48, align 8, !dbg !225, !tbaa !226
  %49 = icmp sgt i64 %30, -1, !dbg !227
  %50 = sub nsw i64 0, %30, !dbg !227
  %51 = select i1 %49, i64 %30, i64 %50, !dbg !227
  %52 = getelementptr inbounds %struct.basket* %47, i64 0, i32 2, !dbg !228
  store i64 %51, i64* %52, align 8, !dbg !229, !tbaa !123
  %.pre = load i64* @basket_size, align 8
  br label %.thread, !dbg !230

.thread:                                          ; preds = %32, %36, %38, %42
  %53 = phi i64 [ %.pre, %42 ], [ %14, %38 ], [ %14, %36 ], [ %14, %32 ], !dbg !231
  %next.1 = phi i64 [ %43, %42 ], [ %next.07, %38 ], [ %next.07, %36 ], [ %next.07, %32 ]
  %54 = add nuw nsw i64 %i.16, 1, !dbg !231
  tail call void @llvm.dbg.value(metadata i64 %54, i64 0, metadata !74, metadata !94), !dbg !232
  %55 = icmp sgt i64 %i.16, 49, !dbg !233
  %56 = icmp sge i64 %i.16, %53, !dbg !175
  %or.cond = or i1 %55, %56, !dbg !179
  br i1 %or.cond, label %.critedge, label %.lr.ph8, !dbg !179

.critedge:                                        ; preds = %.thread, %.preheader
  %next.0.lcssa = phi i64 [ 0, %.preheader ], [ %next.1, %.thread ]
  store i64 %next.0.lcssa, i64* @basket_size, align 8, !dbg !234, !tbaa !184
  %.pre10 = load i64* @group_pos, align 8, !dbg !235, !tbaa !184
  br label %57

; <label>:57                                      ; preds = %.critedge, %middle.block
  %58 = phi i64 [ %next.0.lcssa, %.critedge ], [ 0, %middle.block ]
  %59 = phi i64 [ %.pre10, %.critedge ], [ 0, %middle.block ]
  tail call void @llvm.dbg.value(metadata i64 %59, i64 0, metadata !76, metadata !94), !dbg !236
  br label %60, !dbg !237

; <label>:60                                      ; preds = %105, %57
  %61 = phi i64 [ %107, %105 ], [ %58, %57 ]
  %62 = phi i64 [ %., %105 ], [ %59, %57 ]
  %63 = getelementptr inbounds %struct.arc* %arcs, i64 %62, !dbg !238
  tail call void @llvm.dbg.value(metadata %struct.arc* %63, i64 0, metadata !77, metadata !94), !dbg !192
  %64 = icmp ult %struct.arc* %63, %stop_arcs, !dbg !239
  br i1 %64, label %.lr.ph, label %._crit_edge11, !dbg !242

._crit_edge11:                                    ; preds = %60
  %.pre12 = load i64* @nr_group, align 8, !dbg !243, !tbaa !184
  br label %105, !dbg !242

.lr.ph:                                           ; preds = %60, %101
  %arc.05 = phi %struct.arc* [ %103, %101 ], [ %63, %60 ]
  %65 = getelementptr inbounds %struct.arc* %arc.05, i64 0, i32 3, !dbg !245
  %66 = load i32* %65, align 4, !dbg !245, !tbaa !100
  %67 = icmp sgt i32 %66, 0, !dbg !248
  br i1 %67, label %68, label %101, !dbg !249

; <label>:68                                      ; preds = %.lr.ph
  %69 = getelementptr inbounds %struct.arc* %arc.05, i64 0, i32 0, !dbg !250
  %70 = load i64* %69, align 8, !dbg !250, !tbaa !194
  %71 = getelementptr inbounds %struct.arc* %arc.05, i64 0, i32 1, !dbg !252
  %72 = load %struct.node** %71, align 8, !dbg !252, !tbaa !196
  %73 = getelementptr inbounds %struct.node* %72, i64 0, i32 0, !dbg !253
  %74 = load i64* %73, align 8, !dbg !253, !tbaa !198
  %75 = sub nsw i64 %70, %74, !dbg !254
  %76 = getelementptr inbounds %struct.arc* %arc.05, i64 0, i32 2, !dbg !255
  %77 = load %struct.node** %76, align 8, !dbg !255, !tbaa !202
  %78 = getelementptr inbounds %struct.node* %77, i64 0, i32 0, !dbg !256
  %79 = load i64* %78, align 8, !dbg !256, !tbaa !198
  %80 = add nsw i64 %79, %75, !dbg !257
  tail call void @llvm.dbg.value(metadata i64 %80, i64 0, metadata !78, metadata !94), !dbg !205
  tail call void @llvm.dbg.value(metadata %struct.arc* %103, i64 0, metadata !46, metadata !94), !dbg !258
  tail call void @llvm.dbg.value(metadata i64 %80, i64 0, metadata !47, metadata !94), !dbg !261
  %81 = icmp slt i64 %80, 0, !dbg !262
  br i1 %81, label %82, label %bea_is_dual_infeasible.exit, !dbg !263

; <label>:82                                      ; preds = %68
  %83 = icmp eq i32 %66, 1, !dbg !264
  br i1 %83, label %86, label %101, !dbg !265

bea_is_dual_infeasible.exit:                      ; preds = %68
  %84 = icmp sgt i64 %80, 0, !dbg !266
  %85 = icmp eq i32 %66, 2, !dbg !267
  %.3 = and i1 %85, %84, !dbg !268
  br i1 %.3, label %86, label %101, !dbg !265

; <label>:86                                      ; preds = %82, %bea_is_dual_infeasible.exit
  %87 = load i64* @basket_size, align 8, !dbg !269, !tbaa !184
  %88 = add nsw i64 %87, 1, !dbg !269
  store i64 %88, i64* @basket_size, align 8, !dbg !269, !tbaa !184
  %89 = getelementptr inbounds [351 x %struct.basket*]* @perm, i64 0, i64 %88, !dbg !271
  %90 = load %struct.basket** %89, align 8, !dbg !271, !tbaa !121
  %91 = getelementptr inbounds %struct.basket* %90, i64 0, i32 0, !dbg !272
  store %struct.arc* %arc.05, %struct.arc** %91, align 8, !dbg !273, !tbaa !191
  %92 = load %struct.basket** %89, align 8, !dbg !274, !tbaa !121
  %93 = getelementptr inbounds %struct.basket* %92, i64 0, i32 1, !dbg !275
  store i64 %80, i64* %93, align 8, !dbg !276, !tbaa !226
  %94 = icmp sgt i64 %80, -1, !dbg !277
  %95 = sub nsw i64 0, %80, !dbg !277
  %96 = select i1 %94, i64 %80, i64 %95, !dbg !277
  %97 = load i64* @basket_size, align 8, !dbg !278, !tbaa !184
  %98 = getelementptr inbounds [351 x %struct.basket*]* @perm, i64 0, i64 %97, !dbg !279
  %99 = load %struct.basket** %98, align 8, !dbg !279, !tbaa !121
  %100 = getelementptr inbounds %struct.basket* %99, i64 0, i32 2, !dbg !280
  store i64 %96, i64* %100, align 8, !dbg !281, !tbaa !123
  br label %101, !dbg !282

; <label>:101                                     ; preds = %82, %bea_is_dual_infeasible.exit, %.lr.ph, %86
  %102 = load i64* @nr_group, align 8, !dbg !283, !tbaa !184
  %103 = getelementptr inbounds %struct.arc* %arc.05, i64 %102, !dbg !284
  tail call void @llvm.dbg.value(metadata %struct.arc* %103, i64 0, metadata !77, metadata !94), !dbg !192
  %104 = icmp ult %struct.arc* %103, %stop_arcs, !dbg !239
  br i1 %104, label %.lr.ph, label %._crit_edge, !dbg !242

._crit_edge:                                      ; preds = %101
  %.pre13 = load i64* @basket_size, align 8, !dbg !285, !tbaa !184
  %.pre14 = load i64* @group_pos, align 8, !dbg !287, !tbaa !184
  br label %105, !dbg !242

; <label>:105                                     ; preds = %._crit_edge11, %._crit_edge
  %106 = phi i64 [ %62, %._crit_edge11 ], [ %.pre14, %._crit_edge ], !dbg !287
  %107 = phi i64 [ %61, %._crit_edge11 ], [ %.pre13, %._crit_edge ], !dbg !287
  %108 = phi i64 [ %.pre12, %._crit_edge11 ], [ %102, %._crit_edge ], !dbg !287
  %109 = add nsw i64 %106, 1, !dbg !287
  %110 = icmp eq i64 %109, %108, !dbg !288
  %. = select i1 %110, i64 0, i64 %109, !dbg !289
  store i64 %., i64* @group_pos, align 8, !dbg !290, !tbaa !184
  %111 = icmp sgt i64 %107, 49, !dbg !291
  %112 = icmp eq i64 %., %59, !dbg !292
  %or.cond2 = or i1 %111, %112, !dbg !293
  br i1 %or.cond2, label %113, label %60, !dbg !293

; <label>:113                                     ; preds = %105
  %114 = icmp eq i64 %107, 0, !dbg !294
  br i1 %114, label %115, label %116, !dbg !296

; <label>:115                                     ; preds = %113
  store i1 false, i1* @initialize, align 1
  store i64 0, i64* %red_cost_of_bea, align 8, !dbg !297, !tbaa !184
  br label %122, !dbg !299

; <label>:116                                     ; preds = %113
  tail call void @sort_basket(i64 1, i64 %107) #3, !dbg !300
  %117 = load %struct.basket** getelementptr inbounds ([351 x %struct.basket*]* @perm, i64 0, i64 1), align 8, !dbg !301, !tbaa !121
  %118 = getelementptr inbounds %struct.basket* %117, i64 0, i32 1, !dbg !302
  %119 = load i64* %118, align 8, !dbg !302, !tbaa !226
  store i64 %119, i64* %red_cost_of_bea, align 8, !dbg !303, !tbaa !184
  %120 = getelementptr inbounds %struct.basket* %117, i64 0, i32 0, !dbg !304
  %121 = load %struct.arc** %120, align 8, !dbg !304, !tbaa !191
  br label %122, !dbg !305

; <label>:122                                     ; preds = %116, %115
  %.0 = phi %struct.arc* [ null, %115 ], [ %121, %116 ]
  ret %struct.arc* %.0, !dbg !306
}
