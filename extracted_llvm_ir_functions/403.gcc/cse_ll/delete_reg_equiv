define internal fastcc void @delete_reg_equiv(i32 %reg) #0 {
entry:
  %0 = load i32* @cached_regno, align 4, !tbaa !4
  %cmp = icmp eq i32 %0, %reg
  %1 = load %struct.cse_reg_info** @cached_cse_reg_info, align 8, !tbaa !0
  %tobool = icmp ne %struct.cse_reg_info* %1, null
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %call = tail call fastcc %struct.cse_reg_info* @get_cse_reg_info(i32 %reg) #7
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi %struct.cse_reg_info* [ %call, %cond.false ], [ %1, %entry ]
  %reg_qty = getelementptr inbounds %struct.cse_reg_info* %cond, i64 0, i32 3
  %2 = load i32* %reg_qty, align 4, !tbaa !4
  %cmp1 = icmp eq i32 %2, %reg
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %cond.end
  %idxprom = sext i32 %2 to i64
  %3 = load %struct.qty_table_elem** @qty_table, align 8, !tbaa !0
  %idxprom2 = zext i32 %reg to i64
  %4 = load %struct.reg_eqv_elem** @reg_eqv_table, align 8, !tbaa !0
  %prev = getelementptr inbounds %struct.reg_eqv_elem* %4, i64 %idxprom2, i32 1
  %5 = load i32* %prev, align 4, !tbaa !4
  %next = getelementptr inbounds %struct.reg_eqv_elem* %4, i64 %idxprom2, i32 0
  %6 = load i32* %next, align 4, !tbaa !4
  %cmp6 = icmp eq i32 %6, -1
  br i1 %cmp6, label %if.else, label %if.then7

if.then7:                                         ; preds = %if.end
  %idxprom8 = sext i32 %6 to i64
  %prev10 = getelementptr inbounds %struct.reg_eqv_elem* %4, i64 %idxprom8, i32 1
  store i32 %5, i32* %prev10, align 4, !tbaa !4
  br label %if.end11

if.else:                                          ; preds = %if.end
  %last_reg = getelementptr inbounds %struct.qty_table_elem* %3, i64 %idxprom, i32 5
  store i32 %5, i32* %last_reg, align 4, !tbaa !4
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then7
  %cmp12 = icmp eq i32 %5, -1
  br i1 %cmp12, label %if.else17, label %if.then13

if.then13:                                        ; preds = %if.end11
  %idxprom14 = sext i32 %5 to i64
  %next16 = getelementptr inbounds %struct.reg_eqv_elem* %4, i64 %idxprom14, i32 0
  store i32 %6, i32* %next16, align 4, !tbaa !4
  br label %if.end18

if.else17:                                        ; preds = %if.end11
  %first_reg = getelementptr inbounds %struct.qty_table_elem* %3, i64 %idxprom, i32 4
  store i32 %6, i32* %first_reg, align 4, !tbaa !4
  br label %if.end18

if.end18:                                         ; preds = %if.else17, %if.then13
  %7 = load i32* @cached_regno, align 4, !tbaa !4
  %cmp19 = icmp eq i32 %7, %reg
  %8 = load %struct.cse_reg_info** @cached_cse_reg_info, align 8, !tbaa !0
  %tobool21 = icmp ne %struct.cse_reg_info* %8, null
  %or.cond28 = and i1 %cmp19, %tobool21
  br i1 %or.cond28, label %cond.end25, label %cond.false23

cond.false23:                                     ; preds = %if.end18
  %call24 = tail call fastcc %struct.cse_reg_info* @get_cse_reg_info(i32 %reg) #7
  br label %cond.end25

cond.end25:                                       ; preds = %if.end18, %cond.false23
  %cond26 = phi %struct.cse_reg_info* [ %call24, %cond.false23 ], [ %8, %if.end18 ]
  %reg_qty27 = getelementptr inbounds %struct.cse_reg_info* %cond26, i64 0, i32 3
  store i32 %reg, i32* %reg_qty27, align 4, !tbaa !4
  br label %return

return:                                           ; preds = %cond.end, %cond.end25
  ret void
}
