define zeroext i1 @assemble_integer(%struct.rtx_def* %x, i32 %size, i32 %align, i32 %force) #0 {
entry:
  %mul = shl i32 %size, 3
  %cmp = icmp ult i32 %mul, 128
  %mul. = select i1 %cmp, i32 %mul, i32 128
  %cmp2 = icmp ule i32 %mul., %align
  %conv = zext i1 %cmp2 to i32
  %0 = load i1 (%struct.rtx_def*, i32, i32)** getelementptr inbounds (%struct.gcc_target* @targetm, i64 0, i32 0, i32 5), align 8, !tbaa !3
  %call = tail call zeroext i1 %0(%struct.rtx_def* %x, i32 %size, i32 %conv) #9
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp3 = icmp ugt i32 %size, 1
  br i1 %cmp3, label %for.body.lr.ph, label %if.end43

for.body.lr.ph:                                   ; preds = %if.end
  %1 = load i32* @target_flags, align 4, !tbaa !4
  %and = lshr i32 %1, 23
  %2 = and i32 %and, 4
  %3 = add i32 %2, 4
  %cmp7 = icmp ult i32 %3, %size
  %. = select i1 %cmp7, i32 %3, i32 1
  %mul16 = shl nsw i32 %., 3
  %cmp17 = icmp ugt i32 %mul16, %align
  %cond23 = select i1 %cmp17, i32 %align, i32 %mul16
  %call25 = tail call i32 @mode_for_size(i32 %mul16, i32 1, i32 0) #9
  %call27 = tail call i32 @mode_for_size(i32 %mul, i32 1, i32 0) #9
  br label %for.body

for.cond:                                         ; preds = %lor.lhs.false
  %cmp28 = icmp ult i32 %add, %size
  br i1 %cmp28, label %for.body, label %for.end

for.body:                                         ; preds = %for.body.lr.ph, %for.cond
  %i.067 = phi i32 [ 0, %for.body.lr.ph ], [ %add, %for.cond ]
  %call30 = tail call %struct.rtx_def* @simplify_subreg(i32 %call25, %struct.rtx_def* %x, i32 %call27, i32 %i.067) #9
  %tobool31 = icmp eq %struct.rtx_def* %call30, null
  br i1 %tobool31, label %for.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %call32 = tail call zeroext i1 @assemble_integer(%struct.rtx_def* %call30, i32 %., i32 %cond23, i32 0) #10
  %add = add i32 %i.067, %.
  br i1 %call32, label %for.cond, label %for.end

for.end:                                          ; preds = %for.cond, %for.body, %lor.lhs.false
  %i.0.lcssa = phi i32 [ %i.067, %lor.lhs.false ], [ %i.067, %for.body ], [ %add, %for.cond ]
  %cmp35 = icmp eq i32 %i.0.lcssa, %size
  br i1 %cmp35, label %return, label %if.end38

if.end38:                                         ; preds = %for.end
  %cmp39 = icmp eq i32 %i.0.lcssa, 0
  br i1 %cmp39, label %if.end43, label %if.then41

if.then41:                                        ; preds = %if.end38
  tail call void @fancy_abort(i8* getelementptr inbounds ([50 x i8]* @.str4, i64 0, i64 0), i32 2008, i8* getelementptr inbounds ([17 x i8]* @__FUNCTION__.assemble_integer, i64 0, i64 0)) #12
  unreachable

if.end43:                                         ; preds = %if.end38, %if.end
  %tobool44 = icmp eq i32 %force, 0
  br i1 %tobool44, label %return, label %if.then45

if.then45:                                        ; preds = %if.end43
  tail call void @fancy_abort(i8* getelementptr inbounds ([50 x i8]* @.str4, i64 0, i64 0), i32 2012, i8* getelementptr inbounds ([17 x i8]* @__FUNCTION__.assemble_integer, i64 0, i64 0)) #12
  unreachable

return:                                           ; preds = %if.end43, %for.end, %entry
  %retval.0 = phi i1 [ true, %entry ], [ true, %for.end ], [ false, %if.end43 ]
  ret i1 %retval.0
}
