define internal fastcc void @reg_is_born(%struct.rtx_def* %reg, i32 %birth) #0 {
entry:
  %0 = bitcast %struct.rtx_def* %reg to i32*
  %bf.load = load i32* %0, align 8
  %bf.clear = and i32 %bf.load, 65535
  %cmp = icmp eq i32 %bf.clear, 63
  %arrayidx = getelementptr inbounds %struct.rtx_def* %reg, i64 0, i32 1, i64 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %rtx = bitcast %union.rtunion_def* %arrayidx to %struct.rtx_def**
  %1 = load %struct.rtx_def** %rtx, align 8, !tbaa !3
  %arrayidx2 = getelementptr inbounds %struct.rtx_def* %1, i64 0, i32 1, i64 0
  %rtuint = bitcast %union.rtunion_def* %arrayidx2 to i32*
  %2 = load i32* %rtuint, align 4, !tbaa !0
  %cmp3 = icmp slt i32 %2, 53
  br i1 %cmp3, label %if.then4, label %if.else20

if.then4:                                         ; preds = %if.then
  %call = tail call i32 @subreg_hard_regno(%struct.rtx_def* %reg, i32 1) #6
  br label %if.end8

if.else:                                          ; preds = %entry
  %rtuint7 = bitcast %union.rtunion_def* %arrayidx to i32*
  %3 = load i32* %rtuint7, align 4, !tbaa !0
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.else
  %regno.0 = phi i32 [ %call, %if.then4 ], [ %3, %if.else ]
  %cmp9 = icmp slt i32 %regno.0, 53
  br i1 %cmp9, label %if.then10, label %if.else20

if.then10:                                        ; preds = %if.end8
  %bf.load11 = load i32* %0, align 8
  %bf.lshr = lshr i32 %bf.load11, 16
  %bf.clear12 = and i32 %bf.lshr, 255
  tail call fastcc void @mark_life(i32 %regno.0, i32 %bf.clear12, i32 1) #8
  %4 = load i32* @this_insn_number, align 4, !tbaa !0
  %mul = shl nsw i32 %4, 1
  %cmp13 = icmp sgt i32 %mul, %birth
  br i1 %cmp13, label %if.then14, label %if.end48

if.then14:                                        ; preds = %if.then10
  %bf.load15 = load i32* %0, align 8
  %bf.lshr16 = lshr i32 %bf.load15, 16
  %bf.clear17 = and i32 %bf.lshr16, 255
  tail call fastcc void @post_mark_life(i32 %regno.0, i32 %bf.clear17, i32 %birth, i32 %mul) #8
  br label %if.end48

if.else20:                                        ; preds = %if.then, %if.end8
  %regno.065 = phi i32 [ %regno.0, %if.end8 ], [ %2, %if.then ]
  %idxprom = sext i32 %regno.065 to i64
  %5 = load i32** @reg_qty, align 8, !tbaa !3
  %arrayidx21 = getelementptr inbounds i32* %5, i64 %idxprom
  %6 = load i32* %arrayidx21, align 4, !tbaa !0
  %cmp22 = icmp eq i32 %6, -2
  br i1 %cmp22, label %if.then23, label %if.end37

if.then23:                                        ; preds = %if.else20
  %bf.load24 = load i32* %0, align 8
  %bf.lshr25 = lshr i32 %bf.load24, 16
  %bf.clear26 = and i32 %bf.lshr25, 255
  %7 = load %struct.function** @cfun, align 8, !tbaa !3
  %emit = getelementptr inbounds %struct.function* %7, i64 0, i32 3
  %8 = load %struct.emit_status** %emit, align 8, !tbaa !3
  %x_regno_reg_rtx = getelementptr inbounds %struct.emit_status* %8, i64 0, i32 12
  %9 = load %struct.rtx_def*** %x_regno_reg_rtx, align 8, !tbaa !3
  %arrayidx28 = getelementptr inbounds %struct.rtx_def** %9, i64 %idxprom
  %10 = load %struct.rtx_def** %arrayidx28, align 8, !tbaa !3
  %11 = bitcast %struct.rtx_def* %10 to i32*
  %bf.load29 = load i32* %11, align 8
  %bf.lshr30 = lshr i32 %bf.load29, 16
  %bf.clear31 = and i32 %bf.lshr30, 255
  %idxprom3263 = zext i32 %bf.clear31 to i64
  %arrayidx33 = getelementptr inbounds [59 x i8]* @mode_size, i64 0, i64 %idxprom3263
  %12 = load i8* %arrayidx33, align 1, !tbaa !1
  %conv = zext i8 %12 to i32
  %13 = load i32* @target_flags, align 4, !tbaa !0
  %and = lshr i32 %13, 23
  %14 = and i32 %and, 4
  %15 = add i32 %14, 4
  %add = add i32 %conv, -1
  %sub = add i32 %add, %15
  %div = sdiv i32 %sub, %15
  %16 = load i32* @next_qty, align 4, !tbaa !0
  %inc.i = add nsw i32 %16, 1
  store i32 %inc.i, i32* @next_qty, align 4, !tbaa !0
  store i32 %16, i32* %arrayidx21, align 4, !tbaa !0
  %17 = load i8** @reg_offset, align 8, !tbaa !3
  %arrayidx2.i = getelementptr inbounds i8* %17, i64 %idxprom
  store i8 0, i8* %arrayidx2.i, align 1, !tbaa !1
  %18 = load i32** @reg_next_in_qty, align 8, !tbaa !3
  %arrayidx4.i = getelementptr inbounds i32* %18, i64 %idxprom
  store i32 -1, i32* %arrayidx4.i, align 4, !tbaa !0
  %idxprom5.i = sext i32 %16 to i64
  %19 = load %struct.qty** @qty, align 8, !tbaa !3
  %first_reg.i = getelementptr inbounds %struct.qty* %19, i64 %idxprom5.i, i32 6
  store i32 %regno.065, i32* %first_reg.i, align 4, !tbaa !0
  %size9.i = getelementptr inbounds %struct.qty* %19, i64 %idxprom5.i, i32 4
  store i32 %div, i32* %size9.i, align 4, !tbaa !0
  %mode12.i = getelementptr inbounds %struct.qty* %19, i64 %idxprom5.i, i32 9
  store i32 %bf.clear26, i32* %mode12.i, align 4, !tbaa !7
  %birth15.i = getelementptr inbounds %struct.qty* %19, i64 %idxprom5.i, i32 2
  store i32 %birth, i32* %birth15.i, align 4, !tbaa !0
  %20 = load %struct.varray_head_tag** @reg_n_info, align 8, !tbaa !3
  %data.i = getelementptr inbounds %struct.varray_head_tag* %20, i64 0, i32 4
  %reg.i = bitcast %union.varray_data_tag* %data.i to [1 x %struct.reg_info_def*]*
  %arrayidx17.i = getelementptr inbounds [1 x %struct.reg_info_def*]* %reg.i, i64 0, i64 %idxprom
  %21 = load %struct.reg_info_def** %arrayidx17.i, align 8, !tbaa !3
  %calls_crossed.i = getelementptr inbounds %struct.reg_info_def* %21, i64 0, i32 8
  %22 = load i32* %calls_crossed.i, align 4, !tbaa !0
  %n_calls_crossed.i = getelementptr inbounds %struct.qty* %19, i64 %idxprom5.i, i32 5
  store i32 %22, i32* %n_calls_crossed.i, align 4, !tbaa !0
  %call.i = tail call i32 @reg_preferred_class(i32 %regno.065) #6
  %23 = load %struct.qty** @qty, align 8, !tbaa !3
  %min_class.i = getelementptr inbounds %struct.qty* %23, i64 %idxprom5.i, i32 7
  store i32 %call.i, i32* %min_class.i, align 4, !tbaa !6
  %call22.i = tail call i32 @reg_alternate_class(i32 %regno.065) #6
  %24 = load %struct.qty** @qty, align 8, !tbaa !3
  %alternate_class.i = getelementptr inbounds %struct.qty* %24, i64 %idxprom5.i, i32 8
  store i32 %call22.i, i32* %alternate_class.i, align 4, !tbaa !6
  %25 = load %struct.varray_head_tag** @reg_n_info, align 8, !tbaa !3
  %data26.i = getelementptr inbounds %struct.varray_head_tag* %25, i64 0, i32 4
  %reg27.i = bitcast %union.varray_data_tag* %data26.i to [1 x %struct.reg_info_def*]*
  %arrayidx28.i = getelementptr inbounds [1 x %struct.reg_info_def*]* %reg27.i, i64 0, i64 %idxprom
  %26 = load %struct.reg_info_def** %arrayidx28.i, align 8, !tbaa !3
  %refs.i = getelementptr inbounds %struct.reg_info_def* %26, i64 0, i32 4
  %27 = load i32* %refs.i, align 4, !tbaa !0
  %n_refs.i = getelementptr inbounds %struct.qty* %24, i64 %idxprom5.i, i32 0
  store i32 %27, i32* %n_refs.i, align 4, !tbaa !0
  %freq.i = getelementptr inbounds %struct.reg_info_def* %26, i64 0, i32 5
  %28 = load i32* %freq.i, align 4, !tbaa !0
  %freq37.i = getelementptr inbounds %struct.qty* %24, i64 %idxprom5.i, i32 1
  store i32 %28, i32* %freq37.i, align 4, !tbaa !0
  %changes_mode.i = getelementptr inbounds %struct.reg_info_def* %26, i64 0, i32 10
  %29 = load i8* %changes_mode.i, align 1, !tbaa !1
  %changes_mode44.i = getelementptr inbounds %struct.qty* %24, i64 %idxprom5.i, i32 11
  store i8 %29, i8* %changes_mode44.i, align 1, !tbaa !1
  %.pre = load i32** @reg_qty, align 8, !tbaa !3
  %arrayidx39.phi.trans.insert = getelementptr inbounds i32* %.pre, i64 %idxprom
  %.pre66 = load i32* %arrayidx39.phi.trans.insert, align 4, !tbaa !0
  br label %if.end37

if.end37:                                         ; preds = %if.then23, %if.else20
  %30 = phi i32 [ %.pre66, %if.then23 ], [ %6, %if.else20 ]
  %cmp40 = icmp sgt i32 %30, -1
  br i1 %cmp40, label %if.then42, label %if.end48

if.then42:                                        ; preds = %if.end37
  %idxprom45 = sext i32 %30 to i64
  %31 = load %struct.qty** @qty, align 8, !tbaa !3
  %death = getelementptr inbounds %struct.qty* %31, i64 %idxprom45, i32 3
  store i32 -1, i32* %death, align 4, !tbaa !0
  br label %if.end48

if.end48:                                         ; preds = %if.end37, %if.then42, %if.then10, %if.then14
  ret void
}
