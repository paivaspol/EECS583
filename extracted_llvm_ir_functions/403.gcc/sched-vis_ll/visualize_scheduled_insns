define void @visualize_scheduled_insns(i32 %clock) #0 {
entry:
  %str = alloca [2048 x i8], align 16
  %0 = load i32* @n_visual_lines, align 4, !tbaa !3
  %cmp = icmp sgt i32 %0, 99
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @print_block_visualization(i8* getelementptr inbounds ([13 x i8]* @.str16, i64 0, i64 0)) #6
  %1 = load i8** @visual_tbl, align 8, !tbaa !0
  store i8 0, i8* %1, align 1
  store i32 0, i32* @n_visual_lines, align 4, !tbaa !3
  store i32 0, i32* @n_vis_no_unit, align 4, !tbaa !3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = phi i32 [ 0, %if.then ], [ %0, %entry ]
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* @n_visual_lines, align 4, !tbaa !3
  %3 = load i8** @visual_tbl, align 8, !tbaa !0
  %call = call i64 @strlen(i8* %3) #7
  %add.ptr = getelementptr inbounds i8* %3, i64 %call
  %call1 = call i32 (i8*, i8*, ...)* @sprintf(i8* %add.ptr, i8* getelementptr inbounds ([10 x i8]* @.str17, i64 0, i64 0), i32 %clock) #5
  %4 = getelementptr inbounds [2048 x i8]* %str, i64 0, i64 0
  %arrayidx14 = getelementptr inbounds [2048 x i8]* %str, i64 0, i64 30
  br label %for.body

for.cond28.preheader:                             ; preds = %for.inc25
  %5 = load i32* @n_vis_no_unit, align 4, !tbaa !3
  %cmp2957 = icmp sgt i32 %5, 0
  br i1 %cmp2957, label %for.body30, label %for.end39

for.body:                                         ; preds = %for.inc25, %if.end
  %indvars.iv64 = phi i64 [ 0, %if.end ], [ %indvars.iv.next65, %for.inc25 ]
  %bitmask = getelementptr inbounds [0 x %struct.function_unit_desc]* @function_units, i64 0, i64 %indvars.iv64, i32 1
  %6 = load i32* %bitmask, align 8, !tbaa !3
  %7 = load i32* @target_units, align 4, !tbaa !3
  %and = and i32 %7, %6
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %for.inc25, label %for.cond4.preheader

for.cond4.preheader:                              ; preds = %for.body
  %multiplicity = getelementptr inbounds [0 x %struct.function_unit_desc]* @function_units, i64 0, i64 %indvars.iv64, i32 2
  %8 = load i32* %multiplicity, align 4, !tbaa !3
  %cmp759 = icmp sgt i32 %8, 0
  br i1 %cmp759, label %for.body8, label %for.inc25

for.body8:                                        ; preds = %for.cond4.preheader, %for.inc
  %i.060 = phi i32 [ %inc23, %for.inc ], [ 0, %for.cond4.preheader ]
  %mul = mul nsw i32 %i.060, 26
  %9 = trunc i64 %indvars.iv64 to i32
  %add = add nsw i32 %mul, %9
  %call9 = call %struct.rtx_def* @get_unit_last_insn(i32 %add) #5
  %tobool10 = icmp eq %struct.rtx_def* %call9, null
  br i1 %tobool10, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body8
  %call11 = call i32 @actual_hazard_this_instance(i32 %9, i32 %add, %struct.rtx_def* %call9, i32 %clock, i32 0) #5
  %tobool12 = icmp eq i32 %call11, 0
  br i1 %tobool12, label %if.else, label %if.then13

if.then13:                                        ; preds = %land.lhs.true
  call void @llvm.lifetime.start(i64 2048, i8* %4) #4
  call fastcc void @print_insn(i8* %4, %struct.rtx_def* %call9) #6
  store i8 0, i8* %arrayidx14, align 2, !tbaa !1
  %10 = load i8** @visual_tbl, align 8, !tbaa !0
  %call15 = call i64 @strlen(i8* %10) #7
  %add.ptr16 = getelementptr inbounds i8* %10, i64 %call15
  %call18 = call i32 (i8*, i8*, ...)* @sprintf(i8* %add.ptr16, i8* getelementptr inbounds ([8 x i8]* @.str9, i64 0, i64 0), i8* %4) #5
  call void @llvm.lifetime.end(i64 2048, i8* %4) #4
  br label %for.inc

if.else:                                          ; preds = %land.lhs.true, %for.body8
  %11 = load i8** @visual_tbl, align 8, !tbaa !0
  %call19 = call i64 @strlen(i8* %11) #7
  %add.ptr20 = getelementptr inbounds i8* %11, i64 %call19
  %call21 = call i32 (i8*, i8*, ...)* @sprintf(i8* %add.ptr20, i8* getelementptr inbounds ([8 x i8]* @.str9, i64 0, i64 0), i8* getelementptr inbounds ([31 x i8]* @.str18, i64 0, i64 0)) #5
  br label %for.inc

for.inc:                                          ; preds = %if.then13, %if.else
  %inc23 = add nsw i32 %i.060, 1
  %cmp7 = icmp slt i32 %inc23, %8
  br i1 %cmp7, label %for.body8, label %for.inc25

for.inc25:                                        ; preds = %for.cond4.preheader, %for.inc, %for.body
  %indvars.iv.next65 = add i64 %indvars.iv64, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next65 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, 26
  br i1 %exitcond, label %for.cond28.preheader, label %for.body

for.body30:                                       ; preds = %for.cond28.preheader, %for.body30
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body30 ], [ 0, %for.cond28.preheader ]
  %12 = load i8** @visual_tbl, align 8, !tbaa !0
  %call31 = call i64 @strlen(i8* %12) #7
  %add.ptr32 = getelementptr inbounds i8* %12, i64 %call31
  %arrayidx34 = getelementptr inbounds [20 x %struct.rtx_def*]* @vis_no_unit, i64 0, i64 %indvars.iv
  %13 = load %struct.rtx_def** %arrayidx34, align 8, !tbaa !0
  %arrayidx35 = getelementptr inbounds %struct.rtx_def* %13, i64 0, i32 1, i64 0
  %rtint = bitcast %union.rtunion_def* %arrayidx35 to i32*
  %14 = load i32* %rtint, align 4, !tbaa !3
  %call36 = call i32 (i8*, i8*, ...)* @sprintf(i8* %add.ptr32, i8* getelementptr inbounds ([7 x i8]* @.str19, i64 0, i64 0), i32 %14) #5
  %indvars.iv.next = add i64 %indvars.iv, 1
  %15 = load i32* @n_vis_no_unit, align 4, !tbaa !3
  %16 = trunc i64 %indvars.iv.next to i32
  %cmp29 = icmp slt i32 %16, %15
  br i1 %cmp29, label %for.body30, label %for.end39

for.end39:                                        ; preds = %for.body30, %for.cond28.preheader
  store i32 0, i32* @n_vis_no_unit, align 4, !tbaa !3
  %17 = load i8** @visual_tbl, align 8, !tbaa !0
  %call40 = call i64 @strlen(i8* %17) #7
  %add.ptr41 = getelementptr inbounds i8* %17, i64 %call40
  %18 = bitcast i8* %add.ptr41 to i16*
  store i16 10, i16* %18, align 1
  ret void
}
