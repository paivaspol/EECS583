define internal fastcc void @clear_dead_regs(i64* nocapture %pset, i32 %kind, %struct.rtx_def* %notes) #0 {
entry:
  %tobool116 = icmp eq %struct.rtx_def* %notes, null
  br i1 %tobool116, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %note.0117 = phi %struct.rtx_def* [ %19, %for.inc ], [ %notes, %entry ]
  %0 = bitcast %struct.rtx_def* %note.0117 to i32*
  %bf.load = load i32* %0, align 8
  %bf.lshr = lshr i32 %bf.load, 16
  %bf.clear = and i32 %bf.lshr, 255
  %cmp = icmp eq i32 %bf.clear, %kind
  br i1 %cmp, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %arrayidx = getelementptr inbounds %struct.rtx_def* %note.0117, i64 0, i32 1, i64 0
  %rtx = bitcast %union.rtunion_def* %arrayidx to %struct.rtx_def**
  %1 = load %struct.rtx_def** %rtx, align 8, !tbaa !0
  %2 = bitcast %struct.rtx_def* %1 to i32*
  %bf.load1 = load i32* %2, align 8
  %bf.clear2 = and i32 %bf.load1, 65535
  %cmp3 = icmp eq i32 %bf.clear2, 61
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %land.lhs.true
  %arrayidx8 = getelementptr inbounds %struct.rtx_def* %1, i64 0, i32 1, i64 0
  %rtuint = bitcast %union.rtunion_def* %arrayidx8 to i32*
  %3 = load i32* %rtuint, align 4, !tbaa !3
  %.off = add i32 %3, -8
  %4 = icmp ult i32 %.off, 8
  %.off102 = add i32 %3, -21
  %5 = icmp ult i32 %.off102, 8
  %or.cond = or i1 %4, %5
  %.off103 = add i32 %3, -45
  %6 = icmp ult i32 %.off103, 8
  %or.cond109 = or i1 %or.cond, %6
  %.off104 = add i32 %3, -29
  %7 = icmp ult i32 %.off104, 8
  %or.cond111 = or i1 %or.cond109, %7
  %bf.lshr24 = lshr i32 %bf.load1, 16
  %bf.clear25 = and i32 %bf.lshr24, 255
  br i1 %or.cond111, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %idxprom106 = zext i32 %bf.clear25 to i64
  %arrayidx26 = getelementptr inbounds [59 x i32]* @mode_class, i64 0, i64 %idxprom106
  %8 = load i32* %arrayidx26, align 4, !tbaa !6
  %cmp27 = icmp eq i32 %8, 5
  br i1 %cmp27, label %cond.end65, label %lor.rhs

lor.rhs:                                          ; preds = %cond.true
  %cmp33 = icmp eq i32 %8, 6
  %phitmp = select i1 %cmp33, i32 2, i32 1
  br label %cond.end65

cond.false:                                       ; preds = %if.then
  switch i32 %bf.clear25, label %cond.false50 [
    i32 18, label %cond.true38
    i32 24, label %cond.true46
  ]

cond.true38:                                      ; preds = %cond.false
  %9 = load i32* @target_flags, align 4, !tbaa !3
  %and = lshr i32 %9, 25
  %10 = and i32 %and, 1
  %11 = xor i32 %10, 3
  br label %cond.end65

cond.true46:                                      ; preds = %cond.false
  %12 = load i32* @target_flags, align 4, !tbaa !3
  %and47 = lshr i32 %12, 24
  %13 = and i32 %and47, 2
  %14 = xor i32 %13, 6
  br label %cond.end65

cond.false50:                                     ; preds = %cond.false
  %idxprom54105 = zext i32 %bf.clear25 to i64
  %arrayidx55 = getelementptr inbounds [59 x i8]* @mode_size, i64 0, i64 %idxprom54105
  %15 = load i8* %arrayidx55, align 1, !tbaa !1
  %conv = zext i8 %15 to i32
  %16 = load i32* @target_flags, align 4, !tbaa !3
  %and56 = lshr i32 %16, 23
  %17 = and i32 %and56, 4
  %18 = add i32 %17, 4
  %add = add i32 %conv, -1
  %sub = add i32 %add, %18
  %div = sdiv i32 %sub, %18
  br label %cond.end65

cond.end65:                                       ; preds = %cond.true, %lor.rhs, %cond.true38, %cond.false50, %cond.true46
  %cond66 = phi i32 [ %11, %cond.true38 ], [ %14, %cond.true46 ], [ %div, %cond.false50 ], [ 2, %cond.true ], [ %phitmp, %lor.rhs ]
  %add67 = add i32 %cond66, %3
  %cmp68 = icmp ugt i32 %add67, 53
  br i1 %cmp68, label %if.then70, label %while.cond.preheader

while.cond.preheader:                             ; preds = %cond.end65
  %cmp71113 = icmp sgt i32 %cond66, 0
  br i1 %cmp71113, label %while.body.lr.ph, label %for.inc

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %pset.promoted = load i64* %pset, align 8, !tbaa !7
  br label %while.body

if.then70:                                        ; preds = %cond.end65
  tail call void @fancy_abort(i8* getelementptr inbounds ([53 x i8]* @.str40, i64 0, i64 0), i32 144, i8* getelementptr inbounds ([16 x i8]* @__FUNCTION__.clear_dead_regs, i64 0, i64 0)) #7
  unreachable

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %and74115 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and74, %while.body ]
  %dec114.in = phi i32 [ %cond66, %while.body.lr.ph ], [ %dec114, %while.body ]
  %dec114 = add nsw i32 %dec114.in, -1
  %add73 = add i32 %dec114, %3
  %sh_prom = zext i32 %add73 to i64
  %shl = shl i64 1, %sh_prom
  %neg = xor i64 %shl, -1
  %and74 = and i64 %and74115, %neg
  %cmp71 = icmp sgt i32 %dec114, 0
  br i1 %cmp71, label %while.body, label %while.cond.for.inc.loopexit_crit_edge

while.cond.for.inc.loopexit_crit_edge:            ; preds = %while.body
  store i64 %and74, i64* %pset, align 8, !tbaa !7
  br label %for.inc

for.inc:                                          ; preds = %while.cond.preheader, %while.cond.for.inc.loopexit_crit_edge, %for.body, %land.lhs.true
  %arrayidx77 = getelementptr inbounds %struct.rtx_def* %note.0117, i64 0, i32 1, i64 1
  %rtx78 = bitcast %union.rtunion_def* %arrayidx77 to %struct.rtx_def**
  %19 = load %struct.rtx_def** %rtx78, align 8, !tbaa !0
  %tobool = icmp eq %struct.rtx_def* %19, null
  br i1 %tobool, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc, %entry
  ret void
}
