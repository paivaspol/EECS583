define internal fastcc %struct.case_node* @case_tree2list(%struct.case_node* %node, %struct.case_node* %right) #0 {
entry:
  br label %tailrecurse

tailrecurse:                                      ; preds = %if.then6, %entry
  %node.tr = phi %struct.case_node* [ %node, %entry ], [ %1, %if.then6 ]
  %right.tr = phi %struct.case_node* [ %right, %entry ], [ %node.tr, %if.then6 ]
  %right1 = getelementptr inbounds %struct.case_node* %node.tr, i64 0, i32 1
  %0 = load %struct.case_node** %right1, align 8, !tbaa !0
  %tobool = icmp eq %struct.case_node* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %tailrecurse
  %call = tail call fastcc %struct.case_node* @case_tree2list(%struct.case_node* %0, %struct.case_node* %right.tr) #9
  br label %if.end

if.end:                                           ; preds = %tailrecurse, %if.then
  %right.addr.0 = phi %struct.case_node* [ %call, %if.then ], [ %right.tr, %tailrecurse ]
  store %struct.case_node* %right.addr.0, %struct.case_node** %right1, align 8, !tbaa !0
  %left4 = getelementptr inbounds %struct.case_node* %node.tr, i64 0, i32 0
  %1 = load %struct.case_node** %left4, align 8, !tbaa !0
  %tobool5 = icmp eq %struct.case_node* %1, null
  br i1 %tobool5, label %return, label %if.then6

if.then6:                                         ; preds = %if.end
  store %struct.case_node* null, %struct.case_node** %left4, align 8, !tbaa !0
  br label %tailrecurse

return:                                           ; preds = %if.end
  ret %struct.case_node* %node.tr
}
