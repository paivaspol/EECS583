define zeroext i1 @ix86_fp_jump_nontrivial_p(i32 %code) #1 {
entry:
  %bypass_code = alloca i32, align 4
  %first_code = alloca i32, align 4
  %second_code = alloca i32, align 4
  call void @llvm.dbg.value(metadata !{i32 %code}, i64 0, metadata !2914), !dbg !8062
  call void @llvm.dbg.declare(metadata !{i32* %bypass_code}, metadata !2915), !dbg !8063
  call void @llvm.dbg.declare(metadata !{i32* %first_code}, metadata !2916), !dbg !8063
  call void @llvm.dbg.declare(metadata !{i32* %second_code}, metadata !2917), !dbg !8063
  %0 = load i32* @ix86_arch, align 4, !dbg !8064, !tbaa !4347
  %shl = shl i32 1, %0, !dbg !8064
  %and = and i32 %shl, 104, !dbg !8064
  %tobool = icmp eq i32 %and, 0, !dbg !8064
  br i1 %tobool, label %lor.lhs.false, label %if.end, !dbg !8064

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32* @target_flags, align 4, !dbg !8064, !tbaa !4347
  %and1 = and i32 %1, 327680, !dbg !8064
  %cmp = icmp eq i32 %and1, 0, !dbg !8064
  br i1 %cmp, label %return, label %if.end, !dbg !8064

if.end:                                           ; preds = %lor.lhs.false, %entry
  call fastcc void @ix86_fp_comparison_codes(i32 %code, i32* %bypass_code, i32* %first_code, i32* %second_code) #11, !dbg !8065
  call void @llvm.dbg.value(metadata !{i32* %bypass_code}, i64 0, metadata !2915), !dbg !8066
  %2 = load i32* %bypass_code, align 4, !dbg !8066, !tbaa !5195
  %cmp2 = icmp eq i32 %2, 1, !dbg !8066
  br i1 %cmp2, label %lor.rhs, label %return, !dbg !8066

lor.rhs:                                          ; preds = %if.end
  call void @llvm.dbg.value(metadata !{i32* %second_code}, i64 0, metadata !2917), !dbg !8066
  %3 = load i32* %second_code, align 4, !dbg !8066, !tbaa !5195
  %cmp3 = icmp ne i32 %3, 1, !dbg !8066
  br label %return, !dbg !8066

return:                                           ; preds = %lor.rhs, %if.end, %lor.lhs.false
  %retval.0 = phi i1 [ true, %lor.lhs.false ], [ true, %if.end ], [ %cmp3, %lor.rhs ]
  ret i1 %retval.0, !dbg !8067
}
