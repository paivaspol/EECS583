define internal fastcc void @e64toe(i16* nocapture %pe, i16* nocapture %y) #0 {
for.cond1.preheader:
  %yy = alloca [9 x i16], align 16
  %temp = alloca [9 x i16], align 16
  %arraydecay = getelementptr inbounds [9 x i16]* %yy, i64 0, i64 0
  store i16 0, i16* %arraydecay, align 16, !tbaa !0
  %x4.i = bitcast i16* %y to i8*
  %scevgep = getelementptr [9 x i16]* %yy, i64 0, i64 1
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.cond1.preheader
  %i.1128 = phi i32 [ 0, %for.cond1.preheader ], [ %inc7, %for.body3 ]
  %p.1127 = phi i16* [ %scevgep, %for.cond1.preheader ], [ %incdec.ptr5, %for.body3 ]
  %e.0126 = phi i16* [ %pe, %for.cond1.preheader ], [ %incdec.ptr4, %for.body3 ]
  %incdec.ptr4 = getelementptr inbounds i16* %e.0126, i64 1
  %0 = load i16* %e.0126, align 2, !tbaa !0
  %incdec.ptr5 = getelementptr inbounds i16* %p.1127, i64 1
  store i16 %0, i16* %p.1127, align 2, !tbaa !0
  %inc7 = add nsw i32 %i.1128, 1
  %exitcond131 = icmp eq i32 %inc7, 5
  br i1 %exitcond131, label %for.end8, label %for.body3

for.end8:                                         ; preds = %for.body3
  %arrayidx = getelementptr inbounds [9 x i16]* %yy, i64 0, i64 5
  %1 = load i16* %arrayidx, align 2, !tbaa !0
  %and = and i16 %1, 32767
  %cmp9 = icmp eq i16 %and, 0
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.end8
  %arrayidx11 = getelementptr inbounds [9 x i16]* %yy, i64 0, i64 4
  %2 = bitcast i16* %arrayidx11 to i32*
  %3 = load i32* %2, align 8
  %4 = trunc i32 %3 to i16
  %cmp14 = icmp sgt i16 %4, -1
  %5 = lshr i32 %3, 16
  %6 = trunc i32 %5 to i16
  br i1 %cmp14, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %arraydecay17 = getelementptr inbounds [9 x i16]* %temp, i64 0, i64 0
  call fastcc void @emovi(i16* %arraydecay, i16* %arraydecay17) #6
  %add.ptr.i = getelementptr inbounds [9 x i16]* %temp, i64 0, i64 8
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.then
  %i.025.i = phi i32 [ 2, %if.then ], [ %inc.i, %for.body.i ]
  %bits.024.i = phi i16 [ 0, %if.then ], [ %shl14.i, %for.body.i ]
  %x.addr.023.i = phi i16* [ %add.ptr.i, %if.then ], [ %incdec.ptr.i, %for.body.i ]
  %7 = load i16* %x.addr.023.i, align 2, !tbaa !0
  %.lobit.i = lshr i16 %7, 15
  %or.bits.0.i = or i16 %.lobit.i, %bits.024.i
  %shl.i = shl i16 %7, 1
  %and6.i = lshr exact i16 %bits.024.i, 1
  %8 = and i16 %and6.i, 1
  %9 = or i16 %shl.i, %8
  store i16 %9, i16* %x.addr.023.i, align 2, !tbaa !0
  %shl14.i = shl i16 %or.bits.0.i, 1
  %incdec.ptr.i = getelementptr inbounds i16* %x.addr.023.i, i64 -1
  %inc.i = add nsw i32 %i.025.i, 1
  %exitcond.i = icmp eq i32 %inc.i, 9
  br i1 %exitcond.i, label %eshup1.exit, label %for.body.i

eshup1.exit:                                      ; preds = %for.body.i
  call fastcc void @emovo(i16* %arraydecay17, i16* %y) #6
  br label %for.end95

if.end:                                           ; preds = %land.lhs.true, %for.end8
  %10 = phi i16 [ %6, %land.lhs.true ], [ %1, %for.end8 ]
  %and22 = and i16 %10, 32767
  %cmp23 = icmp eq i16 %and22, 32767
  br i1 %cmp23, label %for.body30, label %for.body90

for.body30:                                       ; preds = %if.end, %for.inc52
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc52 ], [ 0, %if.end ]
  %11 = trunc i64 %indvars.iv to i32
  %cond = icmp eq i32 %11, 3
  %arrayidx42 = getelementptr inbounds i16* %pe, i64 %indvars.iv
  %12 = load i16* %arrayidx42, align 2, !tbaa !0
  br i1 %cond, label %land.lhs.true40, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %for.body30
  %cmp36 = icmp eq i16 %12, 0
  br i1 %cmp36, label %for.inc52, label %if.then46

land.lhs.true40:                                  ; preds = %for.body30
  %cmp44 = icmp eq i16 %12, -32768
  br i1 %cmp44, label %for.inc52, label %if.then46

if.then46:                                        ; preds = %land.lhs.true33, %land.lhs.true40
  %scevgep.i119 = getelementptr i16* %y, i64 5
  %13 = bitcast i16* %y to i64*
  store i64 0, i64* %13, align 2
  %scevgep8.i = getelementptr i16* %y, i64 4
  store i16 -16384, i16* %scevgep8.i, align 2, !tbaa !0
  %or.i121 = or i16 %10, 32767
  store i16 %or.i121, i16* %scevgep.i119, align 2, !tbaa !0
  br label %for.end95

for.inc52:                                        ; preds = %land.lhs.true33, %land.lhs.true40
  %indvars.iv.next = add i64 %indvars.iv, 1
  %14 = trunc i64 %indvars.iv.next to i32
  %cmp28 = icmp slt i32 %14, 4
  br i1 %cmp28, label %for.body30, label %if.end80

if.end80:                                         ; preds = %for.inc52
  call void @llvm.memset.p0i8.i64(i8* %x4.i, i8 0, i64 10, i32 2, i1 false) #1
  call void @llvm.memset.p0i8.i64(i8* %x4.i, i8 0, i64 10, i32 2, i1 false) #1
  %scevgep.i = getelementptr i16* %y, i64 5
  %15 = or i16 %10, 32767
  store i16 %15, i16* %scevgep.i, align 2, !tbaa !0
  ret void

for.body90:                                       ; preds = %if.end, %for.body90
  %i.3125 = phi i32 [ %inc94, %for.body90 ], [ 0, %if.end ]
  %q.0124 = phi i16* [ %incdec.ptr92, %for.body90 ], [ %y, %if.end ]
  %p.2123 = phi i16* [ %incdec.ptr91, %for.body90 ], [ %arraydecay, %if.end ]
  %incdec.ptr91 = getelementptr inbounds i16* %p.2123, i64 1
  %16 = load i16* %p.2123, align 2, !tbaa !0
  %incdec.ptr92 = getelementptr inbounds i16* %q.0124, i64 1
  store i16 %16, i16* %q.0124, align 2, !tbaa !0
  %inc94 = add nsw i32 %i.3125, 1
  %exitcond = icmp eq i32 %inc94, 6
  br i1 %exitcond, label %for.end95, label %for.body90

for.end95:                                        ; preds = %for.body90, %eshup1.exit, %if.then46
  ret void
}
