define i32 @add_double(i64 %l1, i64 %h1, i64 %l2, i64 %h2, i64* nocapture %lv, i64* nocapture %hv) #0 {
entry:
  %uadd = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %l1, i64 %l2)
  %0 = extractvalue { i64, i1 } %uadd, 0
  %add1 = add nsw i64 %h2, %h1
  %cmp = extractvalue { i64, i1 } %uadd, 1
  %conv2 = zext i1 %cmp to i64
  %add3 = add nsw i64 %add1, %conv2
  store i64 %0, i64* %lv, align 8, !tbaa !0
  store i64 %add3, i64* %hv, align 8, !tbaa !0
  %xor = xor i64 %h1, -9223372036854775808
  %neg = xor i64 %xor, %h2
  %xor4 = xor i64 %add3, %h1
  %and = and i64 %xor4, %neg
  %and.lobit = lshr i64 %and, 63
  %1 = trunc i64 %and.lobit to i32
  ret i32 %1
}
