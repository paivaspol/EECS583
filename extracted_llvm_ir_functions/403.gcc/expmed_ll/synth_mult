define internal fastcc void @synth_mult(%struct.algorithm* nocapture %alg_out, i64 %t, i32 %cost_limit) #0 {
entry:
  %conv = trunc i32 %cost_limit to i16
  %cost1 = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 0
  store i16 %conv, i16* %cost1, align 2, !tbaa !5
  %cmp = icmp slt i32 %cost_limit, 1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  switch i64 %t, label %if.end19 [
    i64 1, label %if.then5
    i64 0, label %if.then10
  ]

if.then5:                                         ; preds = %if.end
  %ops = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 1
  store i16 1, i16* %ops, align 2, !tbaa !5
  store i16 0, i16* %cost1, align 2, !tbaa !5
  %arrayidx = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 2, i64 0
  store i32 1, i32* %arrayidx, align 4, !tbaa !10
  br label %return

if.then10:                                        ; preds = %if.end
  %0 = load i32* @zero_cost, align 4, !tbaa !4
  %cmp11 = icmp slt i32 %0, %cost_limit
  br i1 %cmp11, label %if.else, label %return

if.else:                                          ; preds = %if.then10
  %ops14 = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 1
  store i16 1, i16* %ops14, align 2, !tbaa !5
  %conv15 = trunc i32 %0 to i16
  store i16 %conv15, i16* %cost1, align 2, !tbaa !5
  %arrayidx18 = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 2, i64 0
  store i32 0, i32* %arrayidx18, align 4, !tbaa !10
  br label %return

if.end19:                                         ; preds = %if.end
  %1 = alloca %struct.algorithm, align 2
  %2 = alloca %struct.algorithm, align 1
  %and = and i64 %t, 1
  %cmp20 = icmp eq i64 %and, 0
  br i1 %cmp20, label %if.then22, label %for.cond

if.then22:                                        ; preds = %if.end19
  %sub = sub i64 0, %t
  %and23 = and i64 %t, %sub
  %call = call i32 @floor_log2_wide(i64 %and23) #4
  %3 = load i32* @target_flags, align 4, !tbaa !4
  %and24 = lshr i32 %3, 20
  %4 = and i32 %and24, 32
  %5 = add i32 %4, 32
  %cmp25 = icmp slt i32 %call, %5
  br i1 %cmp25, label %if.then27, label %if.end98

if.then27:                                        ; preds = %if.then22
  %sh_prom = zext i32 %call to i64
  %shr = lshr i64 %t, %sh_prom
  %idxprom = sext i32 %call to i64
  %arrayidx28 = getelementptr inbounds [64 x i32]* @shift_cost, i64 0, i64 %idxprom
  %6 = load i32* %arrayidx28, align 4, !tbaa !4
  %sub29 = sub nsw i32 %cost_limit, %6
  call fastcc void @synth_mult(%struct.algorithm* %1, i64 %shr, i32 %sub29) #6
  %cost30 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 0
  %7 = load i16* %cost30, align 2, !tbaa !5
  %conv31 = sext i16 %7 to i32
  %add = add nsw i32 %conv31, %6
  %cmp32 = icmp slt i32 %add, %cost_limit
  br i1 %cmp32, label %if.end45, label %if.end98

if.end45:                                         ; preds = %if.then27
  %conv35 = trunc i32 %call to i8
  %ops36 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 1
  %8 = load i16* %ops36, align 2, !tbaa !5
  %idxprom37 = sext i16 %8 to i64
  %arrayidx38 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 3, i64 %idxprom37
  store i8 %conv35, i8* %arrayidx38, align 1, !tbaa !1
  %9 = load i16* %ops36, align 2, !tbaa !5
  %idxprom40 = sext i16 %9 to i64
  %arrayidx42 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 2, i64 %idxprom40
  store i32 2, i32* %arrayidx42, align 4, !tbaa !10
  br label %if.end98

for.cond:                                         ; preds = %if.end19, %for.cond
  %w.0 = phi i64 [ %shl, %for.cond ], [ 1, %if.end19 ]
  %and50 = and i64 %w.0, %t
  %cmp51 = icmp eq i64 %and50, 0
  %shl = shl i64 %w.0, 1
  br i1 %cmp51, label %for.end, label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp53 = icmp eq i64 %w.0, 0
  br i1 %cmp53, label %if.then59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %cmp55 = icmp ult i64 %w.0, 3
  %cmp57 = icmp eq i64 %t, 3
  %or.cond = or i1 %cmp55, %cmp57
  br i1 %or.cond, label %if.else78, label %if.then59

if.then59:                                        ; preds = %lor.lhs.false, %for.end
  %10 = load i32* @add_cost, align 4, !tbaa !4
  %add60 = add i64 %t, 1
  %sub61 = sub nsw i32 %cost_limit, %10
  call fastcc void @synth_mult(%struct.algorithm* %1, i64 %add60, i32 %sub61) #6
  %cost62 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 0
  %11 = load i16* %cost62, align 2, !tbaa !5
  %conv63 = sext i16 %11 to i32
  %add64 = add nsw i32 %conv63, %10
  %cmp65 = icmp slt i32 %add64, %cost_limit
  br i1 %cmp65, label %if.then67, label %if.end98

if.then67:                                        ; preds = %if.then59
  %ops69 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 1
  %12 = load i16* %ops69, align 2, !tbaa !5
  %idxprom70 = sext i16 %12 to i64
  %arrayidx72 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 3, i64 %idxprom70
  store i8 0, i8* %arrayidx72, align 1, !tbaa !1
  %13 = load i16* %ops69, align 2, !tbaa !5
  %idxprom74 = sext i16 %13 to i64
  %arrayidx76 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 2, i64 %idxprom74
  store i32 4, i32* %arrayidx76, align 4, !tbaa !10
  br label %if.end98

if.else78:                                        ; preds = %lor.lhs.false
  %14 = load i32* @add_cost, align 4, !tbaa !4
  %sub79 = add i64 %t, -1
  %sub80 = sub nsw i32 %cost_limit, %14
  call fastcc void @synth_mult(%struct.algorithm* %1, i64 %sub79, i32 %sub80) #6
  %cost81 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 0
  %15 = load i16* %cost81, align 2, !tbaa !5
  %conv82 = sext i16 %15 to i32
  %add83 = add nsw i32 %conv82, %14
  %cmp84 = icmp slt i32 %add83, %cost_limit
  br i1 %cmp84, label %if.then86, label %if.end98

if.then86:                                        ; preds = %if.else78
  %ops88 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 1
  %16 = load i16* %ops88, align 2, !tbaa !5
  %idxprom89 = sext i16 %16 to i64
  %arrayidx91 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 3, i64 %idxprom89
  store i8 0, i8* %arrayidx91, align 1, !tbaa !1
  %17 = load i16* %ops88, align 2, !tbaa !5
  %idxprom93 = sext i16 %17 to i64
  %arrayidx95 = getelementptr inbounds %struct.algorithm* %1, i64 0, i32 2, i64 %idxprom93
  store i32 3, i32* %arrayidx95, align 4, !tbaa !10
  br label %if.end98

if.end98:                                         ; preds = %if.then27, %if.then22, %if.end45, %if.then67, %if.then59, %if.then86, %if.else78
  %cmp47497 = phi i1 [ true, %if.then67 ], [ true, %if.then59 ], [ true, %if.then86 ], [ true, %if.else78 ], [ false, %if.end45 ], [ false, %if.then22 ], [ false, %if.then27 ]
  %best_alg.1 = phi %struct.algorithm* [ %1, %if.then67 ], [ %2, %if.then59 ], [ %1, %if.then86 ], [ %2, %if.else78 ], [ %1, %if.end45 ], [ %2, %if.then22 ], [ %2, %if.then27 ]
  %alg_in.1 = phi %struct.algorithm* [ %2, %if.then67 ], [ %1, %if.then59 ], [ %2, %if.then86 ], [ %1, %if.else78 ], [ %2, %if.end45 ], [ %1, %if.then22 ], [ %1, %if.then27 ]
  %cost_limit.addr.1 = phi i32 [ %add64, %if.then67 ], [ %cost_limit, %if.then59 ], [ %add83, %if.then86 ], [ %cost_limit, %if.else78 ], [ %add, %if.end45 ], [ %cost_limit, %if.then22 ], [ %cost_limit, %if.then27 ]
  %sub99 = add i64 %t, -1
  %call100 = call i32 @floor_log2_wide(i64 %sub99) #4
  %cmp102507 = icmp sgt i32 %call100, 1
  br i1 %cmp102507, label %for.body104.lr.ph, label %for.end205

for.body104.lr.ph:                                ; preds = %if.end98
  %18 = load i32* @target_flags, align 4, !tbaa !4
  %and114 = lshr i32 %18, 20
  %19 = and i32 %and114, 32
  %20 = add i32 %19, 32
  %21 = zext i32 %call100 to i64
  br label %for.body104

for.body104:                                      ; preds = %for.body104.lr.ph, %for.inc204
  %indvars.iv = phi i64 [ %21, %for.body104.lr.ph ], [ %indvars.iv.next, %for.inc204 ]
  %m.0508 = phi i32 [ %call100, %for.body104.lr.ph ], [ %dec, %for.inc204 ]
  %shl106 = shl i64 1, %indvars.iv
  %add107 = add i64 %shl106, 1
  %rem = urem i64 %t, %add107
  %cmp108 = icmp eq i64 %rem, 0
  %cmp111 = icmp ult i64 %add107, %t
  %or.cond494 = and i1 %cmp108, %cmp111
  br i1 %or.cond494, label %land.lhs.true113, label %if.end151

land.lhs.true113:                                 ; preds = %for.body104
  %22 = trunc i64 %indvars.iv to i32
  %cmp117 = icmp slt i32 %22, %20
  br i1 %cmp117, label %if.then119, label %if.end151

if.then119:                                       ; preds = %land.lhs.true113
  %idxprom120 = sext i32 %m.0508 to i64
  %arrayidx121 = getelementptr inbounds [64 x i32]* @shiftadd_cost, i64 0, i64 %idxprom120
  %23 = load i32* %arrayidx121, align 4, !tbaa !4
  %24 = load i32* @add_cost, align 4, !tbaa !4
  %arrayidx123 = getelementptr inbounds [64 x i32]* @shift_cost, i64 0, i64 %idxprom120
  %25 = load i32* %arrayidx123, align 4, !tbaa !4
  %add124 = add nsw i32 %25, %24
  %cmp125 = icmp slt i32 %23, %add124
  %.add124 = select i1 %cmp125, i32 %23, i32 %add124
  %div = udiv i64 %t, %add107
  %sub133 = sub nsw i32 %cost_limit.addr.1, %.add124
  call fastcc void @synth_mult(%struct.algorithm* %alg_in.1, i64 %div, i32 %sub133) #6
  %cost134 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 0
  %26 = load i16* %cost134, align 2, !tbaa !5
  %conv135 = sext i16 %26 to i32
  %add136 = add nsw i32 %conv135, %.add124
  %cmp137 = icmp slt i32 %add136, %cost_limit.addr.1
  br i1 %cmp137, label %if.then139, label %for.end205

if.then139:                                       ; preds = %if.then119
  %conv141 = trunc i32 %m.0508 to i8
  %ops142 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 1
  %27 = load i16* %ops142, align 2, !tbaa !5
  %idxprom143 = sext i16 %27 to i64
  %arrayidx145 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 3, i64 %idxprom143
  store i8 %conv141, i8* %arrayidx145, align 1, !tbaa !1
  %28 = load i16* %ops142, align 2, !tbaa !5
  %idxprom147 = sext i16 %28 to i64
  %arrayidx149 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 2, i64 %idxprom147
  store i32 5, i32* %arrayidx149, align 4, !tbaa !10
  br label %for.end205

if.end151:                                        ; preds = %land.lhs.true113, %for.body104
  %sub154 = add i64 %shl106, -1
  %rem155 = urem i64 %t, %sub154
  %cmp156 = icmp eq i64 %rem155, 0
  %cmp159 = icmp ult i64 %sub154, %t
  %or.cond495 = and i1 %cmp156, %cmp159
  br i1 %or.cond495, label %land.lhs.true161, label %for.inc204

land.lhs.true161:                                 ; preds = %if.end151
  %29 = trunc i64 %indvars.iv to i32
  %cmp165 = icmp slt i32 %29, %20
  br i1 %cmp165, label %if.then167, label %for.inc204

if.then167:                                       ; preds = %land.lhs.true161
  %idxprom168 = sext i32 %m.0508 to i64
  %arrayidx169 = getelementptr inbounds [64 x i32]* @shiftsub_cost, i64 0, i64 %idxprom168
  %30 = load i32* %arrayidx169, align 4, !tbaa !4
  %31 = load i32* @add_cost, align 4, !tbaa !4
  %arrayidx171 = getelementptr inbounds [64 x i32]* @shift_cost, i64 0, i64 %idxprom168
  %32 = load i32* %arrayidx171, align 4, !tbaa !4
  %add172 = add nsw i32 %32, %31
  %cmp173 = icmp slt i32 %30, %add172
  %.add172 = select i1 %cmp173, i32 %30, i32 %add172
  %div184 = udiv i64 %t, %sub154
  %sub185 = sub nsw i32 %cost_limit.addr.1, %.add172
  call fastcc void @synth_mult(%struct.algorithm* %alg_in.1, i64 %div184, i32 %sub185) #6
  %cost186 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 0
  %33 = load i16* %cost186, align 2, !tbaa !5
  %conv187 = sext i16 %33 to i32
  %add188 = add nsw i32 %conv187, %.add172
  %cmp189 = icmp slt i32 %add188, %cost_limit.addr.1
  br i1 %cmp189, label %if.then191, label %for.end205

if.then191:                                       ; preds = %if.then167
  %conv193 = trunc i32 %m.0508 to i8
  %ops194 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 1
  %34 = load i16* %ops194, align 2, !tbaa !5
  %idxprom195 = sext i16 %34 to i64
  %arrayidx197 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 3, i64 %idxprom195
  store i8 %conv193, i8* %arrayidx197, align 1, !tbaa !1
  %35 = load i16* %ops194, align 2, !tbaa !5
  %idxprom199 = sext i16 %35 to i64
  %arrayidx201 = getelementptr inbounds %struct.algorithm* %alg_in.1, i64 0, i32 2, i64 %idxprom199
  store i32 6, i32* %arrayidx201, align 4, !tbaa !10
  br label %for.end205

for.inc204:                                       ; preds = %if.end151, %land.lhs.true161
  %dec = add nsw i32 %m.0508, -1
  %cmp102 = icmp sgt i32 %dec, 1
  %indvars.iv.next = add i64 %indvars.iv, -1
  br i1 %cmp102, label %for.body104, label %for.end205

for.end205:                                       ; preds = %if.end98, %for.inc204, %if.then167, %if.then191, %if.then119, %if.then139
  %best_alg.2 = phi %struct.algorithm* [ %alg_in.1, %if.then139 ], [ %best_alg.1, %if.then119 ], [ %alg_in.1, %if.then191 ], [ %best_alg.1, %if.then167 ], [ %best_alg.1, %for.inc204 ], [ %best_alg.1, %if.end98 ]
  %alg_in.2 = phi %struct.algorithm* [ %best_alg.1, %if.then139 ], [ %alg_in.1, %if.then119 ], [ %best_alg.1, %if.then191 ], [ %alg_in.1, %if.then167 ], [ %alg_in.1, %for.inc204 ], [ %alg_in.1, %if.end98 ]
  %cost_limit.addr.2 = phi i32 [ %add136, %if.then139 ], [ %cost_limit.addr.1, %if.then119 ], [ %add188, %if.then191 ], [ %cost_limit.addr.1, %if.then167 ], [ %cost_limit.addr.1, %for.inc204 ], [ %cost_limit.addr.1, %if.end98 ]
  br i1 %cmp47497, label %if.then209, label %if.end284

if.then209:                                       ; preds = %for.end205
  %sub211 = sub i64 1, %t
  %and212 = and i64 %sub99, %sub211
  %call213 = call i32 @exact_log2_wide(i64 %and212) #4
  %cmp214 = icmp sgt i32 %call213, -1
  br i1 %cmp214, label %land.lhs.true216, label %if.end246

land.lhs.true216:                                 ; preds = %if.then209
  %36 = load i32* @target_flags, align 4, !tbaa !4
  %and217 = lshr i32 %36, 20
  %37 = and i32 %and217, 32
  %38 = add i32 %37, 32
  %cmp220 = icmp slt i32 %call213, %38
  br i1 %cmp220, label %if.then222, label %if.end246

if.then222:                                       ; preds = %land.lhs.true216
  %idxprom223 = sext i32 %call213 to i64
  %arrayidx224 = getelementptr inbounds [64 x i32]* @shiftadd_cost, i64 0, i64 %idxprom223
  %39 = load i32* %arrayidx224, align 4, !tbaa !4
  %sh_prom226 = zext i32 %call213 to i64
  %shr227 = lshr i64 %sub99, %sh_prom226
  %sub228 = sub nsw i32 %cost_limit.addr.2, %39
  call fastcc void @synth_mult(%struct.algorithm* %alg_in.2, i64 %shr227, i32 %sub228) #6
  %cost229 = getelementptr inbounds %struct.algorithm* %alg_in.2, i64 0, i32 0
  %40 = load i16* %cost229, align 2, !tbaa !5
  %conv230 = sext i16 %40 to i32
  %add231 = add nsw i32 %conv230, %39
  %cmp232 = icmp slt i32 %add231, %cost_limit.addr.2
  br i1 %cmp232, label %if.then234, label %if.end246

if.then234:                                       ; preds = %if.then222
  %conv236 = trunc i32 %call213 to i8
  %ops237 = getelementptr inbounds %struct.algorithm* %alg_in.2, i64 0, i32 1
  %41 = load i16* %ops237, align 2, !tbaa !5
  %idxprom238 = sext i16 %41 to i64
  %arrayidx240 = getelementptr inbounds %struct.algorithm* %alg_in.2, i64 0, i32 3, i64 %idxprom238
  store i8 %conv236, i8* %arrayidx240, align 1, !tbaa !1
  %42 = load i16* %ops237, align 2, !tbaa !5
  %idxprom242 = sext i16 %42 to i64
  %arrayidx244 = getelementptr inbounds %struct.algorithm* %alg_in.2, i64 0, i32 2, i64 %idxprom242
  store i32 7, i32* %arrayidx244, align 4, !tbaa !10
  br label %if.end246

if.end246:                                        ; preds = %if.then222, %if.then234, %land.lhs.true216, %if.then209
  %best_alg.3 = phi %struct.algorithm* [ %alg_in.2, %if.then234 ], [ %best_alg.2, %if.then222 ], [ %best_alg.2, %land.lhs.true216 ], [ %best_alg.2, %if.then209 ]
  %alg_in.3 = phi %struct.algorithm* [ %best_alg.2, %if.then234 ], [ %alg_in.2, %if.then222 ], [ %alg_in.2, %land.lhs.true216 ], [ %alg_in.2, %if.then209 ]
  %cost_limit.addr.3 = phi i32 [ %add231, %if.then234 ], [ %cost_limit.addr.2, %if.then222 ], [ %cost_limit.addr.2, %land.lhs.true216 ], [ %cost_limit.addr.2, %if.then209 ]
  %add247 = add i64 %t, 1
  %sub248 = xor i64 %t, -1
  %and249 = and i64 %add247, %sub248
  %call250 = call i32 @exact_log2_wide(i64 %and249) #4
  %cmp251 = icmp sgt i32 %call250, -1
  br i1 %cmp251, label %land.lhs.true253, label %if.end284

land.lhs.true253:                                 ; preds = %if.end246
  %43 = load i32* @target_flags, align 4, !tbaa !4
  %and254 = lshr i32 %43, 20
  %44 = and i32 %and254, 32
  %45 = add i32 %44, 32
  %cmp257 = icmp slt i32 %call250, %45
  br i1 %cmp257, label %if.then259, label %if.end284

if.then259:                                       ; preds = %land.lhs.true253
  %idxprom260 = sext i32 %call250 to i64
  %arrayidx261 = getelementptr inbounds [64 x i32]* @shiftsub_cost, i64 0, i64 %idxprom260
  %46 = load i32* %arrayidx261, align 4, !tbaa !4
  %sh_prom263 = zext i32 %call250 to i64
  %shr264 = lshr i64 %add247, %sh_prom263
  %sub265 = sub nsw i32 %cost_limit.addr.3, %46
  call fastcc void @synth_mult(%struct.algorithm* %alg_in.3, i64 %shr264, i32 %sub265) #6
  %cost266 = getelementptr inbounds %struct.algorithm* %alg_in.3, i64 0, i32 0
  %47 = load i16* %cost266, align 2, !tbaa !5
  %conv267 = sext i16 %47 to i32
  %add268 = add nsw i32 %conv267, %46
  %cmp269 = icmp slt i32 %add268, %cost_limit.addr.3
  br i1 %cmp269, label %if.then271, label %if.end284

if.then271:                                       ; preds = %if.then259
  %conv273 = trunc i32 %call250 to i8
  %ops274 = getelementptr inbounds %struct.algorithm* %alg_in.3, i64 0, i32 1
  %48 = load i16* %ops274, align 2, !tbaa !5
  %idxprom275 = sext i16 %48 to i64
  %arrayidx277 = getelementptr inbounds %struct.algorithm* %alg_in.3, i64 0, i32 3, i64 %idxprom275
  store i8 %conv273, i8* %arrayidx277, align 1, !tbaa !1
  %49 = load i16* %ops274, align 2, !tbaa !5
  %idxprom279 = sext i16 %49 to i64
  %arrayidx281 = getelementptr inbounds %struct.algorithm* %alg_in.3, i64 0, i32 2, i64 %idxprom279
  store i32 8, i32* %arrayidx281, align 4, !tbaa !10
  br label %if.end284

if.end284:                                        ; preds = %if.end246, %land.lhs.true253, %if.then271, %if.then259, %for.end205
  %best_alg.4 = phi %struct.algorithm* [ %alg_in.3, %if.then271 ], [ %best_alg.3, %if.then259 ], [ %best_alg.3, %land.lhs.true253 ], [ %best_alg.3, %if.end246 ], [ %best_alg.2, %for.end205 ]
  %cost_limit.addr.4 = phi i32 [ %add268, %if.then271 ], [ %cost_limit.addr.3, %if.then259 ], [ %cost_limit.addr.3, %land.lhs.true253 ], [ %cost_limit.addr.3, %if.end246 ], [ %cost_limit.addr.2, %for.end205 ]
  %50 = load i16* %cost1, align 2, !tbaa !5
  %conv286 = sext i16 %50 to i32
  %cmp287 = icmp eq i32 %cost_limit.addr.4, %conv286
  br i1 %cmp287, label %return, label %if.end290

if.end290:                                        ; preds = %if.end284
  %ops291 = getelementptr inbounds %struct.algorithm* %best_alg.4, i64 0, i32 1
  %51 = load i16* %ops291, align 2, !tbaa !5
  %cmp293 = icmp eq i16 %51, 64
  br i1 %cmp293, label %return, label %if.end296

if.end296:                                        ; preds = %if.end290
  %add299 = add i16 %51, 1
  %ops301 = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 1
  store i16 %add299, i16* %ops301, align 2, !tbaa !5
  %conv302 = trunc i32 %cost_limit.addr.4 to i16
  store i16 %conv302, i16* %cost1, align 2, !tbaa !5
  %op304 = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 2
  %52 = bitcast [64 x i32]* %op304 to i8*
  %op305 = getelementptr inbounds %struct.algorithm* %best_alg.4, i64 0, i32 2
  %53 = bitcast [64 x i32]* %op305 to i8*
  %conv307 = sext i16 %add299 to i64
  %mul = shl nsw i64 %conv307, 2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* %53, i64 %mul, i32 4, i1 false)
  %54 = getelementptr inbounds %struct.algorithm* %alg_out, i64 0, i32 3, i64 0
  %55 = getelementptr inbounds %struct.algorithm* %best_alg.4, i64 0, i32 3, i64 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 %conv307, i32 4, i1 false)
  br label %return

return:                                           ; preds = %if.then10, %if.end290, %if.end284, %entry, %if.end296, %if.else, %if.then5
  ret void
}
