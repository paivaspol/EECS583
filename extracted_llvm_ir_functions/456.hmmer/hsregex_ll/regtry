define internal fastcc i32 @regtry(%struct.exec* %ep, %struct.sqd_regexp* %prog, i8* %string) #0 {
entry:
  %reginput = getelementptr inbounds %struct.exec* %ep, i64 0, i32 0
  store i8* %string, i8** %reginput, align 8, !tbaa !0
  %arraydecay = getelementptr inbounds %struct.sqd_regexp* %prog, i64 0, i32 0, i64 0
  %arraydecay1 = getelementptr inbounds %struct.sqd_regexp* %prog, i64 0, i32 1, i64 0
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %enp.018 = phi i8** [ %arraydecay1, %entry ], [ %incdec.ptr2, %for.body ]
  %stp.017 = phi i8** [ %arraydecay, %entry ], [ %incdec.ptr, %for.body ]
  %i.016 = phi i32 [ 10, %entry ], [ %dec, %for.body ]
  %incdec.ptr = getelementptr inbounds i8** %stp.017, i64 1
  store i8* null, i8** %stp.017, align 8, !tbaa !0
  %incdec.ptr2 = getelementptr inbounds i8** %enp.018, i64 1
  store i8* null, i8** %enp.018, align 8, !tbaa !0
  %dec = add nsw i32 %i.016, -1
  %cmp = icmp sgt i32 %dec, 0
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  %add.ptr = getelementptr inbounds %struct.sqd_regexp* %prog, i64 0, i32 6, i64 1
  %call = tail call fastcc i32 @regmatch(%struct.exec* %ep, i8* %add.ptr) #10
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %for.end
  store i8* %string, i8** %arraydecay, align 8, !tbaa !0
  %0 = load i8** %reginput, align 8, !tbaa !0
  store i8* %0, i8** %arraydecay1, align 8, !tbaa !0
  br label %return

return:                                           ; preds = %for.end, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 0, %for.end ]
  ret i32 %retval.0
}
