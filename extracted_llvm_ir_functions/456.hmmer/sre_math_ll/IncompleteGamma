define double @IncompleteGamma(double %a, double %x) #0 {
entry:
  %cmp = fcmp ugt double %a, 0.000000e+00
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void (i8*, ...)* @Die(i8* getelementptr inbounds ([33 x i8]* @.str1, i64 0, i64 0)) #4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %cmp1 = fcmp olt double %x, 0.000000e+00
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  tail call void (i8*, ...)* @Die(i8* getelementptr inbounds ([34 x i8]* @.str2, i64 0, i64 0)) #4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %add = fadd double %a, 1.000000e+00
  %cmp4 = fcmp olt double %add, %x
  br i1 %cmp4, label %for.body, label %if.else

for.cond:                                         ; preds = %if.end25
  %cmp6 = icmp slt i32 %inc, 100
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %if.end3, %for.cond
  %de1.0116 = phi double [ %de1.1, %for.cond ], [ %x, %if.end3 ]
  %de0.0115 = phi double [ %de0.1, %for.cond ], [ 1.000000e+00, %if.end3 ]
  %nu0.0114 = phi double [ %nu0.1, %for.cond ], [ 0.000000e+00, %if.end3 ]
  %oldp.0113 = phi double [ %nu1.1, %for.cond ], [ 1.000000e+00, %if.end3 ]
  %iter.0112 = phi i32 [ %inc, %for.cond ], [ 1, %if.end3 ]
  %conv = sitofp i32 %iter.0112 to double
  %sub = fsub double %conv, %a
  %mul = fmul double %sub, %nu0.0114
  %add7 = fadd double %oldp.0113, %mul
  %mul10 = fmul double %sub, %de0.0115
  %add11 = fadd double %de1.0116, %mul10
  %mul12 = fmul double %add7, %x
  %mul14 = fmul double %conv, %oldp.0113
  %add15 = fadd double %mul14, %mul12
  %mul16 = fmul double %add11, %x
  %mul18 = fmul double %conv, %de1.0116
  %add19 = fadd double %mul18, %mul16
  %cmp20 = fcmp une double %add19, 0.000000e+00
  br i1 %cmp20, label %if.then22, label %if.end25

if.then22:                                        ; preds = %for.body
  %div = fdiv double %add7, %add19
  %div23 = fdiv double %add11, %add19
  %div24 = fdiv double %add15, %add19
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %for.body
  %nu0.1 = phi double [ %div, %if.then22 ], [ %add7, %for.body ]
  %nu1.1 = phi double [ %div24, %if.then22 ], [ %add15, %for.body ]
  %de0.1 = phi double [ %div23, %if.then22 ], [ %add11, %for.body ]
  %de1.1 = phi double [ 1.000000e+00, %if.then22 ], [ %add19, %for.body ]
  %sub26 = fsub double %nu1.1, %oldp.0113
  %div27 = fdiv double %sub26, %nu1.1
  %call = tail call double @fabs(double %div27) #5
  %cmp28 = fcmp olt double %call, 1.000000e-07
  %inc = add nsw i32 %iter.0112, 1
  br i1 %cmp28, label %if.then30, label %for.cond

if.then30:                                        ; preds = %if.end25
  %call31 = tail call double @log(double %x) #4
  %mul32 = fmul double %call31, %a
  %sub33 = fsub double %mul32, %x
  %call34 = tail call double @Gammln(double %a) #6
  %sub35 = fsub double %sub33, %call34
  %call36 = tail call double @exp(double %sub35) #4
  %mul37 = fmul double %nu1.1, %call36
  br label %return

for.end:                                          ; preds = %for.cond
  tail call void (i8*, ...)* @Die(i8* getelementptr inbounds ([70 x i8]* @.str3, i64 0, i64 0)) #4
  br label %return

if.else:                                          ; preds = %if.end3
  %div39 = fdiv double 1.000000e+00, %a
  br label %for.body43

for.cond40:                                       ; preds = %for.body43
  %cmp41 = icmp slt i32 %inc64, 10000
  br i1 %cmp41, label %for.body43, label %for.end65

for.body43:                                       ; preds = %if.else, %for.cond40
  %val.0119 = phi double [ %div39, %if.else ], [ %mul47, %for.cond40 ]
  %p.0118 = phi double [ %div39, %if.else ], [ %add48, %for.cond40 ]
  %iter.1117 = phi i32 [ 1, %if.else ], [ %inc64, %for.cond40 ]
  %conv44 = sitofp i32 %iter.1117 to double
  %add45 = fadd double %conv44, %a
  %div46 = fdiv double %x, %add45
  %mul47 = fmul double %val.0119, %div46
  %add48 = fadd double %p.0118, %mul47
  %div49 = fdiv double %mul47, %add48
  %call50 = tail call double @fabs(double %div49) #5
  %cmp51 = fcmp olt double %call50, 1.000000e-07
  %inc64 = add nsw i32 %iter.1117, 1
  br i1 %cmp51, label %if.then53, label %for.cond40

if.then53:                                        ; preds = %for.body43
  %call54 = tail call double @log(double %x) #4
  %mul55 = fmul double %call54, %a
  %sub56 = fsub double %mul55, %x
  %call57 = tail call double @Gammln(double %a) #6
  %sub58 = fsub double %sub56, %call57
  %call59 = tail call double @exp(double %sub58) #4
  %mul60 = fmul double %add48, %call59
  %sub61 = fsub double 1.000000e+00, %mul60
  br label %return

for.end65:                                        ; preds = %for.cond40
  tail call void (i8*, ...)* @Die(i8* getelementptr inbounds ([58 x i8]* @.str4, i64 0, i64 0)) #4
  br label %return

return:                                           ; preds = %for.end, %for.end65, %if.then53, %if.then30
  %retval.0 = phi double [ %mul37, %if.then30 ], [ %sub61, %if.then53 ], [ 0.000000e+00, %for.end65 ], [ 0.000000e+00, %for.end ]
  ret double %retval.0
}
