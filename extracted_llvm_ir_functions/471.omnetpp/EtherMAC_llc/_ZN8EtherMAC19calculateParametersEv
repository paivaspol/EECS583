define void @_ZN8EtherMAC19calculateParametersEv(%class.EtherMAC* %this) #0 align 2 {
  %1 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 1
  %2 = load i8* %1, align 1, !tbaa !24, !range !30
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %9, label %4

; <label>:4                                       ; preds = %0
  %5 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 10
  %6 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 7
  store i8 0, i8* %6, align 1, !tbaa !42
  %7 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 6
  store i8 0, i8* %7, align 1, !tbaa !43
  %8 = bitcast double* %5 to i8*
  call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 40, i32 8, i1 false)
  br label %41

; <label>:9                                       ; preds = %0
  %10 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 9
  %11 = load double* %10, align 8, !tbaa !32
  %12 = fcmp une double %11, 1.000000e+07
  %13 = fcmp une double %11, 1.000000e+08
  %or.cond = and i1 %12, %13
  %14 = fcmp une double %11, 1.000000e+09
  %or.cond1 = and i1 %14, %or.cond
  br i1 %or.cond1, label %15, label %17

; <label>:15                                      ; preds = %9
  %16 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 0
  tail call void (%class.cSimpleModule*, i8*, ...)* @_ZNK13cSimpleModule5errorEPKcz(%class.cSimpleModule* %16, i8* getelementptr inbounds ([52 x i8]* @.str55, i64 0, i64 0), i64 10000000, i64 100000000, i64 1000000000) #10
  %.pre = load double* %10, align 8, !tbaa !32
  br label %17

; <label>:17                                      ; preds = %15, %9
  %18 = phi double [ %.pre, %15 ], [ %11, %9 ]
  %19 = fdiv double 1.000000e+00, %18
  %20 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 10
  store double %19, double* %20, align 8, !tbaa !44
  %21 = fcmp oeq double %18, 1.000000e+09
  br i1 %21, label %22, label %26

; <label>:22                                      ; preds = %17
  %23 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 5
  %24 = load i8* %23, align 1, !tbaa !33, !range !30
  %25 = xor i8 %24, 1
  br label %26

; <label>:26                                      ; preds = %22, %17
  %27 = phi i8 [ 0, %17 ], [ %25, %22 ]
  %28 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 6
  store i8 %27, i8* %28, align 1, !tbaa !43
  %29 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 7
  %30 = zext i1 %21 to i8
  store i8 %30, i8* %29, align 1, !tbaa !42
  %31 = fcmp oeq double %18, 1.000000e+07
  %32 = fcmp oeq double %18, 1.000000e+08
  %or.cond2 = or i1 %31, %32
  %33 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 11
  %. = select i1 %or.cond2, double 5.120000e-05, double 4.096000e-06
  store double %., double* %33, align 8, !tbaa !45
  %34 = fdiv double 9.600000e+01, %18
  %35 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 12
  store double %34, double* %35, align 8, !tbaa !46
  %36 = fmul double %19, 3.200000e+01
  %37 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 13
  store double %36, double* %37, align 8, !tbaa !47
  %38 = icmp ne i8 %27, 0
  %39 = select i1 %38, double 5.120000e+02, double 6.400000e+01
  %40 = getelementptr inbounds %class.EtherMAC* %this, i64 0, i32 14
  store double %39, double* %40, align 8, !tbaa !48
  br label %41

; <label>:41                                      ; preds = %26, %4
  ret void
}
