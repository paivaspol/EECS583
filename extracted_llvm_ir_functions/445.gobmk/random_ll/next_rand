define internal fastcc i32 @next_rand() #0 {
  %.b = load i1* @rand_initialized, align 1
  br i1 %.b, label %2, label %1, !dbg !85

; <label>:1                                       ; preds = %0
  tail call void @__assert_rtn(i8* getelementptr inbounds ([10 x i8]* @__func__.next_rand, i64 0, i64 0), i8* getelementptr inbounds ([70 x i8]* @.str, i64 0, i64 0), i32 90, i8* getelementptr inbounds ([17 x i8]* @.str1, i64 0, i64 0)) #4, !dbg !86
  unreachable, !dbg !86

; <label>:2                                       ; preds = %0
  %3 = load i32* @k, align 4, !dbg !89, !tbaa !74
  %4 = add nsw i32 %3, 1, !dbg !89
  store i32 %4, i32* @k, align 4, !dbg !89, !tbaa !74
  %5 = icmp eq i32 %4, 25, !dbg !91
  br i1 %5, label %vector.body, label %30, !dbg !92

vector.body:                                      ; preds = %2, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %2 ], !dbg !93
  %6 = add i64 %index, 7, !dbg !95
  %7 = getelementptr inbounds [25 x i32]* @x, i64 0, i64 %6, !dbg !95
  %8 = bitcast i32* %7 to <2 x i32>*, !dbg !95
  %wide.load = load <2 x i32>* %8, align 4, !dbg !95, !tbaa !74
  %9 = getelementptr inbounds [25 x i32]* @x, i64 0, i64 %index, !dbg !99
  %10 = bitcast i32* %9 to <2 x i32>*, !dbg !99
  %wide.load1 = load <2 x i32>* %10, align 8, !dbg !99, !tbaa !74
  %11 = lshr <2 x i32> %wide.load1, <i32 1, i32 1>, !dbg !100
  %12 = xor <2 x i32> %11, %wide.load, !dbg !101
  %13 = and <2 x i32> %wide.load1, <i32 1, i32 1>, !dbg !102
  %14 = icmp ne <2 x i32> %13, zeroinitializer, !dbg !103
  %15 = select <2 x i1> %14, <2 x i32> <i32 -1900031960, i32 -1900031960>, <2 x i32> zeroinitializer, !dbg !103
  %16 = xor <2 x i32> %12, %15, !dbg !104
  %17 = bitcast i32* %9 to <2 x i32>*, !dbg !105
  store <2 x i32> %16, <2 x i32>* %17, align 8, !dbg !105, !tbaa !74
  %index.next = add i64 %index, 2, !dbg !93
  %18 = icmp eq i64 %index.next, 18, !dbg !93
  br i1 %18, label %.lr.ph.i, label %vector.body, !dbg !93, !llvm.loop !106

.lr.ph.i:                                         ; preds = %vector.body, %.lr.ph.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %.lr.ph.i ], [ 18, %vector.body ], !dbg !93
  %19 = add nsw i64 %indvars.iv.i, -18, !dbg !109
  %20 = getelementptr inbounds [25 x i32]* @x, i64 0, i64 %19, !dbg !112
  %21 = load i32* %20, align 4, !dbg !112, !tbaa !74
  %22 = getelementptr inbounds [25 x i32]* @x, i64 0, i64 %indvars.iv.i, !dbg !113
  %23 = load i32* %22, align 4, !dbg !113, !tbaa !74
  %24 = lshr i32 %23, 1, !dbg !114
  %25 = xor i32 %24, %21, !dbg !115
  %26 = and i32 %23, 1, !dbg !116
  %27 = icmp ne i32 %26, 0, !dbg !117
  %28 = select i1 %27, i32 -1900031960, i32 0, !dbg !117
  %29 = xor i32 %25, %28, !dbg !118
  store i32 %29, i32* %22, align 4, !dbg !119, !tbaa !74
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1, !dbg !120
  %exitcond = icmp eq i64 %indvars.iv.next.i, 25, !dbg !120
  br i1 %exitcond, label %iterate_tgfsr.exit, label %.lr.ph.i, !dbg !120

iterate_tgfsr.exit:                               ; preds = %.lr.ph.i
  store i32 0, i32* @k, align 4, !dbg !121, !tbaa !74
  br label %30, !dbg !122

; <label>:30                                      ; preds = %iterate_tgfsr.exit, %2
  %31 = phi i32 [ 0, %iterate_tgfsr.exit ], [ %4, %2 ]
  %32 = sext i32 %31 to i64, !dbg !123
  %33 = getelementptr inbounds [25 x i32]* @x, i64 0, i64 %32, !dbg !123
  %34 = load i32* %33, align 4, !dbg !123, !tbaa !74
  %35 = shl i32 %34, 7, !dbg !124
  %36 = and i32 %35, 727393536, !dbg !125
  %37 = xor i32 %36, %34, !dbg !126
  tail call void @llvm.dbg.value(metadata i32 %37, i64 0, metadata !43, metadata !65), !dbg !127
  %38 = shl i32 %37, 15, !dbg !128
  %39 = and i32 %38, -611647488, !dbg !129
  %40 = xor i32 %39, %37, !dbg !130
  tail call void @llvm.dbg.value(metadata i32 %40, i64 0, metadata !43, metadata !65), !dbg !127
  ret i32 %40, !dbg !131
}
