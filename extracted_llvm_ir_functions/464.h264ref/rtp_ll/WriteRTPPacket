define i32 @WriteRTPPacket(%struct.RTPpacket_t* nocapture %p, %struct._IO_FILE* nocapture %f) #0 {
entry:
  %intime = alloca i32, align 4
  store i32 -1, i32* %intime, align 4, !tbaa !0
  %packlen = getelementptr inbounds %struct.RTPpacket_t* %p, i64 0, i32 12
  %0 = bitcast i32* %packlen to i8*
  %call = call i64 @fwrite(i8* %0, i64 4, i64 1, %struct._IO_FILE* %f) #5
  %cmp = icmp eq i64 %call, 1
  br i1 %cmp, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = bitcast i32* %intime to i8*
  %call1 = call i64 @fwrite(i8* %1, i64 4, i64 1, %struct._IO_FILE* %f) #5
  %cmp2 = icmp eq i64 %call1, 1
  br i1 %cmp2, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %packet = getelementptr inbounds %struct.RTPpacket_t* %p, i64 0, i32 11
  %2 = load i8** %packet, align 8, !tbaa !3
  %3 = load i32* %packlen, align 4, !tbaa !0
  %conv = zext i32 %3 to i64
  %call6 = call i64 @fwrite(i8* %2, i64 %conv, i64 1, %struct._IO_FILE* %f) #5
  %not.cmp7 = icmp ne i64 %call6, 1
  %. = sext i1 %not.cmp7 to i32
  br label %return

return:                                           ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ -1, %if.end ], [ %., %if.end4 ]
  ret i32 %retval.0
}
