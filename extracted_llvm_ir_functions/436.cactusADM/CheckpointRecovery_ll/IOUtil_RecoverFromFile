define internal fastcc i32 @IOUtil_RecoverFromFile(%struct.cGH* %GH, i8* %basefilename, i32 %called_from) #1 {
  tail call void @llvm.dbg.value(metadata %struct.cGH* %GH, i64 0, metadata !528, metadata !598), !dbg !699
  tail call void @llvm.dbg.value(metadata i8* %basefilename, i64 0, metadata !529, metadata !598), !dbg !700
  tail call void @llvm.dbg.value(metadata i32 %called_from, i64 0, metadata !530, metadata !598), !dbg !701
  tail call void @llvm.dbg.value(metadata i32 -1, i64 0, metadata !532, metadata !598), !dbg !702
  tail call void @llvm.dbg.value(metadata i32 0, i64 0, metadata !531, metadata !598), !dbg !703
  %1 = load i32* @num_functions, align 4, !dbg !704, !tbaa !615
  %2 = icmp sgt i32 %1, 0, !dbg !707
  br i1 %2, label %.lr.ph, label %.loopexit.thread, !dbg !708

.lr.ph:                                           ; preds = %0, %10
  %handle.05 = phi i32 [ %11, %10 ], [ 0, %0 ]
  %retval.04 = phi i32 [ %retval.1, %10 ], [ -1, %0 ]
  %3 = load %struct.cHandledData** @RecoverFunctions, align 8, !dbg !709, !tbaa !602
  %4 = tail call i8* @Util_GetHandledData(%struct.cHandledData* %3, i32 %handle.05) #7, !dbg !711
  tail call void @llvm.dbg.value(metadata i32 (%struct.cGH*, i8*, i32)* %7, i64 0, metadata !533, metadata !598), !dbg !712
  %5 = icmp eq i8* %4, null, !dbg !713
  br i1 %5, label %10, label %6, !dbg !715

; <label>:6                                       ; preds = %.lr.ph
  %7 = bitcast i8* %4 to i32 (%struct.cGH*, i8*, i32)*, !dbg !716
  %8 = tail call i32 %7(%struct.cGH* %GH, i8* %basefilename, i32 %called_from) #7, !dbg !717
  tail call void @llvm.dbg.value(metadata i32 %8, i64 0, metadata !532, metadata !598), !dbg !702
  %9 = icmp sgt i32 %8, -1, !dbg !719
  br i1 %9, label %thread-pre-split, label %10, !dbg !721

; <label>:10                                      ; preds = %.lr.ph, %6
  %retval.1 = phi i32 [ %8, %6 ], [ %retval.04, %.lr.ph ]
  %11 = add nuw nsw i32 %handle.05, 1, !dbg !722
  tail call void @llvm.dbg.value(metadata i32 %11, i64 0, metadata !531, metadata !598), !dbg !703
  %12 = load i32* @num_functions, align 4, !dbg !704, !tbaa !615
  %13 = icmp slt i32 %11, %12, !dbg !707
  br i1 %13, label %.lr.ph, label %.loopexit, !dbg !708

thread-pre-split:                                 ; preds = %6
  %.pr = load i32* @num_functions, align 4, !dbg !723, !tbaa !615
  br label %.loopexit

.loopexit:                                        ; preds = %10, %thread-pre-split
  %14 = phi i32 [ %.pr, %thread-pre-split ], [ %12, %10 ], !dbg !723
  %retval.2 = phi i32 [ %8, %thread-pre-split ], [ %retval.1, %10 ]
  %15 = icmp slt i32 %14, 1, !dbg !725
  br i1 %15, label %.loopexit.thread, label %17, !dbg !726

.loopexit.thread:                                 ; preds = %0, %.loopexit
  %retval.210 = phi i32 [ %retval.2, %.loopexit ], [ -1, %0 ]
  %16 = tail call i32 @CCTK_Warn(i32 1, i32 305, i8* getelementptr inbounds ([87 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str2, i64 0, i64 0), i8* getelementptr inbounds ([61 x i8]* @.str30, i64 0, i64 0)) #7, !dbg !727
  br label %17, !dbg !729

; <label>:17                                      ; preds = %.loopexit.thread, %.loopexit
  %retval.29 = phi i32 [ %retval.210, %.loopexit.thread ], [ %retval.2, %.loopexit ]
  ret i32 %retval.29, !dbg !730
}
