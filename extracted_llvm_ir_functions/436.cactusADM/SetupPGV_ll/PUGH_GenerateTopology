define i32 @PUGH_GenerateTopology(i32 %dim, i32 %total_procs, i32* nocapture %nprocs) #1 {
  %1 = icmp sgt i32 %dim, 0
  br i1 %1, label %.lr.ph20, label %._crit_edge21

.lr.ph20:                                         ; preds = %0
  %2 = add i32 %dim, -1
  br label %3

; <label>:3                                       ; preds = %19, %.lr.ph20
  %indvars.iv30 = phi i64 [ 0, %.lr.ph20 ], [ %indvars.iv.next31, %19 ]
  %free_dims.017 = phi i32 [ %dim, %.lr.ph20 ], [ %free_dims.1, %19 ]
  %retval.016 = phi i32 [ 0, %.lr.ph20 ], [ %retval.1, %19 ]
  %free_procs.015 = phi i32 [ %total_procs, %.lr.ph20 ], [ %free_procs.1, %19 ]
  %used_procs.014 = phi i32 [ 0, %.lr.ph20 ], [ %used_procs.2, %19 ]
  %4 = getelementptr inbounds i32* %nprocs, i64 %indvars.iv30
  %5 = load i32* %4, align 4, !tbaa !20
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %19

; <label>:7                                       ; preds = %3
  %8 = add nsw i32 %free_dims.017, -1
  %9 = icmp eq i32 %used_procs.014, 0
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %7
  %11 = mul nsw i32 %5, %used_procs.014
  br label %12

; <label>:12                                      ; preds = %7, %10
  %used_procs.1 = phi i32 [ %11, %10 ], [ %5, %7 ]
  %13 = srem i32 %total_procs, %used_procs.1
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %12
  %16 = tail call i32 @CCTK_Warn(i32 0, i32 325, i8* getelementptr inbounds ([75 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8]* @.str2, i64 0, i64 0)) #7
  br label %19

; <label>:17                                      ; preds = %12
  %18 = sdiv i32 %total_procs, %used_procs.1
  br label %19

; <label>:19                                      ; preds = %3, %17, %15
  %used_procs.2 = phi i32 [ %used_procs.1, %15 ], [ %used_procs.1, %17 ], [ %used_procs.014, %3 ]
  %free_procs.1 = phi i32 [ %free_procs.015, %15 ], [ %18, %17 ], [ %free_procs.015, %3 ]
  %retval.1 = phi i32 [ 1, %15 ], [ %retval.016, %17 ], [ %retval.016, %3 ]
  %free_dims.1 = phi i32 [ %8, %15 ], [ %8, %17 ], [ %free_dims.017, %3 ]
  %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1
  %lftr.wideiv32 = trunc i64 %indvars.iv30 to i32
  %exitcond33 = icmp eq i32 %lftr.wideiv32, %2
  br i1 %exitcond33, label %._crit_edge21, label %3

._crit_edge21:                                    ; preds = %19, %0
  %free_dims.0.lcssa = phi i32 [ %dim, %0 ], [ %free_dims.1, %19 ]
  %retval.0.lcssa = phi i32 [ 0, %0 ], [ %retval.1, %19 ]
  %free_procs.0.lcssa = phi i32 [ %total_procs, %0 ], [ %free_procs.1, %19 ]
  %20 = icmp eq i32 %free_dims.0.lcssa, 0
  %21 = icmp ne i32 %retval.0.lcssa, 0
  %or.cond = or i1 %21, %20
  br i1 %or.cond, label %58, label %22

; <label>:22                                      ; preds = %._crit_edge21
  %23 = sext i32 %free_dims.0.lcssa to i64
  %24 = tail call i8* @calloc(i64 %23, i64 4) #7
  %25 = bitcast i8* %24 to i32*
  %26 = icmp sgt i32 %free_dims.0.lcssa, 0
  br i1 %26, label %.lr.ph12, label %._crit_edge13

.lr.ph12:                                         ; preds = %22
  %27 = add i32 %free_dims.0.lcssa, -1
  br label %28

; <label>:28                                      ; preds = %43, %.lr.ph12
  %indvars.iv26 = phi i64 [ 0, %.lr.ph12 ], [ %indvars.iv.next27, %43 ]
  %root.010 = phi i32 [ %free_dims.0.lcssa, %.lr.ph12 ], [ %46, %43 ]
  %free_procs.27 = phi i32 [ %free_procs.0.lcssa, %.lr.ph12 ], [ %45, %43 ]
  %29 = icmp slt i32 %free_procs.27, 1
  br i1 %29, label %PUGH_IntegerRoot.exit, label %.preheader.lr.ph.i

.preheader.lr.ph.i:                               ; preds = %28
  %30 = icmp sgt i32 %root.010, 1
  %31 = add i32 %root.010, -1
  br label %.preheader.i

.preheader.i:                                     ; preds = %37, %.preheader.lr.ph.i
  %root.04.i = phi i32 [ 1, %.preheader.lr.ph.i ], [ %38, %37 ]
  br i1 %30, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %.preheader.i, %.lr.ph.i
  %tmp.03.i = phi i32 [ %33, %.lr.ph.i ], [ %root.04.i, %.preheader.i ]
  %i.02.i = phi i32 [ %32, %.lr.ph.i ], [ 1, %.preheader.i ]
  %32 = add nuw nsw i32 %i.02.i, 1
  %33 = mul nsw i32 %tmp.03.i, %root.04.i
  %exitcond.i = icmp eq i32 %i.02.i, %31
  br i1 %exitcond.i, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i, %.preheader.i
  %tmp.0.lcssa.i = phi i32 [ %root.04.i, %.preheader.i ], [ %33, %.lr.ph.i ]
  %34 = icmp sgt i32 %tmp.0.lcssa.i, %free_procs.27
  br i1 %34, label %35, label %37

; <label>:35                                      ; preds = %._crit_edge.i
  %36 = add nsw i32 %root.04.i, -1
  br label %PUGH_IntegerRoot.exit

; <label>:37                                      ; preds = %._crit_edge.i
  %38 = add nuw nsw i32 %root.04.i, 1
  %39 = icmp slt i32 %root.04.i, %free_procs.27
  br i1 %39, label %.preheader.i, label %PUGH_IntegerRoot.exit

PUGH_IntegerRoot.exit:                            ; preds = %35, %28, %37, %PUGH_IntegerRoot.exit
  %storemerge = phi i32 [ %42, %PUGH_IntegerRoot.exit ], [ 1, %28 ], [ %36, %35 ], [ %38, %37 ]
  %40 = srem i32 %free_procs.27, %storemerge
  %41 = icmp eq i32 %40, 0
  %42 = add nsw i32 %storemerge, -1
  br i1 %41, label %43, label %PUGH_IntegerRoot.exit

; <label>:43                                      ; preds = %PUGH_IntegerRoot.exit
  %44 = getelementptr inbounds i32* %25, i64 %indvars.iv26
  store i32 %storemerge, i32* %44, align 4, !tbaa !20
  %45 = sdiv i32 %free_procs.27, %storemerge
  %46 = add nsw i32 %root.010, -1
  %indvars.iv.next27 = add nuw nsw i64 %indvars.iv26, 1
  %lftr.wideiv28 = trunc i64 %indvars.iv26 to i32
  %exitcond29 = icmp eq i32 %lftr.wideiv28, %27
  br i1 %exitcond29, label %._crit_edge13, label %28

._crit_edge13:                                    ; preds = %43, %22
  tail call void @qsort(i8* %24, i64 %23, i64 4, i32 (i8*, i8*)* @IntSort) #7
  br i1 %1, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %._crit_edge13
  %47 = add i32 %dim, -1
  br label %48

; <label>:48                                      ; preds = %57, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %57 ]
  %place.05 = phi i32 [ 0, %.lr.ph ], [ %place.1, %57 ]
  %49 = getelementptr inbounds i32* %nprocs, i64 %indvars.iv
  %50 = load i32* %49, align 4, !tbaa !20
  %51 = icmp slt i32 %50, 1
  br i1 %51, label %52, label %57

; <label>:52                                      ; preds = %48
  %53 = sext i32 %place.05 to i64
  %54 = getelementptr inbounds i32* %25, i64 %53
  %55 = load i32* %54, align 4, !tbaa !20
  store i32 %55, i32* %49, align 4, !tbaa !20
  %56 = add nsw i32 %place.05, 1
  br label %57

; <label>:57                                      ; preds = %48, %52
  %place.1 = phi i32 [ %56, %52 ], [ %place.05, %48 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %47
  br i1 %exitcond, label %._crit_edge, label %48

._crit_edge:                                      ; preds = %57, %._crit_edge13
  tail call void @free(i8* %24) #8
  br label %58

; <label>:58                                      ; preds = %._crit_edge21, %._crit_edge
  ret i32 %retval.0.lcssa
}
