define i32 @CCTKi_SetupGHExtensions(%struct.tFleshConfig* %config, i32 %convergence_level, %struct.cGH* %GH) #1 {
entry:
  tail call void @llvm.dbg.value(metadata !{%struct.tFleshConfig* %config}, i64 0, metadata !116), !dbg !251
  tail call void @llvm.dbg.value(metadata !{i32 %convergence_level}, i64 0, metadata !117), !dbg !252
  tail call void @llvm.dbg.value(metadata !{%struct.cGH* %GH}, i64 0, metadata !118), !dbg !253
  tail call void @llvm.dbg.value(metadata !229, i64 0, metadata !254) #5, !dbg !256
  tail call void @llvm.dbg.value(metadata !2, i64 0, metadata !257) #5, !dbg !258
  %0 = load i32* @num_extensions, align 4, !dbg !258, !tbaa !206
  %cmp1.i = icmp sgt i32 %0, 0, !dbg !258
  br i1 %cmp1.i, label %for.body.i, label %CheckAllExtensionsSetup.exit, !dbg !258

for.body.i:                                       ; preds = %entry, %for.inc.i
  %handle.02.i = phi i32 [ %inc.i, %for.inc.i ], [ 0, %entry ]
  %1 = load %struct.cHandledData** @GHExtensions, align 8, !dbg !260, !tbaa !195
  %call.i = tail call i8* @Util_GetHandledData(%struct.cHandledData* %1, i32 %handle.02.i) #6, !dbg !260
  %tobool.i = icmp eq i8* %call.i, null, !dbg !262
  br i1 %tobool.i, label %for.inc.i, label %if.then.i, !dbg !262

if.then.i:                                        ; preds = %for.body.i
  %SetupGH.i = bitcast i8* %call.i to i8* (%struct.tFleshConfig*, i32, %struct.cGH*)**, !dbg !263
  %2 = load i8* (%struct.tFleshConfig*, i32, %struct.cGH*)** %SetupGH.i, align 8, !dbg !263, !tbaa !195
  %tobool1.i = icmp eq i8* (%struct.tFleshConfig*, i32, %struct.cGH*)* %2, null, !dbg !263
  br i1 %tobool1.i, label %if.then2.i, label %if.end.i, !dbg !263

if.then2.i:                                       ; preds = %if.then.i
  %3 = load %struct.cHandledData** @GHExtensions, align 8, !dbg !265, !tbaa !195
  %call3.i = tail call i8* @Util_GetHandleName(%struct.cHandledData* %3, i32 %handle.02.i) #6, !dbg !265
  %call4.i = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 4, i32 728, i8* getelementptr inbounds ([69 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([55 x i8]* @.str2, i64 0, i64 0), i8* %call3.i) #6, !dbg !265
  store i8* (%struct.tFleshConfig*, i32, %struct.cGH*)* @DummySetupGH, i8* (%struct.tFleshConfig*, i32, %struct.cGH*)** %SetupGH.i, align 8, !dbg !267, !tbaa !195
  br label %if.end.i, !dbg !268

if.end.i:                                         ; preds = %if.then2.i, %if.then.i
  %InitGH.i = getelementptr inbounds i8* %call.i, i64 8, !dbg !269
  %4 = bitcast i8* %InitGH.i to i32 (%struct.cGH*)**, !dbg !269
  %5 = load i32 (%struct.cGH*)** %4, align 8, !dbg !269, !tbaa !195
  %tobool6.i = icmp eq i32 (%struct.cGH*)* %5, null, !dbg !269
  br i1 %tobool6.i, label %if.then7.i, label %if.end11.i, !dbg !269

if.then7.i:                                       ; preds = %if.end.i
  %6 = load %struct.cHandledData** @GHExtensions, align 8, !dbg !270, !tbaa !195
  %call8.i = tail call i8* @Util_GetHandleName(%struct.cHandledData* %6, i32 %handle.02.i) #6, !dbg !270
  %call9.i = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 4, i32 737, i8* getelementptr inbounds ([69 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([54 x i8]* @.str3, i64 0, i64 0), i8* %call8.i) #6, !dbg !270
  store i32 (%struct.cGH*)* @DummyInitGH, i32 (%struct.cGH*)** %4, align 8, !dbg !272, !tbaa !195
  br label %if.end11.i, !dbg !273

if.end11.i:                                       ; preds = %if.then7.i, %if.end.i
  %ScheduleTraverseGH.i = getelementptr inbounds i8* %call.i, i64 16, !dbg !274
  %7 = bitcast i8* %ScheduleTraverseGH.i to i32 (%struct.cGH*, i8*)**, !dbg !274
  %8 = load i32 (%struct.cGH*, i8*)** %7, align 8, !dbg !274, !tbaa !195
  %tobool12.i = icmp eq i32 (%struct.cGH*, i8*)* %8, null, !dbg !274
  br i1 %tobool12.i, label %if.then13.i, label %for.inc.i, !dbg !274

if.then13.i:                                      ; preds = %if.end11.i
  %9 = load %struct.cHandledData** @GHExtensions, align 8, !dbg !275, !tbaa !195
  %call14.i = tail call i8* @Util_GetHandleName(%struct.cHandledData* %9, i32 %handle.02.i) #6, !dbg !275
  %call15.i = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 4, i32 746, i8* getelementptr inbounds ([69 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([64 x i8]* @.str4, i64 0, i64 0), i8* %call14.i) #6, !dbg !275
  store i32 (%struct.cGH*, i8*)* @DummyScheduleTraverseGH, i32 (%struct.cGH*, i8*)** %7, align 8, !dbg !277, !tbaa !195
  br label %for.inc.i, !dbg !278

for.inc.i:                                        ; preds = %if.then13.i, %if.end11.i, %for.body.i
  %inc.i = add nsw i32 %handle.02.i, 1, !dbg !258
  tail call void @llvm.dbg.value(metadata !{i32 %inc.i}, i64 0, metadata !257) #5, !dbg !258
  %10 = load i32* @num_extensions, align 4, !dbg !258, !tbaa !206
  %cmp.i = icmp slt i32 %inc.i, %10, !dbg !258
  br i1 %cmp.i, label %for.body.i, label %CheckAllExtensionsSetup.exit, !dbg !258

CheckAllExtensionsSetup.exit:                     ; preds = %for.inc.i, %entry
  %11 = phi i32 [ %0, %entry ], [ %10, %for.inc.i ]
  %tobool1 = icmp eq i32 %11, 0, !dbg !279
  br i1 %tobool1, label %if.else, label %if.then2, !dbg !279

if.then2:                                         ; preds = %CheckAllExtensionsSetup.exit
  %conv = sext i32 %11 to i64, !dbg !281
  %mul = shl nsw i64 %conv, 3, !dbg !281
  %call3 = tail call noalias i8* @malloc(i64 %mul) #6, !dbg !281
  %12 = bitcast i8* %call3 to i8**, !dbg !281
  %extensions = getelementptr inbounds %struct.cGH* %GH, i64 0, i32 18, !dbg !281
  store i8** %12, i8*** %extensions, align 8, !dbg !281, !tbaa !195
  %phitmp = icmp eq i8* %call3, null, !dbg !283
  br label %if.end, !dbg !283

if.else:                                          ; preds = %CheckAllExtensionsSetup.exit
  %extensions4 = getelementptr inbounds %struct.cGH* %GH, i64 0, i32 18, !dbg !284
  store i8** null, i8*** %extensions4, align 8, !dbg !284, !tbaa !195
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %13 = phi i1 [ true, %if.else ], [ %phitmp, %if.then2 ]
  %extensions5 = getelementptr inbounds %struct.cGH* %GH, i64 0, i32 18, !dbg !286
  %tobool7 = icmp ne i32 %11, 0, !dbg !286
  %or.cond = and i1 %13, %tobool7, !dbg !286
  br i1 %or.cond, label %if.end16, label %for.cond.preheader, !dbg !286

for.cond.preheader:                               ; preds = %if.end
  %cmp24 = icmp sgt i32 %11, 0, !dbg !287
  br i1 %cmp24, label %for.body, label %if.end16, !dbg !287

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.cond.preheader ]
  %14 = load %struct.cHandledData** @GHExtensions, align 8, !dbg !290, !tbaa !195
  %15 = trunc i64 %indvars.iv to i32, !dbg !290
  %call10 = tail call i8* @Util_GetHandledData(%struct.cHandledData* %14, i32 %15) #6, !dbg !290
  %SetupGH = bitcast i8* %call10 to i8* (%struct.tFleshConfig*, i32, %struct.cGH*)**, !dbg !292
  %16 = load i8* (%struct.tFleshConfig*, i32, %struct.cGH*)** %SetupGH, align 8, !dbg !292, !tbaa !195
  %call11 = tail call i8* %16(%struct.tFleshConfig* %config, i32 %convergence_level, %struct.cGH* %GH) #6, !dbg !292
  %17 = load i8*** %extensions5, align 8, !dbg !292, !tbaa !195
  %arrayidx = getelementptr inbounds i8** %17, i64 %indvars.iv, !dbg !292
  store i8* %call11, i8** %arrayidx, align 8, !dbg !292, !tbaa !195
  %indvars.iv.next = add i64 %indvars.iv, 1, !dbg !287
  %18 = load i32* @num_extensions, align 4, !dbg !287, !tbaa !206
  %19 = trunc i64 %indvars.iv.next to i32, !dbg !287
  %cmp = icmp slt i32 %19, %18, !dbg !287
  br i1 %cmp, label %for.body, label %if.end16, !dbg !287

if.end16:                                         ; preds = %for.cond.preheader, %for.body, %if.end
  %return_code.0 = phi i32 [ 1, %if.end ], [ 0, %for.body ], [ 0, %for.cond.preheader ]
  ret i32 %return_code.0, !dbg !293
}
