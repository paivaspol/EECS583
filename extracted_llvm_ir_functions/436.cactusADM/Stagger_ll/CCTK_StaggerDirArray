define i32 @CCTK_StaggerDirArray(i32* nocapture %dindex, i32 %dim, i32 %sindex) #1 {
entry:
  tail call void @llvm.dbg.value(metadata !{i32* %dindex}, i64 0, metadata !93), !dbg !256
  tail call void @llvm.dbg.value(metadata !{i32 %dim}, i64 0, metadata !94), !dbg !256
  tail call void @llvm.dbg.value(metadata !{i32 %sindex}, i64 0, metadata !95), !dbg !256
  %.b = load i1* @CCTK_StaggerDirArray.hashed, align 1
  br i1 %.b, label %if.end, label %if.then, !dbg !257

if.then:                                          ; preds = %entry
  store i32 1, i32* getelementptr inbounds ([4 x i32]* @CCTK_StaggerDirArray.hash, i64 0, i64 0), align 16, !dbg !258, !tbaa !175
  store i32 3, i32* getelementptr inbounds ([4 x i32]* @CCTK_StaggerDirArray.hash, i64 0, i64 1), align 4, !dbg !260, !tbaa !175
  store i32 9, i32* getelementptr inbounds ([4 x i32]* @CCTK_StaggerDirArray.hash, i64 0, i64 2), align 8, !dbg !261, !tbaa !175
  store i32 27, i32* getelementptr inbounds ([4 x i32]* @CCTK_StaggerDirArray.hash, i64 0, i64 3), align 4, !dbg !262, !tbaa !175
  store i1 true, i1* @CCTK_StaggerDirArray.hashed, align 1
  br label %if.end, !dbg !263

if.end:                                           ; preds = %entry, %if.then
  %cmp1 = icmp sgt i32 %dim, 4, !dbg !264
  br i1 %cmp1, label %if.then2, label %for.body, !dbg !264

if.then2:                                         ; preds = %if.end
  %call = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 1, i32 256, i8* getelementptr inbounds ([64 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([56 x i8]* @.str3, i64 0, i64 0), i32 %dim) #8, !dbg !265
  br label %return, !dbg !267

for.body:                                         ; preds = %if.end, %for.inc.for.body_crit_edge
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc.for.body_crit_edge ], [ 3, %if.end ]
  %sindex.addr.020 = phi i32 [ %rem, %for.inc.for.body_crit_edge ], [ %sindex, %if.end ]
  %arrayidx = getelementptr inbounds [4 x i32]* @CCTK_StaggerDirArray.hash, i64 0, i64 %indvars.iv, !dbg !268
  %0 = load i32* %arrayidx, align 4, !dbg !268, !tbaa !175
  tail call void @llvm.dbg.value(metadata !{i32 %div}, i64 0, metadata !96), !dbg !268
  %rem = srem i32 %sindex.addr.020, %0, !dbg !271
  tail call void @llvm.dbg.value(metadata !{i32 %rem}, i64 0, metadata !95), !dbg !271
  %1 = trunc i64 %indvars.iv to i32, !dbg !272
  %cmp7 = icmp slt i32 %1, %dim, !dbg !272
  br i1 %cmp7, label %if.then8, label %for.inc, !dbg !272

if.then8:                                         ; preds = %for.body
  %div = sdiv i32 %sindex.addr.020, %0, !dbg !268
  %arrayidx10 = getelementptr inbounds i32* %dindex, i64 %indvars.iv, !dbg !272
  store i32 %div, i32* %arrayidx10, align 4, !dbg !272, !tbaa !175
  br label %for.inc, !dbg !272

for.inc:                                          ; preds = %for.body, %if.then8
  %cmp4 = icmp sgt i32 %1, 0, !dbg !273
  br i1 %cmp4, label %for.inc.for.body_crit_edge, label %return, !dbg !273

for.inc.for.body_crit_edge:                       ; preds = %for.inc
  %indvars.iv.next = add i64 %indvars.iv, -1, !dbg !273
  br label %for.body, !dbg !273

return:                                           ; preds = %for.inc, %if.then2
  %retval.0 = phi i32 [ -1, %if.then2 ], [ 0, %for.inc ]
  ret i32 %retval.0, !dbg !274
}
