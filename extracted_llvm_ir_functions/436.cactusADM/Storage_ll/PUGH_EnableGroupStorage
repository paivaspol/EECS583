define i32 @PUGH_EnableGroupStorage(%struct.cGH* %GH, i8* %groupname) #1 {
  %pgroup = alloca %struct.cGroup, align 4
  %1 = load i8** getelementptr inbounds (%struct.anon.0* @pughpriv_, i64 0, i32 10), align 8, !tbaa !17
  %2 = tail call %struct.PGH* @PUGH_pGH(%struct.cGH* %GH) #7
  %3 = tail call i32 @CCTK_GroupIndex(i8* %groupname) #7
  %4 = icmp ne %struct.PGH* %2, null
  %5 = icmp sgt i32 %3, -1
  %or.cond = and i1 %4, %5
  br i1 %or.cond, label %6, label %155

; <label>:6                                       ; preds = %0
  %7 = tail call i32 @CCTK_FirstVarIndexI(i32 %3) #7
  %8 = call i32 @CCTK_GroupData(i32 %3, %struct.cGroup* %pgroup) #7
  %9 = getelementptr inbounds %struct.cGroup* %pgroup, i64 0, i32 0
  %10 = load i32* %9, align 4, !tbaa !19
  switch i32 %10, label %153 [
    i32 1, label %11
    i32 2, label %46
    i32 3, label %46
  ]

; <label>:11                                      ; preds = %6
  %12 = getelementptr inbounds %struct.cGroup* %pgroup, i64 0, i32 5
  %13 = load i32* %12, align 4, !tbaa !21
  %14 = getelementptr inbounds %struct.cGroup* %pgroup, i64 0, i32 6
  %15 = load i32* %14, align 4, !tbaa !22
  %16 = load i8** getelementptr inbounds (%struct.anon.0* @pughpriv_, i64 0, i32 1), align 8, !tbaa !23
  %17 = call i32 @CCTK_VarTypeI(i32 %7) #7
  %18 = call i32 @CCTK_VarTypeSize(i32 %17) #7
  %19 = sext i32 %7 to i64
  %20 = getelementptr inbounds %struct.PGH* %2, i64 0, i32 7
  %21 = load i8**** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds i8*** %21, i64 %19
  %23 = load i8*** %22, align 8, !tbaa !9
  %24 = load i8** %23, align 8, !tbaa !9
  %25 = sext i32 %18 to i64
  %26 = getelementptr inbounds i8* %24, i64 %25
  %27 = load i8* %26, align 1, !tbaa !16
  %28 = icmp eq i8 %27, 1
  %29 = zext i1 %28 to i32
  %.not.i = xor i1 %28, true
  %30 = icmp sgt i32 %13, 0
  %or.cond.i = and i1 %30, %.not.i
  br i1 %or.cond.i, label %.preheader.lr.ph.i, label %PUGH_EnableScalarGroupStorage.exit

.preheader.lr.ph.i:                               ; preds = %11
  %31 = icmp sgt i32 %15, 0
  %32 = add i32 %15, -1
  %33 = add i32 %13, -1
  br label %.preheader.i

.preheader.i:                                     ; preds = %._crit_edge.i, %.preheader.lr.ph.i
  %indvars.iv4.i = phi i64 [ 0, %.preheader.lr.ph.i ], [ %indvars.iv.next5.i, %._crit_edge.i ]
  br i1 %31, label %.lr.ph.i, label %._crit_edge.i

.lr.ph.i:                                         ; preds = %.preheader.i
  %34 = add nsw i64 %indvars.iv4.i, %19
  br label %35

; <label>:35                                      ; preds = %45, %.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i, %45 ]
  %36 = load i8**** %20, align 8, !tbaa !2
  %37 = getelementptr inbounds i8*** %36, i64 %34
  %38 = load i8*** %37, align 8, !tbaa !9
  %39 = getelementptr inbounds i8** %38, i64 %indvars.iv.i
  %40 = load i8** %39, align 8, !tbaa !9
  %41 = getelementptr inbounds i8* %40, i64 %25
  store i8 1, i8* %41, align 1, !tbaa !16
  %42 = call i32 @CCTK_Equals(i8* %16, i8* getelementptr inbounds ([5 x i8]* @.str18, i64 0, i64 0)) #7
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %44, label %45

; <label>:44                                      ; preds = %35
  call fastcc void @PUGH_InitializeMemory(i8* %16, i32 %17, i32 %18, i8* %40) #7
  br label %45

; <label>:45                                      ; preds = %44, %35
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %lftr.wideiv = trunc i64 %indvars.iv.i to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %32
  br i1 %exitcond, label %._crit_edge.i, label %35

._crit_edge.i:                                    ; preds = %45, %.preheader.i
  %indvars.iv.next5.i = add nuw nsw i64 %indvars.iv4.i, 1
  %lftr.wideiv13 = trunc i64 %indvars.iv4.i to i32
  %exitcond14 = icmp eq i32 %lftr.wideiv13, %33
  br i1 %exitcond14, label %PUGH_EnableScalarGroupStorage.exit, label %.preheader.i

; <label>:46                                      ; preds = %6, %6
  %47 = getelementptr inbounds %struct.cGroup* %pgroup, i64 0, i32 5
  %48 = load i32* %47, align 4, !tbaa !21
  %49 = getelementptr inbounds %struct.cGroup* %pgroup, i64 0, i32 6
  %50 = load i32* %49, align 4, !tbaa !22
  %51 = load i8** getelementptr inbounds (%struct.anon.0* @pughpriv_, i64 0, i32 1), align 8, !tbaa !23
  %52 = load i32* getelementptr inbounds (%struct.anon.0* @pughpriv_, i64 0, i32 32), align 4, !tbaa !24
  %53 = icmp sgt i32 %48, 0
  br i1 %53, label %.preheader.lr.ph.i4, label %._crit_edge9.thread.i

.preheader.lr.ph.i4:                              ; preds = %46
  %54 = add nsw i32 %48, %7
  %55 = icmp sgt i32 %50, 0
  %56 = getelementptr inbounds %struct.PGH* %2, i64 0, i32 7
  %57 = bitcast %struct.PGH* %2 to %struct.cGH**
  %58 = add i32 %50, -1
  %59 = sext i32 %7 to i64
  %60 = sext i32 %54 to i64
  br label %.preheader.i5

.preheader.i5:                                    ; preds = %._crit_edge.i11, %.preheader.lr.ph.i4
  %indvars.iv12.i = phi i64 [ %59, %.preheader.lr.ph.i4 ], [ %indvars.iv.next13.i, %._crit_edge.i11 ]
  %nstorage.08.i = phi i32 [ 0, %.preheader.lr.ph.i4 ], [ %nstorage.1.lcssa.i, %._crit_edge.i11 ]
  %nnostorage.06.i = phi i32 [ 0, %.preheader.lr.ph.i4 ], [ %nnostorage.1.lcssa.i, %._crit_edge.i11 ]
  br i1 %55, label %.lr.ph.i7, label %._crit_edge.i11

.lr.ph.i7:                                        ; preds = %.preheader.i5, %95
  %indvars.iv.i6 = phi i64 [ %indvars.iv.next.i8, %95 ], [ 0, %.preheader.i5 ]
  %nstorage.13.i = phi i32 [ %nstorage.2.i, %95 ], [ %nstorage.08.i, %.preheader.i5 ]
  %nnostorage.12.i = phi i32 [ %nnostorage.2.i, %95 ], [ %nnostorage.06.i, %.preheader.i5 ]
  %61 = load i8**** %56, align 8, !tbaa !2
  %62 = getelementptr inbounds i8*** %61, i64 %indvars.iv12.i
  %63 = load i8*** %62, align 8, !tbaa !9
  %64 = getelementptr inbounds i8** %63, i64 %indvars.iv.i6
  %65 = bitcast i8** %64 to %struct.PGA**
  %66 = load %struct.PGA** %65, align 8, !tbaa !9
  %67 = getelementptr inbounds %struct.PGA* %66, i64 0, i32 5
  %68 = load i32* %67, align 4, !tbaa !10
  %69 = icmp eq i32 %68, 0
  br i1 %69, label %70, label %83

; <label>:70                                      ; preds = %.lr.ph.i7
  %71 = call i32 @PUGH_EnableGArrayDataStorage(%struct.PGA* %66, i32 undef, i8* %51, i32 %52, i32 undef, i32 undef, i32 undef) #7
  %72 = getelementptr inbounds %struct.PGA* %66, i64 0, i32 4
  %73 = bitcast i8** %72 to i64*
  %74 = load i64* %73, align 8, !tbaa !25
  %75 = load %struct.cGH** %57, align 8, !tbaa !26
  %76 = getelementptr inbounds %struct.cGH* %75, i64 0, i32 17
  %77 = load i8**** %76, align 8, !tbaa !27
  %78 = getelementptr inbounds i8*** %77, i64 %indvars.iv12.i
  %79 = load i8*** %78, align 8, !tbaa !9
  %80 = getelementptr inbounds i8** %79, i64 %indvars.iv.i6
  %81 = bitcast i8** %80 to i64*
  store i64 %74, i64* %81, align 8, !tbaa !9
  %82 = add nsw i32 %nnostorage.12.i, 1
  br label %95

; <label>:83                                      ; preds = %.lr.ph.i7
  %84 = getelementptr inbounds %struct.PGA* %66, i64 0, i32 4
  %85 = bitcast i8** %84 to i64*
  %86 = load i64* %85, align 8, !tbaa !25
  %87 = load %struct.cGH** %57, align 8, !tbaa !26
  %88 = getelementptr inbounds %struct.cGH* %87, i64 0, i32 17
  %89 = load i8**** %88, align 8, !tbaa !27
  %90 = getelementptr inbounds i8*** %89, i64 %indvars.iv12.i
  %91 = load i8*** %90, align 8, !tbaa !9
  %92 = getelementptr inbounds i8** %91, i64 %indvars.iv.i6
  %93 = bitcast i8** %92 to i64*
  store i64 %86, i64* %93, align 8, !tbaa !9
  %94 = add nsw i32 %nstorage.13.i, 1
  br label %95

; <label>:95                                      ; preds = %83, %70
  %nnostorage.2.i = phi i32 [ %nnostorage.12.i, %83 ], [ %82, %70 ]
  %nstorage.2.i = phi i32 [ %94, %83 ], [ %nstorage.13.i, %70 ]
  %indvars.iv.next.i8 = add nuw nsw i64 %indvars.iv.i6, 1
  %lftr.wideiv15 = trunc i64 %indvars.iv.i6 to i32
  %exitcond16 = icmp eq i32 %lftr.wideiv15, %58
  br i1 %exitcond16, label %._crit_edge.i11, label %.lr.ph.i7

._crit_edge.i11:                                  ; preds = %95, %.preheader.i5
  %nstorage.1.lcssa.i = phi i32 [ %nstorage.08.i, %.preheader.i5 ], [ %nstorage.2.i, %95 ]
  %nnostorage.1.lcssa.i = phi i32 [ %nnostorage.06.i, %.preheader.i5 ], [ %nnostorage.2.i, %95 ]
  %indvars.iv.next13.i = add nsw i64 %indvars.iv12.i, 1
  %96 = icmp slt i64 %indvars.iv.next13.i, %60
  br i1 %96, label %.preheader.i5, label %._crit_edge9.i

._crit_edge9.i:                                   ; preds = %._crit_edge.i11
  %97 = icmp sgt i32 %nstorage.1.lcssa.i, 0
  %98 = icmp sgt i32 %nnostorage.1.lcssa.i, 0
  %or.cond.i12 = and i1 %97, %98
  br i1 %or.cond.i12, label %99, label %._crit_edge9.thread.i

; <label>:99                                      ; preds = %._crit_edge9.i
  %100 = call i32 @CCTK_Warn(i32 0, i32 713, i8* getelementptr inbounds ([74 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([57 x i8]* @.str24, i64 0, i64 0)) #7
  br label %PUGH_EnableGArrayGroupStorage.exit

._crit_edge9.thread.i:                            ; preds = %._crit_edge9.i, %46
  %101 = phi i1 [ %97, %._crit_edge9.i ], [ false, %46 ]
  %102 = zext i1 %101 to i32
  br label %PUGH_EnableGArrayGroupStorage.exit

PUGH_EnableGArrayGroupStorage.exit:               ; preds = %99, %._crit_edge9.thread.i
  %retval.0.i = phi i32 [ -1, %99 ], [ %102, %._crit_edge9.thread.i ]
  %103 = call i32 @CCTK_Equals(i8* %1, i8* getelementptr inbounds ([3 x i8]* @.str7, i64 0, i64 0)) #7
  %104 = or i32 %103, %retval.0.i
  %105 = icmp eq i32 %104, 0
  br i1 %105, label %106, label %PUGH_EnableScalarGroupStorage.exit

; <label>:106                                     ; preds = %PUGH_EnableGArrayGroupStorage.exit
  %107 = sext i32 %7 to i64
  %108 = getelementptr inbounds %struct.PGH* %2, i64 0, i32 7
  %109 = load i8**** %108, align 8, !tbaa !2
  %110 = getelementptr inbounds i8*** %109, i64 %107
  %111 = bitcast i8*** %110 to %struct.PGA***
  %112 = load %struct.PGA*** %111, align 8, !tbaa !9
  %113 = load %struct.PGA** %112, align 8, !tbaa !9
  %114 = load i32* %9, align 4, !tbaa !19
  %115 = icmp eq i32 %114, 2
  %116 = load i32* %47, align 4, !tbaa !21
  %117 = load i32* %49, align 4, !tbaa !22
  %118 = mul nsw i32 %117, %116
  br i1 %115, label %119, label %122

; <label>:119                                     ; preds = %106
  %120 = load i32* @totalnumberGF, align 4, !tbaa !29
  %121 = add nsw i32 %120, %118
  store i32 %121, i32* @totalnumberGF, align 4, !tbaa !29
  br label %125

; <label>:122                                     ; preds = %106
  %123 = load i32* @totalnumberGA, align 4, !tbaa !29
  %124 = add nsw i32 %123, %118
  store i32 %124, i32* @totalnumberGA, align 4, !tbaa !29
  br label %125

; <label>:125                                     ; preds = %122, %119
  %126 = getelementptr inbounds %struct.PGA* %113, i64 0, i32 10
  %127 = load %struct.PGExtras** %126, align 8, !tbaa !12
  %128 = getelementptr inbounds %struct.PGExtras* %127, i64 0, i32 7
  %129 = load i32* %128, align 4, !tbaa !30
  %130 = getelementptr inbounds %struct.PGA* %113, i64 0, i32 8
  %131 = load i32* %130, align 4, !tbaa !31
  %132 = mul nsw i32 %131, %129
  %133 = mul nsw i32 %132, %117
  %134 = mul nsw i32 %133, %116
  %135 = sitofp i32 %134 to float
  %136 = fmul float %135, 0x3EB0000000000000
  %137 = load float* @totalstorage, align 4, !tbaa !32
  %138 = fadd float %137, %136
  store float %138, float* @totalstorage, align 4, !tbaa !32
  %139 = load float* @maxstorage, align 4, !tbaa !32
  %140 = fcmp ogt float %138, %139
  br i1 %140, label %141, label %144

; <label>:141                                     ; preds = %125
  %142 = load i32* @totalnumberGF, align 4, !tbaa !29
  store i32 %142, i32* @numberGF, align 4, !tbaa !29
  %143 = load i32* @totalnumberGA, align 4, !tbaa !29
  store i32 %143, i32* @numberGA, align 4, !tbaa !29
  store float %138, float* @maxstorage, align 4, !tbaa !32
  br label %144

; <label>:144                                     ; preds = %141, %125
  %145 = call i32 @CCTK_Equals(i8* %1, i8* getelementptr inbounds ([4 x i8]* @.str8, i64 0, i64 0)) #7
  %146 = icmp eq i32 %145, 0
  br i1 %146, label %PUGH_EnableScalarGroupStorage.exit, label %147

; <label>:147                                     ; preds = %144
  %148 = load i32* @totalnumberGF, align 4, !tbaa !29
  %149 = load i32* @totalnumberGA, align 4, !tbaa !29
  %150 = load float* @totalstorage, align 4, !tbaa !32
  %151 = fpext float %150 to double
  %152 = call i32 (i8*, i8*, ...)* @CCTK_VInfo(i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([73 x i8]* @.str9, i64 0, i64 0), i8* %groupname, i32 %148, i32 %149, double %151) #7
  br label %PUGH_EnableScalarGroupStorage.exit

; <label>:153                                     ; preds = %6
  %154 = call i32 @CCTK_Warn(i32 1, i32 377, i8* getelementptr inbounds ([74 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([44 x i8]* @.str10, i64 0, i64 0)) #7
  br label %PUGH_EnableScalarGroupStorage.exit

; <label>:155                                     ; preds = %0
  br i1 %4, label %158, label %156

; <label>:156                                     ; preds = %155
  %157 = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 1, i32 386, i8* getelementptr inbounds ([74 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([64 x i8]* @.str11, i64 0, i64 0), i8* %groupname) #7
  br label %PUGH_EnableScalarGroupStorage.exit

; <label>:158                                     ; preds = %155
  %159 = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 1, i32 393, i8* getelementptr inbounds ([74 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([42 x i8]* @.str12, i64 0, i64 0), i8* %groupname) #7
  br label %PUGH_EnableScalarGroupStorage.exit

PUGH_EnableScalarGroupStorage.exit:               ; preds = %._crit_edge.i, %11, %144, %156, %158, %PUGH_EnableGArrayGroupStorage.exit, %147, %153
  %retval.0 = phi i32 [ %retval.0.i, %147 ], [ %retval.0.i, %144 ], [ %retval.0.i, %PUGH_EnableGArrayGroupStorage.exit ], [ -1, %153 ], [ -3, %158 ], [ -2, %156 ], [ %29, %11 ], [ %29, %._crit_edge.i ]
  ret i32 %retval.0
}
