define i32 @PUGH_EnableGArrayDataStorage(%struct.PGA* %GA, i32 %this_proc, i8* %initialize_memory, i32 %padding_active, i32 %padding_cacheline_bits, i32 %padding_size, i32 %padding_address_spacing) #1 {
entry:
  tail call void @llvm.dbg.value(metadata !{%struct.PGA* %GA}, i64 0, metadata !349), !dbg !811
  tail call void @llvm.dbg.value(metadata !{i32 %this_proc}, i64 0, metadata !350), !dbg !812
  tail call void @llvm.dbg.value(metadata !{i8* %initialize_memory}, i64 0, metadata !351), !dbg !813
  tail call void @llvm.dbg.value(metadata !{i32 %padding_active}, i64 0, metadata !352), !dbg !814
  tail call void @llvm.dbg.value(metadata !{i32 %padding_cacheline_bits}, i64 0, metadata !353), !dbg !815
  tail call void @llvm.dbg.value(metadata !{i32 %padding_size}, i64 0, metadata !354), !dbg !816
  tail call void @llvm.dbg.value(metadata !{i32 %padding_address_spacing}, i64 0, metadata !355), !dbg !817
  tail call void @llvm.dbg.value(metadata !{i32 %this_proc}, i64 0, metadata !350), !dbg !818
  tail call void @llvm.dbg.value(metadata !{i32 %padding_active}, i64 0, metadata !352), !dbg !819
  tail call void @llvm.dbg.value(metadata !{i32 %padding_cacheline_bits}, i64 0, metadata !353), !dbg !820
  tail call void @llvm.dbg.value(metadata !{i32 %padding_size}, i64 0, metadata !354), !dbg !821
  tail call void @llvm.dbg.value(metadata !{i32 %padding_address_spacing}, i64 0, metadata !355), !dbg !822
  tail call void @llvm.dbg.value(metadata !2, i64 0, metadata !356), !dbg !823
  %storage = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 5, !dbg !824
  %0 = load i32* %storage, align 4, !dbg !824, !tbaa !551
  %cmp = icmp eq i32 %0, 0, !dbg !824
  br i1 %cmp, label %if.then, label %if.end70, !dbg !824

if.then:                                          ; preds = %entry
  %vector_size = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 14, !dbg !825
  %1 = load i32* %vector_size, align 4, !dbg !825, !tbaa !551
  %cmp2 = icmp sgt i32 %1, 1, !dbg !825
  br i1 %cmp2, label %land.lhs.true, label %if.else, !dbg !825

land.lhs.true:                                    ; preds = %if.then
  %vector_entry = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 15, !dbg !825
  %2 = load i32* %vector_entry, align 4, !dbg !825, !tbaa !551
  %cmp3 = icmp sgt i32 %2, 0, !dbg !825
  br i1 %cmp3, label %if.then4, label %if.else, !dbg !825

if.then4:                                         ; preds = %land.lhs.true
  %vector_base = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 16, !dbg !827
  %3 = load %struct.PGA** %vector_base, align 8, !dbg !827, !tbaa !547
  %data = getelementptr inbounds %struct.PGA* %3, i64 0, i32 4, !dbg !827
  %4 = load i8** %data, align 8, !dbg !827, !tbaa !547
  %extras = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 10, !dbg !827
  %5 = load %struct.PGExtras** %extras, align 8, !dbg !827, !tbaa !547
  %npoints = getelementptr inbounds %struct.PGExtras* %5, i64 0, i32 7, !dbg !827
  %6 = load i32* %npoints, align 4, !dbg !827, !tbaa !551
  %varsize = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 8, !dbg !827
  %7 = load i32* %varsize, align 4, !dbg !827, !tbaa !551
  %mul = mul i32 %6, %2, !dbg !827
  %mul6 = mul i32 %mul, %7, !dbg !827
  %idx.ext = sext i32 %mul6 to i64, !dbg !827
  %add.ptr = getelementptr inbounds i8* %4, i64 %idx.ext, !dbg !827
  %data7 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 4, !dbg !827
  store i8* %add.ptr, i8** %data7, align 8, !dbg !827, !tbaa !547
  tail call void @llvm.dbg.value(metadata !2, i64 0, metadata !356), !dbg !829
  br label %if.end55, !dbg !830

if.else:                                          ; preds = %land.lhs.true, %if.then
  %padddata = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 3, !dbg !831
  %8 = load i8** %padddata, align 8, !dbg !831, !tbaa !547
  %tobool = icmp eq i8* %8, null, !dbg !831
  br i1 %tobool, label %if.end, label %if.then8, !dbg !831

if.then8:                                         ; preds = %if.else
  tail call void @free(i8* %8) #7, !dbg !833
  store i8* null, i8** %padddata, align 8, !dbg !835, !tbaa !547
  br label %if.end, !dbg !836

if.end:                                           ; preds = %if.else, %if.then8
  %extras11 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 10, !dbg !837
  %9 = load %struct.PGExtras** %extras11, align 8, !dbg !837, !tbaa !547
  %npoints12 = getelementptr inbounds %struct.PGExtras* %9, i64 0, i32 7, !dbg !837
  %10 = load i32* %npoints12, align 4, !dbg !837, !tbaa !551
  %varsize13 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 8, !dbg !837
  %11 = load i32* %varsize13, align 4, !dbg !837, !tbaa !551
  %mul14 = mul nsw i32 %11, %10, !dbg !837
  %cmp15 = icmp slt i32 %mul14, 1, !dbg !837
  br i1 %cmp15, label %if.end42.thread, label %if.else19, !dbg !837

if.end42.thread:                                  ; preds = %if.end
  %name = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 0, !dbg !838
  %12 = load i8** %name, align 8, !dbg !838, !tbaa !547
  %call = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 1, i32 809, i8* getelementptr inbounds ([62 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([85 x i8]* @.str17, i64 0, i64 0), i8* %12) #7, !dbg !838
  %13 = bitcast i8** %padddata to i8*, !dbg !840
  call void @llvm.memset.p0i8.i64(i8* %13, i8 0, i64 16, i32 8, i1 false), !dbg !841
  br label %if.end55, !dbg !842

if.else19:                                        ; preds = %if.end
  %tobool20 = icmp eq i32 %padding_active, 0, !dbg !843
  br i1 %tobool20, label %if.then21, label %if.else30, !dbg !843

if.then21:                                        ; preds = %if.else19
  %conv = sext i32 %mul14 to i64, !dbg !844
  %call26 = tail call noalias i8* @malloc(i64 %conv) #7, !dbg !844
  %data27 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 4, !dbg !844
  store i8* %call26, i8** %data27, align 8, !dbg !844, !tbaa !547
  store i8* %call26, i8** %padddata, align 8, !dbg !846, !tbaa !547
  br label %if.end42, !dbg !847

if.else30:                                        ; preds = %if.else19
  %arrayid = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 2, !dbg !848
  %14 = load i32* %arrayid, align 4, !dbg !848, !tbaa !551
  %15 = load i32* %vector_size, align 4, !dbg !848, !tbaa !551
  %mul36 = mul nsw i32 %15, %mul14, !dbg !848
  %conv37 = sext i32 %mul36 to i64, !dbg !848
  %call39 = tail call i8* @Util_CacheMalloc(i32 %14, i64 %conv37, i8** %padddata) #7, !dbg !848
  %data40 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 4, !dbg !848
  store i8* %call39, i8** %data40, align 8, !dbg !848, !tbaa !547
  br label %if.end42

if.end42:                                         ; preds = %if.then21, %if.else30
  %16 = phi i8* [ %call26, %if.then21 ], [ %call39, %if.else30 ]
  %data43 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 4, !dbg !842
  %tobool44 = icmp eq i8* %16, null, !dbg !842
  br i1 %tobool44, label %if.end55, label %land.lhs.true45, !dbg !842

land.lhs.true45:                                  ; preds = %if.end42
  %call46 = tail call i32 @CCTK_Equals(i8* %initialize_memory, i8* getelementptr inbounds ([5 x i8]* @.str18, i64 0, i64 0)) #7, !dbg !842
  %tobool47 = icmp eq i32 %call46, 0, !dbg !842
  br i1 %tobool47, label %if.then48, label %if.end55, !dbg !842

if.then48:                                        ; preds = %land.lhs.true45
  %vtype = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 9, !dbg !850
  %17 = load i32* %vtype, align 4, !dbg !850, !tbaa !551
  %18 = load %struct.PGExtras** %extras11, align 8, !dbg !850, !tbaa !547
  %npoints50 = getelementptr inbounds %struct.PGExtras* %18, i64 0, i32 7, !dbg !850
  %19 = load i32* %npoints50, align 4, !dbg !850, !tbaa !551
  %20 = load i32* %varsize13, align 4, !dbg !850, !tbaa !551
  %mul52 = mul nsw i32 %20, %19, !dbg !850
  %21 = load i8** %data43, align 8, !dbg !850, !tbaa !547
  tail call fastcc void @PUGH_InitializeMemory(i8* %initialize_memory, i32 %17, i32 %mul52, i8* %21) #8, !dbg !850
  br label %if.end55, !dbg !852

if.end55:                                         ; preds = %land.lhs.true45, %if.end42, %if.end42.thread, %if.then48, %if.then4
  %extras56 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 10, !dbg !853
  %22 = load %struct.PGExtras** %extras56, align 8, !dbg !853, !tbaa !547
  %npoints57 = getelementptr inbounds %struct.PGExtras* %22, i64 0, i32 7, !dbg !853
  %23 = load i32* %npoints57, align 4, !dbg !853, !tbaa !551
  %varsize58 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 8, !dbg !853
  %24 = load i32* %varsize58, align 4, !dbg !853, !tbaa !551
  %mul59 = mul nsw i32 %24, %23, !dbg !853
  %cmp60 = icmp sgt i32 %mul59, 0, !dbg !853
  br i1 %cmp60, label %land.lhs.true62, label %if.end70, !dbg !853

land.lhs.true62:                                  ; preds = %if.end55
  %padddata63 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 3, !dbg !853
  %25 = load i8** %padddata63, align 8, !dbg !853, !tbaa !547
  %cmp64 = icmp eq i8* %25, null, !dbg !853
  br i1 %cmp64, label %if.then66, label %if.end70, !dbg !853

if.then66:                                        ; preds = %land.lhs.true62
  %name67 = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 0, !dbg !854
  %26 = load i8** %name67, align 8, !dbg !854, !tbaa !547
  %id = getelementptr inbounds %struct.PGA* %GA, i64 0, i32 1, !dbg !854
  %27 = load i32* %id, align 4, !dbg !854, !tbaa !551
  %call68 = tail call i32 (i32, i32, i8*, i8*, i8*, ...)* @CCTK_VWarn(i32 0, i32 838, i8* getelementptr inbounds ([62 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8]* @.str19, i64 0, i64 0), i8* %26, i32 %27) #7, !dbg !854
  tail call void @llvm.dbg.value(metadata !570, i64 0, metadata !356), !dbg !856
  br label %if.end70, !dbg !857

if.end70:                                         ; preds = %if.end55, %land.lhs.true62, %if.then66, %entry
  %retval1.1 = phi i32 [ -1, %if.then66 ], [ 0, %land.lhs.true62 ], [ 0, %if.end55 ], [ 0, %entry ]
  store i32 1, i32* %storage, align 4, !dbg !858, !tbaa !551
  ret i32 %retval1.1, !dbg !859
}
