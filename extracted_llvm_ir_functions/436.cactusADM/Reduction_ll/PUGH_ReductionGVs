define i32 @PUGH_ReductionGVs(%struct.cGH* %GH, i32 %proc, i32 %num_invars, i32* nocapture readonly %invars, i32 %outtype, i32 %num_outvals, i8* nocapture %outvals, i32 (%struct.cGH*, i32, i32, i32*, i32*, i32*, i32*, i32, i32, i32*, i8**, i32, double*)* nocapture %reduction_fn) #1 {
  %from.i = alloca i32, align 4
  %to.i = alloca i32, align 4
  %iterator.i = alloca i32, align 4
  %points_per_dim.i = alloca i32, align 4
  %type.i = alloca i32, align 4
  %data.i = alloca i8*, align 8
  %result = alloca double, align 8
  %1 = icmp eq i32 %num_outvals, 1
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = tail call i32 @CCTK_Warn(i32 1, i32 280, i8* getelementptr inbounds ([82 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([11 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([65 x i8]* @.str3, i64 0, i64 0)) #5
  br label %.loopexit

; <label>:4                                       ; preds = %0
  %5 = tail call i32 @CCTK_VarTypeSize(i32 %outtype) #5
  %6 = icmp slt i32 %5, 1
  br i1 %6, label %7, label %9

; <label>:7                                       ; preds = %4
  %8 = tail call i32 @CCTK_Warn(i32 1, i32 287, i8* getelementptr inbounds ([82 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([11 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([48 x i8]* @.str4, i64 0, i64 0)) #5
  br label %.loopexit

; <label>:9                                       ; preds = %4
  %10 = load i32 (%struct.cGH*)** @CCTK_MyProc, align 8, !tbaa !6
  %11 = tail call i32 %10(%struct.cGH* %GH) #5
  %12 = icmp sgt i32 %num_invars, 0
  br i1 %12, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %9
  %13 = bitcast i32* %from.i to i8*
  %14 = bitcast i32* %to.i to i8*
  %15 = bitcast i32* %iterator.i to i8*
  %16 = bitcast i32* %points_per_dim.i to i8*
  %17 = bitcast i32* %type.i to i8*
  %18 = bitcast i8** %data.i to i8*
  %19 = bitcast i8** %data.i to i64*
  %20 = sext i32 %5 to i64
  %21 = add i32 %num_invars, -1
  br label %22

; <label>:22                                      ; preds = %133, %.lr.ph
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %133 ]
  %retval.04 = phi i32 [ 0, %.lr.ph ], [ %134, %133 ]
  %23 = getelementptr inbounds i32* %invars, i64 %indvars.iv
  %24 = load i32* %23, align 4, !tbaa !2
  %25 = call i32 @CCTK_GroupTypeFromVarI(i32 %24) #5
  switch i32 %25, label %.thread [
    i32 2, label %26
    i32 3, label %26
    i32 1, label %115
  ]

; <label>:26                                      ; preds = %22, %22
  %27 = load i32* %23, align 4, !tbaa !2
  %28 = sext i32 %27 to i64
  %29 = call %struct.PGH* @PUGH_pGH(%struct.cGH* %GH) #5
  %30 = getelementptr inbounds %struct.PGH* %29, i64 0, i32 7
  %31 = bitcast i8**** %30 to %struct.PGA****
  %32 = load %struct.PGA**** %31, align 8, !tbaa !19
  %33 = getelementptr inbounds %struct.PGA*** %32, i64 %28
  %34 = load %struct.PGA*** %33, align 8, !tbaa !6
  %35 = load %struct.PGA** %34, align 8, !tbaa !6
  %36 = getelementptr inbounds %struct.PGA* %35, i64 0, i32 11
  %37 = load %struct.PConnectivity** %36, align 8, !tbaa !21
  %38 = getelementptr inbounds %struct.PConnectivity* %37, i64 0, i32 0
  %39 = load i32* %38, align 4, !tbaa !23
  %40 = shl nsw i32 %39, 2
  %41 = sext i32 %40 to i64
  %42 = shl nsw i64 %41, 2
  %43 = call i8* @malloc(i64 %42) #5
  %44 = bitcast i8* %43 to i32*
  %45 = load %struct.PConnectivity** %36, align 8, !tbaa !21
  %46 = getelementptr inbounds %struct.PConnectivity* %45, i64 0, i32 0
  %47 = load i32* %46, align 4, !tbaa !23
  %48 = sext i32 %47 to i64
  %49 = getelementptr inbounds i32* %44, i64 %48
  %50 = shl nsw i32 %47, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds i32* %44, i64 %51
  %53 = mul nsw i32 %47, 3
  %54 = sext i32 %53 to i64
  %55 = getelementptr inbounds i32* %44, i64 %54
  store i32 1, i32* %55, align 4, !tbaa !2
  %56 = load i32* %46, align 4, !tbaa !23
  %57 = icmp sgt i32 %56, 0
  br i1 %57, label %.lr.ph.i, label %PUGH_ReductionGA.exit

.lr.ph.i:                                         ; preds = %26
  %58 = getelementptr inbounds %struct.PGA* %35, i64 0, i32 6
  %59 = getelementptr inbounds %struct.PGA* %35, i64 0, i32 10
  br label %60

; <label>:60                                      ; preds = %107, %.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i, %107 ]
  %num_points.03.i = phi i32 [ 1, %.lr.ph.i ], [ %95, %107 ]
  %61 = load i32* %58, align 4, !tbaa !25
  %62 = trunc i64 %indvars.iv.i to i32
  %63 = call i32 @CCTK_StaggerDirIndex(i32 %62, i32 %61) #5
  %64 = sext i32 %63 to i64
  %65 = load %struct.PGExtras** %59, align 8, !tbaa !26
  %66 = getelementptr inbounds %struct.PGExtras* %65, i64 0, i32 13, i64 %64, i64 0
  %67 = load i32** %66, align 8, !tbaa !6
  %68 = getelementptr inbounds i32* %67, i64 %indvars.iv.i
  %69 = load i32* %68, align 4, !tbaa !2
  %70 = getelementptr inbounds i32* %44, i64 %indvars.iv.i
  store i32 %69, i32* %70, align 4, !tbaa !2
  %71 = getelementptr inbounds %struct.PGExtras* %65, i64 0, i32 13, i64 %64, i64 1
  %72 = load i32** %71, align 8, !tbaa !6
  %73 = getelementptr inbounds i32* %72, i64 %indvars.iv.i
  %74 = load i32* %73, align 4, !tbaa !2
  %.sum.i = add nsw i64 %indvars.iv.i, %48
  %75 = getelementptr inbounds i32* %44, i64 %.sum.i
  store i32 %74, i32* %75, align 4, !tbaa !2
  %76 = getelementptr inbounds %struct.PGExtras* %65, i64 0, i32 1
  %77 = load i32** %76, align 8, !tbaa !27
  %78 = getelementptr inbounds i32* %77, i64 %indvars.iv.i
  %79 = load i32* %78, align 4, !tbaa !2
  %80 = load %struct.PConnectivity** %36, align 8, !tbaa !21
  %81 = getelementptr inbounds %struct.PConnectivity* %80, i64 0, i32 3
  %82 = load i32** %81, align 8, !tbaa !29
  %83 = getelementptr inbounds i32* %82, i64 %indvars.iv.i
  %84 = load i32* %83, align 4, !tbaa !2
  %85 = icmp eq i32 %84, 0
  br i1 %85, label %93, label %86

; <label>:86                                      ; preds = %60
  %87 = getelementptr inbounds %struct.PGExtras* %65, i64 0, i32 12
  %88 = load i32** %87, align 8, !tbaa !30
  %89 = getelementptr inbounds i32* %88, i64 %indvars.iv.i
  %90 = load i32* %89, align 4, !tbaa !2
  %91 = shl nsw i32 %90, 1
  %92 = sub nsw i32 %79, %91
  br label %93

; <label>:93                                      ; preds = %86, %60
  %dir_points.0.i = phi i32 [ %92, %86 ], [ %79, %60 ]
  %not..i = icmp ne i32 %63, 0
  %94 = sext i1 %not..i to i32
  %dir_points.0..i = add nsw i32 %dir_points.0.i, %94
  %95 = mul nsw i32 %dir_points.0..i, %num_points.03.i
  %96 = icmp sgt i64 %indvars.iv.i, 0
  br i1 %96, label %97, label %107

; <label>:97                                      ; preds = %93
  %98 = add nsw i64 %indvars.iv.i, -1
  %.sum1.i = add nsw i64 %98, %54
  %99 = getelementptr inbounds i32* %44, i64 %.sum1.i
  %100 = load i32* %99, align 4, !tbaa !2
  %101 = getelementptr inbounds %struct.PGExtras* %65, i64 0, i32 6
  %102 = load i32** %101, align 8, !tbaa !31
  %103 = getelementptr inbounds i32* %102, i64 %98
  %104 = load i32* %103, align 4, !tbaa !2
  %105 = mul nsw i32 %104, %100
  %.sum2.i = add nsw i64 %indvars.iv.i, %54
  %106 = getelementptr inbounds i32* %44, i64 %.sum2.i
  store i32 %105, i32* %106, align 4, !tbaa !2
  br label %107

; <label>:107                                     ; preds = %97, %93
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %108 = getelementptr inbounds %struct.PConnectivity* %80, i64 0, i32 0
  %109 = load i32* %108, align 4, !tbaa !23
  %110 = sext i32 %109 to i64
  %111 = icmp slt i64 %indvars.iv.next.i, %110
  br i1 %111, label %60, label %PUGH_ReductionGA.exit

PUGH_ReductionGA.exit:                            ; preds = %107, %26
  %.lcssa.i = phi i32 [ %56, %26 ], [ %109, %107 ]
  %num_points.0.lcssa.i = phi i32 [ 1, %26 ], [ %95, %107 ]
  %112 = getelementptr inbounds %struct.PGA* %35, i64 0, i32 9
  %113 = getelementptr inbounds %struct.PGA* %35, i64 0, i32 4
  %114 = call i32 %reduction_fn(%struct.cGH* %GH, i32 %proc, i32 %.lcssa.i, i32* %44, i32* %49, i32* %52, i32* %55, i32 %num_points.0.lcssa.i, i32 1, i32* %112, i8** %113, i32 1, double* %result) #5
  call void @free(i8* %43) #5
  br label %128

; <label>:115                                     ; preds = %22
  %116 = load i32* %23, align 4, !tbaa !2
  call void @llvm.lifetime.start(i64 4, i8* %13)
  call void @llvm.lifetime.start(i64 4, i8* %14)
  call void @llvm.lifetime.start(i64 4, i8* %15)
  call void @llvm.lifetime.start(i64 4, i8* %16)
  call void @llvm.lifetime.start(i64 4, i8* %17)
  call void @llvm.lifetime.start(i64 8, i8* %18)
  %117 = sext i32 %116 to i64
  %118 = call %struct.PGH* @PUGH_pGH(%struct.cGH* %GH) #5
  %119 = getelementptr inbounds %struct.PGH* %118, i64 0, i32 7
  %120 = load i8**** %119, align 8, !tbaa !19
  %121 = getelementptr inbounds i8*** %120, i64 %117
  %122 = bitcast i8*** %121 to i64**
  %123 = load i64** %122, align 8, !tbaa !6
  %124 = load i64* %123, align 8, !tbaa !6
  store i64 %124, i64* %19, align 8, !tbaa !6
  store i32 0, i32* %from.i, align 4, !tbaa !2
  store i32 1, i32* %to.i, align 4, !tbaa !2
  store i32 1, i32* %iterator.i, align 4, !tbaa !2
  store i32 1, i32* %points_per_dim.i, align 4, !tbaa !2
  %125 = call i32 @CCTK_VarTypeI(i32 %116) #5
  store i32 %125, i32* %type.i, align 4, !tbaa !2
  %126 = call i32 %reduction_fn(%struct.cGH* %GH, i32 %proc, i32 1, i32* %from.i, i32* %to.i, i32* %iterator.i, i32* %points_per_dim.i, i32 1, i32 1, i32* %type.i, i8** %data.i, i32 1, double* %result) #5
  call void @llvm.lifetime.end(i64 4, i8* %13)
  call void @llvm.lifetime.end(i64 4, i8* %14)
  call void @llvm.lifetime.end(i64 4, i8* %15)
  call void @llvm.lifetime.end(i64 4, i8* %16)
  call void @llvm.lifetime.end(i64 4, i8* %17)
  call void @llvm.lifetime.end(i64 8, i8* %18)
  br label %128

.thread:                                          ; preds = %22
  %127 = call i32 @CCTK_Warn(i32 1, i32 310, i8* getelementptr inbounds ([82 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([11 x i8]* @.str1, i64 0, i64 0), i8* getelementptr inbounds ([42 x i8]* @.str5, i64 0, i64 0)) #5
  br label %133

; <label>:128                                     ; preds = %115, %PUGH_ReductionGA.exit
  %this_retval.0 = phi i32 [ %126, %115 ], [ %114, %PUGH_ReductionGA.exit ]
  %.not = icmp ne i32 %this_retval.0, 0
  %notlhs = icmp sgt i32 %proc, -1
  %notrhs = icmp ne i32 %11, %proc
  %or.cond.not = and i1 %notrhs, %notlhs
  %brmerge = or i1 %.not, %or.cond.not
  br i1 %brmerge, label %133, label %129

; <label>:129                                     ; preds = %128
  %130 = mul nsw i64 %indvars.iv, %20
  %131 = getelementptr inbounds i8* %outvals, i64 %130
  %132 = call fastcc i32 @copy_real_to_outtype(i32 1, double* %result, i32 %outtype, i8* %131) #6
  br label %133

; <label>:133                                     ; preds = %128, %.thread, %129
  %this_retval.1 = phi i32 [ %132, %129 ], [ %this_retval.0, %128 ], [ -1, %.thread ]
  %134 = or i32 %this_retval.1, %retval.04
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %21
  br i1 %exitcond, label %.loopexit, label %22

.loopexit:                                        ; preds = %133, %9, %7, %2
  %.0 = phi i32 [ -1, %2 ], [ -1, %7 ], [ 0, %9 ], [ %134, %133 ]
  ret i32 %.0
}
