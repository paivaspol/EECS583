define i8** @CCTKi_ScheduleCreateArray(i32 %size) #1 {
  %1 = sext i32 %size to i64
  %2 = shl nsw i64 %1, 3
  %3 = tail call i8* @malloc(i64 %2) #4
  %4 = bitcast i8* %3 to i8**
  %cond = icmp eq i8* %3, null
  br i1 %cond, label %.loopexit, label %.preheader3

.preheader3:                                      ; preds = %0
  %5 = icmp sgt i32 %size, 0
  br i1 %5, label %.lr.ph11, label %.loopexit

.lr.ph11:                                         ; preds = %.preheader3, %12
  %indvars.iv19 = phi i64 [ %indvars.iv.next20, %12 ], [ 0, %.preheader3 ]
  %6 = tail call i8* @malloc(i64 %1) #4
  %7 = getelementptr inbounds i8** %4, i64 %indvars.iv19
  store i8* %6, i8** %7, align 8, !tbaa !2
  %8 = icmp eq i8* %6, null
  br i1 %8, label %.thread.preheader, label %12

.thread.preheader:                                ; preds = %.lr.ph11
  %9 = trunc i64 %indvars.iv19 to i32
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %.lr.ph, label %.critedge.thread

.lr.ph:                                           ; preds = %.thread.preheader
  %sext = shl i64 %indvars.iv19, 32
  %11 = ashr exact i64 %sext, 32
  br label %.thread

; <label>:12                                      ; preds = %.lr.ph11
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %13 = icmp slt i64 %indvars.iv.next20, %1
  br i1 %13, label %.lr.ph11, label %.preheader2

.thread:                                          ; preds = %.lr.ph, %.thread
  %indvars.iv = phi i64 [ %11, %.lr.ph ], [ %indvars.iv.next, %.thread ]
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %14 = getelementptr inbounds i8** %4, i64 %indvars.iv.next
  %15 = load i8** %14, align 8, !tbaa !2
  tail call void @free(i8* %15) #5
  %16 = icmp sgt i64 %indvars.iv, 1
  br i1 %16, label %.thread, label %.critedge.thread

.critedge.thread:                                 ; preds = %.thread, %.thread.preheader
  tail call void @free(i8* %3) #5
  br label %.loopexit

.preheader2:                                      ; preds = %12
  br i1 %5, label %.preheader.lr.ph, label %.loopexit

.preheader.lr.ph:                                 ; preds = %.preheader2
  %17 = add i32 %size, -1
  br label %.lr.ph8

.lr.ph8:                                          ; preds = %.preheader.lr.ph, %._crit_edge
  %indvars.iv15 = phi i64 [ 0, %.preheader.lr.ph ], [ %indvars.iv.next16, %._crit_edge ]
  %18 = getelementptr inbounds i8** %4, i64 %indvars.iv15
  %.pre = load i8** %18, align 8, !tbaa !2
  br label %19

; <label>:19                                      ; preds = %19, %.lr.ph8
  %indvars.iv13 = phi i64 [ 0, %.lr.ph8 ], [ %indvars.iv.next14, %19 ]
  %20 = getelementptr inbounds i8* %.pre, i64 %indvars.iv13
  store i8 0, i8* %20, align 1, !tbaa !6
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %lftr.wideiv = trunc i64 %indvars.iv13 to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %17
  br i1 %exitcond, label %._crit_edge, label %19

._crit_edge:                                      ; preds = %19
  %indvars.iv.next16 = add nuw nsw i64 %indvars.iv15, 1
  %lftr.wideiv17 = trunc i64 %indvars.iv15 to i32
  %exitcond18 = icmp eq i32 %lftr.wideiv17, %17
  br i1 %exitcond18, label %.loopexit, label %.lr.ph8

.loopexit:                                        ; preds = %._crit_edge, %.preheader3, %.preheader2, %0, %.critedge.thread
  %array.01 = phi i8** [ null, %.critedge.thread ], [ null, %0 ], [ %4, %.preheader2 ], [ %4, %.preheader3 ], [ %4, %._crit_edge ]
  ret i8** %array.01
}
