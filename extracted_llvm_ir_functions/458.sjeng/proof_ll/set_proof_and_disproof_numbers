define void @set_proof_and_disproof_numbers(%struct.node* %node) #0 {
entry:
  %moves = alloca [512 x %struct.move_s], align 16
  %0 = bitcast [512 x %struct.move_s]* %moves to i8*
  call void @llvm.lifetime.start(i64 12288, i8* %0) #2
  %expanded = getelementptr inbounds %struct.node* %node, i64 0, i32 2
  %1 = load i8* %expanded, align 1, !tbaa !1
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %if.else90, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32* @white_to_move, align 4, !tbaa !0
  %not.tobool1 = icmp eq i32 %2, 0
  %cond = zext i1 %not.tobool1 to i32
  %3 = load i32* @root_to_move, align 4, !tbaa !0
  %cmp = icmp eq i32 %cond, %3
  %num_children38 = getelementptr inbounds %struct.node* %node, i64 0, i32 1
  %4 = load i8* %num_children38, align 1, !tbaa !1
  %cmp40421 = icmp eq i8 %4, 0
  br i1 %cmp, label %for.cond37.preheader, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then
  br i1 %cmp40421, label %if.then25, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %children = getelementptr inbounds %struct.node* %node, i64 0, i32 6
  %5 = load %struct.node*** %children, align 8, !tbaa !3
  %conv = zext i8 %4 to i32
  br label %for.body

for.cond37.preheader:                             ; preds = %if.then
  br i1 %cmp40421, label %for.end66, label %for.body42.lr.ph

for.body42.lr.ph:                                 ; preds = %for.cond37.preheader
  %children44 = getelementptr inbounds %struct.node* %node, i64 0, i32 6
  %6 = load %struct.node*** %children44, align 8, !tbaa !3
  %conv39 = zext i8 %4 to i32
  br label %for.body42

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv436 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next437, %for.body ]
  %disproof.0430 = phi i32 [ 100000000, %for.body.lr.ph ], [ %.disproof.0, %for.body ]
  %proof.0429 = phi i32 [ 0, %for.body.lr.ph ], [ %.add, %for.body ]
  %arrayidx = getelementptr inbounds %struct.node** %5, i64 %indvars.iv436
  %7 = load %struct.node** %arrayidx, align 8, !tbaa !3
  %proof5 = getelementptr inbounds %struct.node* %7, i64 0, i32 4
  %8 = load i32* %proof5, align 4, !tbaa !0
  %add = add nsw i32 %8, %proof.0429
  %cmp6 = icmp sgt i32 %add, 100000000
  %.add = select i1 %cmp6, i32 100000000, i32 %add
  %disproof12 = getelementptr inbounds %struct.node* %7, i64 0, i32 5
  %9 = load i32* %disproof12, align 4, !tbaa !0
  %cmp13 = icmp slt i32 %9, %disproof.0430
  %.disproof.0 = select i1 %cmp13, i32 %9, i32 %disproof.0430
  %indvars.iv.next437 = add i64 %indvars.iv436, 1
  %10 = trunc i64 %indvars.iv.next437 to i32
  %cmp3 = icmp slt i32 %10, %conv
  br i1 %cmp3, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  %cmp21 = icmp eq i32 %.add, 0
  %cmp23 = icmp eq i32 %.disproof.0, 100000000
  %or.cond400 = or i1 %cmp21, %cmp23
  br i1 %or.cond400, label %if.then25, label %if.else

if.then25:                                        ; preds = %for.cond.preheader, %for.end
  %proof.0.lcssa442 = phi i32 [ %.add, %for.end ], [ 0, %for.cond.preheader ]
  %disproof.0.lcssa441 = phi i32 [ %.disproof.0, %for.end ], [ 100000000, %for.cond.preheader ]
  %11 = load i32* @forwards, align 4, !tbaa !0
  %inc26 = add nsw i32 %11, 1
  store i32 %inc26, i32* @forwards, align 4, !tbaa !0
  call void @StoreTT(i32 999500, i32 1000000, i32 -1000000, i32 -1, i32 0, i32 200) #6
  br label %if.end84

if.else:                                          ; preds = %for.end
  %cmp27 = icmp eq i32 %.disproof.0, 0
  %cmp30 = icmp eq i32 %.add, 100000000
  %or.cond401 = or i1 %cmp27, %cmp30
  br i1 %or.cond401, label %if.then32, label %if.end84

if.then32:                                        ; preds = %if.else
  %12 = load i32* @forwards, align 4, !tbaa !0
  %inc33 = add nsw i32 %12, 1
  store i32 %inc33, i32* @forwards, align 4, !tbaa !0
  call void @StoreTT(i32 -999500, i32 1000000, i32 -1000000, i32 -1, i32 0, i32 200) #6
  br label %if.end84

for.body42:                                       ; preds = %for.body42.lr.ph, %for.body42
  %indvars.iv = phi i64 [ 0, %for.body42.lr.ph ], [ %indvars.iv.next, %for.body42 ]
  %disproof.2423 = phi i32 [ 0, %for.body42.lr.ph ], [ %.add47, %for.body42 ]
  %proof.1422 = phi i32 [ 100000000, %for.body42.lr.ph ], [ %.proof.1, %for.body42 ]
  %arrayidx45 = getelementptr inbounds %struct.node** %6, i64 %indvars.iv
  %13 = load %struct.node** %arrayidx45, align 8, !tbaa !3
  %disproof46 = getelementptr inbounds %struct.node* %13, i64 0, i32 5
  %14 = load i32* %disproof46, align 4, !tbaa !0
  %add47 = add nsw i32 %14, %disproof.2423
  %cmp48 = icmp sgt i32 %add47, 100000000
  %.add47 = select i1 %cmp48, i32 100000000, i32 %add47
  %proof55 = getelementptr inbounds %struct.node* %13, i64 0, i32 4
  %15 = load i32* %proof55, align 4, !tbaa !0
  %cmp56 = icmp slt i32 %15, %proof.1422
  %.proof.1 = select i1 %cmp56, i32 %15, i32 %proof.1422
  %indvars.iv.next = add i64 %indvars.iv, 1
  %16 = trunc i64 %indvars.iv.next to i32
  %cmp40 = icmp slt i32 %16, %conv39
  br i1 %cmp40, label %for.body42, label %for.end66

for.end66:                                        ; preds = %for.body42, %for.cond37.preheader
  %disproof.2.lcssa = phi i32 [ 0, %for.cond37.preheader ], [ %.add47, %for.body42 ]
  %proof.1.lcssa = phi i32 [ 100000000, %for.cond37.preheader ], [ %.proof.1, %for.body42 ]
  %cmp67 = icmp eq i32 %proof.1.lcssa, 0
  %cmp70 = icmp eq i32 %disproof.2.lcssa, 100000000
  %or.cond402 = or i1 %cmp67, %cmp70
  br i1 %or.cond402, label %if.then72, label %if.else74

if.then72:                                        ; preds = %for.end66
  %17 = load i32* @forwards, align 4, !tbaa !0
  %inc73 = add nsw i32 %17, 1
  store i32 %inc73, i32* @forwards, align 4, !tbaa !0
  call void @StoreTT(i32 999500, i32 1000000, i32 -1000000, i32 -1, i32 0, i32 200) #6
  br label %if.end84

if.else74:                                        ; preds = %for.end66
  %cmp75 = icmp eq i32 %disproof.2.lcssa, 0
  %cmp78 = icmp eq i32 %proof.1.lcssa, 100000000
  %or.cond403 = or i1 %cmp75, %cmp78
  br i1 %or.cond403, label %if.then80, label %if.end84

if.then80:                                        ; preds = %if.else74
  %18 = load i32* @forwards, align 4, !tbaa !0
  %inc81 = add nsw i32 %18, 1
  store i32 %inc81, i32* @forwards, align 4, !tbaa !0
  call void @StoreTT(i32 -999500, i32 1000000, i32 -1000000, i32 -1, i32 0, i32 200) #6
  br label %if.end84

if.end84:                                         ; preds = %if.else74, %if.else, %if.then72, %if.then80, %if.then25, %if.then32
  %proof.3 = phi i32 [ %proof.0.lcssa442, %if.then25 ], [ %.add, %if.then32 ], [ %proof.1.lcssa, %if.then72 ], [ %proof.1.lcssa, %if.then80 ], [ %.add, %if.else ], [ %proof.1.lcssa, %if.else74 ]
  %disproof.3 = phi i32 [ %disproof.0.lcssa441, %if.then25 ], [ %.disproof.0, %if.then32 ], [ %disproof.2.lcssa, %if.then72 ], [ %disproof.2.lcssa, %if.then80 ], [ %.disproof.0, %if.else ], [ %disproof.2.lcssa, %if.else74 ]
  %19 = load i32* @hash, align 4, !tbaa !0
  %20 = load i32* @move_number, align 4, !tbaa !0
  %21 = load i32* @ply, align 4, !tbaa !0
  %add85 = add i32 %20, -1
  %sub = add i32 %add85, %21
  %idxprom86 = sext i32 %sub to i64
  %arrayidx87 = getelementptr inbounds [600 x i32]* @hash_history, i64 0, i64 %idxprom86
  store i32 %19, i32* %arrayidx87, align 4, !tbaa !0
  %proof88 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %proof.3, i32* %proof88, align 4, !tbaa !0
  %disproof89 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %disproof.3, i32* %disproof89, align 4, !tbaa !0
  br label %cleanup

if.else90:                                        ; preds = %entry
  %evaluated = getelementptr inbounds %struct.node* %node, i64 0, i32 3
  %22 = load i8* %evaluated, align 1, !tbaa !1
  %tobool91 = icmp eq i8 %22, 0
  br i1 %tobool91, label %if.else299, label %if.then92

if.then92:                                        ; preds = %if.else90
  %value = getelementptr inbounds %struct.node* %node, i64 0, i32 0
  %23 = load i8* %value, align 1, !tbaa !1
  switch i8 %23, label %cleanup [
    i8 2, label %if.then96
    i8 0, label %if.then276
    i8 1, label %if.then284
    i8 3, label %if.then292
  ]

if.then96:                                        ; preds = %if.then92
  %24 = load i32* @hash, align 4, !tbaa !0
  %25 = load i32* @move_number, align 4, !tbaa !0
  %26 = load i32* @ply, align 4, !tbaa !0
  %add97 = add i32 %25, -1
  %sub98 = add i32 %add97, %26
  %idxprom99 = sext i32 %sub98 to i64
  %arrayidx100 = getelementptr inbounds [600 x i32]* @hash_history, i64 0, i64 %idxprom99
  store i32 %24, i32* %arrayidx100, align 4, !tbaa !0
  %call = call i32 @is_draw() #6
  %tobool101 = icmp ne i32 %call, 0
  %27 = load i32* @ply, align 4, !tbaa !0
  %cmp103 = icmp sgt i32 %27, 200
  %or.cond = or i1 %tobool101, %cmp103
  br i1 %or.cond, label %if.then105, label %if.end108

if.then105:                                       ; preds = %if.then96
  %proof106 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 50000, i32* %proof106, align 4, !tbaa !0
  %disproof107 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 50000, i32* %disproof107, align 4, !tbaa !0
  br label %cleanup

if.end108:                                        ; preds = %if.then96
  %28 = load i32* @Variant, align 4, !tbaa !0
  %cmp109 = icmp eq i32 %28, 4
  br i1 %cmp109, label %if.else134, label %if.then111

if.then111:                                       ; preds = %if.end108
  %arrayidx112 = getelementptr inbounds [512 x %struct.move_s]* %moves, i64 0, i64 0
  call void @gen(%struct.move_s* %arrayidx112) #6
  %29 = load i32* @numb_moves, align 4, !tbaa !0
  %call113 = call i32 @in_check() #6
  %30 = load i32* @Variant, align 4, !tbaa !0
  %cmp114 = icmp eq i32 %30, 3
  br i1 %cmp114, label %if.else132, label %for.cond117.preheader

for.cond117.preheader:                            ; preds = %if.then111
  %cmp118416 = icmp sgt i32 %29, 0
  br i1 %cmp118416, label %for.body120, label %if.then177

for.body120:                                      ; preds = %for.cond117.preheader, %for.body120
  %l.0418 = phi i32 [ %l.0.inc126, %for.body120 ], [ 0, %for.cond117.preheader ]
  %i.2417 = phi i32 [ %inc130, %for.body120 ], [ 0, %for.cond117.preheader ]
  call void @make(%struct.move_s* %arrayidx112, i32 %i.2417) #6
  %call123 = call i32 @check_legal(%struct.move_s* %arrayidx112, i32 %i.2417, i32 %call113) #6
  %not.tobool124 = icmp ne i32 %call123, 0
  %inc126 = zext i1 %not.tobool124 to i32
  %l.0.inc126 = add nsw i32 %inc126, %l.0418
  call void @unmake(%struct.move_s* %arrayidx112, i32 %i.2417) #6
  %inc130 = add nsw i32 %i.2417, 1
  %exitcond435 = icmp eq i32 %inc130, %29
  br i1 %exitcond435, label %if.end174, label %for.body120

if.else132:                                       ; preds = %if.then111
  %31 = load i32* @numb_moves, align 4, !tbaa !0
  br label %if.end174

if.else134:                                       ; preds = %if.end108
  store i32 1, i32* @captures, align 4, !tbaa !1
  %arrayidx135 = getelementptr inbounds [512 x %struct.move_s]* %moves, i64 0, i64 0
  call void @gen(%struct.move_s* %arrayidx135) #6
  %32 = load i32* @numb_moves, align 4, !tbaa !0
  store i32 0, i32* @captures, align 4, !tbaa !1
  %call136 = call i32 @in_check() #6
  %33 = icmp sgt i32 %32, 0
  br i1 %33, label %for.body142, label %if.then156

for.body142:                                      ; preds = %if.else134, %for.body142
  %l.2413 = phi i32 [ %l.2.inc148, %for.body142 ], [ 0, %if.else134 ]
  %i.3412 = phi i32 [ %inc152, %for.body142 ], [ 0, %if.else134 ]
  call void @make(%struct.move_s* %arrayidx135, i32 %i.3412) #6
  %call145 = call i32 @check_legal(%struct.move_s* %arrayidx135, i32 %i.3412, i32 %call136) #6
  %not.tobool146 = icmp ne i32 %call145, 0
  %inc148 = zext i1 %not.tobool146 to i32
  %l.2.inc148 = add nsw i32 %inc148, %l.2413
  call void @unmake(%struct.move_s* %arrayidx135, i32 %i.3412) #6
  %inc152 = add nsw i32 %i.3412, 1
  %exitcond434 = icmp eq i32 %inc152, %32
  br i1 %exitcond434, label %if.end154, label %for.body142

if.end154:                                        ; preds = %for.body142
  %tobool155 = icmp eq i32 %l.2.inc148, 0
  br i1 %tobool155, label %if.then156, label %if.else180

if.then156:                                       ; preds = %if.else134, %if.end154
  store i32 0, i32* @captures, align 4, !tbaa !1
  call void @gen(%struct.move_s* %arrayidx135) #6
  %34 = load i32* @numb_moves, align 4, !tbaa !0
  %cmp159408 = icmp sgt i32 %34, 0
  br i1 %cmp159408, label %for.body161, label %if.then177

for.body161:                                      ; preds = %if.then156, %for.body161
  %l.5410 = phi i32 [ %l.5.inc167, %for.body161 ], [ 0, %if.then156 ]
  %i.4409 = phi i32 [ %inc171, %for.body161 ], [ 0, %if.then156 ]
  call void @make(%struct.move_s* %arrayidx135, i32 %i.4409) #6
  %call164 = call i32 @check_legal(%struct.move_s* %arrayidx135, i32 %i.4409, i32 %call136) #6
  %not.tobool165 = icmp ne i32 %call164, 0
  %inc167 = zext i1 %not.tobool165 to i32
  %l.5.inc167 = add nsw i32 %inc167, %l.5410
  call void @unmake(%struct.move_s* %arrayidx135, i32 %i.4409) #6
  %inc171 = add nsw i32 %i.4409, 1
  %exitcond = icmp eq i32 %inc171, %34
  br i1 %exitcond, label %if.end174, label %for.body161

if.end174:                                        ; preds = %for.body120, %for.body161, %if.else132
  %l.7 = phi i32 [ %31, %if.else132 ], [ %l.5.inc167, %for.body161 ], [ %l.0.inc126, %for.body120 ]
  %cmp175 = icmp eq i32 %l.7, 0
  br i1 %cmp175, label %if.then177, label %if.else180

if.then177:                                       ; preds = %for.cond117.preheader, %if.then156, %if.end174
  %proof178 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 1, i32* %proof178, align 4, !tbaa !0
  %disproof179 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 1, i32* %disproof179, align 4, !tbaa !0
  br label %cleanup

if.else180:                                       ; preds = %if.end174, %if.end154
  %l.7407 = phi i32 [ %l.2.inc148, %if.end154 ], [ %l.7, %if.end174 ]
  %35 = load i32* @white_to_move, align 4, !tbaa !0
  %not.tobool181 = icmp eq i32 %35, 0
  %cond182 = zext i1 %not.tobool181 to i32
  %36 = load i32* @root_to_move, align 4, !tbaa !0
  %cmp183 = icmp eq i32 %cond182, %36
  %37 = load i32* @Variant, align 4, !tbaa !0
  %.off = add i32 %37, -3
  %38 = icmp ugt i32 %.off, 1
  br i1 %cmp183, label %if.then185, label %if.else226

if.then185:                                       ; preds = %if.else180
  br i1 %38, label %if.then190, label %if.else196

if.then190:                                       ; preds = %if.then185
  %39 = load i32* @ply, align 4, !tbaa !0
  %div = sdiv i32 %39, 50
  %add191 = add nsw i32 %div, 1
  %proof192 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add191, i32* %proof192, align 4, !tbaa !0
  %40 = load i32* @ply, align 4, !tbaa !0
  %div193 = sdiv i32 %40, 50
  %add194 = add nsw i32 %div193, %l.7407
  %disproof195 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add194, i32* %disproof195, align 4, !tbaa !0
  br label %cleanup

if.else196:                                       ; preds = %if.then185
  %cmp197 = icmp eq i32 %37, 4
  br i1 %cmp197, label %if.then199, label %if.else217

if.then199:                                       ; preds = %if.else196
  %41 = load i32* @phase, align 4, !tbaa !0
  %cmp200 = icmp eq i32 %41, 2
  %42 = load i32* @ply, align 4, !tbaa !0
  br i1 %cmp200, label %if.then202, label %if.else209

if.then202:                                       ; preds = %if.then199
  %div203 = sdiv i32 %42, 30
  %add204 = add nsw i32 %div203, 1
  %proof205 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add204, i32* %proof205, align 4, !tbaa !0
  %43 = load i32* @ply, align 4, !tbaa !0
  %div206 = sdiv i32 %43, 30
  %add207 = add nsw i32 %div206, %l.7407
  %disproof208 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add207, i32* %disproof208, align 4, !tbaa !0
  br label %cleanup

if.else209:                                       ; preds = %if.then199
  %div210 = sdiv i32 %42, 80
  %add211 = add nsw i32 %div210, 1
  %proof212 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add211, i32* %proof212, align 4, !tbaa !0
  %44 = load i32* @ply, align 4, !tbaa !0
  %div213 = sdiv i32 %44, 80
  %add214 = add nsw i32 %div213, %l.7407
  %disproof215 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add214, i32* %disproof215, align 4, !tbaa !0
  br label %cleanup

if.else217:                                       ; preds = %if.else196
  %45 = load i32* @ply, align 4, !tbaa !0
  %div218 = sdiv i32 %45, 150
  %add219 = add nsw i32 %div218, 1
  %proof220 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add219, i32* %proof220, align 4, !tbaa !0
  %46 = load i32* @ply, align 4, !tbaa !0
  %div221 = sdiv i32 %46, 150
  %add222 = add nsw i32 %div221, %l.7407
  %disproof223 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add222, i32* %disproof223, align 4, !tbaa !0
  br label %cleanup

if.else226:                                       ; preds = %if.else180
  br i1 %38, label %if.then232, label %if.else239

if.then232:                                       ; preds = %if.else226
  %47 = load i32* @ply, align 4, !tbaa !0
  %div233 = sdiv i32 %47, 50
  %add234 = add nsw i32 %div233, %l.7407
  %proof235 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add234, i32* %proof235, align 4, !tbaa !0
  %48 = load i32* @ply, align 4, !tbaa !0
  %div236 = sdiv i32 %48, 50
  %add237 = add nsw i32 %div236, 1
  %disproof238 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add237, i32* %disproof238, align 4, !tbaa !0
  br label %cleanup

if.else239:                                       ; preds = %if.else226
  %cmp240 = icmp eq i32 %37, 4
  br i1 %cmp240, label %if.then242, label %if.else260

if.then242:                                       ; preds = %if.else239
  %49 = load i32* @phase, align 4, !tbaa !0
  %cmp243 = icmp eq i32 %49, 2
  %50 = load i32* @ply, align 4, !tbaa !0
  br i1 %cmp243, label %if.then245, label %if.else252

if.then245:                                       ; preds = %if.then242
  %div246 = sdiv i32 %50, 30
  %add247 = add nsw i32 %div246, %l.7407
  %proof248 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add247, i32* %proof248, align 4, !tbaa !0
  %51 = load i32* @ply, align 4, !tbaa !0
  %div249 = sdiv i32 %51, 30
  %add250 = add nsw i32 %div249, 1
  %disproof251 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add250, i32* %disproof251, align 4, !tbaa !0
  br label %cleanup

if.else252:                                       ; preds = %if.then242
  %div253 = sdiv i32 %50, 80
  %add254 = add nsw i32 %div253, %l.7407
  %proof255 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add254, i32* %proof255, align 4, !tbaa !0
  %52 = load i32* @ply, align 4, !tbaa !0
  %div256 = sdiv i32 %52, 80
  %add257 = add nsw i32 %div256, 1
  %disproof258 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add257, i32* %disproof258, align 4, !tbaa !0
  br label %cleanup

if.else260:                                       ; preds = %if.else239
  %53 = load i32* @ply, align 4, !tbaa !0
  %div261 = sdiv i32 %53, 150
  %add262 = add nsw i32 %div261, %l.7407
  %proof263 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 %add262, i32* %proof263, align 4, !tbaa !0
  %54 = load i32* @ply, align 4, !tbaa !0
  %div264 = sdiv i32 %54, 150
  %add265 = add nsw i32 %div264, 1
  %disproof266 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 %add265, i32* %disproof266, align 4, !tbaa !0
  br label %cleanup

if.then276:                                       ; preds = %if.then92
  %proof277 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 100000000, i32* %proof277, align 4, !tbaa !0
  %disproof278 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 0, i32* %disproof278, align 4, !tbaa !0
  br label %cleanup

if.then284:                                       ; preds = %if.then92
  %proof285 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 0, i32* %proof285, align 4, !tbaa !0
  %disproof286 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 100000000, i32* %disproof286, align 4, !tbaa !0
  br label %cleanup

if.then292:                                       ; preds = %if.then92
  %proof293 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 50000, i32* %proof293, align 4, !tbaa !0
  %disproof294 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 50000, i32* %disproof294, align 4, !tbaa !0
  br label %cleanup

if.else299:                                       ; preds = %if.else90
  %disproof300 = getelementptr inbounds %struct.node* %node, i64 0, i32 5
  store i32 1, i32* %disproof300, align 4, !tbaa !0
  %proof301 = getelementptr inbounds %struct.node* %node, i64 0, i32 4
  store i32 1, i32* %proof301, align 4, !tbaa !0
  br label %cleanup

cleanup:                                          ; preds = %if.end84, %if.else217, %if.else209, %if.then202, %if.then190, %if.else260, %if.else252, %if.then245, %if.then232, %if.then177, %if.then284, %if.then292, %if.then276, %if.else299, %if.then92, %if.then105
  call void @llvm.lifetime.end(i64 12288, i8* %0) #2
  ret void
}
