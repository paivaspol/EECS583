void r_serial_arch(gauge_file *gf)
{
  /* gf  = gauge configuration file structure */

  FILE *fp;
  gauge_header *gh;
  char *filename;
  int byterevflag;

  off_t gauge_check_size;   /* Size of gauge configuration checksum record */
  int rcv_rank, rcv_coords;
  int destnode;
  int i,k;
  int x,y,z,t;
  gauge_check test_gc;
  u_int32type *val;
  int rank29,rank31;
  su3_matrix tmpsu3[4];
  char myname[] = "r_serial_arch";

  int mu,a,b,p;
  double *uin, *q;
  int big_end;
  double U[4][18];
  u_int32type chksum;
  
  fp = gf->fp;
  gh = gf->header;
  filename = gf->filename;
  byterevflag = gf->byterevflag;

  if(this_node == 0)
    {
      gauge_check_size = 0;
      
      if(gf->parallel)
	printf("%s: Attempting serial read from parallel file \n",myname);

      big_end = big_endian();
      /* printf("big_end is %d\n", big_end); */
      uin = (double *) calloc(nx*ny*nz*48, sizeof(double));
      if(uin == NULL)
	{
	  printf("%s: Node %d can't malloc uin buffer to read timeslice\n",
		 myname,this_node);
	  printf("recompile with smaller read buffer: uin\n");
	  fflush(stdout);
	  terminate(1);
	}
    }

  /* Initialize checksums */
  chksum = 0;
  test_gc.sum29 = 0;
  test_gc.sum31 = 0;
  /* counts 32-bit words mod 29 and mod 31 in order of appearance
     on file */
  /* Here all nodes see the same sequence because we read serially */
  rank29 = 0;
  rank31 = 0;

  g_sync();

  /* Node 0 reads and deals out the values */
  for(rcv_rank=0; rcv_rank<volume; rcv_rank++)
    {
      rcv_coords = rcv_rank;

      x = rcv_coords % nx;   rcv_coords /= nx;
      y = rcv_coords % ny;   rcv_coords /= ny;
      z = rcv_coords % nz;   rcv_coords /= nz;
      t = rcv_coords % nt;

      /* The node that gets the next set of gauge links */
      destnode=node_number(x,y,z,t);
      
      if(this_node==0){
	if( (int)fread(uin,48*sizeof(double),1,fp) != 1)
	  {
	    printf("%s: node %d gauge configuration read error %d file %s\n",
		   myname,this_node,errno,filename); 
	    fflush(stdout); terminate(1);
	  }

	if (!big_end) byterevn((int32type *)uin,48);
	q = uin;
	for (mu=0;mu<4;mu++) {
	  for (p=0;p<12;p++) {
	    chksum += *(u_int32type *) q;
	    U[mu][p] = (double) *q++;
	  }
	  complete_U(U[mu]);
	  /**
	  for (p=0;p<18;p++) printf("p=%d, e=%f\n", p, U[mu][p]);
	  **/
		 
          for(a=0; a<3; a++) for(b=0; b<3; b++) { 
	    tmpsu3[mu].e[a][b].real = U[mu][2*(3*a+b)];
     /*	    printf("real: p=%d, mu=%d, e=%f\n", p,mu,U[mu][2*(3*a+b)]); */
	    tmpsu3[mu].e[a][b].imag = U[mu][2*(3*a+b)+1];
     /*	    printf("imag: p=%d, mu=%d, e=%f\n", p,mu,U[mu][2*(3*a+b)+1]); */
	  } 
	}

	if(destnode==0){	/* just copy links */
	  i = node_index(x,y,z,t);
     /*   printf("lattice node_index = %d, mu = %d\n", i, mu); */
	  memcpy((void *)&lattice[i].link[0], 
		 (void *)&tmpsu3, 4*sizeof(su3_matrix));
	} else {		/* send to correct node */
	  send_field((char *)tmpsu3, 4*sizeof(su3_matrix),destnode);
	}
      } 
      /* The node which contains this site reads message */
      else {	/* for all nodes other than node 0 */
	if(this_node==destnode){
	  i = node_index(x,y,z,t);
	  get_field((char *)&lattice[i].link[0],4*sizeof(su3_matrix));
	}
      }

      /* Any needed byte reversing was already done. Compute MILC checksums */

      if(this_node==destnode)
	{
	  /* Accumulate checksums */
	  for(k = 0, val = (u_int32type *)&lattice[i].link[0]; 
	      k < 4*(int)sizeof(su3_matrix)/(int)sizeof(int32type); k++, val++)
   	    {
	      test_gc.sum29 ^= (*val)<<rank29 | (*val)>>(32-rank29);
	      test_gc.sum31 ^= (*val)<<rank31 | (*val)>>(32-rank31);
	      rank29++; if(rank29 >= 29)rank29 = 0;
	      rank31++; if(rank31 >= 31)rank31 = 0;
	    }
	}
      else
	{
	  rank29 += 4*sizeof(su3_matrix)/sizeof(int32type);
	  rank31 += 4*sizeof(su3_matrix)/sizeof(int32type);
	  rank29 %= 29;
	  rank31 %= 31;
	}
    }
  
  /* Combine node checksum contributions with global exclusive or */
  g_xor32(&test_gc.sum29);
  g_xor32(&test_gc.sum31);
  
  if(this_node==0)
    {
      /* Read and verify checksum */
      
      printf("Restored archive gauge configuration serially from file %s\n",
	     filename);
      if (chksum != gf->check.sum31)
	{
	  printf("Archive style checksum violation: computed %x, read %x\n",
		 chksum, gf->check.sum31);
	}
      else
	{
	  printf("Archive style checksum = %x OK\n", chksum);
	}
      fflush(stdout);
      free(uin);

      /* Store MILC style checksums */
      gf->check.sum29 = test_gc.sum29;
      gf->check.sum31 = test_gc.sum31;
    }
  
} /* r_serial_arch */
