static void init_slice (int start_mb_addr)
{
  int i;
  Picture *currPic = img->currentPicture;
  DataPartition *dataPart;
  Bitstream *currStream;
  Slice *currSlice;

  img->current_mb_nr = start_mb_addr;

  // Allocate new Slice in the current Picture, and set img->currentSlice
  assert (currPic != NULL);
  currPic->no_slices++;
  if (currPic->no_slices >= MAXSLICEPERPICTURE)
    error ("Too many slices per picture, increase MAXLSICESPERPICTURE in global.h.", -1);

  currPic->slices[currPic->no_slices-1] = malloc_slice();
  currSlice = currPic->slices[currPic->no_slices-1];

  img->currentSlice = currSlice;

  currSlice->picture_id = img->tr % 256;
  currSlice->qp = img->qp;
  currSlice->start_mb_nr = start_mb_addr;
  currSlice->slice_too_big = dummy_slice_too_big;

  for (i = 0; i < currSlice->max_part_nr; i++)
  {
    dataPart = &(currSlice->partArr[i]);
    if (input->symbol_mode == UVLC)
      dataPart->writeSyntaxElement = writeSyntaxElement_UVLC;
    else
      dataPart->writeSyntaxElement = writeSyntaxElement_CABAC;
    
    currStream = dataPart->bitstream;
    currStream->bits_to_go = 8;
    currStream->byte_pos = 0;
    currStream->byte_buf = 0;
  }

    // restrict list 1 size
//  img->num_ref_idx_l0_active = max(1, (img->type==B_SLICE ? active_pps->num_ref_idx_l0_active_minus1 + 1: active_pps->num_ref_idx_l0_active_minus1 +1 )); 
//  img->num_ref_idx_l1_active = (img->type==B_SLICE ? active_pps->num_ref_idx_l1_active_minus1 + 1 : 0);
  img->num_ref_idx_l0_active = active_pps->num_ref_idx_l0_active_minus1 + 1; 
  img->num_ref_idx_l1_active = active_pps->num_ref_idx_l1_active_minus1 + 1;

  // generate reference picture lists
  init_lists(img->type, img->structure);

  // assign list 0 size from list size
  img->num_ref_idx_l0_active = listXsize[0];
  img->num_ref_idx_l1_active = listXsize[1];

  //if (!img->MbaffFrameFlag)
  {
    if ((img->type == P_SLICE || img->type == SP_SLICE) && input->P_List0_refs)
    {
      img->num_ref_idx_l0_active = min(img->num_ref_idx_l0_active, input->P_List0_refs);
      listXsize[0] = min(listXsize[0], input->P_List0_refs);  
    }
    if (img->type == B_SLICE )
    {
      
      if (input->B_List0_refs)
      {
        img->num_ref_idx_l0_active = min(img->num_ref_idx_l0_active, input->B_List0_refs);
        listXsize[0] = min(listXsize[0], input->B_List0_refs);  
      }
      if (input->B_List1_refs)
      {
        
        img->num_ref_idx_l1_active = min(img->num_ref_idx_l1_active, input->B_List1_refs);
        listXsize[1] = min(listXsize[1], input->B_List1_refs);  
      }
    }
  } 

  //Perform memory management based on poc distances for PyramidCoding
  if (img->nal_reference_idc  && input->PyramidCoding && input->PocMemoryManagement && dpb.used_size == dpb.size)
  {    
    poc_based_ref_management(img->frame_num);
  }

  init_ref_pic_list_reordering();

  //Perform reordering based on poc distances for PyramidCoding
  if (img->type==P_SLICE && input->PyramidCoding && input->PyramidRefReorder)
  {
    
    int i, num_ref;

    alloc_ref_pic_list_reordering_buffer(currSlice);
    
    if ((img->type != I_SLICE) && (img->type !=SI_SLICE))
    {
      for (i=0; i<img->num_ref_idx_l0_active + 1; i++)
      {
        currSlice->remapping_of_pic_nums_idc_l0[i] = 3;
        currSlice->abs_diff_pic_num_minus1_l0[i] = 0;
        currSlice->long_term_pic_idx_l0[i] = 0;
      }
      
      if (img->type == B_SLICE)
      {
        for (i=0; i<img->num_ref_idx_l1_active + 1; i++)
        {
          currSlice->remapping_of_pic_nums_idc_l1[i] = 3;
          currSlice->abs_diff_pic_num_minus1_l1[i] = 0;
          currSlice->long_term_pic_idx_l1[i] = 0;
        }
      }
    }
    
    if ((img->type != I_SLICE) && (img->type !=SI_SLICE))
    {
      num_ref = img->num_ref_idx_l0_active;
      poc_ref_pic_reorder(listX[LIST_0], 
                          num_ref, 
                          currSlice->remapping_of_pic_nums_idc_l0, 
                          currSlice->abs_diff_pic_num_minus1_l0, 
                          currSlice->long_term_pic_idx_l0, 0, LIST_0);
      
      //reference picture reordering
      reorder_ref_pic_list(listX[LIST_0], &listXsize[LIST_0], 
                           img->num_ref_idx_l0_active - 1, 
                           currSlice->remapping_of_pic_nums_idc_l0, 
                           currSlice->abs_diff_pic_num_minus1_l0, 
                           currSlice->long_term_pic_idx_l0);
      
		// This is not necessary since order is already poc based...  
      if (img->type == B_SLICE)
      {
        num_ref = img->num_ref_idx_l1_active;
        poc_ref_pic_reorder(listX[LIST_1], 
                            num_ref, 
                            currSlice->remapping_of_pic_nums_idc_l1, 
                            currSlice->abs_diff_pic_num_minus1_l1, 
                            currSlice->long_term_pic_idx_l1, 0, LIST_1);
        
        //reference picture reordering
        reorder_ref_pic_list(listX[LIST_1], &listXsize[LIST_1], 
                             img->num_ref_idx_l1_active - 1, 
                             currSlice->remapping_of_pic_nums_idc_l1, 
                             currSlice->abs_diff_pic_num_minus1_l1, 
                             currSlice->long_term_pic_idx_l1);
      }
    }
  }


  //if (img->MbaffFrameFlag)
  if (img->structure==FRAME)
    init_mbaff_lists();

  if (img->type != I_SLICE && (active_pps->weighted_pred_flag == 1 || (active_pps->weighted_bipred_idc > 0 && (img->type == B_SLICE))))
  {
  	if (img->type==P_SLICE || img->type==SP_SLICE)
    {
      if (input->GenerateMultiplePPS && input->RDPictureDecision)
      {
        if (enc_picture==enc_frame_picture2)
          estimate_weighting_factor_P_slice (0);
        else
          estimate_weighting_factor_P_slice (1);
      }
      else
        estimate_weighting_factor_P_slice (0);
      
    }
    else
       estimate_weighting_factor_B_slice ();
  }

  set_ref_pic_num();

  if (img->type == B_SLICE)
    compute_colocated(Co_located, listX);

}
