int Mode_Decision_for_4x4IntraBlocks (int  b8,  int  b4,  double  lambda,  int*  min_cost)
{
  int     ipmode, best_ipmode = 0, i, j, k, x, y, cost, dummy;
  int     c_nz, nonzero = 0, rec4x4[4][4], diff[16];
  double  rdcost;
  int     block_x     = 8*(b8%2)+4*(b4%2);
  int     block_y     = 8*(b8/2)+4*(b4/2);
  int     pic_pix_x   = img->pix_x+block_x;
  int     pic_pix_y   = img->pix_y+block_y;
  int     pic_opix_x   = img->opix_x+block_x;
  int     pic_opix_y   = img->opix_y+block_y;
  int     pic_block_x = pic_pix_x/4;
  int     pic_block_y = pic_pix_y/4;
  double  min_rdcost  = 1e30;

#if defined(SPEC_CPU)
  /* SPEC_CPU: epsilon is required for systems where double can be
     more than 64-bits (e.g. x87) */
  /* Allow 1 ulp of error @ ~2000.0f */
  /* hex value of epsilon = 0x3d50000000000000ull */
  double epsilon = 2.27373675443232059478759765626E-13f;
#endif

  int left_available, up_available, all_available;

  int     upMode;
  int     leftMode;
  int     mostProbableMode;

  PixelPos left_block;
  PixelPos top_block;

#ifdef BEST_NZ_COEFF
  int best_nz_coeff = 0;
#endif

  // Residue Color Transform
  int residue_R, residue_G, residue_B;
  int rate, distortion, temp;
  int c_ipmode = img->mb_data[img->current_mb_nr].c_ipred_mode;
  int rec4x4_c[2][4][4];
  
  getLuma4x4Neighbour(img->current_mb_nr, block_x/4, block_y/4, -1,  0, &left_block);
  getLuma4x4Neighbour(img->current_mb_nr, block_x/4, block_y/4,  0, -1, &top_block);

  // constrained intra pred
  if (input->UseConstrainedIntraPred)
  {
    left_block.available = left_block.available ? img->intra_block[left_block.mb_addr] : 0;
    top_block.available  = top_block.available  ? img->intra_block[top_block.mb_addr]  : 0;
  }

  upMode            = top_block.available ? img->ipredmode[top_block.pos_x ][top_block.pos_y ] : -1;
  leftMode          = left_block.available ? img->ipredmode[left_block.pos_x][left_block.pos_y] : -1;

  mostProbableMode  = (upMode < 0 || leftMode < 0) ? DC_PRED : upMode < leftMode ? upMode : leftMode;

  *min_cost = INT_MAX;

  //===== INTRA PREDICTION FOR 4x4 BLOCK =====
  intrapred_luma (pic_pix_x, pic_pix_y, &left_available, &up_available, &all_available);

  //===== LOOP OVER ALL 4x4 INTRA PREDICTION MODES =====
  for (ipmode=0; ipmode<NO_INTRA_PMODE; ipmode++)
  {
    int available_mode =  (ipmode==DC_PRED) ||
        ((ipmode==VERT_PRED||ipmode==VERT_LEFT_PRED||ipmode==DIAG_DOWN_LEFT_PRED) && up_available ) ||
        ((ipmode==HOR_PRED||ipmode==HOR_UP_PRED) && left_available ) ||(all_available);

    if (input->IntraDisableInterOnly==0 || img->type != I_SLICE)
    {
      if (input->Intra4x4ParDisable && (ipmode==VERT_PRED||ipmode==HOR_PRED))
        continue;
      
      if (input->Intra4x4DiagDisable && (ipmode==DIAG_DOWN_LEFT_PRED||ipmode==DIAG_DOWN_RIGHT_PRED))
        continue;
      
      if (input->Intra4x4DirDisable && ipmode>=VERT_RIGHT_PRED)
        continue;
    }
 
    if( available_mode)
    {
      if (!input->rdopt)
      {
        for (k=j=0; j<4; j++)
          for (i=0; i<4; i++, k++)
          {
            diff[k] = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[ipmode][j][i];
          }
        cost  = (ipmode == mostProbableMode) ? 0 : (int)floor(4 * lambda );
        cost += SATD (diff, input->hadamard);
        if (cost < *min_cost)
        {
          best_ipmode = ipmode;
          *min_cost   = cost;
        }
      }
      else
      {
        // Residue Color Transform
        if(!img->residue_transform_flag)
        {
          // get prediction and prediction error
          for (j=0; j<4; j++)
          for (i=0; i<4; i++)
          {
            img->mpr[block_x+i][block_y+j]  = img->mprr[ipmode][j][i];
            img->m7[i][j]                   = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[ipmode][j][i];
          }

          //===== store the coding state =====
          store_coding_state (cs_cm);
          // get and check rate-distortion cost
#if defined(SPEC_CPU)
          rdcost = RDCost_for_4x4IntraBlocks (&c_nz, b8, b4, ipmode, lambda, min_rdcost, mostProbableMode);
          if ((fabs(rdcost - min_rdcost) > epsilon) && (rdcost < min_rdcost))
#else
          if ((rdcost = RDCost_for_4x4IntraBlocks (&c_nz, b8, b4, ipmode, lambda, min_rdcost, mostProbableMode)) < min_rdcost)
#endif
          {
            //--- set coefficients ---
            for (j=0; j<2; j++)
            for (i=0; i<18;i++)  cofAC4x4[j][i]=img->cofAC[b8][b4][j][i];

            //--- set reconstruction ---
            for (y=0; y<4; y++)
            for (x=0; x<4; x++)  rec4x4[y][x] = enc_picture->imgY[pic_pix_y+y][pic_pix_x+x];

            //--- flag if dct-coefficients must be coded ---
            nonzero = c_nz;

            //--- set best mode update minimum cost ---
            min_rdcost    = rdcost;
            best_ipmode   = ipmode;
#ifdef BEST_NZ_COEFF
            best_nz_coeff = img->nz_coeff [img->current_mb_nr][block_x/4][block_y/4];
#endif

          }
          reset_coding_state (cs_cm);
        } 
        else 
        {
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              residue_B = imgUV_org[0][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[0][c_ipmode][block_x+i][block_y+j];
              residue_G = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[ipmode][j][i];
              residue_R = imgUV_org[1][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[1][c_ipmode][block_x+i][block_y+j];
              
              /* Foward Residue Transform */
              resTrans_R[i][j] = residue_R-residue_B;
              temp = residue_B+(resTrans_R[i][j]>>1);
              resTrans_B[i][j] = residue_G-temp;
              resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
            }
            
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              img->m7[i][j]  = resTrans_G[i][j];
            }

          store_coding_state (cs_cm);
          rate = (int) RDCost_for_4x4IntraBlocks (&c_nz, b8, b4, ipmode, lambda, min_rdcost, mostProbableMode);
          reset_coding_state (cs_cm);

          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              rec_resG[i][j] = img->m7[i][j];
              img->m7[i][j]  = resTrans_R[i][j];
            }
          store_coding_state (cs_cm);
          rate += RDCost_for_4x4Blocks_Chroma (b8+4, b4, 0);
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              rec_resR[i][j] = img->m7[i][j];
              img->m7[i][j]  = resTrans_B[i][j];
            }
          rate += RDCost_for_4x4Blocks_Chroma (b8+8, b4, 1);
          reset_coding_state (cs_cm);
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              rec_resB[i][j] = img->m7[i][j];
            }

          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              /* Inverse Residue Transform */
              temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
              residue_G = rec_resB[i][j]+temp;
              residue_B = temp - (rec_resR[i][j]>>1);
              residue_R = residue_B+rec_resR[i][j];
              enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][block_x+i][block_y+j]));
              enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr[ipmode][j][i]));
              enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][block_x+i][block_y+j]));
            }

          //===== get distortion (SSD) of 4x4 block =====
          distortion = 0;
          for (y=0; y<4; y++)
            for (x=pic_pix_x; x<pic_pix_x+4; x++)
            {
              distortion += (imgY_org[pic_pix_y+y][x] - enc_picture->imgY[pic_pix_y+y][x])*(imgY_org[pic_pix_y+y][x] - enc_picture->imgY[pic_pix_y+y][x]);
              distortion += (imgUV_org[0][pic_pix_y+y][x] - enc_picture->imgUV[0][pic_pix_y+y][x])*(imgUV_org[0][pic_pix_y+y][x] - enc_picture->imgUV[0][pic_pix_y+y][x]);
              distortion += (imgUV_org[1][pic_pix_y+y][x] - enc_picture->imgUV[1][pic_pix_y+y][x])*(imgUV_org[1][pic_pix_y+y][x] - enc_picture->imgUV[1][pic_pix_y+y][x]);
            }
          rdcost = (double)distortion + lambda*(double)rate;

          if (rdcost < min_rdcost)
          {
            //--- set coefficients ---
            for (j=0; j<2; j++)
              for (i=0; i<18;i++)  cofAC4x4[j][i]=img->cofAC[b8][b4][j][i];

            for (j=0; j<2; j++)
              for (i=0; i<18;i++)  cofAC4x4_chroma[0][j][i]=img->cofAC[b8+4][b4][j][i];
            for (j=0; j<2; j++)
              for (i=0; i<18;i++)  cofAC4x4_chroma[1][j][i]=img->cofAC[b8+8][b4][j][i];

            for (i=0; i<2; i++)
            { //uv
              dc_level[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
              cbp_chroma_block[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = cbp_chroma_block_temp[i][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
              //--- set reconstruction ---
              for (y=0; y<4; y++)
                for (x=0; x<4; x++)  rec4x4_c[i][y][x] = enc_picture->imgUV[i][pic_pix_y+y][pic_pix_x+x];
            }

            //--- set reconstruction ---
            for (y=0; y<4; y++)
              for (x=0; x<4; x++)  rec4x4[y][x] = enc_picture->imgY[pic_pix_y+y][pic_pix_x+x];

            //--- flag if dct-coefficients must be coded ---
            nonzero = c_nz;

            //--- set best mode update minimum cost ---
            min_rdcost  = rdcost;
            best_ipmode = ipmode;
#ifdef BEST_NZ_COEFF
            best_nz_coeff = img->nz_coeff [img->current_mb_nr][block_x/4][block_y/4];
#endif
          }
        }
      }
    }
  }

#ifdef BEST_NZ_COEFF
  img->nz_coeff [img->current_mb_nr][block_x/4][block_y/4] = best_nz_coeff;
#endif
  //===== set intra mode prediction =====
  img->ipredmode[pic_block_x][pic_block_y] = best_ipmode;
  img->mb_data[img->current_mb_nr].intra_pred_modes[4*b8+b4] = mostProbableMode == best_ipmode ? -1 : best_ipmode < mostProbableMode ? best_ipmode : best_ipmode-1;

  if (!input->rdopt)
  {
    // Residue Color Transform
    if(!img->residue_transform_flag)
    {
      // get prediction and prediction error
      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          img->mpr[block_x+i][block_y+j]  = img->mprr[best_ipmode][j][i];
          img->m7[i][j]                   = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[best_ipmode][j][i];
        }
      nonzero = dct_luma (block_x, block_y, &dummy, 1);
    } else 
    {
      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          residue_B = imgUV_org[0][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[0][c_ipmode][block_x+i][block_y+j];
          residue_G = imgY_org[pic_opix_y+j][pic_opix_x+i] - img->mprr[best_ipmode][j][i];
          residue_R = imgUV_org[1][pic_opix_y+j][pic_opix_x+i] - img->mprr_c[1][c_ipmode][block_x+i][block_y+j];
          
          /* Forward Residue Transform */
          resTrans_R[i][j] = residue_R-residue_B;
          temp = residue_B+(resTrans_R[i][j]>>1);
          resTrans_B[i][j] = residue_G-temp;
          resTrans_G[i][j] = temp+(resTrans_B[i][j]>>1);
        }

      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          img->m7[i][j]  = resTrans_G[i][j];
        }
      nonzero = dct_luma (block_x, block_y, &dummy, 1);
      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          rec_resG[i][j] = img->m7[i][j];
          img->m7[i][j]  = resTrans_R[i][j];
        }
      cbp_chroma_block[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dct_chroma4x4 (0, b8+4, b4);
      dc_level[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[0][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          rec_resR[i][j] = img->m7[i][j];
          img->m7[i][j]  = resTrans_B[i][j];
        }
      cbp_chroma_block[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dct_chroma4x4 (1, b8+8, b4);
      dc_level[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = dc_level_temp[1][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)];
      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          rec_resB[i][j] = img->m7[i][j];
        }
      for (j=0; j<4; j++)
        for (i=0; i<4; i++)
        {
          /* Inverse Residue Transform */
          temp      = rec_resG[i][j]-(rec_resB[i][j]>>1);
          residue_G = rec_resB[i][j]+temp;
          residue_B = temp - (rec_resR[i][j]>>1);
          residue_R = residue_B+rec_resR[i][j];
          enc_picture->imgUV[0][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_B+(int)img->mprr_c[0][c_ipmode][block_x+i][block_y+j]));
          enc_picture->imgY[pic_pix_y+j][pic_pix_x+i]     = min(img->max_imgpel_value,max(0,residue_G+(int)img->mprr[best_ipmode][j][i]));
          enc_picture->imgUV[1][pic_pix_y+j][pic_pix_x+i] = min(img->max_imgpel_value_uv,max(0,residue_R+(int)img->mprr_c[1][c_ipmode][block_x+i][block_y+j]));
        }
    }
  }
  else
  {
    //===== restore coefficients =====
    for (j=0; j<2; j++)
      for (i=0; i<18;i++)  img->cofAC[b8][b4][j][i]=cofAC4x4[j][i];

    // Residue Color Transform
    if(img->residue_transform_flag)
    {
      for (j=0; j<2; j++)
        for (i=0; i<18;i++)  img->cofAC[b8+4][b4][j][i]=cofAC4x4_chroma[0][j][i];
      for (j=0; j<2; j++)
        for (i=0; i<18;i++)  img->cofAC[b8+8][b4][j][i]=cofAC4x4_chroma[1][j][i];
    }

    //===== restore reconstruction and prediction (needed if single coeffs are removed) =====
    for (y=0; y<4; y++)
      for (x=0; x<4; x++)
      {
        enc_picture->imgY[pic_pix_y+y][pic_pix_x+x] = rec4x4[y][x];
        img->mpr[block_x+x][block_y+y] = img->mprr[best_ipmode][y][x];
      }

    // Residue Color Transform
    if(img->residue_transform_flag)
    {
      for (i=0; i<2; i++)
      { //uv
        //--- set reconstruction ---
        for (y=0; y<4; y++)
          for (x=0; x<4; x++) enc_picture->imgUV[i][pic_pix_y+y][pic_pix_x+x] = rec4x4_c[i][y][x] ;
      }
    }

  }

  return nonzero;
}
