int                                               //  ==> minimum motion cost after search
FullPelBlockMotionBiPred (pel_t**   orig_pic,     // <--  original pixel values for the AxB block
                          short       ref,          // <--  reference frame (0... or -1 (backward))
                          int       list,
                          int       pic_pix_x,    // <--  absolute x-coordinate of regarded AxB block
                          int       pic_pix_y,    // <--  absolute y-coordinate of regarded AxB block
                          int       blocktype,    // <--  block type (1-16x16 ... 7-4x4)
                          int       iteration,    
                          short     pred_mv_x1,    // <--  motion vector predictor (x) in sub-pel units
                          short     pred_mv_y1,    // <--  motion vector predictor (y) in sub-pel units
                          short     pred_mv_x2,    // <--  motion vector predictor (x) in sub-pel units
                          short     pred_mv_y2,    // <--  motion vector predictor (y) in sub-pel units
                          short*    mv_x,         // <--> in: search center (x) / out: motion vector (x) - in pel units
                          short*    mv_y,         // <--> in: search center (y) / out: motion vector (y) - in pel units
                          short*    s_mv_x,         // <--> in: search center (x) / out: motion vector (x) - in pel units
                          short*    s_mv_y,         // <--> in: search center (y) / out: motion vector (y) - in pel units
                          int       search_range, // <--  1-d search range in pel units
                          int       min_mcost,    // <--  minimum motion cost (cost for center or huge value)
                          double    lambda)       // <--  lagrangian parameter for determining motion cost
{
  int   pos, cand_x, cand_y, y, x4, mcost;
  
  pel_t *orig_line, *ref2_line, *ref1_line;
  pel_t *(*get_ref_line1)(int, pel_t*, int, int, int, int);
  pel_t *(*get_ref_line2)(int, pel_t*, int, int, int, int);

  int   list_offset   = ((img->MbaffFrameFlag)&&(img->mb_data[img->current_mb_nr].mb_field))? img->current_mb_nr%2 ? 4 : 2 : 0;
  pel_t *ref1_pic     = listX[list + list_offset          ][ref]->imgY_11;
  pel_t *ref2_pic     = listX[list ==0? 1 + list_offset: list_offset][ 0 ]->imgY_11;  
  int   img_width     = listX[list+list_offset            ][ref]->size_x;
  int   img_height    = listX[list+list_offset            ][ref]->size_y;

  int   best_pos      = 0;                                        // position with minimum motion cost
  int   max_pos       = (2*search_range+1)*(2*search_range+1);    // number of search positions
  int   lambda_factor = LAMBDA_FACTOR (lambda);                   // factor for determining lagragian motion cost
  int   blocksize_y   = input->blc_size[blocktype][1];            // vertical block size
  int   blocksize_x   = input->blc_size[blocktype][0];            // horizontal block size
  int   blocksize_x4  = blocksize_x >> 2;                         // horizontal block size in 4-pel units
  int   pred_x1        = (pic_pix_x << 2) + pred_mv_x1;       // predicted position x (in sub-pel units)
  int   pred_y1        = (pic_pix_y << 2) + pred_mv_y1;       // predicted position y (in sub-pel units)
  int   pred_x2        = (pic_pix_x << 2) + pred_mv_x2;       // predicted position x (in sub-pel units)
  int   pred_y2        = (pic_pix_y << 2) + pred_mv_y2;       // predicted position y (in sub-pel units)
  short center_x      = pic_pix_x + *mv_x;                      // center position x (in pel units)
  short center_y      = pic_pix_y + *mv_y;                      // center position y (in pel units)
  short ref1_center_x = pic_pix_x + *s_mv_x;                      // mvx of second pred (in pel units)
  short ref1_center_y = pic_pix_y + *s_mv_y;                      // mvy of second pred (in pel units)
  
  
  int   bi_diff; 
  short apply_weights   = (active_pps->weighted_bipred_idc>0);  
  short weightSpic = (apply_weights ? (list == 0? wbp_weight[list_offset    ][ref][0  ][0]: wbp_weight[list_offset + 1][0  ][ref][0]) : 1<<luma_log_weight_denom);
  short weightRpic = (apply_weights ? (list == 0? wbp_weight[list_offset + 1][ref][0  ][0]: wbp_weight[list_offset    ][0  ][ref][0]) : 1<<luma_log_weight_denom);
  short offsetSpic = (apply_weights ? (list == 0?  wp_offset[list_offset    ][ref]     [0]:  wp_offset[list_offset + 1][0  ]     [0]) : 0);
  short offsetRpic = (apply_weights ? (list == 0?  wp_offset[list_offset + 1][ref]     [0]:  wp_offset[list_offset    ][0  ]     [0]) : 0);
  short weightedpel,pixel1,pixel2;
  short offsetBi=(offsetRpic + offsetSpic + 1)>>1;
  //===== set function for getting reference picture lines =====
  if ((center_x > search_range) && (center_x < img->width -1-search_range-blocksize_x) &&
    (center_y > search_range) && (center_y < img->height-1-search_range-blocksize_y)   )
  {
    get_ref_line2 = FastLineX;
  }
  else
  {
    get_ref_line2 = UMVLineX;
  }
  
  //===== set function for getting reference picture lines =====
  if ((ref1_center_x > search_range) && (ref1_center_x < img->width -1-search_range-blocksize_x) &&
      (ref1_center_y > search_range) && (ref1_center_y < img->height-1-search_range-blocksize_y)   )
  {
    get_ref_line1 = FastLineX;
  }
  else
  {
    get_ref_line1 = UMVLineX;
  }

  //===== loop over all search positions =====
  for (pos=0; pos<max_pos; pos++)
  {
    //--- set candidate position (absolute position in pel units) ---
    cand_x = center_x + spiral_search_x[pos];
    cand_y = center_y + spiral_search_y[pos];

    //--- initialize motion cost (cost for motion vector) and check ---
    mcost =  MV_COST (lambda_factor, 2, ref1_center_x, ref1_center_y, pred_x1, pred_y1);
    mcost += MV_COST (lambda_factor, 2,        cand_x,        cand_y, pred_x2, pred_y2);

    if (mcost >= min_mcost)   continue;

    //--- add residual cost to motion cost ---
    if (apply_weights)
    {
      for (y=0; y<blocksize_y; y++)
      {
        ref2_line  = get_ref_line2 (blocksize_x, ref2_pic,        cand_y+y,        cand_x, img_height, img_width);
        ref1_line  = get_ref_line1 (blocksize_x, ref1_pic, ref1_center_y+y, ref1_center_x, img_height, img_width);
        orig_line = orig_pic [y];
        
        for (x4=0; x4<blocksize_x4; x4++)
        { 
          pixel1=weightSpic * (*ref1_line++);
          pixel2=weightRpic * (*ref2_line++);
          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
          bi_diff = (*orig_line++)  - weightedpel;
          mcost += byte_abs[bi_diff];
          
          pixel1=weightSpic * (*ref1_line++);
          pixel2=weightRpic * (*ref2_line++);
          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
          bi_diff = (*orig_line++)  - weightedpel;
          mcost += byte_abs[bi_diff];
          
          pixel1=weightSpic * (*ref1_line++);
          pixel2=weightRpic * (*ref2_line++);
          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
          bi_diff = (*orig_line++)  - weightedpel;
          mcost += byte_abs[bi_diff];
          
          pixel1=weightSpic * (*ref1_line++);
          pixel2=weightRpic * (*ref2_line++);
          weightedpel =  Clip3 (0, img->max_imgpel_value ,((pixel1 + pixel2 +
                                2 * wp_luma_round) >> (luma_log_weight_denom + 1)) + (offsetBi));
          bi_diff = (*orig_line++)  - weightedpel;
          mcost += byte_abs[bi_diff];
        }    
      
        if (mcost >= min_mcost)
        {
          break;
        }        
      }
    }
    else
    {
      for (y=0; y<blocksize_y; y++)
      {
        ref2_line = get_ref_line2 (blocksize_x, ref2_pic,        cand_y+y,        cand_x, img_height, img_width);
        ref1_line = get_ref_line1 (blocksize_x, ref1_pic, ref1_center_y+y, ref1_center_x, img_height, img_width);
        orig_line = orig_pic [y];
        
        for (x4=0; x4<blocksize_x4; x4++)
        {         
          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
          mcost += byte_abs[bi_diff];
          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
          mcost += byte_abs[bi_diff];
          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
          mcost += byte_abs[bi_diff];
          bi_diff = (*orig_line++) - (((*ref1_line++) + *ref2_line++)>>1) ;
          mcost += byte_abs[bi_diff];
        }    
        
        if (mcost >= min_mcost)
        {
          break;
        }
      }
    }
    
    //--- check if motion cost is less than minimum cost ---
    if (mcost < min_mcost)
    {
      best_pos  = pos;
      min_mcost = mcost;
    }
  }


  //===== set best motion vector and return minimum motion cost =====
  if (best_pos)
  {
    *mv_x += spiral_search_x[best_pos];
    *mv_y += spiral_search_y[best_pos];
  }
  return min_mcost;
}
