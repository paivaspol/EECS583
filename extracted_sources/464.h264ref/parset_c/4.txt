void GenerateSequenceParameterSet(seq_parameter_set_rbsp_t *sps, int SPS_id)
{
  unsigned i;
  int SubWidthC  [4]= { 1, 2, 2, 1};
  int SubHeightC [4]= { 1, 2, 1, 1};

  int frext_profile = ((IdentifyProfile()==FREXT_HP) || 
                      (IdentifyProfile()==FREXT_Hi10P) ||
                      (IdentifyProfile()==FREXT_Hi422) ||
                      (IdentifyProfile()==FREXT_Hi444));

  // *************************************************************************
  // Sequence Parameter Set
  // *************************************************************************
  assert (sps != NULL);
  // Profile and Level should be calculated using the info from the config
  // file.  Calculation is hidden in IndetifyProfile() and IdentifyLevel()
  sps->profile_idc = IdentifyProfile();
  sps->level_idc = IdentifyLevel();

  // needs to be set according to profile
  sps->constrained_set0_flag = 0;
  sps->constrained_set1_flag = 0;
  sps->constrained_set2_flag = 0;
  sps->constrained_set3_flag = 0;

  // Parameter Set ID hard coded to zero
  sps->seq_parameter_set_id = 0;

  // Fidelity Range Extensions stuff
  sps->bit_depth_luma_minus8   = input->BitDepthLuma - 8;
  sps->bit_depth_chroma_minus8 = input->BitDepthChroma - 8;
  img->lossless_qpprime_flag = input->lossless_qpprime_y_zero_flag & (sps->profile_idc==FREXT_Hi444);
  img->residue_transform_flag = input->residue_transform_flag;
  
  //! POC stuff:
  //! The following values are hard-coded in init_poc().  Apparently,
  //! the poc implementation covers only a subset of the poc functionality.
  //! Here, the same subset is implemented.  Changes in the POC stuff have
  //! also to be reflected here
  sps->log2_max_frame_num_minus4 = log2_max_frame_num_minus4;
  sps->log2_max_pic_order_cnt_lsb_minus4 = log2_max_pic_order_cnt_lsb_minus4;
  
  sps->pic_order_cnt_type = input->pic_order_cnt_type;
  sps->num_ref_frames_in_pic_order_cnt_cycle = img->num_ref_frames_in_pic_order_cnt_cycle;
  sps->delta_pic_order_always_zero_flag = img->delta_pic_order_always_zero_flag;
  sps->offset_for_non_ref_pic = img->offset_for_non_ref_pic;
  sps->offset_for_top_to_bottom_field = img->offset_for_top_to_bottom_field;

  for (i=0; i<img->num_ref_frames_in_pic_order_cnt_cycle; i++)
  {
    sps->offset_for_ref_frame[i] = img->offset_for_ref_frame[i];
  }
  // End of POC stuff

  // Number of Reference Frames
  sps->num_ref_frames = input->num_ref_frames;

  //required_frame_num_update_behaviour_flag hardcoded to zero
  sps->gaps_in_frame_num_value_allowed_flag = FALSE;    // double check

  sps->frame_mbs_only_flag = !(input->PicInterlace || input->MbInterlace);

  // Picture size, finally a simple one :-)
  sps->pic_width_in_mbs_minus1 = ((input->img_width+img->auto_crop_right)/16) -1;
  sps->pic_height_in_map_units_minus1 = (((input->img_height+img->auto_crop_bottom)/16)/ (2 - sps->frame_mbs_only_flag)) - 1;

  // a couple of flags, simple
  sps->mb_adaptive_frame_field_flag = (FRAME_CODING != input->MbInterlace);
  sps->direct_8x8_inference_flag = input->directInferenceFlag;
  
  // Sequence VUI not implemented, signalled as not present
  sps->vui_parameters_present_flag = (input->rgb_input_flag && input->yuv_format==3);

  sps->chroma_format_idc = input->yuv_format;

  // This should be moved somewhere else.
  {
    int PicWidthInMbs, PicHeightInMapUnits, FrameHeightInMbs;
    int width, height;
    PicWidthInMbs = (sps->pic_width_in_mbs_minus1 +1);
    PicHeightInMapUnits = (sps->pic_height_in_map_units_minus1 +1);
    FrameHeightInMbs = ( 2 - sps->frame_mbs_only_flag ) * PicHeightInMapUnits;
    
    width = PicWidthInMbs * MB_BLOCK_SIZE;
    height = FrameHeightInMbs * MB_BLOCK_SIZE;
    
    Co_located = alloc_colocated (width, height,sps->mb_adaptive_frame_field_flag);
    
  }

  // Fidelity Range Extensions stuff
  if(frext_profile)
  {

    sps->seq_scaling_matrix_present_flag = (input->ScalingMatrixPresentFlag&1);
    for(i=0; i<8; i++)
    {
      if(i<6)
        sps->seq_scaling_list_present_flag[i] = (input->ScalingListPresentFlag[i]&1);
      else
      {
        if(input->AllowTransform8x8)
          sps->seq_scaling_list_present_flag[i] = (input->ScalingListPresentFlag[i]&1);
        else
          sps->seq_scaling_list_present_flag[i] = 0;
      }
    }
  }
  else
  {
    sps->seq_scaling_matrix_present_flag = 0;
    for(i=0; i<8; i++)
      sps->seq_scaling_list_present_flag[i] = 0;

  }


  if (img->auto_crop_right || img->auto_crop_bottom)
  {
    sps->frame_cropping_flag = TRUE;
    sps->frame_cropping_rect_left_offset=0;
    sps->frame_cropping_rect_top_offset=0;
    sps->frame_cropping_rect_right_offset=  (img->auto_crop_right / SubWidthC[sps->chroma_format_idc]);
    sps->frame_cropping_rect_bottom_offset= (img->auto_crop_bottom / (SubHeightC[sps->chroma_format_idc] * (2 - sps->frame_mbs_only_flag)));
    if (img->auto_crop_right % SubWidthC[sps->chroma_format_idc])
    {
      error("automatic frame cropping (width) not possible",500);
    }
    if (img->auto_crop_bottom % (SubHeightC[sps->chroma_format_idc] * (2 - sps->frame_mbs_only_flag)))
    {
      error("automatic frame cropping (height) not possible",500);
    }
  }
  else
  {
    sps->frame_cropping_flag = FALSE;
  }
};
