int dct_luma8x8(int b8,int *coeff_cost, int intra)
{
  int sign(int a,int b);

  int i,j,ilev,coeff_ctr;
  int qp_const,level,scan_pos,run;
  int nonzero;
  int qp_per,qp_rem,q_bits;
  int dq_lshift = 0, dq_rshift = 0, dq_round = 0;

  int block_x = 8*(b8%2);
  int block_y = 8*(b8/2);
  int*  ACLevel = img->cofAC[b8][0][0];
  int*  ACRun   = img->cofAC[b8][0][1];
  int m6[8][8];
  int scan_poss[4],runs[4];

  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
  Boolean lossless_qpprime = ((img->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);
  
  qp_per    = (img->qp + img->bitdepth_luma_qp_scale - MIN_QP)/6;
  qp_rem    = (img->qp + img->bitdepth_luma_qp_scale - MIN_QP)%6;
  q_bits    = Q_BITS_8+qp_per;

  if (qp_per < 6)
  {
    dq_rshift = 6 - qp_per;
    dq_round  = 1<<(5-qp_per);
  }
  else
    dq_lshift = qp_per - 6;

/*
  if (intra == 1)
    qp_const=(1<<q_bits)/3;
  else 
    qp_const=(1<<q_bits)/6;
*/
  
  if (img->type == I_SLICE)
    qp_const=(1<<q_bits)/3;    // intra
  else
    qp_const=(1<<q_bits)/6;    // inter
  

  // horizontal transform
  for( i=0; i<8 && !lossless_qpprime; i++)
  {
    int a[8], b[8];
    a[0] = img->m7[0][i] + img->m7[7][i];
    a[1] = img->m7[1][i] + img->m7[6][i];
    a[2] = img->m7[2][i] + img->m7[5][i];
    a[3] = img->m7[3][i] + img->m7[4][i];

    b[0] = a[0] + a[3];
    b[1] = a[1] + a[2];
    b[2] = a[0] - a[3];
    b[3] = a[1] - a[2];

    a[4] = img->m7[0][i] - img->m7[7][i];
    a[5] = img->m7[1][i] - img->m7[6][i];
    a[6] = img->m7[2][i] - img->m7[5][i];
    a[7] = img->m7[3][i] - img->m7[4][i];

    b[4]= a[5] + a[6] + ((a[4]>>1) + a[4]);
    b[5]= a[4] - a[7] - ((a[6]>>1) + a[6]);
    b[6]= a[4] + a[7] - ((a[5]>>1) + a[5]);
    b[7]= a[5] - a[6] + ((a[7]>>1) + a[7]);

    m6[0][i] = b[0] + b[1];
    m6[2][i] = b[2] + (b[3]>>1);
    m6[4][i] = b[0] - b[1];
    m6[6][i] = (b[2]>>1) - b[3];
    m6[1][i] =   b[4] + (b[7]>>2);
    m6[3][i] =   b[5] + (b[6]>>2);
    m6[5][i] =   b[6] - (b[5]>>2);
    m6[7][i] = - b[7] + (b[4]>>2);

  }
  // vertical transform
  for( i=0; i<8 && !lossless_qpprime; i++)
  {
    int a[8], b[8];
    a[0] = m6[i][0] + m6[i][7];
    a[1] = m6[i][1] + m6[i][6];
    a[2] = m6[i][2] + m6[i][5];
    a[3] = m6[i][3] + m6[i][4];
    
    b[0] = a[0] + a[3];
    b[1] = a[1] + a[2];
    b[2] = a[0] - a[3];
    b[3] = a[1] - a[2];
    
    a[4] = m6[i][0] - m6[i][7];
    a[5] = m6[i][1] - m6[i][6];
    a[6] = m6[i][2] - m6[i][5];
    a[7] = m6[i][3] - m6[i][4];
    
    b[4]= a[5] + a[6] + ((a[4]>>1) + a[4]);
    b[5]= a[4] - a[7] - ((a[6]>>1) + a[6]);
    b[6]= a[4] + a[7] - ((a[5]>>1) + a[5]);
    b[7]= a[5] - a[6] + ((a[7]>>1) + a[7]);
    
    img->m7[i][0] = b[0] + b[1];
    img->m7[i][2] = b[2] + (b[3]>>1);
    img->m7[i][4] = b[0] - b[1];
    img->m7[i][6] = (b[2]>>1) - b[3];
    img->m7[i][1] =   b[4] + (b[7]>>2);
    img->m7[i][3] =   b[5] + (b[6]>>2);
    img->m7[i][5] =   b[6] - (b[5]>>2);
    img->m7[i][7] = - b[7] + (b[4]>>2);
  }


  // Quant
  
  nonzero=FALSE;
  
  run=-1;
  scan_pos=0;
  
  runs[0]=runs[1]=runs[2]=runs[3]=-1;
  scan_poss[0]=scan_poss[1]=scan_poss[2]=scan_poss[3]=0;
  
  for (coeff_ctr=0;coeff_ctr < 64;coeff_ctr++)
  {
    
    if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) 
    {  // Alternate scan for field coding
      i=FIELD_SCAN8x8[coeff_ctr][0];
      j=FIELD_SCAN8x8[coeff_ctr][1];
    }
    else 
    {
      i=SNGL_SCAN8x8[coeff_ctr][0];
      j=SNGL_SCAN8x8[coeff_ctr][1];
    }
    
    run++;
    ilev=0;
    
    runs[MC(coeff_ctr)]++;
    
    if(lossless_qpprime)
      level = abs (img->m7[i][j]);
    else if(intra == 1)      
      level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Intra[qp_rem][i][j] + LevelOffset8x8Luma_Intra[qp_per][i][j]) >> q_bits;
    //level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Intra[qp_rem][i][j] + qp_const) >> q_bits;
    else
      level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Inter[qp_rem][i][j] + LevelOffset8x8Luma_Inter[qp_per][i][j]) >> q_bits;
    //level = (abs (img->m7[i][j]) * LevelScale8x8Luma_Inter[qp_rem][i][j] + qp_const) >> q_bits;
    
    if (level != 0)
    {
      nonzero=TRUE;
      
      if (currMB->luma_transform_size_8x8_flag && input->symbol_mode == UVLC)
      {
        if (level > 1)
          *coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
        else
          *coeff_cost += COEFF_COST8x8[input->disthres][runs[MC(coeff_ctr)]];
        
        img->cofAC[b8][MC(coeff_ctr)][0][scan_poss[MC(coeff_ctr)]] = sign(level,img->m7[i][j]);
        img->cofAC[b8][MC(coeff_ctr)][1][scan_poss[MC(coeff_ctr)]] = runs[MC(coeff_ctr)];
        ++scan_poss[MC(coeff_ctr)];
        runs[MC(coeff_ctr)]=-1;
      }
      else
      {
        if (level > 1)
          *coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
        else
          *coeff_cost += COEFF_COST8x8[input->disthres][run];
        ACLevel[scan_pos] = sign(level,img->m7[i][j]);
        ACRun  [scan_pos] = run;
        ++scan_pos;
        run=-1;                     // reset zero level counter
      }      
      level = sign(level, img->m7[i][j]);
      if(lossless_qpprime)
      {
        ilev = level;
      }
      else if(intra == 1)
      {
        if (qp_per>=6)
          ilev = level*InvLevelScale8x8Luma_Intra[qp_rem][i][j]<<dq_lshift; // dequantization
        else
          ilev = (level*InvLevelScale8x8Luma_Intra[qp_rem][i][j] + dq_round)>>dq_rshift; // dequantization
      }
      else
      {
        if (qp_per>=6)
          ilev = level*InvLevelScale8x8Luma_Inter[qp_rem][i][j]<<dq_lshift; // dequantization
        else
          ilev = (level*InvLevelScale8x8Luma_Inter[qp_rem][i][j] + dq_round)>>dq_rshift; // dequantization
      }
    }
    if(!lossless_qpprime)
      img->m7[i][j] = ilev;
  }
  if (!currMB->luma_transform_size_8x8_flag || input->symbol_mode != UVLC)
    ACLevel[scan_pos] = 0;
  else
    for(i=0; i<4; i++)
      img->cofAC[b8][i][0][scan_poss[i]] = 0;

 

 
  
  //    Inverse Transform
  // horizontal inverse transform
  for( i=0; i<8 && !lossless_qpprime; i++)
  {
    int a[8], b[8];
    a[0] = img->m7[0][i] + img->m7[4][i];
    a[4] = img->m7[0][i] - img->m7[4][i];
    a[2] = (img->m7[2][i]>>1) - img->m7[6][i];
    a[6] = img->m7[2][i] + (img->m7[6][i]>>1);

    b[0] = a[0] + a[6];
    b[2] = a[4] + a[2];
    b[4] = a[4] - a[2];
    b[6] = a[0] - a[6];

    a[1] = -img->m7[3][i] + img->m7[5][i] - img->m7[7][i] - (img->m7[7][i]>>1);
    a[3] = img->m7[1][i] + img->m7[7][i] - img->m7[3][i] - (img->m7[3][i]>>1);
    a[5] = -img->m7[1][i] + img->m7[7][i] + img->m7[5][i] + (img->m7[5][i]>>1);
    a[7] = img->m7[3][i] + img->m7[5][i] + img->m7[1][i] + (img->m7[1][i]>>1);

    b[1] = a[1] + (a[7]>>2);
    b[7] = -(a[1]>>2) + a[7];
    b[3] = a[3] + (a[5]>>2);
    b[5] = (a[3]>>2) - a[5];

    m6[0][i] = b[0] + b[7];
    m6[1][i] = b[2] + b[5];
    m6[2][i] = b[4] + b[3];
    m6[3][i] = b[6] + b[1];
    m6[4][i] = b[6] - b[1];
    m6[5][i] = b[4] - b[3];
    m6[6][i] = b[2] - b[5];
    m6[7][i] = b[0] - b[7];
  }

  // vertical inverse transform
  for( i=0; i<8 && !lossless_qpprime; i++)
  {
    int a[8], b[8];
    a[0] = m6[i][0] + m6[i][4];
    a[4] = m6[i][0] - m6[i][4];
    a[2] = (m6[i][2]>>1) - m6[i][6];
    a[6] = m6[i][2] + (m6[i][6]>>1);

    b[0] = a[0] + a[6];
    b[2] = a[4] + a[2];
    b[4] = a[4] - a[2];
    b[6] = a[0] - a[6];

    a[1] = -m6[i][3] + m6[i][5] - m6[i][7] - (m6[i][7]>>1);
    a[3] = m6[i][1] + m6[i][7] - m6[i][3] - (m6[i][3]>>1);
    a[5] = -m6[i][1] + m6[i][7] + m6[i][5] + (m6[i][5]>>1);
    a[7] = m6[i][3] + m6[i][5] + m6[i][1] + (m6[i][1]>>1);

    b[1] = a[1] + (a[7]>>2);
    b[7] = -(a[1]>>2) + a[7];
    b[3] = a[3] + (a[5]>>2);
    b[5] = (a[3]>>2) - a[5];
		
    img->m7[i][0] = b[0] + b[7];
    img->m7[i][1] = b[2] + b[5];
    img->m7[i][2] = b[4] + b[3];
    img->m7[i][3] = b[6] + b[1];
    img->m7[i][4] = b[6] - b[1];
    img->m7[i][5] = b[4] - b[3];
    img->m7[i][6] = b[2] - b[5];
    img->m7[i][7] = b[0] - b[7];
  }
 
  for( i=0; i<8; i++)
    for( j=0; j<8; j++)
    {
      if(lossless_qpprime)
        img->m7[i][j] = img->m7[i][j]+img->mpr[i+block_x][j+block_y];
      else{
      // Residue Color Transform
        if (!img->residue_transform_flag)
          img->m7[i][j] =min(img->max_imgpel_value,max(0,(img->m7[i][j]+((long)img->mpr[i+block_x][j+block_y] << DQ_BITS_8)+DQ_ROUND_8)>>DQ_BITS_8));
        else
          img->m7[i][j] =(img->m7[i][j]+DQ_ROUND_8)>>DQ_BITS_8;
      }
    }


  //  Decoded block moved to frame memory
  if (!img->residue_transform_flag)
    for (j=0; j < 2*BLOCK_SIZE; j++)
      for (i=0; i < 2*BLOCK_SIZE; i++)
        enc_picture->imgY[img->pix_y+block_y+j][img->pix_x+block_x+i]=img->m7[i][j];
    
  return nonzero;
}
