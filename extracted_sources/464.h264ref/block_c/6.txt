int dct_chroma4x4(int uv, int b8, int b4)
{
  int sign(int a,int b);

  int i,j,i1,j1,ilev,m5[4],m6[4],coeff_ctr;
  int level,scan_pos,run;
  int nonzeroAC;
  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
  int   intra = IS_INTRA (currMB);

  int qp_per,qp_rem,q_bits;
  int qp_c;

  int*  ACLevel = img->cofAC[b8][b4][0];
  int*  ACRun   = img->cofAC[b8][b4][1];

  Boolean lossless_qpprime = ((img->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);

  qp_c      = currMB->qp + img->chroma_qp_offset[uv];
  qp_c      = (qp_c < 0)? qp_c : QP_SCALE_CR[qp_c - MIN_QP];

  qp_per    = (qp_c + img->bitdepth_chroma_qp_scale)/6;              
  qp_rem    = (qp_c + img->bitdepth_chroma_qp_scale)%6;              
  q_bits    = Q_BITS+qp_per;

  //  Horizontal transform
  if(!lossless_qpprime)
  for (j=0; j < BLOCK_SIZE; j++)
  {
    for (i=0; i < 2; i++)
    {
      i1=3-i;
      m5[i]=img->m7[i][j]+img->m7[i1][j];
      m5[i1]=img->m7[i][j]-img->m7[i1][j];
    }
    img->m7[0][j]=(m5[0]+m5[1]);
    img->m7[2][j]=(m5[0]-m5[1]);
    img->m7[1][j]=m5[3]*2+m5[2];
    img->m7[3][j]=m5[3]-m5[2]*2;
  }

  //  Vertical transform
  if(!lossless_qpprime)
  for (i=0; i < BLOCK_SIZE; i++)
  {
    for (j=0; j < 2; j++)
    {
      j1=3-j;
      m5[j]=img->m7[i][j]+img->m7[i][j1];
      m5[j1]=img->m7[i][j]-img->m7[i][j1];
    }
    img->m7[i][0]=(m5[0]+m5[1]);
    img->m7[i][2]=(m5[0]-m5[1]);
    img->m7[i][1]=m5[3]*2+m5[2];
    img->m7[i][3]=m5[3]-m5[2]*2;
  }

  // Quant

  nonzeroAC=FALSE;

  run=-1;
  scan_pos=0;

  if(lossless_qpprime)
    level = abs(img->m7[0][0]);
  else if(intra == 1)    
    level =(abs(img->m7[0][0]) * LevelScale4x4Chroma_Intra[uv][qp_rem][0][0] + LevelOffset4x4Chroma_Intra[uv][qp_per][0][0]) >> q_bits;
  else
    level =(abs(img->m7[0][0]) * LevelScale4x4Chroma_Inter[uv][qp_rem][0][0] + LevelOffset4x4Chroma_Inter[uv][qp_per][0][0]) >> q_bits;

  b8 -= 4*(uv+1);
  dc_level_temp[uv][2*(b8%2)+(b4%2)][2*(b8/2)+(b4/2)] = sign(level, img->m7[0][0]);

  /* Inverse Quantization */
  if(lossless_qpprime)
  {
    img->m7[0][0] = sign( level, img->m7[0][0]);
  }
  else
  {
    if(qp_per<4)
    {
      if(intra == 1)
        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per)), img->m7[0][0]);
      else
        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per)), img->m7[0][0]);
    }
    else
    {
      if(intra == 1)
        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-4)), img->m7[0][0]);
      else
        img->m7[0][0] = sign( ((level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-4)), img->m7[0][0]);
    }
  }

  for (coeff_ctr=1;coeff_ctr < 16;coeff_ctr++)
  {
    i=SNGL_SCAN[coeff_ctr][0];
    j=SNGL_SCAN[coeff_ctr][1];

    run++;
    ilev=0;

    if(lossless_qpprime)
      level = abs (img->m7[i][j]);
    else if(intra == 1)      
      level = (abs(img->m7[i][j])*LevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Intra[uv][qp_per][i][j])>>q_bits;
    else
      level = (abs(img->m7[i][j])*LevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Inter[uv][qp_per][i][j])>>q_bits;
    
    if (level != 0)
    {
      if(i||j) nonzeroAC=TRUE;
      
      ACLevel[scan_pos] = sign(level,img->m7[i][j]);
      ACRun  [scan_pos] = run;
      ++scan_pos;
      run=-1;                     // reset zero level counter
      
      level=sign(level, img->m7[i][j]);
      if(lossless_qpprime)
      {
        ilev=level;
      }
      else if(qp_per<4)
      {
        if(intra == 1)
          ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
        else
          ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
      }
      else
      {
        if(intra == 1)
          ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j])<<(qp_per-4);
        else
          ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j])<<(qp_per-4);
      }
    }
    if(!lossless_qpprime)
      img->m7[i][j]=ilev;
  }
  ACLevel[scan_pos] = 0;

  
  //     IDCT.
  //     horizontal
  if(!lossless_qpprime)
  for (j=0; j < BLOCK_SIZE; j++)
  {
    for (i=0; i < BLOCK_SIZE; i++)
    {
      m5[i]=img->m7[i][j];
    }
    m6[0]=(m5[0]+m5[2]);
    m6[1]=(m5[0]-m5[2]);
    m6[2]=(m5[1]>>1)-m5[3];
    m6[3]=m5[1]+(m5[3]>>1);

    for (i=0; i < 2; i++)
    {
      i1=3-i;
      img->m7[i][j]=m6[i]+m6[i1];
      img->m7[i1][j]=m6[i]-m6[i1];
    }
  }

  //  vertical
  if(!lossless_qpprime)
  for (i=0; i < BLOCK_SIZE; i++)
  {
    for (j=0; j < BLOCK_SIZE; j++)
    {
      m5[j]=img->m7[i][j];
    }
    m6[0]=(m5[0]+m5[2]);
    m6[1]=(m5[0]-m5[2]);
    m6[2]=(m5[1]>>1)-m5[3];
    m6[3]=m5[1]+(m5[3]>>1);

    for (j=0; j < 2; j++)
    {
      j1=3-j;
      img->m7[i][j] =(m6[j]+m6[j1]+DQ_ROUND)>>DQ_BITS;
      img->m7[i][j1]=(m6[j]-m6[j1]+DQ_ROUND)>>DQ_BITS;
    }
  }

  return nonzeroAC;
}
