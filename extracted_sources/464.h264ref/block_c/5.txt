int dct_chroma(int uv,int cr_cbp)
{
  int i,j,i1,j2,ilev,n2,n1,j1,mb_y,coeff_ctr,level ,scan_pos,run;
  int m1[BLOCK_SIZE],m5[BLOCK_SIZE],m6[BLOCK_SIZE];
  int coeff_cost;
  int cr_cbp_tmp;
  int DCcoded=0 ;
  Macroblock *currMB = &img->mb_data[img->current_mb_nr];
 
  int qp_per,qp_rem,q_bits;
  int qp_c;

  int   b4;
  int*  DCLevel = img->cofDC[uv+1][0];
  int*  DCRun   = img->cofDC[uv+1][1];
  int*  ACLevel;
  int*  ACRun;
  int   intra = IS_INTRA (currMB);
  int   uv_scale = uv*(img->num_blk8x8_uv/2);

  //FRExt
  int64 cbpblk_pattern[4]={0, 0xf0000, 0xff0000, 0xffff0000};
  int yuv = img->yuv_format;
  int b8;
  int m3[4][4];
  int m4[4][4];
  int qp_per_dc = 0;
  int qp_rem_dc = 0;
  int q_bits_422 = 0;	
  Boolean lossless_qpprime = ((currMB->qp + img->bitdepth_luma_qp_scale)==0 && img->lossless_qpprime_flag==1);

  qp_c      = currMB->qp + img->chroma_qp_offset[uv];
  qp_c      = Clip3(-img->bitdepth_chroma_qp_scale,51,qp_c);
  qp_c      = (qp_c < 0)? qp_c : QP_SCALE_CR[qp_c - MIN_QP];

  qp_per    = (qp_c + img->bitdepth_chroma_qp_scale)/6;              
  qp_rem    = (qp_c + img->bitdepth_chroma_qp_scale)%6;              
  q_bits    = Q_BITS+qp_per;

  if (img->yuv_format == YUV422)
  {
    //for YUV422 only
    qp_per_dc = (qp_c + 3 + img->bitdepth_chroma_qp_scale)/6;
    qp_rem_dc = (qp_c + 3 + img->bitdepth_chroma_qp_scale)%6;
    
    q_bits_422 = Q_BITS+qp_per_dc;
  
  }

  
  //============= dct transform ===============	
  for (n2=0; n2 < img->mb_cr_size_y; n2 += BLOCK_SIZE)
  {
    for (n1=0; n1 < img->mb_cr_size_x; n1 += BLOCK_SIZE)
    {

      //  Horizontal transform.
      for (j=0; j < BLOCK_SIZE && !lossless_qpprime; j++)
      {
        mb_y=n2+j;
        for (i=0; i < 2; i++)
        {
          i1=3-i;
          m5[i]=img->m7[i+n1][mb_y]+img->m7[i1+n1][mb_y];
          m5[i1]=img->m7[i+n1][mb_y]-img->m7[i1+n1][mb_y];
        }
        img->m7[n1][mb_y]  =(m5[0]+m5[1]);
        img->m7[n1+2][mb_y]=(m5[0]-m5[1]);
        img->m7[n1+1][mb_y]=m5[3]*2+m5[2];
        img->m7[n1+3][mb_y]=m5[3]-m5[2]*2;
      }

      //  Vertical transform.

      for (i=0; i < BLOCK_SIZE && !lossless_qpprime; i++)
      {
        j1=n1+i;
        for (j=0; j < 2; j++)
        {
          j2=3-j;
          m5[j]=img->m7[j1][n2+j]+img->m7[j1][n2+j2];
          m5[j2]=img->m7[j1][n2+j]-img->m7[j1][n2+j2];
        }
        img->m7[j1][n2+0]=(m5[0]+m5[1]);
        img->m7[j1][n2+2]=(m5[0]-m5[1]);
        img->m7[j1][n2+1]=m5[3]*2+m5[2];
        img->m7[j1][n2+3]=m5[3]-m5[2]*2;
      }
    }
  }

  if (yuv == YUV420)
  {
    //================== CHROMA DC YUV420 ===================
    //     2X2 transform of DC coeffs.
    m1[0]=(img->m7[0][0]+img->m7[4][0]+img->m7[0][4]+img->m7[4][4]);
    m1[1]=(img->m7[0][0]-img->m7[4][0]+img->m7[0][4]-img->m7[4][4]);
    m1[2]=(img->m7[0][0]+img->m7[4][0]-img->m7[0][4]-img->m7[4][4]);
    m1[3]=(img->m7[0][0]-img->m7[4][0]-img->m7[0][4]+img->m7[4][4]);
    
    //     Quant of chroma 2X2 coeffs.
    run=-1;
    scan_pos=0;
    
    for (coeff_ctr=0; coeff_ctr < 4; coeff_ctr++)
    {
      run++;
      ilev=0;
      
      if(intra == 1)
        level =(abs(m1[coeff_ctr]) * LevelScale4x4Chroma_Intra[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Intra[uv][qp_per][0][0]<<1)) >> (q_bits+1);
      else
        level =(abs(m1[coeff_ctr]) * LevelScale4x4Chroma_Inter[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Inter[uv][qp_per][0][0]<<1)) >> (q_bits+1);
      
      if (input->symbol_mode == UVLC && img->qp < 4) 
      {
        if (level > CAVLC_LEVEL_LIMIT) 
        {
          level = CAVLC_LEVEL_LIMIT;
        }
      }
      
      if (level  != 0)
      {
        currMB->cbp_blk |= 0xf0000 << (uv << 2) ;    // if one of the 2x2-DC levels is != 0 set the
        cr_cbp=max(1,cr_cbp);                     // coded-bit all 4 4x4 blocks (bit 16-19 or 20-23)
        DCcoded = 1 ;
        DCLevel[scan_pos] = sign(level ,m1[coeff_ctr]);
        DCRun  [scan_pos] = run;
        scan_pos++;
        run=-1;
        
        ilev=sign(level, m1[coeff_ctr]);
      }
      m1[coeff_ctr]=ilev;
    }
    DCLevel[scan_pos] = 0;
    
    //  Inverse transform of 2x2 DC levels
    m5[0]=(m1[0]+m1[1]+m1[2]+m1[3]);
    m5[1]=(m1[0]-m1[1]+m1[2]-m1[3]);
    m5[2]=(m1[0]+m1[1]-m1[2]-m1[3]);
    m5[3]=(m1[0]-m1[1]-m1[2]+m1[3]);
    for(i=0; i<4; i++)
    {
      if(qp_per<5)
      {
        if(intra == 1)
          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])>>(5-qp_per);
        else
          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])>>(5-qp_per);
      }
      else
      {
        if(intra == 1)
          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-5);
        else
          m1[i]=(m5[i]*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-5);
      }
    }
    img->m7[0][0]=m1[0];
    img->m7[4][0]=m1[1];
    img->m7[0][4]=m1[2];
    img->m7[4][4]=m1[3];
  }
  else if(yuv == YUV422)
  {
    //================== CHROMA DC YUV422 ===================
    //transform DC coeff
    //horizontal

    //pick out DC coeff
    for (j=0; j < img->mb_cr_size_y; j+=BLOCK_SIZE)
      for (i=0; i < img->mb_cr_size_x; i+=BLOCK_SIZE)
        m3[i>>2][j>>2]= img->m7[i][j];
      
    //horizontal
    m4[0][0] = m3[0][0] + m3[1][0];
    m4[0][1] = m3[0][1] + m3[1][1];
    m4[0][2] = m3[0][2] + m3[1][2];
    m4[0][3] = m3[0][3] + m3[1][3];
    
    m4[1][0] = m3[0][0] - m3[1][0];
    m4[1][1] = m3[0][1] - m3[1][1];
    m4[1][2] = m3[0][2] - m3[1][2];
    m4[1][3] = m3[0][3] - m3[1][3];

    // vertical
    for (i=0;i<2;i++)
    {
      for (j=0;j<2;j++)
      {
        j1=3-j;
        m5[j]= m4[i][j]+m4[i][j1];
        m5[j1]=m4[i][j]-m4[i][j1];
      }
      m4[i][0]=(m5[0]+m5[1]);
      m4[i][2]=(m5[0]-m5[1]);
      m4[i][1]=(m5[3]+m5[2]);
      m4[i][3]=(m5[3]-m5[2]);
    }

    run=-1;
    scan_pos=0;

    //quant of chroma DC-coeffs
    for (coeff_ctr=0;coeff_ctr<8;coeff_ctr++)
    {
      i=SCAN_YUV422[coeff_ctr][0];
      j=SCAN_YUV422[coeff_ctr][1];
      
      run++;

      if(intra == 1)
        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0] + (LevelOffset4x4Chroma_Intra[uv][qp_per_dc][0][0]*2)) >> (q_bits_422+1);
      else
        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0] + (LevelOffset4x4Chroma_Inter[uv][qp_per_dc][0][0]*2)) >> (q_bits_422+1);

      if (level != 0)
      {
        //YUV422
        currMB->cbp_blk |= 0xff0000 << (uv << 3) ;   // if one of the DC levels is != 0 set the
        cr_cbp=max(1,cr_cbp);												   // coded-bit all 4 4x4 blocks (bit 16-31 or 32-47) //YUV444
        DCcoded = 1 ;
        
        DCLevel[scan_pos] = sign(level,m4[i][j]);
        DCRun  [scan_pos] = run;
        ++scan_pos;
        run=-1;
      }
      m3[i][j]=sign(level,m4[i][j]);
    }
    DCLevel[scan_pos]=0;

    //inverse DC transform
    //horizontal
    m4[0][0] = m3[0][0] + m3[1][0];
    m4[0][1] = m3[0][1] + m3[1][1];
    m4[0][2] = m3[0][2] + m3[1][2];
    m4[0][3] = m3[0][3] + m3[1][3];
    
    m4[1][0] = m3[0][0] - m3[1][0];
    m4[1][1] = m3[0][1] - m3[1][1];
    m4[1][2] = m3[0][2] - m3[1][2];
    m4[1][3] = m3[0][3] - m3[1][3];
    
    
    // vertical
    for (i=0;i<2;i++)
    {
      for (j=0; j < 4;j++)    //TODO: remove m5 with m4
        m5[j]=m4[i][j]; 
      
      m6[0]=m5[0]+m5[2];
      m6[1]=m5[0]-m5[2];
      m6[2]=m5[1]-m5[3];
      m6[3]=m5[1]+m5[3];
      
      for (j=0;j<2;j++)
      {
        j1=3-j;
		
        if(qp_per_dc<4)
        {
          if(intra == 1)
          {
            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
          }
          else
          {
            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0]+(1<<(3-qp_per_dc)))>>(4-qp_per_dc))+2)>>2;
          }
        }
        else
        {
          if(intra == 1)
          {
            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
          }
          else
          {
            img->m7[i*4][j*4 ]=((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem_dc][0][0])<<(qp_per_dc-4))+2)>>2;
          }
        }
      }//for (j=0;j<2;j++)
    }//for (i=0;i<2;i++)    
  }
  else if(yuv == YUV444)
  {
    //================== CHROMA DC YUV444 ===================
    //transform DC coeff
    //pick out DC coeff
    for (j=0; j < img->mb_cr_size_y; j+=BLOCK_SIZE)
      for (i=0; i < img->mb_cr_size_x; i+=BLOCK_SIZE)
        m4[i>>2][j>>2]= img->m7[i][j];
      
    //horizontal
    for (j=0;j<4 && !lossless_qpprime;j++)
    {
      for (i=0;i<2;i++)
      {
        i1=3-i;
        m5[i] = m4[i][j]+m4[i1][j];
        m5[i1]= m4[i][j]-m4[i1][j];
      }
      m4[0][j]=m5[0]+m5[1];
      m4[2][j]=m5[0]-m5[1];
      m4[1][j]=m5[3]+m5[2];
      m4[3][j]=m5[3]-m5[2];
    }
    // vertical
    for (i=0;i<4 && !lossless_qpprime;i++)
    {
      for (j=0;j<2;j++)
      {
        j1=3-j;
        m5[j]= m4[i][j]+m4[i][j1];
        m5[j1]=m4[i][j]-m4[i][j1];
      }
      m4[i][0]=(m5[0]+m5[1])>>1;
      m4[i][2]=(m5[0]-m5[1])>>1;
      m4[i][1]=(m5[3]+m5[2])>>1;
      m4[i][3]=(m5[3]-m5[2])>>1;
    }

    run=-1;
    scan_pos=0;
    
    //quant of chroma DC-coeffs
    for (coeff_ctr=0;coeff_ctr<16;coeff_ctr++)
    {
      i=SNGL_SCAN[coeff_ctr][0];
      j=SNGL_SCAN[coeff_ctr][1];
      
      run++;
      
      if(lossless_qpprime)
        level = abs(m4[i][j]);
      else if(intra == 1)        
        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Intra[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Intra[uv][qp_per][0][0]*2)) >> (q_bits+1);
      else
        level =(abs(m4[i][j]) * LevelScale4x4Chroma_Inter[uv][qp_rem][0][0] + (LevelOffset4x4Chroma_Inter[uv][qp_per][0][0]*2)) >> (q_bits+1);
      
      if (level != 0)
      {
        //YUV444
        currMB->cbp_blk |= ((int64)0xffff0000) << (uv << 4) ;   // if one of the DC levels is != 0 set the
        cr_cbp=max(1,cr_cbp);												   // coded-bit all 4 4x4 blocks (bit 16-31 or 32-47) //YUV444
        DCcoded = 1 ;
        
        DCLevel[scan_pos] = sign(level,m4[i][j]);
        DCRun  [scan_pos] = run;
        ++scan_pos;
        run=-1;
      }
      if(!lossless_qpprime)
        m4[i][j]=sign(level,m4[i][j]);
    }
    DCLevel[scan_pos]=0;

    // inverse DC transform
    //horizontal
    for (j=0;j<4 && !lossless_qpprime;j++)
    {
      for (i=0;i<4;i++)
        m5[i]=m4[i][j];
      
      m6[0]=m5[0]+m5[2];
      m6[1]=m5[0]-m5[2];
      m6[2]=m5[1]-m5[3];
      m6[3]=m5[1]+m5[3];
      
      for (i=0;i<2;i++)
      {
        i1=3-i;
        m4[i][j]= m6[i]+m6[i1];
        m4[i1][j]=m6[i]-m6[i1];
      }
    }
    
    //vertical
    for (i=0;i<4 && !lossless_qpprime;i++)
    {
      for (j=0;j<4;j++)
        m5[j]=m4[i][j];
      
      m6[0]=m5[0]+m5[2];
      m6[1]=m5[0]-m5[2];
      m6[2]=m5[1]-m5[3];
      m6[3]=m5[1]+m5[3];
      
      for (j=0;j<2;j++)
      {
        j1=3-j;
        if(qp_per<4)
        {
          if(intra == 1)
          {
            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
          }
          else
          {
            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0]+(1<<(3-qp_per)))>>(4-qp_per))+2)>>2;
          }
        }
        else
        {
          if(intra == 1)
          {
            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Intra[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
          }
          else
          {
            img->m7[i*4][j*4] =((((m6[j]+m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
            img->m7[i*4][j1*4]=((((m6[j]-m6[j1])*InvLevelScale4x4Chroma_Inter[uv][qp_rem][0][0])<<(qp_per-4))+2)>>2;
          }
        }
      } 
    }
  }

  //     Quant of chroma AC-coeffs.
  coeff_cost=0;
  cr_cbp_tmp=0;

  for (b8=0; b8 < (img->num_blk8x8_uv/2); b8++)
  {
    for (b4=0; b4 < 4; b4++)
    {
      n1 = hor_offset[yuv][b8][b4];
      n2 = ver_offset[yuv][b8][b4];
      ACLevel = img->cofAC[4+b8+uv_scale][b4][0];
      ACRun   = img->cofAC[4+b8+uv_scale][b4][1];
      run=-1;
      scan_pos=0;

      for (coeff_ctr=1; coeff_ctr < 16; coeff_ctr++)// start change rd_quant
      {

        if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) 
        {  // Alternate scan for field coding
          i=FIELD_SCAN[coeff_ctr][0];
          j=FIELD_SCAN[coeff_ctr][1];
        }
        else 
        {
          i=SNGL_SCAN[coeff_ctr][0];
          j=SNGL_SCAN[coeff_ctr][1];
        }
        ++run;
        ilev=0;

        if(lossless_qpprime)
          level = abs(img->m7[n1+i][n2+j]);
        else if(intra == 1)          
          level=(abs(img->m7[n1+i][n2+j])*LevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Intra[uv][qp_per][i][j])>>q_bits;
        else
          level=(abs(img->m7[n1+i][n2+j])*LevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+LevelOffset4x4Chroma_Inter[uv][qp_per][i][j])>>q_bits;

        if (level  != 0)
        {
          currMB->cbp_blk |= ((int64)1) << cbp_blk_chroma[b8 + uv_scale][b4];
          if (level > 1 || lossless_qpprime)
            coeff_cost += MAX_VALUE;                // set high cost, shall not be discarded
          else
            coeff_cost += COEFF_COST[input->disthres][run];

          cr_cbp_tmp=2;
          ACLevel[scan_pos] = sign(level,img->m7[n1+i][n2+j]);
          ACRun  [scan_pos] = run;
          ++scan_pos;
          run=-1;

          level=sign(level, img->m7[n1+i][n2+j]);
          if(lossless_qpprime)
          {
            ilev = level;
          }
          else if(qp_per<4)
          {
            if(intra == 1)
              ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
            else
              ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j]+(1<<(3-qp_per)))>>(4-qp_per);
          }
          else
          {
            if(intra == 1)
              ilev=(level*InvLevelScale4x4Chroma_Intra[uv][qp_rem][i][j])<<(qp_per-4);
            else
              ilev=(level*InvLevelScale4x4Chroma_Inter[uv][qp_rem][i][j])<<(qp_per-4);
          }
        }
        if(!lossless_qpprime)
          img->m7[n1+i][n2+j]=ilev;
      }
      ACLevel[scan_pos] = 0;
    }
  }

  // * reset chroma coeffs
  if(coeff_cost < _CHROMA_COEFF_COST_ && !lossless_qpprime)
  {
    cr_cbp_tmp = 0 ;
    
    for (b8=0; b8 < (img->num_blk8x8_uv/2); b8++)
    {
      for (b4=0; b4 < 4; b4++)
      {
        n1 = hor_offset[yuv][b8][b4];
        n2 = ver_offset[yuv][b8][b4];
        ACLevel = img->cofAC[4+b8+uv_scale][b4][0];
        ACRun   = img->cofAC[4+b8+uv_scale][b4][1];
        if( DCcoded == 0) currMB->cbp_blk &= ~((int64)cbpblk_pattern[yuv] << (uv << (1+yuv)));  // if no chroma DC's: then reset coded-bits of this chroma subblock
        
        ACLevel[0] = 0;
        for (coeff_ctr=1; coeff_ctr < 16; coeff_ctr++)// ac coeff
        {

          if (img->field_picture || ( img->MbaffFrameFlag && currMB->mb_field )) 
          {  // Alternate scan for field coding
            i=FIELD_SCAN[coeff_ctr][0];
            j=FIELD_SCAN[coeff_ctr][1];
          }
          else 
          {
            i=SNGL_SCAN[coeff_ctr][0];
            j=SNGL_SCAN[coeff_ctr][1];
          }
          img->m7[n1+i][n2+j]=0;
          ACLevel[coeff_ctr] = 0;
        }
      }
    }
  }


  if(cr_cbp_tmp==2)
    cr_cbp = 2;

  
  //     IDCT.
  //     Horizontal.
  for (n2=0; n2 < img->mb_cr_size_y && !lossless_qpprime; n2 += BLOCK_SIZE)
  {
    for (n1=0; n1 < img->mb_cr_size_x; n1 += BLOCK_SIZE)
    {
      for (j=0; j < BLOCK_SIZE; j++)
      {
        for (i=0; i < BLOCK_SIZE; i++)
        {
          m5[i]=img->m7[n1+i][n2+j];
        }
        m6[0]=(m5[0]+m5[2]);
        m6[1]=(m5[0]-m5[2]);
        m6[2]=(m5[1]>>1)-m5[3];
        m6[3]=m5[1]+(m5[3]>>1);

        for (i=0; i < 2; i++)
        {
          i1=3-i;
          img->m7[n1+i][n2+j]=m6[i]+m6[i1];
          img->m7[n1+i1][n2+j]=m6[i]-m6[i1];
        }
      }

      //     Vertical.
      for (i=0; i < BLOCK_SIZE && !lossless_qpprime; i++)
      {
        for (j=0; j < BLOCK_SIZE; j++)
        {
          m5[j]=img->m7[n1+i][n2+j];
        }
        m6[0]=(m5[0]+m5[2]);
        m6[1]=(m5[0]-m5[2]);
        m6[2]=(m5[1]>>1)-m5[3];
        m6[3]=m5[1]+(m5[3]>>1);

        for (j=0; j < 2; j++)
        {
          j2=3-j;
          // Residue Color Transform
          if (!img->residue_transform_flag)
          {
            img->m7[n1+i][n2+j] =min(img->max_imgpel_value_uv,max(0,(m6[j]+m6[j2]+((long)img->mpr[n1+i][n2+j] <<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
            img->m7[n1+i][n2+j2]=min(img->max_imgpel_value_uv,max(0,(m6[j]-m6[j2]+((long)img->mpr[n1+i][n2+j2]<<DQ_BITS)+DQ_ROUND)>>DQ_BITS));
          } 
          else 
          {
            if(lossless_qpprime)
            {
               img->m7[n1+i][n2+j] =m6[j]+m6[j2];
               img->m7[n1+i][n2+j2]=m6[j]-m6[j2];
            }
            else
            {
              img->m7[n1+i][n2+j] =(m6[j]+m6[j2]+DQ_ROUND)>>DQ_BITS;
              img->m7[n1+i][n2+j2]=(m6[j]-m6[j2]+DQ_ROUND)>>DQ_BITS;
            }
          }
        }
      }
    }
  }

  //  Decoded block moved to memory
  if (!img->residue_transform_flag)
  for (j=0; j < img->mb_cr_size_y; j++)
  {
    for (i=0; i < img->mb_cr_size_x; i++)
    {
      if(lossless_qpprime)
        enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i]= img->m7[i][j]+img->mpr[i][j];
      else
        enc_picture->imgUV[uv][img->pix_c_y+j][img->pix_c_x+i]= img->m7[i][j];
    }
  }

  return cr_cbp;
}
