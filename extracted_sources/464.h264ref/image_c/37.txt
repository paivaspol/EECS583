static void rdPictureCoding()
{
  int second_qp = img->qp, rd_qp = img->qp;
  int previntras = intras;
  int prevtype = img->type;
  int skip_encode = 0;
  pic_parameter_set_rbsp_t *sec_pps;
    
  
  if (img->type!=I_SLICE && input->GenerateMultiplePPS)
  {
    if (img->type==P_SLICE)
    {
      if (test_wp_P_slice(0) == 1)
      {
        active_pps = &PicParSet[1];
      }
      else
      {
        skip_encode = input->RDPSliceWeightOnly;
        active_pps = &PicParSet[0];
        img->qp-=1;
      }
    }
    else
    {
      active_pps = &PicParSet[2];
    }
  }
  else        
  {
    img->qp-=1;
  }
  
  sec_pps = active_pps;
  second_qp = img->qp;
  
  img->write_macroblock = 0;
  
  if (skip_encode)
  {
    img->rd_pass = 0;
    enc_frame_picture2 = NULL;
  }
  else
  {
    frame_picture (frame_pic2,1);
    img->rd_pass=picture_coding_decision(frame_pic, frame_pic2, rd_qp);
  }
  //      update_rd_picture_contexts (img->rd_pass); 
  if (img->rd_pass==0)
  {
    enc_picture=enc_frame_picture;
    if (img->type!=I_SLICE && input->GenerateMultiplePPS)
    { 
      img->qp=rd_qp;
      active_pps = &PicParSet[0];
    }
    else       
    {
      img->qp=rd_qp;
    }
    intras = previntras;
    
  }
  else
  {
    previntras = intras;
  }
  // Final Encoding pass - note that we should 
  // make this more flexible in a later version.
  
  if (img->type!=I_SLICE && input->GenerateMultiplePPS)
  {
    skip_encode = 0;
    img->qp    = rd_qp;
    if (img->type==P_SLICE)
    {
      if (test_wp_P_slice(1) == 1)
      {
        active_pps = &PicParSet[1];
      }
      else
      {
        skip_encode = input->RDPSliceWeightOnly;
        active_pps = &PicParSet[0];
        img->qp+=1;
      }
    }
    else
    {
      if (test_wp_B_slice(0) == 1)
      {
        active_pps = &PicParSet[1];
      }
      else
      {
        skip_encode = input->RDBSliceWeightOnly;

        if (img->nal_reference_idc)          
          img->qp = (rd_qp - 1);
        else
          img->qp = (rd_qp + 1);
      }      
    }
  }
  else 
  {
    active_pps = &PicParSet[0];
    img->qp    = (rd_qp + 1);
  }
  
  if (img->type == P_SLICE && input->GenerateMultiplePPS && (intras * 100 )/img->FrameSizeInMbs >=75)
  {
    img->type=I_SLICE;
    active_pps = &PicParSet[0];
  }
  
  img->write_macroblock = 0;
  
  if (skip_encode)
  {
    enc_frame_picture3 = NULL;
    img->qp = rd_qp;
  }
  else
  {
    frame_picture (frame_pic3,2);
    
    if (img->rd_pass==0)
      img->rd_pass  = 2*picture_coding_decision(frame_pic , frame_pic3, rd_qp);
    else
      img->rd_pass +=   picture_coding_decision(frame_pic2, frame_pic3, rd_qp);
  }

  //update_rd_picture_contexts (img->rd_pass); 
  if (img->rd_pass==0)
  {
    enc_picture = enc_frame_picture;
    img->type   = prevtype;
    active_pps  = &PicParSet[0];
    img->qp     = rd_qp;
    intras      = previntras;
  }
  else if (img->rd_pass==1)
  {
    enc_picture = enc_frame_picture2;
    img->type   = prevtype;
    active_pps  = sec_pps;
    img->qp     = second_qp;
    intras      = previntras;
  }       
}
