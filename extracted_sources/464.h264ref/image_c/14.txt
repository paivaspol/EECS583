static void init_field ()
{
  int i;
  int prevP_no, nextP_no;

  last_P_no = last_P_no_fld;

  img->current_mb_nr = 0;
  img->current_slice_nr = 0;
  stats->bit_slice = 0;

  input->jumpd *= 2;
  input->successive_Bframe *= 2;
  img->number /= 2;
  img->buf_cycle /= 2;

  img->mb_y = img->mb_x = 0;
  img->block_y = img->pix_y = img->pix_c_y = 0; // define vertical positions
  img->block_x = img->pix_x = img->block_c_x = img->pix_c_x = 0;        // define horizontal positions

  if (!img->b_frame_to_code)
  //if (img->type != B_SLICE)
    {
      img->tr = img->number * (input->jumpd + 2) + img->fld_type;

      if (!img->fld_type)
        {
          img->imgtr_last_P_fld = img->imgtr_next_P_fld;
          img->imgtr_next_P_fld = img->tr;
        }

#ifdef _ADAPT_LAST_GROUP_
      if (input->last_frame && img->number + 1 == input->no_frames)
        img->tr = input->last_frame;
#endif
      if (img->number != 0 && input->successive_Bframe != 0)    // B pictures to encode
        nextP_tr_fld = img->tr;
      
      //Rate control
      if(!input->RCEnable)                  // without using rate control
      {
        if (img->type == I_SLICE)
      {
#ifdef _CHANGE_QP_
        if (input->qp2start > 0 && img->tr >= input->qp2start)
          img->qp = input->qp02;
        else
#endif    
          img->qp = input->qp0;   // set quant. parameter for I-frame
      }
        else
        {
#ifdef _CHANGE_QP_
          if (input->qp2start > 0 && img->tr >= input->qp2start)
            img->qp = input->qpN2;
          else
#endif
            img->qp = input->qpN;
          if (img->type == SP_SLICE)
          {
            img->qp = input->qpsp;
            img->qpsp = input->qpsp_pred;
          }
        }
      }

      img->mb_y_intra = img->mb_y_upd;  //  img->mb_y_intra indicates which GOB to intra code for this frame

      if (input->intra_upd > 0) // if error robustness, find next GOB to update
        {
          img->mb_y_upd =
            (img->number / input->intra_upd) % (img->width / MB_BLOCK_SIZE);
        }
    }
  else
    {
      img->p_interval = input->jumpd + 2;
      prevP_no = (img->number - 1) * img->p_interval + img->fld_type;
      nextP_no = img->number * img->p_interval + img->fld_type;
#ifdef _ADAPT_LAST_GROUP_
      if (!img->fld_type)       // top field
        {
          last_P_no[0] = prevP_no + 1;
          last_P_no[1] = prevP_no;
          for (i = 1; i <= img->buf_cycle; i++)
            {
              last_P_no[2 * i] = last_P_no[2 * i - 2] - img->p_interval;
              last_P_no[2 * i + 1] = last_P_no[2 * i - 1] - img->p_interval;
            }
        }
      else                      // bottom field
        {
          last_P_no[0] = nextP_no - 1;
          last_P_no[1] = prevP_no;
          for (i = 1; i <= img->buf_cycle; i++)
            {
              last_P_no[2 * i] = last_P_no[2 * i - 2] - img->p_interval;
              last_P_no[2 * i + 1] = last_P_no[2 * i - 1] - img->p_interval;
            }
        }

      if (input->last_frame && img->number + 1 == input->no_frames)
        {
          nextP_no = input->last_frame;
          img->p_interval = nextP_no - prevP_no;
        }
#endif
      img->b_interval =
      ((double) (input->jumpd + 1) / (input->successive_Bframe + 1.0) );

      if (input->PyramidCoding == 3)
        img->b_interval = 1.0;
      
      if (input->PyramidCoding)
        img->tr = prevP_no + (int) ((img->b_interval + 1.0) * (double) (1 + gop_structure[img->b_frame_to_code - 1].display_no));      // from prev_P
      else      
        img->tr = prevP_no + (int) ((img->b_interval + 1.0) * (double) img->b_frame_to_code);      // from prev_P
      

      if (img->tr >= nextP_no)
        img->tr = nextP_no - 1; // ?????
      //Rate control
      if(!input->RCEnable && input->PyramidCoding !=3)                  // without using rate control
      {
#ifdef _CHANGE_QP_
        if (input->qp2start > 0 && img->tr >= input->qp2start)
          img->qp = input->qpB2;
        else
#endif
          img->qp = input->qpB;
        if (img->nal_reference_idc)
        {
#ifdef _CHANGE_QP_
          if (input->qp2start > 0 && img->tr >= input->qp2start)
            img->qp = Clip3(0,51,input->qpB2 + input->qpBRS2Offset);
          else
#endif
            img->qp = Clip3(0,51,input->qpB + input->qpBRSOffset);
          
        }
      }
      else if (input->PyramidCoding ==3)  
      {          
        img->qp =  gop_structure[img->b_frame_to_code - 1].slice_qp;
      }
      

    }
  input->jumpd /= 2;
  input->successive_Bframe /= 2;
  img->buf_cycle *= 2;
  img->number = 2 * img->number + img->fld_type;
  img->total_number_mb = (img->width * img->height) / (MB_BLOCK_SIZE * MB_BLOCK_SIZE);
}
