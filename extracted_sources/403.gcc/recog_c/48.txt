static rtx
split_insn (insn)
     rtx insn;
{
  rtx set;
  if (!INSN_P (insn))
    ;
  /* Don't split no-op move insns.  These should silently
     disappear later in final.  Splitting such insns would
     break the code that handles REG_NO_CONFLICT blocks.  */

  else if ((set = single_set (insn)) != NULL && set_noop_p (set))
    {
      /* Nops get in the way while scheduling, so delete them
         now if register allocation has already been done.  It
         is too risky to try to do this before register
         allocation, and there are unlikely to be very many
         nops then anyways.  */
      if (reload_completed)
	{
	  PUT_CODE (insn, NOTE);
	  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;
	  NOTE_SOURCE_FILE (insn) = 0;
	}
    }
  else
    {
      /* Split insns here to get max fine-grain parallelism.  */
      rtx first = PREV_INSN (insn);
      rtx last = try_split (PATTERN (insn), insn, 1);

      if (last != insn)
	{
	  /* try_split returns the NOTE that INSN became.  */
	  PUT_CODE (insn, NOTE);
	  NOTE_SOURCE_FILE (insn) = 0;
	  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;

	  /* ??? Coddle to md files that generate subregs in post-
	     reload splitters instead of computing the proper 
	     hard register.  */
	  if (reload_completed && first != last)
	    {
	      first = NEXT_INSN (first);
	      while (1)
		{
		  if (INSN_P (first))
		    cleanup_subreg_operands (first);
		  if (first == last)
		    break;
		  first = NEXT_INSN (first);
		}
	    }
	  return last;
	}
    }
  return NULL_RTX;
}
