void
peephole2_optimize (dump_file)
     FILE *dump_file ATTRIBUTE_UNUSED;
{
  regset_head rs_heads[MAX_INSNS_PER_PEEP2 + 2];
  rtx insn, prev;
  regset live;
  int i, b;
#ifdef HAVE_conditional_execution
  sbitmap blocks;
  bool changed;
#endif
  bool do_cleanup_cfg = false;
  bool do_rebuild_jump_labels = false;

  /* Initialize the regsets we're going to use.  */
  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)
    peep2_insn_data[i].live_before = INITIALIZE_REG_SET (rs_heads[i]);
  live = INITIALIZE_REG_SET (rs_heads[i]);

#ifdef HAVE_conditional_execution
  blocks = sbitmap_alloc (n_basic_blocks);
  sbitmap_zero (blocks);
  changed = false;
#else
  count_or_remove_death_notes (NULL, 1);
#endif

  for (b = n_basic_blocks - 1; b >= 0; --b)
    {
      basic_block bb = BASIC_BLOCK (b);
      struct propagate_block_info *pbi;

      /* Indicate that all slots except the last holds invalid data.  */
      for (i = 0; i < MAX_INSNS_PER_PEEP2; ++i)
	peep2_insn_data[i].insn = NULL_RTX;

      /* Indicate that the last slot contains live_after data.  */
      peep2_insn_data[MAX_INSNS_PER_PEEP2].insn = PEEP2_EOB;
      peep2_current = MAX_INSNS_PER_PEEP2;

      /* Start up propagation.  */
      COPY_REG_SET (live, bb->global_live_at_end);
      COPY_REG_SET (peep2_insn_data[MAX_INSNS_PER_PEEP2].live_before, live);

#ifdef HAVE_conditional_execution
      pbi = init_propagate_block_info (bb, live, NULL, NULL, 0);
#else
      pbi = init_propagate_block_info (bb, live, NULL, NULL, PROP_DEATH_NOTES);
#endif

      for (insn = bb->end; ; insn = prev)
	{
	  prev = PREV_INSN (insn);
	  if (INSN_P (insn))
	    {
	      rtx try, before_try, x;
	      int match_len;
	      rtx note;

	      /* Record this insn.  */
	      if (--peep2_current < 0)
		peep2_current = MAX_INSNS_PER_PEEP2;
	      peep2_insn_data[peep2_current].insn = insn;
	      propagate_one_insn (pbi, insn);
	      COPY_REG_SET (peep2_insn_data[peep2_current].live_before, live);

	      /* Match the peephole.  */
	      try = peephole2_insns (PATTERN (insn), insn, &match_len);
	      if (try != NULL)
		{
		  /* If we are splitting a CALL_INSN, look for the CALL_INSN
		     in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other
		     cfg-related call notes.  */
		  for (i = 0; i <= match_len; ++i)
		    {
		      int j, k;
		      rtx old_insn, new_insn, note;

		      j = i + peep2_current;
		      if (j >= MAX_INSNS_PER_PEEP2 + 1)
			j -= MAX_INSNS_PER_PEEP2 + 1;
		      old_insn = peep2_insn_data[j].insn;
		      if (GET_CODE (old_insn) != CALL_INSN)
			continue;

		      new_insn = NULL_RTX;
		      if (GET_CODE (try) == SEQUENCE)
			for (k = XVECLEN (try, 0) - 1; k >= 0; k--)
			  {
			    rtx x = XVECEXP (try, 0, k);
			    if (GET_CODE (x) == CALL_INSN)
			      {
				new_insn = x;
				break;
			      }
			  }
		      else if (GET_CODE (try) == CALL_INSN)
			new_insn = try;
		      if (! new_insn)
			abort ();

		      CALL_INSN_FUNCTION_USAGE (new_insn)
			= CALL_INSN_FUNCTION_USAGE (old_insn);

		      for (note = REG_NOTES (old_insn);
			   note;
			   note = XEXP (note, 1))
			switch (REG_NOTE_KIND (note))
			  {
			  case REG_NORETURN:
			  case REG_SETJMP:
			  case REG_ALWAYS_RETURN:
			    REG_NOTES (new_insn)
			      = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),
						   XEXP (note, 0),
						   REG_NOTES (new_insn));
			  default:
			    /* Discard all other reg notes.  */
			    break;
			  }

		      /* Croak if there is another call in the sequence.  */
		      while (++i <= match_len)
			{
			  j = i + peep2_current;
			  if (j >= MAX_INSNS_PER_PEEP2 + 1)
			    j -= MAX_INSNS_PER_PEEP2 + 1;
			  old_insn = peep2_insn_data[j].insn;
			  if (GET_CODE (old_insn) == CALL_INSN)
			    abort ();
			}
		      break;
		    }

		  i = match_len + peep2_current;
		  if (i >= MAX_INSNS_PER_PEEP2 + 1)
		    i -= MAX_INSNS_PER_PEEP2 + 1;

		  note = find_reg_note (peep2_insn_data[i].insn, 
					REG_EH_REGION, NULL_RTX);

		  /* Replace the old sequence with the new.  */
		  try = emit_insn_after (try, peep2_insn_data[i].insn);
		  before_try = PREV_INSN (insn);
		  delete_insn_chain (insn, peep2_insn_data[i].insn);

		  /* Re-insert the EH_REGION notes.  */
		  if (note)
		    {
		      edge eh_edge;

		      for (eh_edge = bb->succ; eh_edge
			   ; eh_edge = eh_edge->succ_next)
			if (eh_edge->flags & EDGE_EH)
			  break;

		      for (x = try ; x != before_try ; x = PREV_INSN (x))
			if (GET_CODE (x) == CALL_INSN
			    || (flag_non_call_exceptions
				&& may_trap_p (PATTERN (x))
				&& !find_reg_note (x, REG_EH_REGION, NULL)))
			  {
			    REG_NOTES (x)
			      = gen_rtx_EXPR_LIST (REG_EH_REGION,
						   XEXP (note, 0),
						   REG_NOTES (x));

			    if (x != bb->end && eh_edge)
			      {
				edge nfte, nehe;
				int flags;

				nfte = split_block (bb, x);
				flags = EDGE_EH | EDGE_ABNORMAL;
				if (GET_CODE (x) == CALL_INSN)
				  flags |= EDGE_ABNORMAL_CALL;
				nehe = make_edge (nfte->src, eh_edge->dest,
						  flags);

				nehe->probability = eh_edge->probability;
				nfte->probability
				  = REG_BR_PROB_BASE - nehe->probability;

			        do_cleanup_cfg |= purge_dead_edges (nfte->dest);
#ifdef HAVE_conditional_execution
				SET_BIT (blocks, nfte->dest->index);
				changed = true;
#endif
				bb = nfte->src;
				eh_edge = nehe;
			      }
			  }

		      /* Converting possibly trapping insn to non-trapping is
			 possible.  Zap dummy outgoing edges.  */
		      do_cleanup_cfg |= purge_dead_edges (bb);
		    }

#ifdef HAVE_conditional_execution
		  /* With conditional execution, we cannot back up the
		     live information so easily, since the conditional
		     death data structures are not so self-contained.
		     So record that we've made a modification to this
		     block and update life information at the end.  */
		  SET_BIT (blocks, b);
		  changed = true;

		  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)
		    peep2_insn_data[i].insn = NULL_RTX;
		  peep2_insn_data[peep2_current].insn = PEEP2_EOB;
#else
		  /* Back up lifetime information past the end of the
		     newly created sequence.  */
		  if (++i >= MAX_INSNS_PER_PEEP2 + 1)
		    i = 0;
		  COPY_REG_SET (live, peep2_insn_data[i].live_before);

		  /* Update life information for the new sequence.  */
		  x = try;
		  do
		    {
		      if (INSN_P (x))
			{
			  if (--i < 0)
			    i = MAX_INSNS_PER_PEEP2;
			  peep2_insn_data[i].insn = x;
			  propagate_one_insn (pbi, x);
			  COPY_REG_SET (peep2_insn_data[i].live_before, live);
			}
		      x = PREV_INSN (x);
		    }
		  while (x != prev);

		  /* ??? Should verify that LIVE now matches what we
		     had before the new sequence.  */

		  peep2_current = i;
#endif

		  /* If we generated a jump instruction, it won't have
		     JUMP_LABEL set.  Recompute after we're done.  */
		  for (x = try; x != before_try; x = PREV_INSN (x))
		    if (GET_CODE (x) == JUMP_INSN)
		      {
		        do_rebuild_jump_labels = true;
			break;
		      }
		}
	    }

	  if (insn == bb->head)
	    break;
	}

      free_propagate_block_info (pbi);
    }

  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)
    FREE_REG_SET (peep2_insn_data[i].live_before);
  FREE_REG_SET (live);

  if (do_rebuild_jump_labels)
    rebuild_jump_labels (get_insns ());

  /* If we eliminated EH edges, we may be able to merge blocks.  Further,
     we've changed global life since exception handlers are no longer
     reachable.  */
  if (do_cleanup_cfg)
    {
      cleanup_cfg (0);
      update_life_info (0, UPDATE_LIFE_GLOBAL_RM_NOTES, PROP_DEATH_NOTES);
    }
#ifdef HAVE_conditional_execution
  else
    {
      count_or_remove_death_notes (blocks, 1);
      update_life_info (blocks, UPDATE_LIFE_LOCAL, PROP_DEATH_NOTES);
    }
  sbitmap_free (blocks);
#endif
}
