int
flow_loops_find (loops, flags)
     struct loops *loops;
     int flags;
{
  int i;
  int b;
  int num_loops;
  edge e;
  sbitmap headers;
  sbitmap *dom;
  int *dfs_order;
  int *rc_order;

  /* This function cannot be repeatedly called with different
     flags to build up the loop information.  The loop tree
     must always be built if this function is called.  */
  if (! (flags & LOOP_TREE))
    abort ();

  memset (loops, 0, sizeof *loops);

  /* Taking care of this degenerate case makes the rest of
     this code simpler.  */
  if (n_basic_blocks == 0)
    return 0;

  dfs_order = NULL;
  rc_order = NULL;

  /* Compute the dominators.  */
  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);
  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);

  /* Count the number of loop edges (back edges).  This should be the
     same as the number of natural loops.  */
  num_loops = 0;
  for (b = 0; b < n_basic_blocks; b++)
    {
      basic_block header;

      header = BASIC_BLOCK (b);
      header->loop_depth = 0;

      for (e = header->pred; e; e = e->pred_next)
	{
	  basic_block latch = e->src;

	  /* Look for back edges where a predecessor is dominated
	     by this block.  A natural loop has a single entry
	     node (header) that dominates all the nodes in the
	     loop.  It also has single back edge to the header
	     from a latch node.  Note that multiple natural loops
	     may share the same header.  */
	  if (b != header->index)
	    abort ();

	  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index], b))
	    num_loops++;
	}
    }

  if (num_loops)
    {
      /* Compute depth first search order of the CFG so that outer
	 natural loops will be found before inner natural loops.  */
      dfs_order = (int *) xmalloc (n_basic_blocks * sizeof (int));
      rc_order = (int *) xmalloc (n_basic_blocks * sizeof (int));
      flow_depth_first_order_compute (dfs_order, rc_order);

      /* Save CFG derived information to avoid recomputing it.  */
      loops->cfg.dom = dom;
      loops->cfg.dfs_order = dfs_order;
      loops->cfg.rc_order = rc_order;

      /* Allocate loop structures.  */
      loops->array
	= (struct loop *) xcalloc (num_loops, sizeof (struct loop));

      headers = sbitmap_alloc (n_basic_blocks);
      sbitmap_zero (headers);

      loops->shared_headers = sbitmap_alloc (n_basic_blocks);
      sbitmap_zero (loops->shared_headers);

      /* Find and record information about all the natural loops
	 in the CFG.  */
      num_loops = 0;
      for (b = n_basic_blocks - 1; b >= 0; b--)
	{
	  basic_block latch;

	  /* Search the nodes of the CFG in reverse completion order
	     so that we can find outer loops first.  */
	  latch = BASIC_BLOCK (rc_order[b]);

	  /* Look for all the possible headers for this latch block.  */
	  for (e = latch->succ; e; e = e->succ_next)
	    {
	      basic_block header = e->dest;

	      /* Look for forward edges where this block is dominated by
		 a successor of this block.  A natural loop has a single
		 entry node (header) that dominates all the nodes in the
		 loop.  It also has single back edge to the header from a
		 latch node.  Note that multiple natural loops may share
		 the same header.  */
	      if (header != EXIT_BLOCK_PTR
		  && TEST_BIT (dom[latch->index], header->index))
		{
		  struct loop *loop;

		  loop = loops->array + num_loops;

		  loop->header = header;
		  loop->latch = latch;
		  loop->num = num_loops;

		  num_loops++;
		}
	    }
	}

      for (i = 0; i < num_loops; i++)
	{
	  struct loop *loop = &loops->array[i];

	  /* Keep track of blocks that are loop headers so
	     that we can tell which loops should be merged.  */
	  if (TEST_BIT (headers, loop->header->index))
	    SET_BIT (loops->shared_headers, loop->header->index);
	  SET_BIT (headers, loop->header->index);

	  /* Find nodes contained within the loop.  */
	  loop->nodes = sbitmap_alloc (n_basic_blocks);
	  loop->num_nodes
	    = flow_loop_nodes_find (loop->header, loop->latch, loop->nodes);

	  /* Compute first and last blocks within the loop.
	     These are often the same as the loop header and
	     loop latch respectively, but this is not always
	     the case.  */
	  loop->first
	    = BASIC_BLOCK (sbitmap_first_set_bit (loop->nodes));
	  loop->last
	    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));

	  flow_loop_scan (loops, loop, flags);
	}

      /* Natural loops with shared headers may either be disjoint or
	 nested.  Disjoint loops with shared headers cannot be inner
	 loops and should be merged.  For now just mark loops that share
	 headers.  */
      for (i = 0; i < num_loops; i++)
	if (TEST_BIT (loops->shared_headers, loops->array[i].header->index))
	  loops->array[i].shared = 1;

      sbitmap_free (headers);
    }
  else
    sbitmap_vector_free (dom);

  loops->num = num_loops;

  /* Build the loop hierarchy tree.  */
  flow_loops_tree_build (loops);

  /* Assign the loop nesting depth and enclosed loop level for each
     loop.  */
  loops->levels = flow_loops_level_compute (loops);

  return num_loops;
}
