static void do_SUBST_INT		PARAMS ((unsigned int *,
						 unsigned int));
static void init_reg_last_arrays	PARAMS ((void));
static void setup_incoming_promotions   PARAMS ((void));
static void set_nonzero_bits_and_sign_copies  PARAMS ((rtx, rtx, void *));
static int cant_combine_insn_p	PARAMS ((rtx));
static int can_combine_p	PARAMS ((rtx, rtx, rtx, rtx, rtx *, rtx *));
static int sets_function_arg_p	PARAMS ((rtx));
static int combinable_i3pat	PARAMS ((rtx, rtx *, rtx, rtx, int, rtx *));
static int contains_muldiv	PARAMS ((rtx));
static rtx try_combine		PARAMS ((rtx, rtx, rtx, int *));
static void undo_all		PARAMS ((void));
static void undo_commit		PARAMS ((void));
static rtx *find_split_point	PARAMS ((rtx *, rtx));
static rtx subst		PARAMS ((rtx, rtx, rtx, int, int));
static rtx combine_simplify_rtx	PARAMS ((rtx, enum machine_mode, int, int));
static rtx simplify_if_then_else  PARAMS ((rtx));
static rtx simplify_set		PARAMS ((rtx));
static rtx simplify_logical	PARAMS ((rtx, int));
static rtx expand_compound_operation  PARAMS ((rtx));
static rtx expand_field_assignment  PARAMS ((rtx));
static rtx make_extraction	PARAMS ((enum machine_mode, rtx, HOST_WIDE_INT,
					 rtx, unsigned HOST_WIDE_INT, int,
					 int, int));
static rtx extract_left_shift	PARAMS ((rtx, int));
static rtx make_compound_operation  PARAMS ((rtx, enum rtx_code));
static int get_pos_from_mask	PARAMS ((unsigned HOST_WIDE_INT,
					 unsigned HOST_WIDE_INT *));
static rtx force_to_mode	PARAMS ((rtx, enum machine_mode,
					 unsigned HOST_WIDE_INT, rtx, int));
static rtx if_then_else_cond	PARAMS ((rtx, rtx *, rtx *));
static rtx known_cond		PARAMS ((rtx, enum rtx_code, rtx, rtx));
static int rtx_equal_for_field_assignment_p PARAMS ((rtx, rtx));
static rtx make_field_assignment  PARAMS ((rtx));
static rtx apply_distributive_law  PARAMS ((rtx));
static rtx simplify_and_const_int  PARAMS ((rtx, enum machine_mode, rtx,
					    unsigned HOST_WIDE_INT));
static unsigned HOST_WIDE_INT nonzero_bits  PARAMS ((rtx, enum machine_mode));
static unsigned int num_sign_bit_copies  PARAMS ((rtx, enum machine_mode));
static int merge_outer_ops	PARAMS ((enum rtx_code *, HOST_WIDE_INT *,
					 enum rtx_code, HOST_WIDE_INT,
					 enum machine_mode, int *));
static rtx simplify_shift_const	PARAMS ((rtx, enum rtx_code, enum machine_mode,
					 rtx, int));
static int recog_for_combine	PARAMS ((rtx *, rtx, rtx *));
static rtx gen_lowpart_for_combine  PARAMS ((enum machine_mode, rtx));
static rtx gen_binary		PARAMS ((enum rtx_code, enum machine_mode,
					 rtx, rtx));
static enum rtx_code simplify_comparison  PARAMS ((enum rtx_code, rtx *, rtx *));
static void update_table_tick	PARAMS ((rtx));
static void record_value_for_reg  PARAMS ((rtx, rtx, rtx));
static void check_promoted_subreg PARAMS ((rtx, rtx));
static void record_dead_and_set_regs_1  PARAMS ((rtx, rtx, void *));
static void record_dead_and_set_regs  PARAMS ((rtx));
static int get_last_value_validate  PARAMS ((rtx *, rtx, int, int));
static rtx get_last_value	PARAMS ((rtx));
static int use_crosses_set_p	PARAMS ((rtx, int));
static void reg_dead_at_p_1	PARAMS ((rtx, rtx, void *));
static int reg_dead_at_p	PARAMS ((rtx, rtx));
static void move_deaths		PARAMS ((rtx, rtx, int, rtx, rtx *));
static int reg_bitfield_target_p  PARAMS ((rtx, rtx));
static void distribute_notes	PARAMS ((rtx, rtx, rtx, rtx, rtx, rtx));
static void distribute_links	PARAMS ((rtx));
static void mark_used_regs_combine PARAMS ((rtx));
static int insn_cuid		PARAMS ((rtx));
static void record_promoted_value PARAMS ((rtx, rtx));
static rtx reversed_comparison  PARAMS ((rtx, enum machine_mode, rtx, rtx));
static enum rtx_code combine_reversed_comparison_code PARAMS ((rtx));

/* Substitute NEWVAL, an rtx expression, into INTO, a place in some
   insn.  The substitution can be undone by undo_all.  If INTO is already
   set to NEWVAL, do not record this change.  Because computing NEWVAL might
   also call SUBST, we have to compute it before we put anything into
   the undo table.  */

static void
do_SUBST (into, newval)
     rtx *into, newval;
{
  struct undo *buf;
  rtx oldval = *into;

  if (oldval == newval)
    return;

  /* We'd like to catch as many invalid transformations here as
     possible.  Unfortunately, there are way too many mode changes
     that are perfectly valid, so we'd waste too much effort for
     little gain doing the checks here.  Focus on catching invalid
     transformations involving integer constants.  */
  if (GET_MODE_CLASS (GET_MODE (oldval)) == MODE_INT
      && GET_CODE (newval) == CONST_INT)
    {
      /* Sanity check that we're replacing oldval with a CONST_INT
	 that is a valid sign-extension for the original mode.  */
      if (INTVAL (newval) != trunc_int_for_mode (INTVAL (newval),
						 GET_MODE (oldval)))
	abort ();

      /* Replacing the operand of a SUBREG or a ZERO_EXTEND with a
	 CONST_INT is not valid, because after the replacement, the
	 original mode would be gone.  Unfortunately, we can't tell
	 when do_SUBST is called to replace the operand thereof, so we
	 perform this test on oldval instead, checking whether an
	 invalid replacement took place before we got here.  */
      if ((GET_CODE (oldval) == SUBREG
	   && GET_CODE (SUBREG_REG (oldval)) == CONST_INT)
	  || (GET_CODE (oldval) == ZERO_EXTEND
	      && GET_CODE (XEXP (oldval, 0)) == CONST_INT))
	abort ();
     }

  if (undobuf.frees)
    buf = undobuf.frees, undobuf.frees = buf->next;
  else
    buf = (struct undo *) xmalloc (sizeof (struct undo));

  buf->is_int = 0;
  buf->where.r = into;
  buf->old_contents.r = oldval;
  *into = newval;

  buf->next = undobuf.undos, undobuf.undos = buf;
}
