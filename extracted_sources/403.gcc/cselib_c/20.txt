static int
cselib_invalidate_mem_1 (slot, info)
     void **slot;
     void *info;
{
  cselib_val *v = (cselib_val *) *slot;
  rtx mem_rtx = (rtx) info;
  struct elt_loc_list **p = &v->locs;
  int had_locs = v->locs != 0;

  while (*p)
    {
      rtx x = (*p)->loc;
      cselib_val *addr;
      struct elt_list **mem_chain;

      /* MEMs may occur in locations only at the top level; below
	 that every MEM or REG is substituted by its VALUE.  */
      if (GET_CODE (x) != MEM
	  || ! cselib_mem_conflict_p (mem_rtx, x))
	{
	  p = &(*p)->next;
	  continue;
	}

      /* This one overlaps.  */
      /* We must have a mapping from this MEM's address to the
	 value (E).  Remove that, too.  */
      addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);
      mem_chain = &addr->addr_list;
      for (;;)
	{
	  if ((*mem_chain)->elt == v)
	    {
	      unchain_one_elt_list (mem_chain);
	      break;
	    }

	  mem_chain = &(*mem_chain)->next;
	}

      unchain_one_elt_loc_list (p);
    }

  if (had_locs && v->locs == 0)
    n_useless_values++;

  return 1;
}
