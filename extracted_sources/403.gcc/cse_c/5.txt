int
rtx_cost (x, outer_code)
     rtx x;
     enum rtx_code outer_code ATTRIBUTE_UNUSED;
{
  int i, j;
  enum rtx_code code;
  const char *fmt;
  int total;

  if (x == 0)
    return 0;

  /* Compute the default costs of certain things.
     Note that RTX_COSTS can override the defaults.  */

  code = GET_CODE (x);
  switch (code)
    {
    case MULT:
      /* Count multiplication by 2**n as a shift,
	 because if we are considering it, we would output it as a shift.  */
      if (GET_CODE (XEXP (x, 1)) == CONST_INT
	  && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)
	total = 2;
      else
	total = COSTS_N_INSNS (5);
      break;
    case DIV:
    case UDIV:
    case MOD:
    case UMOD:
      total = COSTS_N_INSNS (7);
      break;
    case USE:
      /* Used in loop.c and combine.c as a marker.  */
      total = 0;
      break;
    default:
      total = COSTS_N_INSNS (1);
    }

  switch (code)
    {
    case REG:
      return 0;

    case SUBREG:
      /* If we can't tie these modes, make this expensive.  The larger
	 the mode, the more expensive it is.  */
      if (! MODES_TIEABLE_P (GET_MODE (x), GET_MODE (SUBREG_REG (x))))
	return COSTS_N_INSNS (2
			      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);
      break;

#ifdef RTX_COSTS
      RTX_COSTS (x, code, outer_code);
#endif
#ifdef CONST_COSTS
      CONST_COSTS (x, code, outer_code);
#endif

    default:
#ifdef DEFAULT_RTX_COSTS
      DEFAULT_RTX_COSTS (x, code, outer_code);
#endif
      break;
    }

  /* Sum the costs of the sub-rtx's, plus cost of this operation,
     which is already in total.  */

  fmt = GET_RTX_FORMAT (code);
  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
    if (fmt[i] == 'e')
      total += rtx_cost (XEXP (x, i), code);
    else if (fmt[i] == 'E')
      for (j = 0; j < XVECLEN (x, i); j++)
	total += rtx_cost (XVECEXP (x, i, j), code);

  return total;
}
