static void
merge_blocks_move_successor_nojumps (a, b)
     basic_block a, b;
{
  rtx barrier, real_b_end;

  real_b_end = b->end;
  barrier = NEXT_INSN (b->end);

  /* Recognize a jump table following block B.  */
  if (barrier
      && GET_CODE (barrier) == CODE_LABEL
      && NEXT_INSN (barrier)
      && GET_CODE (NEXT_INSN (barrier)) == JUMP_INSN
      && (GET_CODE (PATTERN (NEXT_INSN (barrier))) == ADDR_VEC
	  || GET_CODE (PATTERN (NEXT_INSN (barrier))) == ADDR_DIFF_VEC))
    {
      /* Temporarily add the table jump insn to b, so that it will also
	 be moved to the correct location.  */
      b->end = NEXT_INSN (barrier);
      barrier = NEXT_INSN (b->end);
    }

  /* There had better have been a barrier there.  Delete it.  */
  if (barrier && GET_CODE (barrier) == BARRIER)
    delete_insn (barrier);

  /* Move block and loop notes out of the chain so that we do not
     disturb their order.

     ??? A better solution would be to squeeze out all the non-nested notes
     and adjust the block trees appropriately.   Even better would be to have
     a tighter connection between block trees and rtl so that this is not
     necessary.  */
  if (squeeze_notes (&b->head, &b->end))
    abort ();

  /* Scramble the insn chain.  */
  reorder_insns_nobb (b->head, b->end, a->end);

  /* Restore the real end of b.  */
  b->end = real_b_end;

  /* Now blocks A and B are contiguous.  Merge them.  */
  merge_blocks_nomove (a, b);
  BB_SET_FLAG (a, BB_UPDATE_LIFE);

  if (rtl_dump_file)
    fprintf (rtl_dump_file, "Moved block %d after %d and merged.\n",
	     b->index, a->index);
}
