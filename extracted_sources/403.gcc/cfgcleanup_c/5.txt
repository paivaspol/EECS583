static bool
try_forward_edges (mode, b)
     basic_block b;
     int mode;
{
  bool changed = false;
  edge e, next, *threaded_edges = NULL;

  for (e = b->succ; e; e = next)
    {
      basic_block target, first;
      int counter;
      bool threaded = false;
      int nthreaded_edges = 0;

      next = e->succ_next;

      /* Skip complex edges because we don't know how to update them.

         Still handle fallthru edges, as we can succeed to forward fallthru
         edge to the same place as the branch edge of conditional branch
         and turn conditional branch to an unconditional branch.  */
      if (e->flags & EDGE_COMPLEX)
	continue;

      target = first = e->dest;
      counter = 0;

      while (counter < n_basic_blocks)
	{
	  basic_block new_target = NULL;
	  bool new_target_threaded = false;

	  if (FORWARDER_BLOCK_P (target)
	      && target->succ->dest != EXIT_BLOCK_PTR)
	    {
	      /* Bypass trivial infinite loops.  */
	      if (target == target->succ->dest)
		counter = n_basic_blocks;
	      new_target = target->succ->dest;
	    }

	  /* Allow to thread only over one edge at time to simplify updating
	     of probabilities.  */
	  else if (mode & CLEANUP_THREADING)
	    {
	      edge t = thread_jump (mode, e, target);
	      if (t)
		{
		  if (!threaded_edges)
		    threaded_edges = xmalloc (sizeof (*threaded_edges)
					      * n_basic_blocks);
		  else
		    {
		      int i;

		      /* Detect an infinite loop across blocks not
			 including the start block.  */
		      for (i = 0; i < nthreaded_edges; ++i)
			if (threaded_edges[i] == t)
			  break;
		      if (i < nthreaded_edges)
			{
			  counter = n_basic_blocks;
			  break;
			}
		    }

		  /* Detect an infinite loop across the start block.  */
		  if (t->dest == b)
		    break;

		  if (nthreaded_edges >= n_basic_blocks)
		    abort ();
		  threaded_edges[nthreaded_edges++] = t;

		  new_target = t->dest;
		  new_target_threaded = true;
		}
	    }

	  if (!new_target)
	    break;

	  /* Avoid killing of loop pre-headers, as it is the place loop
	     optimizer wants to hoist code to.

	     For fallthru forwarders, the LOOP_BEG note must appear between
	     the header of block and CODE_LABEL of the loop, for non forwarders
	     it must appear before the JUMP_INSN.  */
	  if (mode & CLEANUP_PRE_LOOP)
	    {
	      rtx insn = (target->succ->flags & EDGE_FALLTHRU
		          ? target->head : prev_nonnote_insn (target->end));

	      if (GET_CODE (insn) != NOTE)
		insn = NEXT_INSN (insn);

	      for (; insn && GET_CODE (insn) != CODE_LABEL && !INSN_P (insn);
		   insn = NEXT_INSN (insn))
		if (GET_CODE (insn) == NOTE
		    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)
		  break;

	      if (GET_CODE (insn) == NOTE)
		break;
	    }

	  counter++;
	  target = new_target;
	  threaded |= new_target_threaded;
  	}

      if (counter >= n_basic_blocks)
	{
	  if (rtl_dump_file)
	    fprintf (rtl_dump_file, "Infinite loop in BB %i.\n",
		     target->index);
	}
      else if (target == first)
	; /* We didn't do anything.  */
      else
	{
	  /* Save the values now, as the edge may get removed.  */
	  gcov_type edge_count = e->count;
	  int edge_probability = e->probability;
	  int edge_frequency;
	  int n = 0;

	  /* Don't force if target is exit block.  */
	  if (threaded && target != EXIT_BLOCK_PTR)
	    {
	      notice_new_block (redirect_edge_and_branch_force (e, target));
	      if (rtl_dump_file)
	        fprintf (rtl_dump_file, "Conditionals threaded.\n");
	    }
	  else if (!redirect_edge_and_branch (e, target))
	    {
	      if (rtl_dump_file)
		fprintf (rtl_dump_file,
			 "Forwarding edge %i->%i to %i failed.\n",
			 b->index, e->dest->index, target->index);
	      continue;
	    }

	  /* We successfully forwarded the edge.  Now update profile
	     data: for each edge we traversed in the chain, remove
	     the original edge's execution count.  */
	  edge_frequency = ((edge_probability * b->frequency
			     + REG_BR_PROB_BASE / 2)
			    / REG_BR_PROB_BASE);

	  if (!FORWARDER_BLOCK_P (b) && forwarder_block_p (b))
	    BB_SET_FLAG (b, BB_FORWARDER_BLOCK);
	  BB_SET_FLAG (b, BB_UPDATE_LIFE);

	  do
	    {
	      edge t;

	      first->count -= edge_count;
	      if (first->count < 0)
		first->count = 0;
	      first->frequency -= edge_frequency;
	      if (first->frequency < 0)
		first->frequency = 0;
	      if (first->succ->succ_next)
		{
		  edge e;
		  int prob;
		  if (n >= nthreaded_edges)
		    abort ();
		  t = threaded_edges [n++];
		  if (t->src != first)
		    abort ();
		  if (first->frequency)
		    prob = edge_frequency * REG_BR_PROB_BASE / first->frequency;
		  else
		    prob = 0;
		  if (prob > t->probability)
		    prob = t->probability;
		  t->probability -= prob;
		  prob = REG_BR_PROB_BASE - prob;
		  if (prob <= 0)
		    {
		      first->succ->probability = REG_BR_PROB_BASE;
		      first->succ->succ_next->probability = 0;
		    }
		  else
		    for (e = first->succ; e; e = e->succ_next)
		      e->probability = ((e->probability * REG_BR_PROB_BASE)
					/ (double) prob);
		  update_br_prob_note (first);
		}
	      else
		{
		  /* It is possible that as the result of
		     threading we've removed edge as it is
		     threaded to the fallthru edge.  Avoid
		     getting out of sync.  */
		  if (n < nthreaded_edges
		      && first == threaded_edges [n]->src)
		    n++;
		  t = first->succ;
		 }

	      t->count -= edge_count;
	      if (t->count < 0)
		t->count = 0;
	      first = t->dest;
	    }
	  while (first != target);

	  changed = true;
	}
    }

  if (threaded_edges)
    free (threaded_edges);
  return changed;
}
