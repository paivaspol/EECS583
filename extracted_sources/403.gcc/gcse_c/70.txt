static int
handle_avail_expr (insn, expr)
     rtx insn;
     struct expr *expr;
{
  rtx pat, insn_computes_expr, expr_set;
  rtx to;
  struct reg_set *this_reg;
  int found_setting, use_src;
  int changed = 0;

  /* We only handle the case where one computation of the expression
     reaches this instruction.  */
  insn_computes_expr = computing_insn (expr, insn);
  if (insn_computes_expr == NULL)
    return 0;
  expr_set = single_set (insn_computes_expr);
  if (!expr_set)
    abort ();

  found_setting = 0;
  use_src = 0;

  /* At this point we know only one computation of EXPR outside of this
     block reaches this insn.  Now try to find a register that the
     expression is computed into.  */
  if (GET_CODE (SET_SRC (expr_set)) == REG)
    {
      /* This is the case when the available expression that reaches
	 here has already been handled as an available expression.  */
      unsigned int regnum_for_replacing
	= REGNO (SET_SRC (expr_set));

      /* If the register was created by GCSE we can't use `reg_set_table',
	 however we know it's set only once.  */
      if (regnum_for_replacing >= max_gcse_regno
	  /* If the register the expression is computed into is set only once,
	     or only one set reaches this insn, we can use it.  */
	  || (((this_reg = reg_set_table[regnum_for_replacing]),
	       this_reg->next == NULL)
	      || can_disregard_other_sets (&this_reg, insn, 0)))
	{
	  use_src = 1;
	  found_setting = 1;
	}
    }

  if (!found_setting)
    {
      unsigned int regnum_for_replacing
	= REGNO (SET_DEST (expr_set));

      /* This shouldn't happen.  */
      if (regnum_for_replacing >= max_gcse_regno)
	abort ();

      this_reg = reg_set_table[regnum_for_replacing];

      /* If the register the expression is computed into is set only once,
	 or only one set reaches this insn, use it.  */
      if (this_reg->next == NULL
	  || can_disregard_other_sets (&this_reg, insn, 0))
	found_setting = 1;
    }

  if (found_setting)
    {
      pat = PATTERN (insn);
      if (use_src)
	to = SET_SRC (expr_set);
      else
	to = SET_DEST (expr_set);
      changed = validate_change (insn, &SET_SRC (pat), to, 0);

      /* We should be able to ignore the return code from validate_change but
	 to play it safe we check.  */
      if (changed)
	{
	  gcse_subst_count++;
	  if (gcse_file != NULL)
	    {
	      fprintf (gcse_file, "GCSE: Replacing the source in insn %d with",
		       INSN_UID (insn));
	      fprintf (gcse_file, " reg %d %s insn %d\n",
		       REGNO (to), use_src ? "from" : "set in",
		       INSN_UID (insn_computes_expr));
	    }
	}
    }

  /* The register that the expr is computed into is set more than once.  */
  else if (1 /*expensive_op(this_pattrn->op) && do_expensive_gcse)*/)
    {
      /* Insert an insn after insnx that copies the reg set in insnx
	 into a new pseudo register call this new register REGN.
	 From insnb until end of basic block or until REGB is set
	 replace all uses of REGB with REGN.  */
      rtx new_insn;

      to = gen_reg_rtx (GET_MODE (SET_DEST (expr_set)));

      /* Generate the new insn.  */
      /* ??? If the change fails, we return 0, even though we created
	 an insn.  I think this is ok.  */
      new_insn
	= emit_insn_after (gen_rtx_SET (VOIDmode, to,
					SET_DEST (expr_set)),
			   insn_computes_expr);

      /* Keep register set table up to date.  */
      record_one_set (REGNO (to), new_insn);

      gcse_create_count++;
      if (gcse_file != NULL)
	{
	  fprintf (gcse_file, "GCSE: Creating insn %d to copy value of reg %d",
		   INSN_UID (NEXT_INSN (insn_computes_expr)),
		   REGNO (SET_SRC (PATTERN (NEXT_INSN (insn_computes_expr)))));
	  fprintf (gcse_file, ", computed in insn %d,\n",
		   INSN_UID (insn_computes_expr));
	  fprintf (gcse_file, "      into newly allocated reg %d\n",
		   REGNO (to));
	}

      pat = PATTERN (insn);

      /* Do register replacement for INSN.  */
      changed = validate_change (insn, &SET_SRC (pat),
				 SET_DEST (PATTERN
					   (NEXT_INSN (insn_computes_expr))),
				 0);

      /* We should be able to ignore the return code from validate_change but
	 to play it safe we check.  */
      if (changed)
	{
	  gcse_subst_count++;
	  if (gcse_file != NULL)
	    {
	      fprintf (gcse_file,
		       "GCSE: Replacing the source in insn %d with reg %d ",
		       INSN_UID (insn),
		       REGNO (SET_DEST (PATTERN (NEXT_INSN
						 (insn_computes_expr)))));
	      fprintf (gcse_file, "set in insn %d\n",
		       INSN_UID (insn_computes_expr)); 
	    }
	}
    }

  return changed;
}
