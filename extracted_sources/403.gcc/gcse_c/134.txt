static int
insert_store (expr, e)
     struct ls_expr * expr;
     edge e;
{
  rtx reg, insn;
  basic_block bb;
  edge tmp;

  /* We did all the deleted before this insert, so if we didn't delete a
     store, then we haven't set the reaching reg yet either.  */
  if (expr->reaching_reg == NULL_RTX)
    return 0;

  reg = expr->reaching_reg;
  insn = gen_move_insn (expr->pattern, reg);
  
  /* If we are inserting this expression on ALL predecessor edges of a BB,
     insert it at the start of the BB, and reset the insert bits on the other
     edges so we don't try to insert it on the other edges.  */
  bb = e->dest;
  for (tmp = e->dest->pred; tmp ; tmp = tmp->pred_next)
    {
      int index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);
      if (index == EDGE_INDEX_NO_EDGE)
	abort ();
      if (! TEST_BIT (pre_insert_map[index], expr->index))
	break;
    }

  /* If tmp is NULL, we found an insertion on every edge, blank the
     insertion vector for these edges, and insert at the start of the BB.  */
  if (!tmp && bb != EXIT_BLOCK_PTR)
    {
      for (tmp = e->dest->pred; tmp ; tmp = tmp->pred_next)
	{
	  int index = EDGE_INDEX (edge_list, tmp->src, tmp->dest);
	  RESET_BIT (pre_insert_map[index], expr->index);
	}
      insert_insn_start_bb (insn, bb);
      return 0;
    }
  
  /* We can't insert on this edge, so we'll insert at the head of the
     successors block.  See Morgan, sec 10.5.  */
  if ((e->flags & EDGE_ABNORMAL) == EDGE_ABNORMAL)
    {
      insert_insn_start_bb (insn, bb);
      return 0;
    }

  insert_insn_on_edge (insn, e);
  
  if (gcse_file)
    {
      fprintf (gcse_file, "STORE_MOTION  insert insn on edge (%d, %d):\n",
	       e->src->index, e->dest->index);
      print_inline_rtx (gcse_file, insn, 6);
      fprintf (gcse_file, "\n");
    }
  
  return 1;
}
