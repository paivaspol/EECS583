static int
const_hash (exp)
     tree exp;
{
  const char *p;
  int len, hi, i;
  enum tree_code code = TREE_CODE (exp);

  /* Either set P and LEN to the address and len of something to hash and
     exit the switch or return a value.  */

  switch (code)
    {
    case INTEGER_CST:
      p = (char *) &TREE_INT_CST (exp);
      len = sizeof TREE_INT_CST (exp);
      break;

    case REAL_CST:
      p = (char *) &TREE_REAL_CST (exp);
      len = sizeof TREE_REAL_CST (exp);
      break;

    case STRING_CST:
      p = TREE_STRING_POINTER (exp);
      len = TREE_STRING_LENGTH (exp);
      break;

    case COMPLEX_CST:
      return (const_hash (TREE_REALPART (exp)) * 5
	      + const_hash (TREE_IMAGPART (exp)));

    case CONSTRUCTOR:
      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)
	{
	  char *tmp;

	  len = int_size_in_bytes (TREE_TYPE (exp));
	  tmp = (char *) alloca (len);
	  get_set_constructor_bytes (exp, (unsigned char *) tmp, len);
	  p = tmp;
	  break;
	}
      else
	{
	  tree link;

	  /* For record type, include the type in the hashing.
	     We do not do so for array types
	     because (1) the sizes of the elements are sufficient
	     and (2) distinct array types can have the same constructor.
	     Instead, we include the array size because the constructor could
	     be shorter.  */
	  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)
	    hi = ((unsigned long) TREE_TYPE (exp) & ((1 << HASHBITS) - 1))
	      % MAX_HASH_TABLE;
	  else
	    hi = ((5 + int_size_in_bytes (TREE_TYPE (exp)))
		  & ((1 << HASHBITS) - 1)) % MAX_HASH_TABLE;

	  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))
	    if (TREE_VALUE (link))
	      hi
		= (hi * 603 + const_hash (TREE_VALUE (link))) % MAX_HASH_TABLE;

	  return hi;
	}

    case ADDR_EXPR:
    case FDESC_EXPR:
      {
	struct addr_const value;

	decode_addr_const (exp, &value);
	if (GET_CODE (value.base) == SYMBOL_REF)
	  {
	    /* Don't hash the address of the SYMBOL_REF;
	       only use the offset and the symbol name.  */
	    hi = value.offset;
	    p = XSTR (value.base, 0);
	    for (i = 0; p[i] != 0; i++)
	      hi = ((hi * 613) + (unsigned) (p[i]));
	  }
	else if (GET_CODE (value.base) == LABEL_REF)
	  hi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;
	else
	  abort ();

	hi &= (1 << HASHBITS) - 1;
	hi %= MAX_HASH_TABLE;
      }
      return hi;

    case PLUS_EXPR:
    case MINUS_EXPR:
      return (const_hash (TREE_OPERAND (exp, 0)) * 9
	      + const_hash (TREE_OPERAND (exp, 1)));

    case NOP_EXPR:
    case CONVERT_EXPR:
    case NON_LVALUE_EXPR:
      return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;

    default:
      /* A language specific constant. Just hash the code.  */
      return (int) code % MAX_HASH_TABLE;
    }

  /* Compute hashing function */
  hi = len;
  for (i = 0; i < len; i++)
    hi = ((hi * 613) + (unsigned) (p[i]));

  hi &= (1 << HASHBITS) - 1;
  hi %= MAX_HASH_TABLE;
  return hi;
}
