static int
rename_insn_1 (ptr, data)
     rtx *ptr;
     void *data;
{
  rtx x = *ptr;
  struct rename_context *context = data;

  if (x == NULL_RTX)
    return 0;

  switch (GET_CODE (x))
    {
    case SET:
      {
	rtx *destp = &SET_DEST (x);
	rtx dest = SET_DEST (x);

	/* An assignment to a paradoxical SUBREG does not read from
	   the destination operand, and thus does not need to be
	   wrapped into a SEQUENCE when translating into SSA form.
	   We merely strip off the SUBREG and proceed normally for
	   this case.  */
	if (GET_CODE (dest) == SUBREG
	    && (GET_MODE_SIZE (GET_MODE (dest))
		> GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))
	    && GET_CODE (SUBREG_REG (dest)) == REG
	    && CONVERT_REGISTER_TO_SSA_P (REGNO (SUBREG_REG (dest))))
	  {
	    destp = &XEXP (dest, 0);
	    dest = XEXP (dest, 0);
	  }

	/* Some SETs also use the REG specified in their LHS.
	   These can be detected by the presence of
	   STRICT_LOW_PART, SUBREG, SIGN_EXTRACT, and ZERO_EXTRACT
	   in the LHS.  Handle these by changing
	   (set (subreg (reg foo)) ...)
	   into
	   (sequence [(set (reg foo_1) (reg foo))
	              (set (subreg (reg foo_1)) ...)])  

	   FIXME: Much of the time this is too much.  For some constructs
	   we know that the output register is strictly an output
	   (paradoxical SUBREGs and some libcalls for example).

	   For those cases we are better off not making the false
	   dependency.  */
	if (GET_CODE (dest) == STRICT_LOW_PART
	    || GET_CODE (dest) == SUBREG
	    || GET_CODE (dest) == SIGN_EXTRACT
	    || GET_CODE (dest) == ZERO_EXTRACT)
	  {
	    rtx i, reg;
	    reg = dest;
	    
	    while (GET_CODE (reg) == STRICT_LOW_PART
		   || GET_CODE (reg) == SUBREG
		   || GET_CODE (reg) == SIGN_EXTRACT
		   || GET_CODE (reg) == ZERO_EXTRACT)
		reg = XEXP (reg, 0);
	    
	    if (GET_CODE (reg) == REG
		&& CONVERT_REGISTER_TO_SSA_P (REGNO (reg)))
	      {
		/* Generate (set reg reg), and do renaming on it so
		   that it becomes (set reg_1 reg_0), and we will
		   replace reg with reg_1 in the SUBREG.  */

		struct rename_set_data *saved_new_renames;
		saved_new_renames = context->new_renames;
		context->new_renames = NULL;
		i = emit_insn (gen_rtx_SET (VOIDmode, reg, reg));
		for_each_rtx (&i, rename_insn_1, data);
		apply_delayed_renames (context);
		context->new_renames = saved_new_renames;
	      }
	  }
	else if (GET_CODE (dest) == REG
		 && CONVERT_REGISTER_TO_SSA_P (REGNO (dest)))
	  {
	    /* We found a genuine set of an interesting register.  Tag
	       it so that we can create a new name for it after we finish
	       processing this insn.  */

	    create_delayed_rename (context, destp);

	    /* Since we do not wish to (directly) traverse the
	       SET_DEST, recurse through for_each_rtx for the SET_SRC
	       and return.  */
	    if (GET_CODE (x) == SET)
	      for_each_rtx (&SET_SRC (x), rename_insn_1, data);
	    return -1;
	  }

	/* Otherwise, this was not an interesting destination.  Continue
	   on, marking uses as normal.  */
	return 0;
      }

    case REG:
      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)) &&
	  REGNO (x) < ssa_max_reg_num)
	{
	  rtx new_reg = ssa_rename_to_lookup (x);

	  if (new_reg != NULL_RTX && new_reg != RENAME_NO_RTX)
	    {
	      if (GET_MODE (x) != GET_MODE (new_reg))
		abort ();
	      *ptr = new_reg;
	    }
	  /* Else this is a use before a set.  Warn?  */
	}
      return -1;

    case CLOBBER:
      /* There is considerable debate on how CLOBBERs ought to be
	 handled in SSA.  For now, we're keeping the CLOBBERs, which
	 means that we don't really have SSA form.  There are a couple
	 of proposals for how to fix this problem, but neither is
	 implemented yet.  */
      {
	rtx dest = XCEXP (x, 0, CLOBBER);
	if (REG_P (dest))
	  {
	    if (CONVERT_REGISTER_TO_SSA_P (REGNO (dest))
		&& REGNO (dest) < ssa_max_reg_num)
	      {
		rtx new_reg = ssa_rename_to_lookup (dest);
		if (new_reg != NULL_RTX && new_reg != RENAME_NO_RTX)
		    XCEXP (x, 0, CLOBBER) = new_reg;
	      }
	    /* Stop traversing.  */
	    return -1;
	  }	    
	else
	  /* Continue traversing.  */
	  return 0;
      }

    case PHI:
      /* Never muck with the phi.  We do that elsewhere, special-like.  */
      return -1;

    default:
      /* Anything else, continue traversing.  */
      return 0;
    }
}
