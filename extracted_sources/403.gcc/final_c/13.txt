void
compute_alignments ()
{
  int i;
  int log, max_skip, max_log;

  if (label_align)
    {
      free (label_align);
      label_align = 0;
    }

  max_labelno = max_label_num ();
  min_labelno = get_first_label_num ();
  label_align = (struct label_alignment *)
    xcalloc (max_labelno - min_labelno + 1, sizeof (struct label_alignment));

  /* If not optimizing or optimizing for size, don't assign any alignments.  */
  if (! optimize || optimize_size)
    return;

  for (i = 0; i < n_basic_blocks; i++)
    {
      basic_block bb = BASIC_BLOCK (i);
      rtx label = bb->head;
      int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;
      edge e;

      if (GET_CODE (label) != CODE_LABEL)
	continue;
      max_log = LABEL_ALIGN (label);
      max_skip = LABEL_ALIGN_MAX_SKIP;

      for (e = bb->pred; e; e = e->pred_next)
	{
	  if (e->flags & EDGE_FALLTHRU)
	    has_fallthru = 1, fallthru_frequency += EDGE_FREQUENCY (e);
	  else
	    branch_frequency += EDGE_FREQUENCY (e);
	}

      /* There are two purposes to align block with no fallthru incoming edge:
	 1) to avoid fetch stalls when branch destination is near cache boundary
	 2) to improve cache efficiency in case the previous block is not executed
	    (so it does not need to be in the cache).

	 We to catch first case, we align frequently executed blocks.
	 To catch the second, we align blocks that are executed more frequently
	 than the predecessor and the predecessor is likely to not be executed
	 when function is called.  */

      if (!has_fallthru
	  && (branch_frequency > BB_FREQ_MAX / 10
	      || (bb->frequency > BASIC_BLOCK (i - 1)->frequency * 10
		  && (BASIC_BLOCK (i - 1)->frequency
		      <= ENTRY_BLOCK_PTR->frequency / 2))))
	{
	  log = JUMP_ALIGN (label);
	  if (max_log < log)
	    {
	      max_log = log;
	      max_skip = JUMP_ALIGN_MAX_SKIP;
	    }
	}
      /* In case block is frequent and reached mostly by non-fallthru edge,
	 align it.  It is most likely an first block of loop.  */
      if (has_fallthru
	  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10
	  && branch_frequency > fallthru_frequency * 5)
	{
	  log = LOOP_ALIGN (label);
	  if (max_log < log)
	    {
	      max_log = log;
	      max_skip = LOOP_ALIGN_MAX_SKIP;
	    }
	}
      LABEL_TO_ALIGNMENT (label) = max_log;
      LABEL_TO_MAX_SKIP (label) = max_skip;
    }
}
