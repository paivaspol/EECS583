static int
requires_inout (p)
     const char *p;
{
  char c;
  int found_zero = 0;
  int reg_allowed = 0;
  int num_matching_alts = 0;

  while ((c = *p++))
    switch (c)
      {
      case '=':  case '+':  case '?':
      case '#':  case '&':  case '!':
      case '*':  case '%':
      case 'm':  case '<':  case '>':  case 'V':  case 'o':
      case 'E':  case 'F':  case 'G':  case 'H':
      case 's':  case 'i':  case 'n':
      case 'I':  case 'J':  case 'K':  case 'L':
      case 'M':  case 'N':  case 'O':  case 'P':
      case 'X':
	/* These don't say anything we care about.  */
	break;

      case ',':
	if (found_zero && ! reg_allowed)
	  num_matching_alts++;

	found_zero = reg_allowed = 0;
	break;

      case '0':
	found_zero = 1;
	break;

      case '1':  case '2':  case '3':  case '4': case '5':
      case '6':  case '7':  case '8':  case '9':
	/* Skip the balance of the matching constraint.  */
	while (ISDIGIT (*p))
	  p++;
	break;

      default:
	if (REG_CLASS_FROM_LETTER (c) == NO_REGS)
	  break;
	/* FALLTHRU */
      case 'p':
      case 'g': case 'r':
	reg_allowed = 1;
	break;
      }

  if (found_zero && ! reg_allowed)
    num_matching_alts++;

  return num_matching_alts;
}
