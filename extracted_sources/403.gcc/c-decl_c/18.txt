static int
duplicate_decls (newdecl, olddecl, different_binding_level)
     tree newdecl, olddecl;
     int different_binding_level;
{
  int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl));
  int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL
			   && DECL_INITIAL (newdecl) != 0);
  tree oldtype = TREE_TYPE (olddecl);
  tree newtype = TREE_TYPE (newdecl);
  int errmsg = 0;

  if (DECL_P (olddecl))
    {
      if (TREE_CODE (newdecl) == FUNCTION_DECL
	  && TREE_CODE (olddecl) == FUNCTION_DECL
	  && (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl)))
	{
	  if (DECL_DECLARED_INLINE_P (newdecl)
	      && DECL_UNINLINABLE (newdecl)
	      && lookup_attribute ("noinline", DECL_ATTRIBUTES (newdecl)))
	    /* Already warned elsewhere.  */;
	  else if (DECL_DECLARED_INLINE_P (olddecl)
		   && DECL_UNINLINABLE (olddecl)
		   && lookup_attribute ("noinline", DECL_ATTRIBUTES (olddecl)))
	    /* Already warned.  */;
	  else if (DECL_DECLARED_INLINE_P (newdecl)
		   && ! DECL_DECLARED_INLINE_P (olddecl)
		   && DECL_UNINLINABLE (olddecl)
		   && lookup_attribute ("noinline", DECL_ATTRIBUTES (olddecl)))
	    {
	      warning_with_decl (newdecl,
				 "function `%s' redeclared as inline");
	      warning_with_decl (olddecl,
				 "previous declaration of function `%s' with attribute noinline");
	    }
	  else if (DECL_DECLARED_INLINE_P (olddecl)
		   && DECL_UNINLINABLE (newdecl)
		   && lookup_attribute ("noinline", DECL_ATTRIBUTES (newdecl)))
	    {
	      warning_with_decl (newdecl,
				 "function `%s' redeclared with attribute noinline");
	      warning_with_decl (olddecl,
				 "previous declaration of function `%s' was inline");
	    }
	}

      DECL_ATTRIBUTES (newdecl)
	= (*targetm.merge_decl_attributes) (olddecl, newdecl);
    }

  if (TREE_CODE (newtype) == ERROR_MARK
      || TREE_CODE (oldtype) == ERROR_MARK)
    types_match = 0;

  /* New decl is completely inconsistent with the old one =>
     tell caller to replace the old one.
     This is always an error except in the case of shadowing a builtin.  */
  if (TREE_CODE (olddecl) != TREE_CODE (newdecl))
    {
      if (TREE_CODE (olddecl) == FUNCTION_DECL
	  && (DECL_BUILT_IN (olddecl)
	      || DECL_BUILT_IN_NONANSI (olddecl)))
	{
	  /* If you declare a built-in or predefined function name as static,
	     the old definition is overridden,
	     but optionally warn this was a bad choice of name.  */
	  if (!TREE_PUBLIC (newdecl))
	    {
	      if (!warn_shadow)
		;
	      else if (DECL_BUILT_IN (olddecl))
		warning_with_decl (newdecl, "shadowing built-in function `%s'");
	      else
		warning_with_decl (newdecl, "shadowing library function `%s'");
	    }
	  /* Likewise, if the built-in is not ansi, then programs can
	     override it even globally without an error.  */
	  else if (! DECL_BUILT_IN (olddecl))
	    warning_with_decl (newdecl,
			       "library function `%s' declared as non-function");

	  else if (DECL_BUILT_IN_NONANSI (olddecl))
	    warning_with_decl (newdecl,
			       "built-in function `%s' declared as non-function");
	  else
	    warning_with_decl (newdecl,
			       "built-in function `%s' declared as non-function");
	}
      else
	{
	  error_with_decl (newdecl, "`%s' redeclared as different kind of symbol");
	  error_with_decl (olddecl, "previous declaration of `%s'");
	}

      return 0;
    }

  /* For real parm decl following a forward decl,
     return 1 so old decl will be reused.  */
  if (types_match && TREE_CODE (newdecl) == PARM_DECL
      && TREE_ASM_WRITTEN (olddecl) && ! TREE_ASM_WRITTEN (newdecl))
    return 1;

  /* The new declaration is the same kind of object as the old one.
     The declarations may partially match.  Print warnings if they don't
     match enough.  Ultimately, copy most of the information from the new
     decl to the old one, and keep using the old one.  */

  if (flag_traditional && TREE_CODE (newdecl) == FUNCTION_DECL
      && IDENTIFIER_IMPLICIT_DECL (DECL_NAME (newdecl)) == olddecl
      && DECL_INITIAL (olddecl) == 0)
    /* If -traditional, avoid error for redeclaring fcn
       after implicit decl.  */
    ;
  else if (TREE_CODE (olddecl) == FUNCTION_DECL
	   && DECL_BUILT_IN (olddecl))
    {
      /* A function declaration for a built-in function.  */
      if (!TREE_PUBLIC (newdecl))
	{
	  /* If you declare a built-in function name as static, the
	     built-in definition is overridden,
	     but optionally warn this was a bad choice of name.  */
	  if (warn_shadow)
	    warning_with_decl (newdecl, "shadowing built-in function `%s'");
	  /* Discard the old built-in function.  */
	  return 0;
	}
      else if (!types_match)
	{
	  /* Accept the return type of the new declaration if same modes.  */
	  tree oldreturntype = TREE_TYPE (oldtype);
	  tree newreturntype = TREE_TYPE (newtype);

	  if (TYPE_MODE (oldreturntype) == TYPE_MODE (newreturntype))
	    {
	      /* Function types may be shared, so we can't just modify
		 the return type of olddecl's function type.  */
	      tree trytype
		= build_function_type (newreturntype,
				       TYPE_ARG_TYPES (oldtype));
	      trytype = build_type_attribute_variant (trytype,
						      TYPE_ATTRIBUTES (oldtype));

              types_match = comptypes (newtype, trytype);
	      if (types_match)
		oldtype = trytype;
	    }
	  /* Accept harmless mismatch in first argument type also.
	     This is for the ffs and fprintf builtins.  */
	  if (TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != 0
	      && TYPE_ARG_TYPES (oldtype) != 0
	      && TREE_VALUE (TYPE_ARG_TYPES (newtype)) != 0
	      && TREE_VALUE (TYPE_ARG_TYPES (oldtype)) != 0
	      && (TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (newtype)))
		  == TYPE_MODE (TREE_VALUE (TYPE_ARG_TYPES (oldtype)))))
	    {
	      /* Function types may be shared, so we can't just modify
		 the return type of olddecl's function type.  */
	      tree trytype
		= build_function_type (TREE_TYPE (oldtype),
				       tree_cons (NULL_TREE,
						  TREE_VALUE (TYPE_ARG_TYPES (newtype)),
						  TREE_CHAIN (TYPE_ARG_TYPES (oldtype))));
	      trytype = build_type_attribute_variant (trytype,
						      TYPE_ATTRIBUTES (oldtype));

	      types_match = comptypes (newtype, trytype);
	      if (types_match)
		oldtype = trytype;
	    }
	  if (! different_binding_level)
	    TREE_TYPE (olddecl) = oldtype;
	}
      else if (TYPE_ARG_TYPES (oldtype) == NULL
	       && TYPE_ARG_TYPES (newtype) != NULL)
	{
	  /* For bcmp, bzero, fputs the builtin type has arguments not
	     specified.  Use the ones from the prototype so that type checking
	     is done for them.  */
	  tree trytype
	    = build_function_type (TREE_TYPE (oldtype),
				   TYPE_ARG_TYPES (newtype));
	  trytype = build_type_attribute_variant (trytype,
						  TYPE_ATTRIBUTES (oldtype));

	  oldtype = trytype;
	  if (! different_binding_level)
	    TREE_TYPE (olddecl) = oldtype;
	}
      if (!types_match)
	{
	  /* If types don't match for a built-in, throw away the built-in.  */
	  warning_with_decl (newdecl, "conflicting types for built-in function `%s'");
	  return 0;
	}
    }
  else if (TREE_CODE (olddecl) == FUNCTION_DECL
	   && DECL_SOURCE_LINE (olddecl) == 0)
    {
      /* A function declaration for a predeclared function
	 that isn't actually built in.  */
      if (!TREE_PUBLIC (newdecl))
	{
	  /* If you declare it as static, the
	     default definition is overridden.  */
	  return 0;
	}
      else if (!types_match)
	{
	  /* If the types don't match, preserve volatility indication.
	     Later on, we will discard everything else about the
	     default declaration.  */
	  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);
	}
    }
  /* Permit char *foo () to match void *foo (...) if not pedantic,
     if one of them came from a system header file.  */
  else if (!types_match
	   && TREE_CODE (olddecl) == FUNCTION_DECL
	   && TREE_CODE (newdecl) == FUNCTION_DECL
	   && TREE_CODE (TREE_TYPE (oldtype)) == POINTER_TYPE
	   && TREE_CODE (TREE_TYPE (newtype)) == POINTER_TYPE
	   && (DECL_IN_SYSTEM_HEADER (olddecl)
	       || DECL_IN_SYSTEM_HEADER (newdecl))
	   && ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (newtype))) == void_type_node
		&& TYPE_ARG_TYPES (oldtype) == 0
		&& self_promoting_args_p (TYPE_ARG_TYPES (newtype))
		&& TREE_TYPE (TREE_TYPE (oldtype)) == char_type_node)
	       ||
	       (TREE_TYPE (TREE_TYPE (newtype)) == char_type_node
		&& TYPE_ARG_TYPES (newtype) == 0
		&& self_promoting_args_p (TYPE_ARG_TYPES (oldtype))
		&& TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)))
    {
      if (pedantic)
	pedwarn_with_decl (newdecl, "conflicting types for `%s'");
      /* Make sure we keep void * as ret type, not char *.  */
      if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)
	TREE_TYPE (newdecl) = newtype = oldtype;

      /* Set DECL_IN_SYSTEM_HEADER, so that if we see another declaration
	 we will come back here again.  */
      DECL_IN_SYSTEM_HEADER (newdecl) = 1;
    }
  else if (!types_match
	   /* Permit char *foo (int, ...); followed by char *foo ();
	      if not pedantic.  */
	   && ! (TREE_CODE (olddecl) == FUNCTION_DECL
		 && ! pedantic
		 /* Return types must still match.  */
		 && comptypes (TREE_TYPE (oldtype),
			       TREE_TYPE (newtype))
		 && TYPE_ARG_TYPES (newtype) == 0))
    {
      error_with_decl (newdecl, "conflicting types for `%s'");
      /* Check for function type mismatch
	 involving an empty arglist vs a nonempty one.  */
      if (TREE_CODE (olddecl) == FUNCTION_DECL
	  && comptypes (TREE_TYPE (oldtype),
			TREE_TYPE (newtype))
	  && ((TYPE_ARG_TYPES (oldtype) == 0
	       && DECL_INITIAL (olddecl) == 0)
	      ||
	      (TYPE_ARG_TYPES (newtype) == 0
	       && DECL_INITIAL (newdecl) == 0)))
	{
	  /* Classify the problem further.  */
	  tree t = TYPE_ARG_TYPES (oldtype);
	  if (t == 0)
	    t = TYPE_ARG_TYPES (newtype);
	  for (; t; t = TREE_CHAIN (t))
	    {
	      tree type = TREE_VALUE (t);

	      if (TREE_CHAIN (t) == 0
		  && TYPE_MAIN_VARIANT (type) != void_type_node)
		{
		  error ("a parameter list with an ellipsis can't match an empty parameter name list declaration");
		  break;
		}

	      if (simple_type_promotes_to (type) != NULL_TREE)
		{
		  error ("an argument type that has a default promotion can't match an empty parameter name list declaration");
		  break;
		}
	    }
	}
      error_with_decl (olddecl, "previous declaration of `%s'");
    }
  else
    {
      errmsg = redeclaration_error_message (newdecl, olddecl);
      if (errmsg)
	{
	  switch (errmsg)
	    {
	    case 1:
	      error_with_decl (newdecl, "redefinition of `%s'");
	      break;
	    case 2:
	      error_with_decl (newdecl, "redeclaration of `%s'");
	      break;
	    case 3:
	      error_with_decl (newdecl, "conflicting declarations of `%s'");
	      break;
	    default:
	      abort ();
	    }

	  error_with_decl (olddecl,
			   ((DECL_INITIAL (olddecl)
			     && current_binding_level == global_binding_level)
			    ? "`%s' previously defined here"
			    : "`%s' previously declared here"));
	  return 0;
	}
      else if (TREE_CODE (newdecl) == TYPE_DECL
               && (DECL_IN_SYSTEM_HEADER (olddecl)
                   || DECL_IN_SYSTEM_HEADER (newdecl)))
	{
	  warning_with_decl (newdecl, "redefinition of `%s'");
	  warning_with_decl
	    (olddecl,
	     ((DECL_INITIAL (olddecl)
	       && current_binding_level == global_binding_level)
	      ? "`%s' previously defined here"
	      : "`%s' previously declared here"));
	}
      else if (TREE_CODE (olddecl) == FUNCTION_DECL
	       && DECL_INITIAL (olddecl) != 0
	       && TYPE_ARG_TYPES (oldtype) == 0
	       && TYPE_ARG_TYPES (newtype) != 0
	       && TYPE_ACTUAL_ARG_TYPES (oldtype) != 0)
	{
	  tree type, parm;
	  int nargs;
	  /* Prototype decl follows defn w/o prototype.  */

	  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),
	       type = TYPE_ARG_TYPES (newtype),
	       nargs = 1;
	       ;
	       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type), nargs++)
	    {
	      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node
		  && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)
		{
		  warning_with_decl (newdecl, "prototype for `%s' follows");
		  warning_with_decl (olddecl, "non-prototype definition here");
		  break;
		}
	      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node
		  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)
		{
		  error_with_decl (newdecl,
				   "prototype for `%s' follows and number of arguments doesn't match");
		  error_with_decl (olddecl, "non-prototype definition here");
		  errmsg = 1;
		  break;
		}
	      /* Type for passing arg must be consistent
		 with that declared for the arg.  */
	      if (! comptypes (TREE_VALUE (parm), TREE_VALUE (type))
		  /* If -traditional, allow `unsigned int' instead of `int'
		     in the prototype.  */
		  && (! (flag_traditional
			 && TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == integer_type_node
			 && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == unsigned_type_node)))
		{
		  error_with_decl (newdecl,
				   "prototype for `%s' follows and argument %d doesn't match",
				   nargs);
		  error_with_decl (olddecl, "non-prototype definition here");
		  errmsg = 1;
		  break;
		}
	    }
	}
      /* Warn about mismatches in various flags.  */
      else
	{
	  /* Warn if function is now inline
	     but was previously declared not inline and has been called.  */
	  if (TREE_CODE (olddecl) == FUNCTION_DECL
	      && ! DECL_DECLARED_INLINE_P (olddecl)
	      && DECL_DECLARED_INLINE_P (newdecl)
	      && TREE_USED (olddecl))
	    warning_with_decl (newdecl,
			       "`%s' declared inline after being called");
	  if (TREE_CODE (olddecl) == FUNCTION_DECL
	      && ! DECL_DECLARED_INLINE_P (olddecl)
	      && DECL_DECLARED_INLINE_P (newdecl)
	      && DECL_INITIAL (olddecl) != 0)
	    warning_with_decl (newdecl,
			       "`%s' declared inline after its definition");

	  /* If pedantic, warn when static declaration follows a non-static
	     declaration.  Otherwise, do so only for functions.  */
	  if ((pedantic || TREE_CODE (olddecl) == FUNCTION_DECL)
	      && TREE_PUBLIC (olddecl)
	      && !TREE_PUBLIC (newdecl))
	    warning_with_decl (newdecl, "static declaration for `%s' follows non-static");

	  /* If warn_traditional, warn when a non-static function
	     declaration follows a static one.  */
	  if (warn_traditional && !in_system_header
	      && TREE_CODE (olddecl) == FUNCTION_DECL
	      && !TREE_PUBLIC (olddecl)
	      && TREE_PUBLIC (newdecl))
	    warning_with_decl (newdecl, "non-static declaration for `%s' follows static");

	  /* Warn when const declaration follows a non-const
	     declaration, but not for functions.  */
	  if (TREE_CODE (olddecl) != FUNCTION_DECL
	      && !TREE_READONLY (olddecl)
	      && TREE_READONLY (newdecl))
	    warning_with_decl (newdecl, "const declaration for `%s' follows non-const");
	  /* These bits are logically part of the type, for variables.
	     But not for functions
	     (where qualifiers are not valid ANSI anyway).  */
	  else if (pedantic && TREE_CODE (olddecl) != FUNCTION_DECL
	      && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)
		  || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))
	    pedwarn_with_decl (newdecl, "type qualifiers for `%s' conflict with previous decl");
	}
    }

  /* Optionally warn about more than one declaration for the same name.  */
  if (errmsg == 0 && warn_redundant_decls && DECL_SOURCE_LINE (olddecl) != 0
      /* Don't warn about a function declaration
	 followed by a definition.  */
      && !(TREE_CODE (newdecl) == FUNCTION_DECL && DECL_INITIAL (newdecl) != 0
	   && DECL_INITIAL (olddecl) == 0)
      /* Don't warn about extern decl followed by (tentative) definition.  */
      && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl)))
    {
      warning_with_decl (newdecl, "redundant redeclaration of `%s' in same scope");
      warning_with_decl (olddecl, "previous declaration of `%s'");
    }

  /* Copy all the DECL_... slots specified in the new decl
     except for any that we copy here from the old type.

     Past this point, we don't change OLDTYPE and NEWTYPE
     even if we change the types of NEWDECL and OLDDECL.  */

  if (types_match)
    {
      /* When copying info to olddecl, we store into write_olddecl
	 instead.  This allows us to avoid modifying olddecl when
	 different_binding_level is true.  */
      tree write_olddecl = different_binding_level ? newdecl : olddecl;

      /* Merge the data types specified in the two decls.  */
      if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))
	{
	  if (different_binding_level)
	    {
	      if (TYPE_ARG_TYPES (oldtype) != 0
		  && TYPE_ARG_TYPES (newtype) == 0)
		TREE_TYPE (newdecl) = common_type (newtype, oldtype);
	      else
		TREE_TYPE (newdecl)
		  = build_type_attribute_variant
		    (newtype,
		     merge_attributes (TYPE_ATTRIBUTES (newtype),
				       TYPE_ATTRIBUTES (oldtype)));
	    }
	  else
	    TREE_TYPE (newdecl)
	      = TREE_TYPE (olddecl)
		= common_type (newtype, oldtype);
	}

      /* Lay the type out, unless already done.  */
      if (oldtype != TREE_TYPE (newdecl))
	{
	  if (TREE_TYPE (newdecl) != error_mark_node)
	    layout_type (TREE_TYPE (newdecl));
	  if (TREE_CODE (newdecl) != FUNCTION_DECL
	      && TREE_CODE (newdecl) != TYPE_DECL
	      && TREE_CODE (newdecl) != CONST_DECL)
	    layout_decl (newdecl, 0);
	}
      else
	{
	  /* Since the type is OLDDECL's, make OLDDECL's size go with.  */
	  DECL_SIZE (newdecl) = DECL_SIZE (olddecl);
	  DECL_SIZE_UNIT (newdecl) = DECL_SIZE_UNIT (olddecl);
	  DECL_MODE (newdecl) = DECL_MODE (olddecl);
	  if (TREE_CODE (olddecl) != FUNCTION_DECL)
	    if (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))
	      {
		DECL_ALIGN (newdecl) = DECL_ALIGN (olddecl);
		DECL_USER_ALIGN (newdecl) |= DECL_ALIGN (olddecl);
	      }
	}

      /* Keep the old rtl since we can safely use it.  */
      COPY_DECL_RTL (olddecl, newdecl);

      /* Merge the type qualifiers.  */
      if (TREE_CODE (olddecl) == FUNCTION_DECL
	  && DECL_BUILT_IN_NONANSI (olddecl) && TREE_THIS_VOLATILE (olddecl)
	  && ! TREE_THIS_VOLATILE (newdecl))
	TREE_THIS_VOLATILE (write_olddecl) = 0;

      if (TREE_READONLY (newdecl))
	TREE_READONLY (write_olddecl) = 1;

      if (TREE_THIS_VOLATILE (newdecl))
	{
	  TREE_THIS_VOLATILE (write_olddecl) = 1;
	  if (TREE_CODE (newdecl) == VAR_DECL
	      /* If an automatic variable is re-declared in the same
		 function scope, but the old declaration was not
		 volatile, make_var_volatile() would crash because the
		 variable would have been assigned to a pseudo, not a
		 MEM.  Since this duplicate declaration is invalid
		 anyway, we just skip the call.  */
	      && errmsg == 0)
	    make_var_volatile (newdecl);
	}

      /* Keep source location of definition rather than declaration.  */
      /* When called with different_binding_level set, keep the old
	 information so that meaningful diagnostics can be given.  */
      if (DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0
	  && ! different_binding_level)
	{
	  DECL_SOURCE_LINE (newdecl) = DECL_SOURCE_LINE (olddecl);
	  DECL_SOURCE_FILE (newdecl) = DECL_SOURCE_FILE (olddecl);
	}

      /* Merge the unused-warning information.  */
      if (DECL_IN_SYSTEM_HEADER (olddecl))
	DECL_IN_SYSTEM_HEADER (newdecl) = 1;
      else if (DECL_IN_SYSTEM_HEADER (newdecl))
	DECL_IN_SYSTEM_HEADER (write_olddecl) = 1;

      /* Merge the initialization information.  */
      /* When called with different_binding_level set, don't copy over
	 DECL_INITIAL, so that we don't accidentally change function
	 declarations into function definitions.  */
      if (DECL_INITIAL (newdecl) == 0 && ! different_binding_level)
	DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);

      /* Merge the section attribute.
         We want to issue an error if the sections conflict but that must be
	 done later in decl_attributes since we are called before attributes
	 are assigned.  */
      if (DECL_SECTION_NAME (newdecl) == NULL_TREE)
	DECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);

      /* Copy the assembler name.
	 Currently, it can only be defined in the prototype.  */
      COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);

      if (TREE_CODE (newdecl) == FUNCTION_DECL)
	{
	  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);
	  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);
	  DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);
	  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)
	    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);
	}
    }
  /* If cannot merge, then use the new type and qualifiers,
     and don't preserve the old rtl.  */
  else if (! different_binding_level)
    {
      TREE_TYPE (olddecl) = TREE_TYPE (newdecl);
      TREE_READONLY (olddecl) = TREE_READONLY (newdecl);
      TREE_THIS_VOLATILE (olddecl) = TREE_THIS_VOLATILE (newdecl);
      TREE_SIDE_EFFECTS (olddecl) = TREE_SIDE_EFFECTS (newdecl);
    }

  /* Merge the storage class information.  */
  merge_weak (newdecl, olddecl);

  /* For functions, static overrides non-static.  */
  if (TREE_CODE (newdecl) == FUNCTION_DECL)
    {
      TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);
      /* This is since we don't automatically
	 copy the attributes of NEWDECL into OLDDECL.  */
      /* No need to worry about different_binding_level here because
	 then TREE_PUBLIC (newdecl) was true.  */
      TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);
      /* If this clears `static', clear it in the identifier too.  */
      if (! TREE_PUBLIC (olddecl))
	TREE_PUBLIC (DECL_NAME (olddecl)) = 0;
    }
  if (DECL_EXTERNAL (newdecl))
    {
      if (! different_binding_level)
	{
	  /* Don't mess with these flags on local externs; they remain
	     external even if there's a declaration at file scope which
	     isn't.  */
	  TREE_STATIC (newdecl) = TREE_STATIC (olddecl);
	  DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);
	}
      /* An extern decl does not override previous storage class.  */
      TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);
      if (! DECL_EXTERNAL (newdecl))
	DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);
    }
  else
    {
      TREE_STATIC (olddecl) = TREE_STATIC (newdecl);
      TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);
    }

  if (TREE_CODE (newdecl) == FUNCTION_DECL)
    {
      /* If we're redefining a function previously defined as extern
	 inline, make sure we emit debug info for the inline before we
	 throw it away, in case it was inlined into a function that hasn't
	 been written out yet.  */
      if (new_is_definition && DECL_INITIAL (olddecl) && TREE_USED (olddecl))
	{
	  (*debug_hooks->outlining_inline_function) (olddecl);

	  /* The new defn must not be inline.  */
	  DECL_INLINE (newdecl) = 0;
	  DECL_UNINLINABLE (newdecl) = 1;
	}
      else
	{
	  /* If either decl says `inline', this fn is inline,
	     unless its definition was passed already.  */
	  if (DECL_DECLARED_INLINE_P (newdecl)
	      || DECL_DECLARED_INLINE_P (olddecl))
	    DECL_DECLARED_INLINE_P (newdecl) = 1;

	  DECL_UNINLINABLE (newdecl) = DECL_UNINLINABLE (olddecl)
	    = (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl));
	}

      if (DECL_BUILT_IN (olddecl))
	{
	  /* Get rid of any built-in function if new arg types don't match it
	     or if we have a function definition.  */
	  if (! types_match || new_is_definition)
	    {
	      if (! different_binding_level)
		{
		  TREE_TYPE (olddecl) = TREE_TYPE (newdecl);
		  DECL_BUILT_IN_CLASS (olddecl) = NOT_BUILT_IN;
		}
	    }
	  else
	    {
	      /* If redeclaring a builtin function, and not a definition,
		 it stays built in.  */
	      DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);
	      DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);
	    }
	}

      /* Also preserve various other info from the definition.  */
      if (! new_is_definition)
	{
	  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);
	  /* When called with different_binding_level set, don't copy over
	     DECL_INITIAL, so that we don't accidentally change function
	     declarations into function definitions.  */
	  if (! different_binding_level)
	    DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);
	  DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl);
	  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);
	  DECL_NUM_STMTS (newdecl) = DECL_NUM_STMTS (olddecl);
	  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);

	  /* Set DECL_INLINE on the declaration if we've got a body
	     from which to instantiate.  */
	  if (DECL_INLINE (olddecl) && ! DECL_UNINLINABLE (newdecl))
	    {
	      DECL_INLINE (newdecl) = 1;
	      DECL_ABSTRACT_ORIGIN (newdecl)
		= (different_binding_level
		   ? DECL_ORIGIN (olddecl)
		   : DECL_ABSTRACT_ORIGIN (olddecl));
	    }
	}
      else
	{
	  /* If a previous declaration said inline, mark the
	     definition as inlinable.  */
	  if (DECL_DECLARED_INLINE_P (newdecl)
	      && ! DECL_UNINLINABLE (newdecl))
	    DECL_INLINE (newdecl) = 1;
	}
    }
  if (different_binding_level)
    return 0;

  /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.
     But preserve OLDDECL's DECL_UID.  */
  {
    unsigned olddecl_uid = DECL_UID (olddecl);

    memcpy ((char *) olddecl + sizeof (struct tree_common),
	    (char *) newdecl + sizeof (struct tree_common),
	    sizeof (struct tree_decl) - sizeof (struct tree_common));
    DECL_UID (olddecl) = olddecl_uid;
  }

  /* NEWDECL contains the merged attribute lists.
     Update OLDDECL to be the same.  */
  DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);

  return 1;
}
