static void
exact_real_inverse_1 (p)
     PTR p;
{
  struct exact_real_inverse_args *args =
    (struct exact_real_inverse_args *) p;

  enum machine_mode mode = args->mode;
  REAL_VALUE_TYPE *r = args->r;

  union
  {
    double d;
    unsigned short i[4];
  }
  x, t, y;
#ifdef CHECK_FLOAT_VALUE
  int i;
#endif

  /* Set array index to the less significant bits in the unions, depending
     on the endian-ness of the host doubles.  */
#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT \
 || HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT
# define K 2
#else
# define K (2 * HOST_FLOAT_WORDS_BIG_ENDIAN)
#endif

  /* Domain check the argument.  */
  x.d = *r;
  if (x.d == 0.0)
    goto fail;

#ifdef REAL_INFINITY
  if (REAL_VALUE_ISINF (x.d) || REAL_VALUE_ISNAN (x.d))
    goto fail;
#endif

  /* Compute the reciprocal and check for numerical exactness.
     It is unnecessary to check all the significand bits to determine
     whether X is a power of 2.  If X is not, then it is impossible for
     the bottom half significand of both X and 1/X to be all zero bits.
     Hence we ignore the data structure of the top half and examine only
     the low order bits of the two significands.  */
  t.d = 1.0 / x.d;
  if (x.i[K] != 0 || x.i[K + 1] != 0 || t.i[K] != 0 || t.i[K + 1] != 0)
    goto fail;

  /* Truncate to the required mode and range-check the result.  */
  y.d = REAL_VALUE_TRUNCATE (mode, t.d);
#ifdef CHECK_FLOAT_VALUE
  i = 0;
  if (CHECK_FLOAT_VALUE (mode, y.d, i))
    goto fail;
#endif

  /* Fail if truncation changed the value.  */
  if (y.d != t.d || y.d == 0.0)
    goto fail;

#ifdef REAL_INFINITY
  if (REAL_VALUE_ISINF (y.d) || REAL_VALUE_ISNAN (y.d))
    goto fail;
#endif

  /* Output the reciprocal and return success flag.  */
  *r = y.d;
  args->success = 1;
  return;

 fail:
  args->success = 0;
  return;

#undef K
}
