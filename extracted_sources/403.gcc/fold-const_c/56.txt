static tree
fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)
     enum tree_code code;
     tree type;
     tree cond;
     tree arg;
     int cond_first_p;
{
  tree test, true_value, false_value;
  tree lhs = NULL_TREE;
  tree rhs = NULL_TREE;
  /* In the end, we'll produce a COND_EXPR.  Both arms of the
     conditional expression will be binary operations.  The left-hand
     side of the expression to be executed if the condition is true
     will be pointed to by TRUE_LHS.  Similarly, the right-hand side
     of the expression to be executed if the condition is true will be
     pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analogous --
     but apply to the expression to be executed if the conditional is
     false.  */
  tree *true_lhs;
  tree *true_rhs;
  tree *false_lhs;
  tree *false_rhs;
  /* These are the codes to use for the left-hand side and right-hand
     side of the COND_EXPR.  Normally, they are the same as CODE.  */
  enum tree_code lhs_code = code;
  enum tree_code rhs_code = code;
  /* And these are the types of the expressions.  */
  tree lhs_type = type;
  tree rhs_type = type;

  if (cond_first_p)
    {
      true_rhs = false_rhs = &arg;
      true_lhs = &true_value;
      false_lhs = &false_value;
    }
  else
    {
      true_lhs = false_lhs = &arg;
      true_rhs = &true_value;
      false_rhs = &false_value;
    }

  if (TREE_CODE (cond) == COND_EXPR)
    {
      test = TREE_OPERAND (cond, 0);
      true_value = TREE_OPERAND (cond, 1);
      false_value = TREE_OPERAND (cond, 2);
      /* If this operand throws an expression, then it does not make
	 sense to try to perform a logical or arithmetic operation
	 involving it.  Instead of building `a + throw 3' for example,
	 we simply build `a, throw 3'.  */
      if (VOID_TYPE_P (TREE_TYPE (true_value)))
	{
	  lhs_code = COMPOUND_EXPR;
	  if (!cond_first_p)
	    lhs_type = void_type_node;
	}
      if (VOID_TYPE_P (TREE_TYPE (false_value)))
	{
	  rhs_code = COMPOUND_EXPR;
	  if (!cond_first_p)
	    rhs_type = void_type_node;
	}
    }
  else
    {
      tree testtype = TREE_TYPE (cond);
      test = cond;
      true_value = convert (testtype, integer_one_node);
      false_value = convert (testtype, integer_zero_node);
    }
  
  /* If ARG is complex we want to make sure we only evaluate
     it once.  Though this is only required if it is volatile, it
     might be more efficient even if it is not.  However, if we
     succeed in folding one part to a constant, we do not need
     to make this SAVE_EXPR.  Since we do this optimization
     primarily to see if we do end up with constant and this
     SAVE_EXPR interferes with later optimizations, suppressing
     it when we can is important.
     
     If we are not in a function, we can't make a SAVE_EXPR, so don't
     try to do so.  Don't try to see if the result is a constant
     if an arm is a COND_EXPR since we get exponential behavior
     in that case.  */
  
  if (TREE_CODE (arg) != SAVE_EXPR && ! TREE_CONSTANT (arg)
      && global_bindings_p () == 0
      && ((TREE_CODE (arg) != VAR_DECL
	   && TREE_CODE (arg) != PARM_DECL)
	  || TREE_SIDE_EFFECTS (arg)))
    {
      if (TREE_CODE (true_value) != COND_EXPR)
	lhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));
      
      if (TREE_CODE (false_value) != COND_EXPR)
	rhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));
      
      if ((lhs == 0 || ! TREE_CONSTANT (lhs))
	  && (rhs == 0 || !TREE_CONSTANT (rhs)))
	arg = save_expr (arg), lhs = rhs = 0;
    }
  
  if (lhs == 0)
    lhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));
  if (rhs == 0)
    rhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));
  
  test = fold (build (COND_EXPR, type, test, lhs, rhs));
  
  if (TREE_CODE (arg) == SAVE_EXPR)
    return build (COMPOUND_EXPR, type,
		  convert (void_type_node, arg),
		  strip_compound_expr (test, arg));
  else
    return convert (type, test);
}
