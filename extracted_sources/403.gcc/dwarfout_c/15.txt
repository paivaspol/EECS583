static int
fundamental_type_code (type)
     tree type;
{
  if (TREE_CODE (type) == ERROR_MARK)
    return 0;

  switch (TREE_CODE (type))
    {
      case ERROR_MARK:
	return FT_void;

      case VOID_TYPE:
	return FT_void;

      case INTEGER_TYPE:
	/* Carefully distinguish all the standard types of C,
	   without messing up if the language is not C.
	   Note that we check only for the names that contain spaces;
	   other names might occur by coincidence in other languages.  */
	if (TYPE_NAME (type) != 0
	    && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
	    && DECL_NAME (TYPE_NAME (type)) != 0
	    && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)
	  {
	    const char *const name =
	      IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));

	    if (!strcmp (name, "unsigned char"))
	      return FT_unsigned_char;
	    if (!strcmp (name, "signed char"))
	      return FT_signed_char;
	    if (!strcmp (name, "unsigned int"))
	      return FT_unsigned_integer;
	    if (!strcmp (name, "short int"))
	      return FT_short;
	    if (!strcmp (name, "short unsigned int"))
	      return FT_unsigned_short;
	    if (!strcmp (name, "long int"))
	      return FT_long;
	    if (!strcmp (name, "long unsigned int"))
	      return FT_unsigned_long;
	    if (!strcmp (name, "long long int"))
	      return FT_long_long;		/* Not grok'ed by svr4 SDB */
	    if (!strcmp (name, "long long unsigned int"))
	      return FT_unsigned_long_long;	/* Not grok'ed by svr4 SDB */
	  }

	/* Most integer types will be sorted out above, however, for the
	   sake of special `array index' integer types, the following code
	   is also provided.  */

	if (TYPE_PRECISION (type) == INT_TYPE_SIZE)
	  return (TREE_UNSIGNED (type) ? FT_unsigned_integer : FT_integer);

	if (TYPE_PRECISION (type) == LONG_TYPE_SIZE)
	  return (TREE_UNSIGNED (type) ? FT_unsigned_long : FT_long);

	if (TYPE_PRECISION (type) == LONG_LONG_TYPE_SIZE)
	  return (TREE_UNSIGNED (type) ? FT_unsigned_long_long : FT_long_long);

	if (TYPE_PRECISION (type) == SHORT_TYPE_SIZE)
	  return (TREE_UNSIGNED (type) ? FT_unsigned_short : FT_short);

	if (TYPE_PRECISION (type) == CHAR_TYPE_SIZE)
	  return (TREE_UNSIGNED (type) ? FT_unsigned_char : FT_char);

	if (TYPE_MODE (type) == TImode)
	  return (TREE_UNSIGNED (type) ? FT_unsigned_int128 : FT_int128);

	/* In C++, __java_boolean is an INTEGER_TYPE with precision == 1 */
	if (TYPE_PRECISION (type) == 1)
	  return FT_boolean;

	abort ();

      case REAL_TYPE:
	/* Carefully distinguish all the standard types of C,
	   without messing up if the language is not C.  */
	if (TYPE_NAME (type) != 0
	    && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
	    && DECL_NAME (TYPE_NAME (type)) != 0
	    && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)
	  {
	    const char *const name =
	      IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));

	    /* Note that here we can run afoul of a serious bug in "classic"
	       svr4 SDB debuggers.  They don't seem to understand the
	       FT_ext_prec_float type (even though they should).  */

	    if (!strcmp (name, "long double"))
	      return FT_ext_prec_float;
	  }

	if (TYPE_PRECISION (type) == DOUBLE_TYPE_SIZE)
	  {
	    /* On the SH, when compiling with -m3e or -m4-single-only, both
	       float and double are 32 bits.  But since the debugger doesn't
	       know about the subtarget, it always thinks double is 64 bits.
	       So we have to tell the debugger that the type is float to
	       make the output of the 'print' command etc. readable.  */
	    if (DOUBLE_TYPE_SIZE == FLOAT_TYPE_SIZE && FLOAT_TYPE_SIZE == 32)
	      return FT_float;
	    return FT_dbl_prec_float;
	  }
	if (TYPE_PRECISION (type) == FLOAT_TYPE_SIZE)
	  return FT_float;

	/* Note that here we can run afoul of a serious bug in "classic"
	   svr4 SDB debuggers.  They don't seem to understand the
	   FT_ext_prec_float type (even though they should).  */

	if (TYPE_PRECISION (type) == LONG_DOUBLE_TYPE_SIZE)
	  return FT_ext_prec_float;
	abort ();

      case COMPLEX_TYPE:
	return FT_complex;	/* GNU FORTRAN COMPLEX type.  */

      case CHAR_TYPE:
	return FT_char;		/* GNU Pascal CHAR type.  Not used in C.  */

      case BOOLEAN_TYPE:
	return FT_boolean;	/* GNU FORTRAN BOOLEAN type.  */

      default:
	abort ();	/* No other TREE_CODEs are Dwarf fundamental types.  */
    }
  return 0;
}
