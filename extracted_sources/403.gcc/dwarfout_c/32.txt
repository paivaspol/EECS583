static HOST_WIDE_INT
field_byte_offset (decl)
     tree decl;
{
  unsigned int type_align_in_bytes;
  unsigned int type_align_in_bits;
  unsigned HOST_WIDE_INT type_size_in_bits;
  HOST_WIDE_INT object_offset_in_align_units;
  HOST_WIDE_INT object_offset_in_bits;
  HOST_WIDE_INT object_offset_in_bytes;
  tree type;
  tree field_size_tree;
  HOST_WIDE_INT bitpos_int;
  HOST_WIDE_INT deepest_bitpos;
  unsigned HOST_WIDE_INT field_size_in_bits;

  if (TREE_CODE (decl) == ERROR_MARK)
    return 0;

  if (TREE_CODE (decl) != FIELD_DECL)
    abort ();

  type = field_type (decl);
  field_size_tree = DECL_SIZE (decl);

  /* The size could be unspecified if there was an error, or for
     a flexible array member.  */
  if (! field_size_tree)
    field_size_tree = bitsize_zero_node;

  /* We cannot yet cope with fields whose positions or sizes are variable,
     so for now, when we see such things, we simply return 0.  Someday,
     we may be able to handle such cases, but it will be damn difficult.  */

  if (! host_integerp (bit_position (decl), 0)
      || ! host_integerp (field_size_tree, 1))
    return 0;

  bitpos_int = int_bit_position (decl);
  field_size_in_bits = tree_low_cst (field_size_tree, 1);

  type_size_in_bits = simple_type_size_in_bits (type);
  type_align_in_bits = simple_type_align_in_bits (type);
  type_align_in_bytes = type_align_in_bits / BITS_PER_UNIT;

  /* Note that the GCC front-end doesn't make any attempt to keep track
     of the starting bit offset (relative to the start of the containing
     structure type) of the hypothetical "containing object" for a bit-
     field.  Thus, when computing the byte offset value for the start of
     the "containing object" of a bit-field, we must deduce this infor-
     mation on our own.

     This can be rather tricky to do in some cases.  For example, handling
     the following structure type definition when compiling for an i386/i486
     target (which only aligns long long's to 32-bit boundaries) can be very
     tricky:

		struct S {
			int		field1;
			long long	field2:31;
		};

     Fortunately, there is a simple rule-of-thumb which can be used in such
     cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for
     the structure shown above.  It decides to do this based upon one simple
     rule for bit-field allocation.  Quite simply, GCC allocates each "con-
     taining object" for each bit-field at the first (i.e. lowest addressed)
     legitimate alignment boundary (based upon the required minimum alignment
     for the declared type of the field) which it can possibly use, subject
     to the condition that there is still enough available space remaining
     in the containing object (when allocated at the selected point) to
     fully accommodate all of the bits of the bit-field itself.

     This simple rule makes it obvious why GCC allocates 8 bytes for each
     object of the structure type shown above.  When looking for a place to
     allocate the "containing object" for `field2', the compiler simply tries
     to allocate a 64-bit "containing object" at each successive 32-bit
     boundary (starting at zero) until it finds a place to allocate that 64-
     bit field such that at least 31 contiguous (and previously unallocated)
     bits remain within that selected 64 bit field.  (As it turns out, for
     the example above, the compiler finds that it is OK to allocate the
     "containing object" 64-bit field at bit-offset zero within the
     structure type.)

     Here we attempt to work backwards from the limited set of facts we're
     given, and we try to deduce from those facts, where GCC must have
     believed that the containing object started (within the structure type).

     The value we deduce is then used (by the callers of this routine) to
     generate AT_location and AT_bit_offset attributes for fields (both
     bit-fields and, in the case of AT_location, regular fields as well).  */

  /* Figure out the bit-distance from the start of the structure to the
     "deepest" bit of the bit-field.  */
  deepest_bitpos = bitpos_int + field_size_in_bits;

  /* This is the tricky part.  Use some fancy footwork to deduce where the
     lowest addressed bit of the containing object must be.  */
  object_offset_in_bits
    = ceiling (deepest_bitpos, type_align_in_bits) - type_size_in_bits;

  /* Compute the offset of the containing object in "alignment units".  */
  object_offset_in_align_units = object_offset_in_bits / type_align_in_bits;

  /* Compute the offset of the containing object in bytes.  */
  object_offset_in_bytes = object_offset_in_align_units * type_align_in_bytes;

  /* The above code assumes that the field does not cross an alignment
     boundary.  This can happen if PCC_BITFIELD_TYPE_MATTERS is not defined,
     or if the structure is packed.  If this happens, then we get an object
     which starts after the bitfield, which means that the bit offset is
     negative.  Gdb fails when given negative bit offsets.  We avoid this
     by recomputing using the first bit of the bitfield.  This will give
     us an object which does not completely contain the bitfield, but it
     will be aligned, and it will contain the first bit of the bitfield.

     However, only do this for a BYTES_BIG_ENDIAN target.  For a
     ! BYTES_BIG_ENDIAN target, bitpos_int + field_size_in_bits is the first
     first bit of the bitfield.  If we recompute using bitpos_int + 1 below,
     then we end up computing the object byte offset for the wrong word of the
     desired bitfield, which in turn causes the field offset to be negative
     in bit_offset_attribute.  */
  if (BYTES_BIG_ENDIAN
      && object_offset_in_bits > bitpos_int)
    {
      deepest_bitpos = bitpos_int + 1;
      object_offset_in_bits
	= ceiling (deepest_bitpos, type_align_in_bits) - type_size_in_bits;
      object_offset_in_align_units = (object_offset_in_bits
				      / type_align_in_bits);
      object_offset_in_bytes = (object_offset_in_align_units
				* type_align_in_bytes);
    }

  return object_offset_in_bytes;
}
