static void
type_attribute (type, decl_const, decl_volatile)
     tree type;
     int decl_const;
     int decl_volatile;
{
  enum tree_code code = TREE_CODE (type);
  int root_type_modified;

  if (code == ERROR_MARK)
    return;

  /* Handle a special case.  For functions whose return type is void,
     we generate *no* type attribute.  (Note that no object may have
     type `void', so this only applies to function return types.  */

  if (code == VOID_TYPE)
    return;

  /* If this is a subtype, find the underlying type.  Eventually,
     this should write out the appropriate subtype info.  */
  while ((code == INTEGER_TYPE || code == REAL_TYPE)
	 && TREE_TYPE (type) != 0)
    type = TREE_TYPE (type), code = TREE_CODE (type);

  root_type_modified = (code == POINTER_TYPE || code == REFERENCE_TYPE
			|| decl_const || decl_volatile
			|| TYPE_READONLY (type) || TYPE_VOLATILE (type));

  if (type_is_fundamental (root_type (type)))
    {
      if (root_type_modified)
	mod_fund_type_attribute (type, decl_const, decl_volatile);
      else
	fund_type_attribute (fundamental_type_code (type));
    }
  else
    {
      if (root_type_modified)
	mod_u_d_type_attribute (type, decl_const, decl_volatile);
      else
	/* We have to get the type_main_variant here (and pass that to the
	   `user_def_type_attribute' routine) because the ..._TYPE node we
	   have might simply be a *copy* of some original type node (where
	   the copy was created to help us keep track of typedef names)
	   and that copy might have a different TYPE_UID from the original
	   ..._TYPE node.  (Note that when `equate_type_number_to_die_number'
	   is labeling a given type DIE for future reference, it always and
	   only creates labels for DIEs representing *main variants*, and it
	   never even knows about non-main-variants.)  */
	user_def_type_attribute (type_main_variant (type));
    }
}
