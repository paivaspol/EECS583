static int
convert_regs_1 (file, block)
     FILE *file;
     basic_block block;
{
  struct stack_def regstack;
  block_info bi = BLOCK_INFO (block);
  int inserted, reg;
  rtx insn, next;
  edge e, beste = NULL;

  inserted = 0;

  /* Find the edge we will copy stack from.  It should be the most frequent
     one as it will get cheapest after compensation code is generated,
     if multiple such exists, take one with largest count, prefer critical
     one (as splitting critical edges is more expensive), or one with lowest
     index, to avoid random changes with different orders of the edges.  */
  for (e = block->pred; e ; e = e->pred_next)
    {
      if (e->flags & EDGE_DFS_BACK)
	;
      else if (! beste)
	beste = e;
      else if (EDGE_FREQUENCY (beste) < EDGE_FREQUENCY (e))
	beste = e;
      else if (EDGE_FREQUENCY (beste) > EDGE_FREQUENCY (e))
	;
      else if (beste->count < e->count)
	beste = e;
      else if (beste->count > e->count)
	;
      else if ((EDGE_CRITICAL_P (e) != 0)
	       != (EDGE_CRITICAL_P (beste) != 0))
	{
	  if (EDGE_CRITICAL_P (e))
	    beste = e;
	}
      else if (e->src->index < beste->src->index)
	beste = e;
    }

  /* Entry block does have stack already initialized.  */
  if (bi->stack_in.top == -2)
    inserted |= compensate_edge (beste, file);
  else
    beste = NULL;
  
  current_block = block;

  if (file)
    {
      fprintf (file, "\nBasic block %d\nInput stack: ", block->index);
      print_stack (file, &bi->stack_in);
    }

  /* Process all insns in this block.  Keep track of NEXT so that we
     don't process insns emitted while substituting in INSN.  */
  next = block->head;
  regstack = bi->stack_in;
  do
    {
      insn = next;
      next = NEXT_INSN (insn);

      /* Ensure we have not missed a block boundary.  */
      if (next == NULL)
	abort ();
      if (insn == block->end)
	next = NULL;

      /* Don't bother processing unless there is a stack reg
	 mentioned or if it's a CALL_INSN.  */
      if (stack_regs_mentioned (insn)
	  || GET_CODE (insn) == CALL_INSN)
	{
	  if (file)
	    {
	      fprintf (file, "  insn %d input stack: ",
		       INSN_UID (insn));
	      print_stack (file, &regstack);
	    }
	  subst_stack_regs (insn, &regstack);
	}
    }
  while (next);

  if (file)
    {
      fprintf (file, "Expected live registers [");
      for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; ++reg)
	if (TEST_HARD_REG_BIT (bi->out_reg_set, reg))
	  fprintf (file, " %d", reg);
      fprintf (file, " ]\nOutput stack: ");
      print_stack (file, &regstack);
    }

  insn = block->end;
  if (GET_CODE (insn) == JUMP_INSN)
    insn = PREV_INSN (insn);

  /* If the function is declared to return a value, but it returns one
     in only some cases, some registers might come live here.  Emit
     necessary moves for them.  */

  for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; ++reg)
    {
      if (TEST_HARD_REG_BIT (bi->out_reg_set, reg)
	  && ! TEST_HARD_REG_BIT (regstack.reg_set, reg))
	{
	  rtx set;

	  if (file)
	    {
	      fprintf (file, "Emitting insn initializing reg %d\n",
		       reg);
	    }

	  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode),
			     nan);
	  insn = emit_insn_after (set, insn);
	  subst_stack_regs (insn, &regstack);
	}
    }

  /* Something failed if the stack lives don't match.  */
  GO_IF_HARD_REG_EQUAL (regstack.reg_set, bi->out_reg_set, win);
  abort ();
 win:
  bi->stack_out = regstack;

  /* Compensate the back edges, as those wasn't visited yet.  */
  for (e = block->succ; e ; e = e->succ_next)
    {
      if (e->flags & EDGE_DFS_BACK
	  || (e->dest == EXIT_BLOCK_PTR))
	{
	  if (!BLOCK_INFO (e->dest)->done
	      && e->dest != block)
	    abort ();
          inserted |= compensate_edge (e, file);
	}
    }
  for (e = block->pred; e ; e = e->pred_next)
    {
      if (e != beste && !(e->flags & EDGE_DFS_BACK)
	  && e->src != ENTRY_BLOCK_PTR)
	{
	  if (!BLOCK_INFO (e->src)->done)
	    abort ();
          inserted |= compensate_edge (e, file);
	}
    }

  return inserted;
}
