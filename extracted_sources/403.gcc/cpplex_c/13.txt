static void
parse_number (pfile, number, c, leading_period)
     cpp_reader *pfile;
     cpp_string *number;
     cppchar_t c;
     int leading_period;
{
  cpp_buffer *buffer = pfile->buffer;
  unsigned char *dest, *limit;

  dest = BUFF_FRONT (pfile->u_buff);
  limit = BUFF_LIMIT (pfile->u_buff);

  /* Place a leading period.  */
  if (leading_period)
    {
      if (dest == limit)
	{
	  _cpp_extend_buff (pfile, &pfile->u_buff, 1);
	  dest = BUFF_FRONT (pfile->u_buff);
	  limit = BUFF_LIMIT (pfile->u_buff);
	}
      *dest++ = '.';
    }
  
  do
    {
      do
	{
	  /* Need room for terminating null.  */
	  if ((size_t) (limit - dest) < 2)
	    {
	      size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);
	      _cpp_extend_buff (pfile, &pfile->u_buff, 2);
	      dest = BUFF_FRONT (pfile->u_buff) + len_so_far;
	      limit = BUFF_LIMIT (pfile->u_buff);
	    }
	  *dest++ = c;

	  c = *buffer->cur++;
	}
      while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));

      /* Potential escaped newline?  */
      buffer->backup_to = buffer->cur - 1;
      if (c != '?' && c != '\\')
	break;
      c = skip_escaped_newlines (pfile);
    }
  while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));

  /* Step back over the unwanted char.  */
  BACKUP ();

  /* Null-terminate the number.  */
  *dest = '\0';

  number->text = BUFF_FRONT (pfile->u_buff);
  number->len = dest - number->text;
  BUFF_FRONT (pfile->u_buff) = dest + 1;
}
