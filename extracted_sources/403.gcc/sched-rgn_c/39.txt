static void
propagate_deps (bb, pred_deps)
     int bb;
     struct deps *pred_deps;
{
  int b = BB_TO_BLOCK (bb);
  int e, first_edge;

  /* bb's structures are inherited by its successors.  */
  first_edge = e = OUT_EDGES (b);
  if (e > 0)
    do
      {
	int b_succ = TO_BLOCK (e);
	int bb_succ = BLOCK_TO_BB (b_succ);
	struct deps *succ_deps = bb_deps + bb_succ;
	int reg;

	/* Only bbs "below" bb, in the same region, are interesting.  */
	if (CONTAINING_RGN (b) != CONTAINING_RGN (b_succ)
	    || bb_succ <= bb)
	  {
	    e = NEXT_OUT (e);
	    continue;
	  }

	/* The reg_last lists are inherited by bb_succ.  */
	EXECUTE_IF_SET_IN_REG_SET (&pred_deps->reg_last_in_use, 0, reg,
	  {
	    struct deps_reg *pred_rl = &pred_deps->reg_last[reg];
	    struct deps_reg *succ_rl = &succ_deps->reg_last[reg];

	    succ_rl->uses = concat_INSN_LIST (pred_rl->uses, succ_rl->uses);
	    succ_rl->sets = concat_INSN_LIST (pred_rl->sets, succ_rl->sets);
	    succ_rl->clobbers = concat_INSN_LIST (pred_rl->clobbers,
						  succ_rl->clobbers);
	    succ_rl->uses_length += pred_rl->uses_length;
	    succ_rl->clobbers_length += pred_rl->clobbers_length;
	  });
	IOR_REG_SET (&succ_deps->reg_last_in_use, &pred_deps->reg_last_in_use);

	/* Mem read/write lists are inherited by bb_succ.  */
	concat_insn_mem_list (pred_deps->pending_read_insns,
			      pred_deps->pending_read_mems,
			      &succ_deps->pending_read_insns,
			      &succ_deps->pending_read_mems);
	concat_insn_mem_list (pred_deps->pending_write_insns,
			      pred_deps->pending_write_mems,
			      &succ_deps->pending_write_insns,
			      &succ_deps->pending_write_mems);

	succ_deps->last_pending_memory_flush
	  = concat_INSN_LIST (pred_deps->last_pending_memory_flush,
			      succ_deps->last_pending_memory_flush);
	
	succ_deps->pending_lists_length += pred_deps->pending_lists_length;
	succ_deps->pending_flush_length += pred_deps->pending_flush_length;

	/* last_function_call is inherited by bb_succ.  */
	succ_deps->last_function_call
	  = concat_INSN_LIST (pred_deps->last_function_call,
			      succ_deps->last_function_call);

	/* sched_before_next_call is inherited by bb_succ.  */
	succ_deps->sched_before_next_call
	  = concat_INSN_LIST (pred_deps->sched_before_next_call,
			      succ_deps->sched_before_next_call);

	e = NEXT_OUT (e);
      }
    while (e != first_edge);

  /* These lists should point to the right place, for correct
     freeing later.  */
  bb_deps[bb].pending_read_insns = pred_deps->pending_read_insns;
  bb_deps[bb].pending_read_mems = pred_deps->pending_read_mems;
  bb_deps[bb].pending_write_insns = pred_deps->pending_write_insns;
  bb_deps[bb].pending_write_mems = pred_deps->pending_write_mems;

  /* Can't allow these to be freed twice.  */
  pred_deps->pending_read_insns = 0;
  pred_deps->pending_read_mems = 0;
  pred_deps->pending_write_insns = 0;
  pred_deps->pending_write_mems = 0;
}
