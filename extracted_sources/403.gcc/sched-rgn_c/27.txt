static int
can_schedule_ready_p (insn)
     rtx insn;
{
  if (GET_CODE (insn) == JUMP_INSN)
    last_was_jump = 1;

  /* An interblock motion?  */
  if (INSN_BB (insn) != target_bb)
    {
      rtx temp;
      basic_block b1;

      if (IS_SPECULATIVE_INSN (insn))
	{
	  if (!check_live (insn, INSN_BB (insn)))
	    return 0;
	  update_live (insn, INSN_BB (insn));

	  /* For speculative load, mark insns fed by it.  */
	  if (IS_LOAD_INSN (insn) || FED_BY_SPEC_LOAD (insn))
	    set_spec_fed (insn);

	  nr_spec++;
	}
      nr_inter++;

      /* Find the beginning of the scheduling group.  */
      /* ??? Ought to update basic block here, but later bits of
	 schedule_block assumes the original insn block is
	 still intact.  */

      temp = insn;
      while (SCHED_GROUP_P (temp))
	temp = PREV_INSN (temp);

      /* Update source block boundaries.  */
      b1 = BLOCK_FOR_INSN (temp);
      if (temp == b1->head && insn == b1->end)
	{
	  /* We moved all the insns in the basic block.
	     Emit a note after the last insn and update the
	     begin/end boundaries to point to the note.  */
	  rtx note = emit_note_after (NOTE_INSN_DELETED, insn);
	  b1->head = note;
	  b1->end = note;
	}
      else if (insn == b1->end)
	{
	  /* We took insns from the end of the basic block,
	     so update the end of block boundary so that it
	     points to the first insn we did not move.  */
	  b1->end = PREV_INSN (temp);
	}
      else if (temp == b1->head)
	{
	  /* We took insns from the start of the basic block,
	     so update the start of block boundary so that
	     it points to the first insn we did not move.  */
	  b1->head = NEXT_INSN (insn);
	}
    }
  else
    {
      /* In block motion.  */
      sched_target_n_insns++;
    }
  sched_n_insns++;

  return 1;
}
