int
_cpp_parse_expr (pfile)
     cpp_reader *pfile;
{
  /* The implementation is an operator precedence parser, i.e. a
     bottom-up parser, using a stack for not-yet-reduced tokens.

     The stack base is 'stack', and the current stack pointer is 'top'.
     There is a stack element for each operator (only),
     and the most recently pushed operator is 'top->op'.
     An operand (value) is stored in the 'value' field of the stack
     element of the operator that precedes it.
     In that case the 'flags' field has the HAVE_VALUE flag set.  */

#define INIT_STACK_SIZE 20
  struct op init_stack[INIT_STACK_SIZE];
  struct op *stack = init_stack;
  struct op *limit = stack + INIT_STACK_SIZE;
  struct op *top = stack + 1;
  int skip_evaluation = 0;
  int result;
  unsigned int lex_count, saw_leading_not;

  /* Set up detection of #if ! defined().  */
  pfile->mi_ind_cmacro = 0;
  saw_leading_not = 0;
  lex_count = 0;

  /* We've finished when we try to reduce this.  */
  top->op = CPP_EOF;
  /* Nifty way to catch missing '('.  */
  top->prio = EXTRACT_PRIO(CLOSE_PAREN_PRIO);
  /* Avoid missing right operand checks.  */
  top->flags = NO_R_OPERAND;

  for (;;)
    {
      unsigned int prio;
      unsigned int flags;
      struct op op;

      /* Read a token */
      op = lex (pfile, skip_evaluation);
      lex_count++;

      /* If the token is an operand, push its value and get next
	 token.  If it is an operator, get its priority and flags, and
	 try to reduce the expression on the stack.  */
      switch (op.op)
	{
	case CPP_ERROR:
	  goto syntax_error;
	push_immediate:
	case CPP_NUMBER:
	  /* Push a value onto the stack.  */
	  if (top->flags & HAVE_VALUE)
	    SYNTAX_ERROR ("missing binary operator");
	  top->value = op.value;
	  top->unsignedp = op.unsignedp;
	  top->flags |= HAVE_VALUE;
	  continue;

	case CPP_EOF:	prio = FORCE_REDUCE_PRIO;	break;

	case CPP_NOT:
	  saw_leading_not = lex_count == 1;
	  prio = op_to_prio[op.op];
	  break;
	case CPP_PLUS:
	case CPP_MINUS: prio = PLUS_PRIO;  if (top->flags & HAVE_VALUE) break;
          /* else unary; fall through */
	default:	prio = op_to_prio[op.op];	break;
	}

      /* Separate the operator's code into priority and flags.  */
      flags = EXTRACT_FLAGS(prio);
      prio = EXTRACT_PRIO(prio);
      if (prio == EXTRACT_PRIO(OPEN_PAREN_PRIO))
	goto skip_reduction;

      /* Check for reductions.  Then push the operator.  */
      while (prio <= top->prio)
	{
	  HOST_WIDEST_INT v1, v2;
	  unsigned int unsigned1, unsigned2;
	  
	  /* Most operators that can appear on the stack require a
	     right operand.  Check this before trying to reduce.  */
	  if ((top->flags & (HAVE_VALUE | NO_R_OPERAND)) == 0)
	    {
	      if (top->op == CPP_OPEN_PAREN)
		SYNTAX_ERROR ("void expression between '(' and ')'");
	      else
		SYNTAX_ERROR2 ("operator '%s' has no right operand",
			       op_as_text (pfile, top->op));
	    }

	  unsigned2 = top->unsignedp, v2 = top->value;
	  top--;
	  unsigned1 = top->unsignedp, v1 = top->value;

	  /* Now set top->value = (top[1].op)(v1, v2); */
	  switch (top[1].op)
	    {
	    default:
	      cpp_ice (pfile, "impossible operator '%s'",
			       op_as_text (pfile, top[1].op));
	      goto syntax_error;

	    case CPP_NOT:	 UNARY(!);	break;
	    case CPP_COMPL:	 UNARY(~);	break;
	    case CPP_LESS:  	 COMPARE(<);	break;
	    case CPP_GREATER:	 COMPARE(>);	break;
	    case CPP_LESS_EQ:	 COMPARE(<=);	break;
	    case CPP_GREATER_EQ: COMPARE(>=);	break;
	    case CPP_EQ_EQ:	 EQUALITY(==);	break;
	    case CPP_NOT_EQ:	 EQUALITY(!=);	break;
	    case CPP_AND:	 BITWISE(&);	break;
	    case CPP_XOR:	 BITWISE(^);	break;
	    case CPP_OR:	 BITWISE(|);	break;
	    case CPP_LSHIFT:	 SHIFT(left_shift, right_shift); break;
	    case CPP_RSHIFT:	 SHIFT(right_shift, left_shift); break;
	    case CPP_MIN:	 MINMAX(<);	break;
	    case CPP_MAX:	 MINMAX(>);	break;

	    case CPP_PLUS:
	      if (!(top->flags & HAVE_VALUE))
		{
		  /* Can't use UNARY(+) because K+R C did not have unary
		     plus.  Can't use UNARY() because some compilers object
		     to the empty argument.  */
		  top->value = v2;
		  top->unsignedp = unsigned2;
		  top->flags |= HAVE_VALUE;

		  if (CPP_WTRADITIONAL (pfile))
		    cpp_warning (pfile,
			"traditional C rejects the unary plus operator");
		}
	      else
		{
		  top->value = v1 + v2;
		  top->unsignedp = unsigned1 | unsigned2;
		  if (! top->unsignedp && ! skip_evaluation
		      && ! possible_sum_sign (v1, v2, top->value))
		    integer_overflow (pfile);
		}
	      break;
	    case CPP_MINUS:
	      if (!(top->flags & HAVE_VALUE))
		{
		  UNARY(-);
		  if (!skip_evaluation && (top->value & v2) < 0 && !unsigned2)
		    integer_overflow (pfile);
		}
	      else
		{ /* Binary '-' */
		  top->value = v1 - v2;
		  top->unsignedp = unsigned1 | unsigned2;
		  if (! top->unsignedp && ! skip_evaluation
		      && ! possible_sum_sign (top->value, v2, v1))
		    integer_overflow (pfile);
		}
	      break;
	    case CPP_MULT:
	      top->unsignedp = unsigned1 | unsigned2;
	      if (top->unsignedp)
		top->value = (unsigned HOST_WIDEST_INT) v1 * v2;
	      else if (!skip_evaluation)
		{
		  top->value = v1 * v2;
		  if (v1 && (top->value / v1 != v2
		             || (top->value & v1 & v2) < 0))
		    integer_overflow (pfile);
		}
	      break;
	    case CPP_DIV:
	    case CPP_MOD:
	      if (skip_evaluation)
		break;
	      if (v2 == 0)
		SYNTAX_ERROR ("division by zero in #if");
	      top->unsignedp = unsigned1 | unsigned2;
	      if (top[1].op == CPP_DIV)
		{
		  if (top->unsignedp)
		    top->value = (unsigned HOST_WIDEST_INT) v1 / v2;
		  else
		    {
		      top->value = v1 / v2;
		      if ((top->value & v1 & v2) < 0)
			integer_overflow (pfile);
		    }
		}
	      else
		{
		  if (top->unsignedp)
		    top->value = (unsigned HOST_WIDEST_INT) v1 % v2;
		  else
		    top->value = v1 % v2;
		}
	      break;

	    case CPP_OR_OR:
	      top->value = v1 || v2;
	      top->unsignedp = 0;
	      if (v1) skip_evaluation--;
	      break;
	    case CPP_AND_AND:
	      top->value = v1 && v2;
	      top->unsignedp = 0;
	      if (!v1) skip_evaluation--;
	      break;
	    case CPP_COMMA:
	      if (CPP_PEDANTIC (pfile))
		cpp_pedwarn (pfile, "comma operator in operand of #if");
	      top->value = v2;
	      top->unsignedp = unsigned2;
	      break;
	    case CPP_QUERY:
	      SYNTAX_ERROR ("syntax error '?' without following ':'");
	    case CPP_COLON:
	      if (top[0].op != CPP_QUERY)
		SYNTAX_ERROR ("syntax error ':' without preceding '?'");
	      top--;
	      if (top->value) skip_evaluation--;
	      top->value = top->value ? v1 : v2;
	      top->unsignedp = unsigned1 | unsigned2;
	      break;
	    case CPP_OPEN_PAREN:
	      if (op.op != CPP_CLOSE_PAREN)
		SYNTAX_ERROR ("missing ')' in expression");
	      op.value = v2;
	      op.unsignedp = unsigned2;
	      goto push_immediate;
	    case CPP_EOF:
	      /* Reducing this dummy operator indicates we've finished.  */
	      if (op.op == CPP_CLOSE_PAREN)
		SYNTAX_ERROR ("missing '(' in expression");
	      goto done;
	    }
	}

      /* Handle short-circuit evaluations.  */
      if (flags & SHORT_CIRCUIT)
	switch (op.op)
	  {
	  case CPP_OR_OR:    if (top->value) skip_evaluation++; break;
	  case CPP_AND_AND:
	  case CPP_QUERY:    if (!top->value) skip_evaluation++; break;
	  case CPP_COLON:
	    if (top[-1].value) /* Was '?' condition true?  */
	      skip_evaluation++;
	    else
	      skip_evaluation--;
	  default:
	    break;
	  }

    skip_reduction:
      /* Check we have a left operand iff we need one.  */
      if (flags & NO_L_OPERAND)
	{
	  if (top->flags & HAVE_VALUE)
	    SYNTAX_ERROR2 ("missing binary operator before '%s'",
			   op_as_text (pfile, op.op));
	}
      else
	{
	  if (!(top->flags & HAVE_VALUE))
	    SYNTAX_ERROR2 ("operator '%s' has no left operand",
			   op_as_text (pfile, op.op));
	}

      /* Check for and handle stack overflow.  */
      top++;
      if (top == limit)
	{
	  struct op *new_stack;
	  int old_size = (char *) limit - (char *) stack;
	  int new_size = 2 * old_size;
	  if (stack != init_stack)
	    new_stack = (struct op *) xrealloc (stack, new_size);
	  else
	    {
	      new_stack = (struct op *) xmalloc (new_size);
	      memcpy (new_stack, stack, old_size);
	    }
	  stack = new_stack;
	  top = (struct op *) ((char *) new_stack + old_size);
	  limit = (struct op *) ((char *) new_stack + new_size);
	}
      
      top->flags = flags;
      top->prio = prio & ~EXTRACT_PRIO(RIGHT_ASSOC);
      top->op = op.op;
    }

 done:
  /* The controlling macro expression is only valid if we called lex 3
     times: <!> <defined expression> and <EOF>.  push_conditional ()
     checks that we are at top-of-file.  */
  if (pfile->mi_ind_cmacro && !(saw_leading_not && lex_count == 3))
    pfile->mi_ind_cmacro = 0;

  result = (top[1].value != 0);

  if (top != stack)
    CPP_ICE ("unbalanced stack in #if");
  else if (!(top[1].flags & HAVE_VALUE))
    {
      SYNTAX_ERROR ("#if with no expression");
    syntax_error:
      result = 0;  /* Return 0 on syntax error.  */
    }

  /* Free dynamic stack if we allocated one.  */
  if (stack != init_stack)
    free (stack);
  return result;
}
