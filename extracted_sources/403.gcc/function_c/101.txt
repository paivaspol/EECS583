void
thread_prologue_and_epilogue_insns (f)
     rtx f ATTRIBUTE_UNUSED;
{
  int inserted = 0;
  edge e;
#if defined (HAVE_sibcall_epilogue) || defined (HAVE_epilogue) || defined (HAVE_return) || defined (HAVE_prologue)
  rtx seq;
#endif
#ifdef HAVE_prologue
  rtx prologue_end = NULL_RTX;
#endif
#if defined (HAVE_epilogue) || defined(HAVE_return)
  rtx epilogue_end = NULL_RTX;
#endif

#ifdef HAVE_prologue
  if (HAVE_prologue)
    {
      start_sequence ();
      seq = gen_prologue ();
      emit_insn (seq);

      /* Retain a map of the prologue insns.  */
      if (GET_CODE (seq) != SEQUENCE)
	seq = get_insns ();
      record_insns (seq, &prologue);
      prologue_end = emit_note (NULL, NOTE_INSN_PROLOGUE_END);

      seq = gen_sequence ();
      end_sequence ();

      /* Can't deal with multiple successors of the entry block
         at the moment.  Function should always have at least one
         entry point.  */
      if (!ENTRY_BLOCK_PTR->succ || ENTRY_BLOCK_PTR->succ->succ_next)
	abort ();

      insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);
      inserted = 1;
    }
#endif

  /* If the exit block has no non-fake predecessors, we don't need
     an epilogue.  */
  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)
    if ((e->flags & EDGE_FAKE) == 0)
      break;
  if (e == NULL)
    goto epilogue_done;

#ifdef HAVE_return
  if (optimize && HAVE_return)
    {
      /* If we're allowed to generate a simple return instruction,
	 then by definition we don't need a full epilogue.  Examine
	 the block that falls through to EXIT.   If it does not
	 contain any code, examine its predecessors and try to
	 emit (conditional) return instructions.  */

      basic_block last;
      edge e_next;
      rtx label;

      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)
	if (e->flags & EDGE_FALLTHRU)
	  break;
      if (e == NULL)
	goto epilogue_done;
      last = e->src;

      /* Verify that there are no active instructions in the last block.  */
      label = last->end;
      while (label && GET_CODE (label) != CODE_LABEL)
	{
	  if (active_insn_p (label))
	    break;
	  label = PREV_INSN (label);
	}

      if (last->head == label && GET_CODE (label) == CODE_LABEL)
	{
	  rtx epilogue_line_note = NULL_RTX;

	  /* Locate the line number associated with the closing brace,
	     if we can find one.  */
	  for (seq = get_last_insn ();
	       seq && ! active_insn_p (seq);
	       seq = PREV_INSN (seq))
	    if (GET_CODE (seq) == NOTE && NOTE_LINE_NUMBER (seq) > 0)
	      {
		epilogue_line_note = seq;
		break;
	      }

	  for (e = last->pred; e; e = e_next)
	    {
	      basic_block bb = e->src;
	      rtx jump;

	      e_next = e->pred_next;
	      if (bb == ENTRY_BLOCK_PTR)
		continue;

	      jump = bb->end;
	      if ((GET_CODE (jump) != JUMP_INSN) || JUMP_LABEL (jump) != label)
		continue;

	      /* If we have an unconditional jump, we can replace that
		 with a simple return instruction.  */
	      if (simplejump_p (jump))
		{
		  emit_return_into_block (bb, epilogue_line_note);
		  delete_insn (jump);
		}

	      /* If we have a conditional jump, we can try to replace
		 that with a conditional return instruction.  */
	      else if (condjump_p (jump))
		{
		  rtx ret, *loc;

		  ret = SET_SRC (PATTERN (jump));
		  if (GET_CODE (XEXP (ret, 1)) == LABEL_REF)
		    loc = &XEXP (ret, 1);
		  else
		    loc = &XEXP (ret, 2);
		  ret = gen_rtx_RETURN (VOIDmode);

		  if (! validate_change (jump, loc, ret, 0))
		    continue;
		  if (JUMP_LABEL (jump))
		    LABEL_NUSES (JUMP_LABEL (jump))--;

		  /* If this block has only one successor, it both jumps
		     and falls through to the fallthru block, so we can't
		     delete the edge.  */
		  if (bb->succ->succ_next == NULL)
		    continue;
		}
	      else
		continue;

	      /* Fix up the CFG for the successful change we just made.  */
	      redirect_edge_succ (e, EXIT_BLOCK_PTR);
	    }

	  /* Emit a return insn for the exit fallthru block.  Whether
	     this is still reachable will be determined later.  */

	  emit_barrier_after (last->end);
	  emit_return_into_block (last, epilogue_line_note);
	  epilogue_end = last->end;
	  last->succ->flags &= ~EDGE_FALLTHRU;
	  goto epilogue_done;
	}
    }
#endif
#ifdef HAVE_epilogue
  if (HAVE_epilogue)
    {
      /* Find the edge that falls through to EXIT.  Other edges may exist
	 due to RETURN instructions, but those don't need epilogues.
	 There really shouldn't be a mixture -- either all should have
	 been converted or none, however...  */

      for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)
	if (e->flags & EDGE_FALLTHRU)
	  break;
      if (e == NULL)
	goto epilogue_done;

      start_sequence ();
      epilogue_end = emit_note (NULL, NOTE_INSN_EPILOGUE_BEG);

      seq = gen_epilogue ();

#ifdef INCOMING_RETURN_ADDR_RTX
      /* If this function returns with the stack depressed and we can support
	 it, massage the epilogue to actually do that.  */
      if (TREE_CODE (TREE_TYPE (current_function_decl)) == FUNCTION_TYPE
	  && TYPE_RETURNS_STACK_DEPRESSED (TREE_TYPE (current_function_decl)))
	seq = keep_stack_depressed (seq);
#endif

      emit_jump_insn (seq);

      /* Retain a map of the epilogue insns.  */
      if (GET_CODE (seq) != SEQUENCE)
	seq = get_insns ();
      record_insns (seq, &epilogue);

      seq = gen_sequence ();
      end_sequence ();

      insert_insn_on_edge (seq, e);
      inserted = 1;
    }
#endif
epilogue_done:

  if (inserted)
    commit_edge_insertions ();

#ifdef HAVE_sibcall_epilogue
  /* Emit sibling epilogues before any sibling call sites.  */
  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)
    {
      basic_block bb = e->src;
      rtx insn = bb->end;
      rtx i;
      rtx newinsn;

      if (GET_CODE (insn) != CALL_INSN
	  || ! SIBLING_CALL_P (insn))
	continue;

      start_sequence ();
      seq = gen_sibcall_epilogue ();
      end_sequence ();

      i = PREV_INSN (insn);
      newinsn = emit_insn_before (seq, insn);

      /* Retain a map of the epilogue insns.  Used in life analysis to
	 avoid getting rid of sibcall epilogue insns.  */
      record_insns (GET_CODE (seq) == SEQUENCE
		    ? seq : newinsn, &sibcall_epilogue);
    }
#endif

#ifdef HAVE_prologue
  if (prologue_end)
    {
      rtx insn, prev;

      /* GDB handles `break f' by setting a breakpoint on the first
	 line note after the prologue.  Which means (1) that if
	 there are line number notes before where we inserted the
	 prologue we should move them, and (2) we should generate a
	 note before the end of the first basic block, if there isn't
	 one already there.

	 ??? This behaviour is completely broken when dealing with
	 multiple entry functions.  We simply place the note always
	 into first basic block and let alternate entry points
	 to be missed.
       */

      for (insn = prologue_end; insn; insn = prev)
	{
	  prev = PREV_INSN (insn);
	  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)
	    {
	      /* Note that we cannot reorder the first insn in the
		 chain, since rest_of_compilation relies on that
		 remaining constant.  */
	      if (prev == NULL)
		break;
	      reorder_insns (insn, insn, prologue_end);
	    }
	}

      /* Find the last line number note in the first block.  */
      for (insn = BASIC_BLOCK (0)->end;
	   insn != prologue_end && insn;
	   insn = PREV_INSN (insn))
	if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)
	  break;

      /* If we didn't find one, make a copy of the first line number
	 we run across.  */
      if (! insn)
	{
	  for (insn = next_active_insn (prologue_end);
	       insn;
	       insn = PREV_INSN (insn))
	    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)
	      {
		emit_line_note_after (NOTE_SOURCE_FILE (insn),
				      NOTE_LINE_NUMBER (insn),
				      prologue_end);
		break;
	      }
	}
    }
#endif
#ifdef HAVE_epilogue
  if (epilogue_end)
    {
      rtx insn, next;

      /* Similarly, move any line notes that appear after the epilogue.
         There is no need, however, to be quite so anal about the existence
	 of such a note.  */
      for (insn = epilogue_end; insn; insn = next)
	{
	  next = NEXT_INSN (insn);
	  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)
	    reorder_insns (insn, insn, PREV_INSN (epilogue_end));
	}
    }
#endif
}
