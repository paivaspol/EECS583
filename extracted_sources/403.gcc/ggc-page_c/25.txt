void
ggc_print_statistics ()
{
  struct ggc_statistics stats;
  unsigned int i;
  size_t total_overhead = 0;

#ifdef SPEC_CPU
  return;
#endif
  /* Clear the statistics.  */
  memset (&stats, 0, sizeof (stats));
  
  /* Make sure collection will really occur.  */
  G.allocated_last_gc = 0;

  /* Collect and print the statistics common across collectors.  */
  ggc_print_common_statistics (stderr, &stats);

  /* Release free pages so that we will not count the bytes allocated
     there as part of the total allocated memory.  */
  release_pages ();

  /* Collect some information about the various sizes of 
     allocation.  */
  fprintf (stderr, "\n%-5s %10s  %10s  %10s\n",
	   "Size", "Allocated", "Used", "Overhead");
  for (i = 0; i < NUM_ORDERS; ++i)
    {
      page_entry *p;
      size_t allocated;
      size_t in_use;
      size_t overhead;

      /* Skip empty entries.  */
      if (!G.pages[i])
	continue;

      overhead = allocated = in_use = 0;

      /* Figure out the total number of bytes allocated for objects of
	 this size, and how many of them are actually in use.  Also figure
	 out how much memory the page table is using.  */
      for (p = G.pages[i]; p; p = p->next)
	{
	  allocated += p->bytes;
	  in_use += 
	    (OBJECTS_PER_PAGE (i) - p->num_free_objects) * OBJECT_SIZE (i);

	  overhead += (sizeof (page_entry) - sizeof (long)
		       + BITMAP_SIZE (OBJECTS_PER_PAGE (i) + 1));
	}
      fprintf (stderr, "%-5d %10ld%c %10ld%c %10ld%c\n", OBJECT_SIZE (i),
	       SCALE (allocated), LABEL (allocated),
	       SCALE (in_use), LABEL (in_use),
	       SCALE (overhead), LABEL (overhead));
      total_overhead += overhead;
    }
  fprintf (stderr, "%-5s %10ld%c %10ld%c %10ld%c\n", "Total",
	   SCALE (G.bytes_mapped), LABEL (G.bytes_mapped),
	   SCALE (G.allocated), LABEL(G.allocated),
	   SCALE (total_overhead), LABEL (total_overhead));
}
