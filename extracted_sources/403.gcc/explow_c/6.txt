void
optimize_save_area_alloca (insns)
     rtx insns;
{
  rtx insn;

  for (insn = insns; insn; insn = NEXT_INSN(insn))
    {
      rtx note;

      if (GET_CODE (insn) != INSN)
	continue;

      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
	{
	  if (REG_NOTE_KIND (note) != REG_SAVE_AREA)
	    continue;

	  if (!current_function_calls_setjmp)
	    {
	      rtx pat = PATTERN (insn);

	      /* If we do not see the note in a pattern matching
		 these precise characteristics, we did something
		 entirely wrong in allocate_dynamic_stack_space.

		 Note, one way this could happen is if SETJMP_VIA_SAVE_AREA
		 was defined on a machine where stacks grow towards higher
		 addresses.

		 Right now only supported port with stack that grow upward
		 is the HPPA and it does not define SETJMP_VIA_SAVE_AREA.  */
	      if (GET_CODE (pat) != SET
		  || SET_DEST (pat) != stack_pointer_rtx
		  || GET_CODE (SET_SRC (pat)) != MINUS
		  || XEXP (SET_SRC (pat), 0) != stack_pointer_rtx)
		abort ();

	      /* This will now be transformed into a (set REG REG)
		 so we can just blow away all the other notes.  */
	      XEXP (SET_SRC (pat), 1) = XEXP (note, 0);
	      REG_NOTES (insn) = NULL_RTX;
	    }
	  else
	    {
	      /* setjmp was called, we must remove the REG_SAVE_AREA
		 note so that later passes do not get confused by its
		 presence.  */
	      if (note == REG_NOTES (insn))
		{
		  REG_NOTES (insn) = XEXP (note, 1);
		}
	      else
		{
		  rtx srch;

		  for (srch = REG_NOTES (insn); srch; srch = XEXP (srch, 1))
		    if (XEXP (srch, 1) == note)
		      break;

		  if (srch == NULL_RTX)
		    abort ();

		  XEXP (srch, 1) = XEXP (note, 1);
		}
	    }
	  /* Once we've seen the note of interest, we need not look at
	     the rest of them.  */
	  break;
	}
    }
}
