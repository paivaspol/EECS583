static void
dbxout_block (block, depth, args)
     tree block;
     int depth;
     tree args;
{
  int blocknum = -1;

#if DBX_BLOCKS_FUNCTION_RELATIVE
  const char *begin_label; 
  if (current_function_func_begin_label != NULL_TREE)
    begin_label = IDENTIFIER_POINTER (current_function_func_begin_label);
  else
    begin_label = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
#endif

  while (block)
    {
      /* Ignore blocks never expanded or otherwise marked as real.  */
      if (TREE_USED (block) && TREE_ASM_WRITTEN (block))
	{
	  int did_output;

#ifdef DBX_LBRAC_FIRST
	  did_output = 1;
#else
	  /* In dbx format, the syms of a block come before the N_LBRAC.
	     If nothing is output, we don't need the N_LBRAC, either.  */
	  did_output = 0;
	  if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)
	    did_output = dbxout_syms (BLOCK_VARS (block));
	  if (args)
	    dbxout_reg_parms (args);
#endif

	  /* Now output an N_LBRAC symbol to represent the beginning of
	     the block.  Use the block's tree-walk order to generate
	     the assembler symbols LBBn and LBEn
	     that final will define around the code in this block.  */
	  if (depth > 0 && did_output)
	    {
	      char buf[20];
	      blocknum = BLOCK_NUMBER (block);
	      ASM_GENERATE_INTERNAL_LABEL (buf, "LBB", blocknum);

	      if (BLOCK_HANDLER_BLOCK (block))
		{
		  /* A catch block.  Must precede N_LBRAC.  */
		  tree decl = BLOCK_VARS (block);
		  while (decl)
		    {
#ifdef DBX_OUTPUT_CATCH
		      DBX_OUTPUT_CATCH (asmfile, decl, buf);
#else
		      fprintf (asmfile, "%s\"%s:C1\",%d,0,0,", ASM_STABS_OP,
			       IDENTIFIER_POINTER (DECL_NAME (decl)), N_CATCH);
		      assemble_name (asmfile, buf);
		      fprintf (asmfile, "\n");
#endif
		      decl = TREE_CHAIN (decl);
		    }
		}

#ifdef DBX_OUTPUT_LBRAC
	      DBX_OUTPUT_LBRAC (asmfile, buf);
#else
	      fprintf (asmfile, "%s%d,0,0,", ASM_STABN_OP, N_LBRAC);
	      assemble_name (asmfile, buf);
#if DBX_BLOCKS_FUNCTION_RELATIVE
	      putc ('-', asmfile);
	      assemble_name (asmfile, begin_label);
#endif
	      fprintf (asmfile, "\n");
#endif
	    }

#ifdef DBX_LBRAC_FIRST
	  /* On some weird machines, the syms of a block
	     come after the N_LBRAC.  */
	  if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)
	    dbxout_syms (BLOCK_VARS (block));
	  if (args)
	    dbxout_reg_parms (args);
#endif

	  /* Output the subblocks.  */
	  dbxout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE);

	  /* Refer to the marker for the end of the block.  */
	  if (depth > 0 && did_output)
	    {
	      char buf[20];
	      ASM_GENERATE_INTERNAL_LABEL (buf, "LBE", blocknum);
#ifdef DBX_OUTPUT_RBRAC
	      DBX_OUTPUT_RBRAC (asmfile, buf);
#else
	      fprintf (asmfile, "%s%d,0,0,", ASM_STABN_OP, N_RBRAC);
	      assemble_name (asmfile, buf);
#if DBX_BLOCKS_FUNCTION_RELATIVE
	      putc ('-', asmfile);
	      assemble_name (asmfile, begin_label);
#endif
	      fprintf (asmfile, "\n");
#endif
	    }
	}
      block = BLOCK_CHAIN (block);
    }
}
