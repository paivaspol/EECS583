static void
dbxout_type (type, full)
     tree type;
     int full;
{
  tree tem;
  tree main_variant;
  static int anonymous_type_number = 0;

  if (TREE_CODE (type) == VECTOR_TYPE)
    type = TYPE_DEBUG_REPRESENTATION_TYPE (type);

  /* If there was an input error and we don't really have a type,
     avoid crashing and write something that is at least valid
     by assuming `int'.  */
  if (type == error_mark_node)
    type = integer_type_node;
  else
    {
      if (TYPE_NAME (type)
	  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
	  && TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (type)))
	full = 0;
    }

  /* Try to find the "main variant" with the same name.  */
  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))
    main_variant = TREE_TYPE (TYPE_NAME (type));
  else
    main_variant = TYPE_MAIN_VARIANT (type);

  /* If we are not using extensions, stabs does not distinguish const and
     volatile, so there is no need to make them separate types.  */
  if (!use_gnu_debug_info_extensions)
    type = main_variant;

  if (TYPE_SYMTAB_ADDRESS (type) == 0)
    {
      /* Type has no dbx number assigned.  Assign next available number.  */
      TYPE_SYMTAB_ADDRESS (type) = next_type_number++;

      /* Make sure type vector is long enough to record about this type.  */

      if (next_type_number == typevec_len)
	{
	  typevec
	    = (struct typeinfo *) xrealloc (typevec,
					    typevec_len * 2 * sizeof typevec[0]);
	  memset ((char *) (typevec + typevec_len), 0,
		 typevec_len * sizeof typevec[0]);
	  typevec_len *= 2;
	}

#ifdef DBX_USE_BINCL
      typevec[TYPE_SYMTAB_ADDRESS (type)].file_number
	= current_file->file_number;
      typevec[TYPE_SYMTAB_ADDRESS (type)].type_number
	= current_file->next_type_number++;
#endif
    }

  /* Output the number of this type, to refer to it.  */
  dbxout_type_index (type);

#ifdef DBX_TYPE_DEFINED
  if (DBX_TYPE_DEFINED (type))
    return;
#endif

  /* If this type's definition has been output or is now being output,
     that is all.  */

  switch (typevec[TYPE_SYMTAB_ADDRESS (type)].status)
    {
    case TYPE_UNSEEN:
      break;
    case TYPE_XREF:
      /* If we have already had a cross reference,
	 and either that's all we want or that's the best we could do,
	 don't repeat the cross reference.
	 Sun dbx crashes if we do.  */
      if (! full || !COMPLETE_TYPE_P (type)
	  /* No way in DBX fmt to describe a variable size.  */
	  || ! host_integerp (TYPE_SIZE (type), 1))
	return;
      break;
    case TYPE_DEFINED:
      return;
    }

#ifdef DBX_NO_XREFS
  /* For systems where dbx output does not allow the `=xsNAME:' syntax,
     leave the type-number completely undefined rather than output
     a cross-reference.  If we have already used GNU debug info extensions,
     then it is OK to output a cross reference.  This is necessary to get
     proper C++ debug output.  */
  if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE
       || TREE_CODE (type) == QUAL_UNION_TYPE
       || TREE_CODE (type) == ENUMERAL_TYPE)
      && ! use_gnu_debug_info_extensions)
    /* We must use the same test here as we use twice below when deciding
       whether to emit a cross-reference.  */
    if ((TYPE_NAME (type) != 0
	 && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
	       && DECL_IGNORED_P (TYPE_NAME (type)))
	 && !full)
	|| !COMPLETE_TYPE_P (type)
	/* No way in DBX fmt to describe a variable size.  */
	|| ! host_integerp (TYPE_SIZE (type), 1))
      {
	typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;
	return;
      }
#endif

  /* Output a definition now.  */

  fprintf (asmfile, "=");
  CHARS (1);

  /* Mark it as defined, so that if it is self-referent
     we will not get into an infinite recursion of definitions.  */

  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_DEFINED;

  /* If this type is a variant of some other, hand off.  Types with
     different names are usefully distinguished.  We only distinguish
     cv-qualified types if we're using extensions.  */
  if (TYPE_READONLY (type) > TYPE_READONLY (main_variant))
    {
      putc ('k', asmfile);
      CHARS (1);
      dbxout_type (build_type_variant (type, 0, TYPE_VOLATILE (type)), 0);
      return;
    }
  else if (TYPE_VOLATILE (type) > TYPE_VOLATILE (main_variant))
    {
      putc ('B', asmfile);
      CHARS (1);
      dbxout_type (build_type_variant (type, TYPE_READONLY (type), 0), 0);
      return;
    }
  else if (main_variant != TYPE_MAIN_VARIANT (type))
    {
      /* 'type' is a typedef; output the type it refers to.  */
      dbxout_type (DECL_ORIGINAL_TYPE (TYPE_NAME (type)), 0);
      return;
    }
  /* else continue.  */

  switch (TREE_CODE (type))
    {
    case VOID_TYPE:
    case LANG_TYPE:
      /* For a void type, just define it as itself; ie, "5=5".
	 This makes us consider it defined
	 without saying what it is.  The debugger will make it
	 a void type when the reference is seen, and nothing will
	 ever override that default.  */
      dbxout_type_index (type);
      break;

    case INTEGER_TYPE:
      if (type == char_type_node && ! TREE_UNSIGNED (type))
	{
	  /* Output the type `char' as a subrange of itself!
	     I don't understand this definition, just copied it
	     from the output of pcc.
	     This used to use `r2' explicitly and we used to
	     take care to make sure that `char' was type number 2.  */
	  fprintf (asmfile, "r");
	  CHARS (1);
	  dbxout_type_index (type);
	  fprintf (asmfile, ";0;127;");
	  CHARS (7);
	}

      /* If this is a subtype of another integer type, always prefer to
	 write it as a subtype.  */
      else if (TREE_TYPE (type) != 0
	       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)
        {
	  /* If the size is non-standard, say what it is if we can use
	     GDB extensions.  */

	  if (use_gnu_debug_info_extensions
	      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))
	    {
	      have_used_extensions = 1;
	      fprintf (asmfile, "@s%d;", TYPE_PRECISION (type));
	      CHARS (5);
	    }

	  dbxout_range_type (type);
        }

      else
  	{
	  /* If the size is non-standard, say what it is if we can use
	     GDB extensions.  */

	  if (use_gnu_debug_info_extensions
	      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))
	    {
	      have_used_extensions = 1;
	      fprintf (asmfile, "@s%d;", TYPE_PRECISION (type));
	      CHARS (5);
	    }

	  /* If we can use GDB extensions and the size is wider than a
	     long (the size used by GDB to read them) or we may have
	     trouble writing the bounds the usual way, write them in
	     octal.  Note the test is for the *target's* size of "long",
	     not that of the host.  The host test is just to make sure we
	     can write it out in case the host wide int is narrower than the
	     target "long".  */

	  /* For unsigned types, we use octal if they are the same size or
	     larger.  This is because we print the bounds as signed decimal,
	     and hence they can't span same size unsigned types.  */

 	  if (use_gnu_debug_info_extensions
	      && TYPE_MIN_VALUE (type) != 0
	      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST
	      && TYPE_MAX_VALUE (type) != 0
	      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST
	      && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)
		  || ((TYPE_PRECISION (type)
		       == TYPE_PRECISION (integer_type_node))
		      && TREE_UNSIGNED (type))
		  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT
		  || (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT
		      && TREE_UNSIGNED (type))))
	    {
	      fprintf (asmfile, "r");
	      CHARS (1);
	      dbxout_type_index (type);
	      fprintf (asmfile, ";");
	      CHARS (1);
	      print_int_cst_octal (TYPE_MIN_VALUE (type));
	      fprintf (asmfile, ";");
	      CHARS (1);
	      print_int_cst_octal (TYPE_MAX_VALUE (type));
	      fprintf (asmfile, ";");
	      CHARS (1);
	    }

	  else
	    /* Output other integer types as subranges of `int'.  */
	    dbxout_range_type (type);
  	}

      break;

    case REAL_TYPE:
      /* This used to say `r1' and we used to take care
	 to make sure that `int' was type number 1.  */
      fprintf (asmfile, "r");
      CHARS (1);
      dbxout_type_index (integer_type_node);
      putc (';', asmfile);
      CHARS (1);
      print_wide_int (int_size_in_bytes (type));
      fputs (";0;", asmfile);
      CHARS (3);
      break;

    case CHAR_TYPE:
      if (use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  fputs ("@s", asmfile);
	  CHARS (2);
	  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));
	  fputs (";-20;", asmfile);
	  CHARS (4);
	}
      else
	{
	  /* Output the type `char' as a subrange of itself.
	     That is what pcc seems to do.  */
	  fprintf (asmfile, "r");
	  CHARS (1);
	  dbxout_type_index (char_type_node);
	  fprintf (asmfile, ";0;%d;", TREE_UNSIGNED (type) ? 255 : 127);
	  CHARS (7);
	}
      break;

    case BOOLEAN_TYPE:
      if (use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  fputs ("@s", asmfile);
	  CHARS (2);
	  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));
	  fputs (";-16;", asmfile);
	  CHARS (4);
	}
      else /* Define as enumeral type (False, True) */
	{
	  fprintf (asmfile, "eFalse:0,True:1,;");
	  CHARS (17);
	}
      break;

    case FILE_TYPE:
      putc ('d', asmfile);
      CHARS (1);
      dbxout_type (TREE_TYPE (type), 0);
      break;

    case COMPLEX_TYPE:
      /* Differs from the REAL_TYPE by its new data type number */

      if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)
	{
	  fprintf (asmfile, "r");
	  CHARS (1);
	  dbxout_type_index (type);
	  putc (';', asmfile);
	  CHARS (1);
	  print_wide_int (2 * int_size_in_bytes (TREE_TYPE (type)));
	  fputs (";0;", asmfile);
	  CHARS (3);
	}
      else
	{
	  /* Output a complex integer type as a structure,
	     pending some other way to do it.  */
	  putc ('s', asmfile);
	  CHARS (1);
	  print_wide_int (int_size_in_bytes (type));
	  fprintf (asmfile, "real:");
	  CHARS (5);

	  dbxout_type (TREE_TYPE (type), 0);
	  fprintf (asmfile, ",0,%d;", TYPE_PRECISION (TREE_TYPE (type)));
	  CHARS (7);
	  fprintf (asmfile, "imag:");
	  CHARS (5);
	  dbxout_type (TREE_TYPE (type), 0);
	  fprintf (asmfile, ",%d,%d;;", TYPE_PRECISION (TREE_TYPE (type)),
		   TYPE_PRECISION (TREE_TYPE (type)));
	  CHARS (10);
	}
      break;

    case SET_TYPE:
      if (use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  fputs ("@s", asmfile);
	  CHARS (2);
	  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));
	  putc (';', asmfile);
	  CHARS (1);

	  /* Check if a bitstring type, which in Chill is
	     different from a [power]set.  */
	  if (TYPE_STRING_FLAG (type))
	    {
	      fprintf (asmfile, "@S;");
	      CHARS (3);
	    }
	}
      putc ('S', asmfile);
      CHARS (1);
      dbxout_type (TYPE_DOMAIN (type), 0);
      break;

    case ARRAY_TYPE:
      /* Make arrays of packed bits look like bitstrings for chill.  */
      if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  fputs ("@s", asmfile);
	  CHARS (2);
	  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));
	  fprintf (asmfile, ";@S;S");
	  CHARS (5);
	  dbxout_type (TYPE_DOMAIN (type), 0);
	  break;
	}

      /* Output "a" followed by a range type definition
	 for the index type of the array
	 followed by a reference to the target-type.
	 ar1;0;N;M for a C array of type M and size N+1.  */
      /* Check if a character string type, which in Chill is
	 different from an array of characters.  */
      if (TYPE_STRING_FLAG (type) && use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  fprintf (asmfile, "@S;");
	  CHARS (3);
	}
      tem = TYPE_DOMAIN (type);
      if (tem == NULL)
	{
	  fprintf (asmfile, "ar");
	  CHARS (2);
	  dbxout_type_index (integer_type_node);
	  fprintf (asmfile, ";0;-1;");
	  CHARS (6);
	}
      else
	{
	  fprintf (asmfile, "a");
	  CHARS (1);
	  dbxout_range_type (tem);
	}

      dbxout_type (TREE_TYPE (type), 0);
      break;

    case RECORD_TYPE:
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
      {
	int i, n_baseclasses = 0;

	if (TYPE_BINFO (type) != 0
	    && TREE_CODE (TYPE_BINFO (type)) == TREE_VEC
	    && TYPE_BINFO_BASETYPES (type) != 0)
	  n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type));

	/* Output a structure type.  We must use the same test here as we
	   use in the DBX_NO_XREFS case above.  */
	if ((TYPE_NAME (type) != 0
	     && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
		   && DECL_IGNORED_P (TYPE_NAME (type)))
	     && !full)
	    || !COMPLETE_TYPE_P (type)
	    /* No way in DBX fmt to describe a variable size.  */
	    || ! host_integerp (TYPE_SIZE (type), 1))
	  {
	    /* If the type is just a cross reference, output one
	       and mark the type as partially described.
	       If it later becomes defined, we will output
	       its real definition.
	       If the type has a name, don't nest its definition within
	       another type's definition; instead, output an xref
	       and let the definition come when the name is defined.  */
	    fputs ((TREE_CODE (type) == RECORD_TYPE) ? "xs" : "xu", asmfile);
	    CHARS (2);
#if 0 /* This assertion is legitimately false in C++.  */
	    /* We shouldn't be outputting a reference to a type before its
	       definition unless the type has a tag name.
	       A typedef name without a tag name should be impossible.  */
	    if (TREE_CODE (TYPE_NAME (type)) != IDENTIFIER_NODE)
	      abort ();
#endif
	    if (TYPE_NAME (type) != 0)
	      dbxout_type_name (type);
	    else
	      {
		fprintf (asmfile, "$$%d", anonymous_type_number++);
		CHARS (5);
	      }

	    fprintf (asmfile, ":");
	    CHARS (1);
	    typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;
	    break;
	  }

	/* Identify record or union, and print its size.  */
	putc (((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u'), asmfile);
	CHARS (1);
	print_wide_int (int_size_in_bytes (type));

	if (use_gnu_debug_info_extensions)
	  {
	    if (n_baseclasses)
	      {
		have_used_extensions = 1;
		fprintf (asmfile, "!%d,", n_baseclasses);
		CHARS (8);
	      }
	  }
	for (i = 0; i < n_baseclasses; i++)
	  {
	    tree child = TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), i);

	    if (use_gnu_debug_info_extensions)
	      {
		have_used_extensions = 1;
		putc (TREE_VIA_VIRTUAL (child) ? '1' : '0', asmfile);
		putc (TREE_VIA_PUBLIC (child) ? '2' : '0', asmfile);
		CHARS (2);
		if (TREE_VIA_VIRTUAL (child) && strcmp (lang_hooks.name, "GNU C++") == 0)
		  /* For a virtual base, print the (negative) offset within
		     the vtable where we must look to find the necessary
		     adjustment.  */
		  print_wide_int (tree_low_cst (BINFO_VPTR_FIELD (child), 0)
				  * BITS_PER_UNIT);
		else
		  print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)
				  * BITS_PER_UNIT);
		putc (',', asmfile);
		CHARS (1);
		dbxout_type (BINFO_TYPE (child), 0);
		putc (';', asmfile);
		CHARS (1);
	      }
	    else
	      {
		/* Print out the base class information with fields
		   which have the same names at the types they hold.  */
		dbxout_type_name (BINFO_TYPE (child));
		putc (':', asmfile);
		CHARS (1);
		dbxout_type (BINFO_TYPE (child), full);
		putc (',', asmfile);
		CHARS (1);
		print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)
				* BITS_PER_UNIT);
		putc (',', asmfile);
		CHARS (1);
		print_wide_int (tree_low_cst (DECL_SIZE
					      (TYPE_NAME
					       (BINFO_TYPE (child))),
					      0)
				* BITS_PER_UNIT);
		putc (';', asmfile);
		CHARS (1);
	      }
	  }
      }

      /* Write out the field declarations.  */
      dbxout_type_fields (type);
      if (use_gnu_debug_info_extensions && TYPE_METHODS (type) != NULL_TREE)
	{
	  have_used_extensions = 1;
	  dbxout_type_methods (type);
	}

      putc (';', asmfile);
      CHARS (1);

      if (use_gnu_debug_info_extensions && TREE_CODE (type) == RECORD_TYPE
	  /* Avoid the ~ if we don't really need it--it confuses dbx.  */
	  && TYPE_VFIELD (type))
	{
	  have_used_extensions = 1;

	  /* Tell GDB+ that it may keep reading.  */
	  putc ('~', asmfile);
	  CHARS (1);

	  /* We need to write out info about what field this class
	     uses as its "main" vtable pointer field, because if this
	     field is inherited from a base class, GDB cannot necessarily
	     figure out which field it's using in time.  */
	  if (TYPE_VFIELD (type))
	    {
	      putc ('%', asmfile);
	      CHARS (1);
	      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);
	    }

	  putc (';', asmfile);
	  CHARS (1);
	}
      break;

    case ENUMERAL_TYPE:
      /* We must use the same test here as we use in the DBX_NO_XREFS case
	 above.  We simplify it a bit since an enum will never have a variable
	 size.  */
      if ((TYPE_NAME (type) != 0
	   && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL
		 && DECL_IGNORED_P (TYPE_NAME (type)))
	   && !full)
	  || !COMPLETE_TYPE_P (type))
	{
	  fprintf (asmfile, "xe");
	  CHARS (2);
	  dbxout_type_name (type);
	  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;
	  putc (':', asmfile);
	  CHARS (1);
	  return;
	}
#ifdef DBX_OUTPUT_ENUM
      DBX_OUTPUT_ENUM (asmfile, type);
#else
      if (use_gnu_debug_info_extensions
	  && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))
	{
	  fprintf (asmfile, "@s%d;", TYPE_PRECISION (type));
	  CHARS (5);
	}

      putc ('e', asmfile);
      CHARS (1);
      for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))
	{
	  fprintf (asmfile, "%s:", IDENTIFIER_POINTER (TREE_PURPOSE (tem)));
	  CHARS (IDENTIFIER_LENGTH (TREE_PURPOSE (tem)) + 1);
	  if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == 0)
	    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));
	  else if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == -1
		   && (HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_VALUE (tem)) < 0)
	    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));
	  else
	    print_int_cst_octal (TREE_VALUE (tem));

	  putc (',', asmfile);
	  CHARS (1);
	  if (TREE_CHAIN (tem) != 0)
	    CONTIN;
	}

      putc (';', asmfile);
      CHARS (1);
#endif
      break;

    case POINTER_TYPE:
      putc ('*', asmfile);
      CHARS (1);
      dbxout_type (TREE_TYPE (type), 0);
      break;

    case METHOD_TYPE:
      if (use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  putc ('#', asmfile);
	  CHARS (1);

	  /* Write the argument types out longhand.  */
	  dbxout_type (TYPE_METHOD_BASETYPE (type), 0);
	  putc (',', asmfile);
	  CHARS (1);
	  dbxout_type (TREE_TYPE (type), 0);
	  dbxout_args (TYPE_ARG_TYPES (type));
	  putc (';', asmfile);
	  CHARS (1);
	}
      else
	/* Treat it as a function type.  */
	dbxout_type (TREE_TYPE (type), 0);
      break;

    case OFFSET_TYPE:
      if (use_gnu_debug_info_extensions)
	{
	  have_used_extensions = 1;
	  putc ('@', asmfile);
	  CHARS (1);
	  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);
	  putc (',', asmfile);
	  CHARS (1);
	  dbxout_type (TREE_TYPE (type), 0);
	}
      else
	/* Should print as an int, because it is really just an offset.  */
	dbxout_type (integer_type_node, 0);
      break;

    case REFERENCE_TYPE:
      if (use_gnu_debug_info_extensions)
	have_used_extensions = 1;
      putc (use_gnu_debug_info_extensions ? '&' : '*', asmfile);
      CHARS (1);
      dbxout_type (TREE_TYPE (type), 0);
      break;

    case FUNCTION_TYPE:
      putc ('f', asmfile);
      CHARS (1);
      dbxout_type (TREE_TYPE (type), 0);
      break;

    default:
      abort ();
    }
}
