static dw_die_ref
modified_type_die (type, is_const_type, is_volatile_type, context_die)
     tree type;
     int is_const_type;
     int is_volatile_type;
     dw_die_ref context_die;
{
  enum tree_code code = TREE_CODE (type);
  dw_die_ref mod_type_die = NULL;
  dw_die_ref sub_die = NULL;
  tree item_type = NULL;

  if (code != ERROR_MARK)
    {
      tree qualified_type;

      /* See if we already have the appropriately qualified variant of
	 this type.  */
      qualified_type 
	= get_qualified_type (type,
			      ((is_const_type ? TYPE_QUAL_CONST : 0)
			       | (is_volatile_type 
				  ? TYPE_QUAL_VOLATILE : 0)));

      /* If we do, then we can just use its DIE, if it exists.  */
      if (qualified_type)
	{
	  mod_type_die = lookup_type_die (qualified_type);
	  if (mod_type_die)
	    return mod_type_die;
	}

      /* Handle C typedef types.  */
      if (qualified_type && TYPE_NAME (qualified_type) 
	  && TREE_CODE (TYPE_NAME (qualified_type)) == TYPE_DECL
	  && DECL_ORIGINAL_TYPE (TYPE_NAME (qualified_type)))
	{
	  tree type_name = TYPE_NAME (qualified_type);
	  tree dtype = TREE_TYPE (type_name);

	  if (qualified_type == dtype)
	    {
	      /* For a named type, use the typedef.  */
	      gen_type_die (qualified_type, context_die);
	      mod_type_die = lookup_type_die (qualified_type);
	    }
	  else if (is_const_type < TYPE_READONLY (dtype)
		   || is_volatile_type < TYPE_VOLATILE (dtype))
	    /* cv-unqualified version of named type.  Just use the unnamed
	       type to which it refers.  */
	    mod_type_die
	      = modified_type_die (DECL_ORIGINAL_TYPE (type_name),
				   is_const_type, is_volatile_type,
				   context_die);

	  /* Else cv-qualified version of named type; fall through.  */
	}

      if (mod_type_die)
	/* OK.  */
	;
      else if (is_const_type)
	{
	  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die, type);
	  sub_die = modified_type_die (type, 0, is_volatile_type, context_die);
	}
      else if (is_volatile_type)
	{
	  mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die, type);
	  sub_die = modified_type_die (type, 0, 0, context_die);
	}
      else if (code == POINTER_TYPE)
	{
	  mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die, type);
	  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);
#if 0
	  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);
#endif
	  item_type = TREE_TYPE (type);
	}
      else if (code == REFERENCE_TYPE)
	{
	  mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die, type);
	  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);
#if 0
	  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);
#endif
	  item_type = TREE_TYPE (type);
	}
      else if (is_base_type (type))
	mod_type_die = base_type_die (type);
      else
	{
	  gen_type_die (type, context_die);

	  /* We have to get the type_main_variant here (and pass that to the
	     `lookup_type_die' routine) because the ..._TYPE node we have
	     might simply be a *copy* of some original type node (where the
	     copy was created to help us keep track of typedef names) and
	     that copy might have a different TYPE_UID from the original
	     ..._TYPE node.  */
	  mod_type_die = lookup_type_die (type_main_variant (type));
	  if (mod_type_die == NULL)
	    abort ();
	}

      /* We want to equate the qualified type to the die below.  */
      type = qualified_type;
    }

  if (type)
    equate_type_number_to_die (type, mod_type_die);
  if (item_type)
    /* We must do this after the equate_type_number_to_die call, in case
       this is a recursive type.  This ensures that the modified_type_die
       recursion will terminate even if the type is recursive.  Recursive
       types are possible in Ada.  */
    sub_die = modified_type_die (item_type,
				 TYPE_READONLY (item_type),
				 TYPE_VOLATILE (item_type),
				 context_die);

  if (sub_die != NULL)
    add_AT_die_ref (mod_type_die, DW_AT_type, sub_die);

  return mod_type_die;
}
