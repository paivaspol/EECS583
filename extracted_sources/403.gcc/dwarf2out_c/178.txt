static rtx
rtl_for_decl_location (decl)
     tree decl;
{
  rtx rtl;

  /* Here we have to decide where we are going to say the parameter "lives"
     (as far as the debugger is concerned).  We only have a couple of
     choices.  GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.

     DECL_RTL normally indicates where the parameter lives during most of the
     activation of the function.  If optimization is enabled however, this
     could be either NULL or else a pseudo-reg.  Both of those cases indicate
     that the parameter doesn't really live anywhere (as far as the code
     generation parts of GCC are concerned) during most of the function's
     activation.  That will happen (for example) if the parameter is never
     referenced within the function.

     We could just generate a location descriptor here for all non-NULL
     non-pseudo values of DECL_RTL and ignore all of the rest, but we can be
     a little nicer than that if we also consider DECL_INCOMING_RTL in cases
     where DECL_RTL is NULL or is a pseudo-reg.

     Note however that we can only get away with using DECL_INCOMING_RTL as
     a backup substitute for DECL_RTL in certain limited cases.  In cases
     where DECL_ARG_TYPE (decl) indicates the same type as TREE_TYPE (decl),
     we can be sure that the parameter was passed using the same type as it is
     declared to have within the function, and that its DECL_INCOMING_RTL
     points us to a place where a value of that type is passed.

     In cases where DECL_ARG_TYPE (decl) and TREE_TYPE (decl) are different,
     we cannot (in general) use DECL_INCOMING_RTL as a substitute for DECL_RTL
     because in these cases DECL_INCOMING_RTL points us to a value of some
     type which is *different* from the type of the parameter itself.  Thus,
     if we tried to use DECL_INCOMING_RTL to generate a location attribute in
     such cases, the debugger would end up (for example) trying to fetch a
     `float' from a place which actually contains the first part of a
     `double'.  That would lead to really incorrect and confusing
     output at debug-time.

     So, in general, we *do not* use DECL_INCOMING_RTL as a backup for DECL_RTL
     in cases where DECL_ARG_TYPE (decl) != TREE_TYPE (decl).  There
     are a couple of exceptions however.  On little-endian machines we can
     get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE (decl) is
     not the same as TREE_TYPE (decl), but only when DECL_ARG_TYPE (decl) is
     an integral type that is smaller than TREE_TYPE (decl). These cases arise
     when (on a little-endian machine) a non-prototyped function has a
     parameter declared to be of type `short' or `char'.  In such cases,
     TREE_TYPE (decl) will be `short' or `char', DECL_ARG_TYPE (decl) will
     be `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the
     passed `int' value.  If the debugger then uses that address to fetch
     a `short' or a `char' (on a little-endian machine) the result will be
     the correct data, so we allow for such exceptional cases below.

     Note that our goal here is to describe the place where the given formal
     parameter lives during most of the function's activation (i.e. between the
     end of the prologue and the start of the epilogue).  We'll do that as best
     as we can. Note however that if the given formal parameter is modified
     sometime during the execution of the function, then a stack backtrace (at
     debug-time) will show the function as having been called with the *new*
     value rather than the value which was originally passed in.  This happens
     rarely enough that it is not a major problem, but it *is* a problem, and
     I'd like to fix it.

     A future version of dwarf2out.c may generate two additional attributes for
     any given DW_TAG_formal_parameter DIE which will describe the "passed
     type" and the "passed location" for the given formal parameter in addition
     to the attributes we now generate to indicate the "declared type" and the
     "active location" for each parameter.  This additional set of attributes
     could be used by debuggers for stack backtraces. Separately, note that
     sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL can be NULL also.
     This happens (for example) for inlined-instances of inline function formal
     parameters which are never referenced.  This really shouldn't be
     happening.  All PARM_DECL nodes should get valid non-NULL
     DECL_INCOMING_RTL values, but integrate.c doesn't currently generate these
     values for inlined instances of inline function parameters, so when we see
     such cases, we are just out-of-luck for the time being (until integrate.c
     gets fixed).  */

  /* Use DECL_RTL as the "location" unless we find something better.  */
  rtl = DECL_RTL_IF_SET (decl);

  /* When generating abstract instances, ignore everything except
     constants and symbols living in memory.  */
  if (! reload_completed)
    {
      if (rtl
	  && (CONSTANT_P (rtl)
	      || (GET_CODE (rtl) == MEM
	          && CONSTANT_P (XEXP (rtl, 0)))))
	{
#ifdef ASM_SIMPLIFY_DWARF_ADDR
	  rtl = ASM_SIMPLIFY_DWARF_ADDR (rtl);
#endif
	  return rtl;
	}
      rtl = NULL_RTX;
    }
  else if (TREE_CODE (decl) == PARM_DECL)
    {
      if (rtl == NULL_RTX || is_pseudo_reg (rtl))
	{
	  tree declared_type = type_main_variant (TREE_TYPE (decl));
	  tree passed_type = type_main_variant (DECL_ARG_TYPE (decl));

	  /* This decl represents a formal parameter which was optimized out.
	     Note that DECL_INCOMING_RTL may be NULL in here, but we handle
	     all cases where (rtl == NULL_RTX) just below.  */
	  if (declared_type == passed_type)
	    rtl = DECL_INCOMING_RTL (decl);
	  else if (! BYTES_BIG_ENDIAN
		   && TREE_CODE (declared_type) == INTEGER_TYPE
		   && (GET_MODE_SIZE (TYPE_MODE (declared_type))
		       <= GET_MODE_SIZE (TYPE_MODE (passed_type))))
	    rtl = DECL_INCOMING_RTL (decl);
	}

      /* If the parm was passed in registers, but lives on the stack, then
	 make a big endian correction if the mode of the type of the
	 parameter is not the same as the mode of the rtl.  */
      /* ??? This is the same series of checks that are made in dbxout.c before
	 we reach the big endian correction code there.  It isn't clear if all
	 of these checks are necessary here, but keeping them all is the safe
	 thing to do.  */
      else if (GET_CODE (rtl) == MEM
	       && XEXP (rtl, 0) != const0_rtx
	       && ! CONSTANT_P (XEXP (rtl, 0))
	       /* Not passed in memory.  */
	       && GET_CODE (DECL_INCOMING_RTL (decl)) != MEM
	       /* Not passed by invisible reference.  */
	       && (GET_CODE (XEXP (rtl, 0)) != REG
		   || REGNO (XEXP (rtl, 0)) == HARD_FRAME_POINTER_REGNUM
		   || REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM
#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM
		   || REGNO (XEXP (rtl, 0)) == ARG_POINTER_REGNUM
#endif
		     )
	       /* Big endian correction check.  */
	       && BYTES_BIG_ENDIAN
	       && TYPE_MODE (TREE_TYPE (decl)) != GET_MODE (rtl)
	       && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl)))
		   < UNITS_PER_WORD))
	{
	  int offset = (UNITS_PER_WORD
			- GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))));

	  rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),
			     plus_constant (XEXP (rtl, 0), offset));
	}
    }

  if (rtl != NULL_RTX)
    {
      rtl = eliminate_regs (rtl, 0, NULL_RTX);
#ifdef LEAF_REG_REMAP
      if (current_function_uses_only_leaf_regs)
	leaf_renumber_regs_insn (rtl);
#endif
    }

  /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,
     and will have been substituted directly into all expressions that use it.
     C does not have such a concept, but C++ and other languages do.  */
  else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))
    {
      /* If a variable is initialized with a string constant without embedded
	 zeros, build CONST_STRING.  */
      if (TREE_CODE (DECL_INITIAL (decl)) == STRING_CST
	  && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)
	{
	  tree arrtype = TREE_TYPE (decl);
	  tree enttype = TREE_TYPE (arrtype);
	  tree domain = TYPE_DOMAIN (arrtype);
	  tree init = DECL_INITIAL (decl);
	  enum machine_mode mode = TYPE_MODE (enttype);

	  if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE_SIZE (mode) == 1
	      && domain
	      && integer_zerop (TYPE_MIN_VALUE (domain))
	      && compare_tree_int (TYPE_MAX_VALUE (domain),
				   TREE_STRING_LENGTH (init) - 1) == 0
	      && ((size_t) TREE_STRING_LENGTH (init)
		  == strlen (TREE_STRING_POINTER (init)) + 1))
	    rtl = gen_rtx_CONST_STRING (VOIDmode, TREE_STRING_POINTER (init));
	}
      /* If the initializer is something that we know will expand into an
	 immediate RTL constant, expand it now.  Expanding anything else
	 tends to produce unresolved symbols; see debug/5770 and c++/6381.  */
      else if (TREE_CODE (DECL_INITIAL (decl)) == INTEGER_CST
	       || TREE_CODE (DECL_INITIAL (decl)) == REAL_CST)
	{
	  rtl = expand_expr (DECL_INITIAL (decl), NULL_RTX, VOIDmode,
			     EXPAND_INITIALIZER);
	  /* If expand_expr returns a MEM, it wasn't immediate.  */
	  if (rtl && GET_CODE (rtl) == MEM)
	    abort ();
	}
    }

#ifdef ASM_SIMPLIFY_DWARF_ADDR
  if (rtl)
    rtl = ASM_SIMPLIFY_DWARF_ADDR (rtl);
#endif
  return rtl;
}
