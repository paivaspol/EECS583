static void
addr_const_to_string (str, x)
     char *str;
     rtx x;
{
  char buf1[256];
  char buf2[256];

restart:
  str[0] = '\0';
  switch (GET_CODE (x))
    {
    case PC:
      if (flag_pic)
	strcat (str, ",");
      else
	abort ();
      break;

    case SYMBOL_REF:
      ASM_NAME_TO_STRING (buf1, XSTR (x, 0));
      strcat (str, buf1);
      break;

    case LABEL_REF:
      ASM_GENERATE_INTERNAL_LABEL (buf1, "L", CODE_LABEL_NUMBER (XEXP (x, 0)));
      ASM_NAME_TO_STRING (buf2, buf1);
      strcat (str, buf2);
      break;

    case CODE_LABEL:
      ASM_GENERATE_INTERNAL_LABEL (buf1, "L", CODE_LABEL_NUMBER (x));
      ASM_NAME_TO_STRING (buf2, buf1);
      strcat (str, buf2);
      break;

    case CONST_INT:
      sprintf (buf1, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));
      strcat (str, buf1);
      break;

    case CONST:
      /* This used to output parentheses around the expression, but that does 
         not work on the 386 (either ATT or BSD assembler).  */
      addr_const_to_string (buf1, XEXP (x, 0));
      strcat (str, buf1);
      break;

    case CONST_DOUBLE:
      if (GET_MODE (x) == VOIDmode)
	{
	  /* We can use %d if the number is one word and positive.  */
	  if (CONST_DOUBLE_HIGH (x))
	    sprintf (buf1, HOST_WIDE_INT_PRINT_DOUBLE_HEX,
		     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));
	  else if (CONST_DOUBLE_LOW (x) < 0)
	    sprintf (buf1, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_LOW (x));
	  else
	    sprintf (buf1, HOST_WIDE_INT_PRINT_DEC,
		     CONST_DOUBLE_LOW (x));
	  strcat (str, buf1);
	}
      else
	/* We can't handle floating point constants; PRINT_OPERAND must
	   handle them.  */
	output_operand_lossage ("floating constant misused");
      break;

    case PLUS:
      /* Some assemblers need integer constants to appear last (eg masm).  */
      if (GET_CODE (XEXP (x, 0)) == CONST_INT)
	{
	  addr_const_to_string (buf1, XEXP (x, 1));
	  strcat (str, buf1);
	  if (INTVAL (XEXP (x, 0)) >= 0)
	    strcat (str, "+");
	  addr_const_to_string (buf1, XEXP (x, 0));
	  strcat (str, buf1);
	}
      else
	{
	  addr_const_to_string (buf1, XEXP (x, 0));
	  strcat (str, buf1);
	  if (INTVAL (XEXP (x, 1)) >= 0)
	    strcat (str, "+");
	  addr_const_to_string (buf1, XEXP (x, 1));
	  strcat (str, buf1);
	}
      break;

    case MINUS:
      /* Avoid outputting things like x-x or x+5-x, since some assemblers
         can't handle that.  */
      x = simplify_subtraction (x);
      if (GET_CODE (x) != MINUS)
	goto restart;

      addr_const_to_string (buf1, XEXP (x, 0));
      strcat (str, buf1);
      strcat (str, "-");
      if (GET_CODE (XEXP (x, 1)) == CONST_INT
	  && INTVAL (XEXP (x, 1)) < 0)
	{
	  strcat (str, "(");
	  addr_const_to_string (buf1, XEXP (x, 1));
	  strcat (str, buf1);
	  strcat (str, ")");
	}
      else
	{
	  addr_const_to_string (buf1, XEXP (x, 1));
	  strcat (str, buf1);
	}
      break;

    case ZERO_EXTEND:
    case SIGN_EXTEND:
      addr_const_to_string (buf1, XEXP (x, 0));
      strcat (str, buf1);
      break;

    default:
      output_operand_lossage ("invalid expression as operand");
    }
}
