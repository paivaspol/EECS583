void
convert_move (to, from, unsignedp)
     rtx to, from;
     int unsignedp;
{
  enum machine_mode to_mode = GET_MODE (to);
  enum machine_mode from_mode = GET_MODE (from);
  int to_real = GET_MODE_CLASS (to_mode) == MODE_FLOAT;
  int from_real = GET_MODE_CLASS (from_mode) == MODE_FLOAT;
  enum insn_code code;
  rtx libcall;

  /* rtx code for making an equivalent value.  */
  enum rtx_code equiv_code = (unsignedp ? ZERO_EXTEND : SIGN_EXTEND);

  to = protect_from_queue (to, 1);
  from = protect_from_queue (from, 0);

  if (to_real != from_real)
    abort ();

  /* If FROM is a SUBREG that indicates that we have already done at least
     the required extension, strip it.  We don't handle such SUBREGs as
     TO here.  */

  if (GET_CODE (from) == SUBREG && SUBREG_PROMOTED_VAR_P (from)
      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (from)))
	  >= GET_MODE_SIZE (to_mode))
      && SUBREG_PROMOTED_UNSIGNED_P (from) == unsignedp)
    from = gen_lowpart (to_mode, from), from_mode = to_mode;

  if (GET_CODE (to) == SUBREG && SUBREG_PROMOTED_VAR_P (to))
    abort ();

  if (to_mode == from_mode
      || (from_mode == VOIDmode && CONSTANT_P (from)))
    {
      emit_move_insn (to, from);
      return;
    }

  if (VECTOR_MODE_P (to_mode) || VECTOR_MODE_P (from_mode))
    {
      if (GET_MODE_BITSIZE (from_mode) != GET_MODE_BITSIZE (to_mode))
	abort ();

      if (VECTOR_MODE_P (to_mode))
	from = simplify_gen_subreg (to_mode, from, GET_MODE (from), 0);
      else
	to = simplify_gen_subreg (from_mode, to, GET_MODE (to), 0);

      emit_move_insn (to, from);
      return;
    }

  if (to_real != from_real)
    abort ();

  if (to_real)
    {
      rtx value, insns;

      if (GET_MODE_BITSIZE (from_mode) < GET_MODE_BITSIZE (to_mode))
	{
	  /* Try converting directly if the insn is supported.  */
	  if ((code = can_extend_p (to_mode, from_mode, 0))
	      != CODE_FOR_nothing)
	    {
	      emit_unop_insn (code, to, from, UNKNOWN);
	      return;
	    }
	}

#ifdef HAVE_trunchfqf2
      if (HAVE_trunchfqf2 && from_mode == HFmode && to_mode == QFmode)
	{
	  emit_unop_insn (CODE_FOR_trunchfqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_trunctqfqf2
      if (HAVE_trunctqfqf2 && from_mode == TQFmode && to_mode == QFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctqfqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncsfqf2
      if (HAVE_truncsfqf2 && from_mode == SFmode && to_mode == QFmode)
	{
	  emit_unop_insn (CODE_FOR_truncsfqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncdfqf2
      if (HAVE_truncdfqf2 && from_mode == DFmode && to_mode == QFmode)
	{
	  emit_unop_insn (CODE_FOR_truncdfqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncxfqf2
      if (HAVE_truncxfqf2 && from_mode == XFmode && to_mode == QFmode)
	{
	  emit_unop_insn (CODE_FOR_truncxfqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_trunctfqf2
      if (HAVE_trunctfqf2 && from_mode == TFmode && to_mode == QFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctfqf2, to, from, UNKNOWN);
	  return;
	}
#endif

#ifdef HAVE_trunctqfhf2
      if (HAVE_trunctqfhf2 && from_mode == TQFmode && to_mode == HFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctqfhf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncsfhf2
      if (HAVE_truncsfhf2 && from_mode == SFmode && to_mode == HFmode)
	{
	  emit_unop_insn (CODE_FOR_truncsfhf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncdfhf2
      if (HAVE_truncdfhf2 && from_mode == DFmode && to_mode == HFmode)
	{
	  emit_unop_insn (CODE_FOR_truncdfhf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncxfhf2
      if (HAVE_truncxfhf2 && from_mode == XFmode && to_mode == HFmode)
	{
	  emit_unop_insn (CODE_FOR_truncxfhf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_trunctfhf2
      if (HAVE_trunctfhf2 && from_mode == TFmode && to_mode == HFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctfhf2, to, from, UNKNOWN);
	  return;
	}
#endif

#ifdef HAVE_truncsftqf2
      if (HAVE_truncsftqf2 && from_mode == SFmode && to_mode == TQFmode)
	{
	  emit_unop_insn (CODE_FOR_truncsftqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncdftqf2
      if (HAVE_truncdftqf2 && from_mode == DFmode && to_mode == TQFmode)
	{
	  emit_unop_insn (CODE_FOR_truncdftqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncxftqf2
      if (HAVE_truncxftqf2 && from_mode == XFmode && to_mode == TQFmode)
	{
	  emit_unop_insn (CODE_FOR_truncxftqf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_trunctftqf2
      if (HAVE_trunctftqf2 && from_mode == TFmode && to_mode == TQFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctftqf2, to, from, UNKNOWN);
	  return;
	}
#endif

#ifdef HAVE_truncdfsf2
      if (HAVE_truncdfsf2 && from_mode == DFmode && to_mode == SFmode)
	{
	  emit_unop_insn (CODE_FOR_truncdfsf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncxfsf2
      if (HAVE_truncxfsf2 && from_mode == XFmode && to_mode == SFmode)
	{
	  emit_unop_insn (CODE_FOR_truncxfsf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_trunctfsf2
      if (HAVE_trunctfsf2 && from_mode == TFmode && to_mode == SFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctfsf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_truncxfdf2
      if (HAVE_truncxfdf2 && from_mode == XFmode && to_mode == DFmode)
	{
	  emit_unop_insn (CODE_FOR_truncxfdf2, to, from, UNKNOWN);
	  return;
	}
#endif
#ifdef HAVE_trunctfdf2
      if (HAVE_trunctfdf2 && from_mode == TFmode && to_mode == DFmode)
	{
	  emit_unop_insn (CODE_FOR_trunctfdf2, to, from, UNKNOWN);
	  return;
	}
#endif

      libcall = (rtx) 0;
      switch (from_mode)
	{
	case SFmode:
	  switch (to_mode)
	    {
	    case DFmode:
	      libcall = extendsfdf2_libfunc;
	      break;

	    case XFmode:
	      libcall = extendsfxf2_libfunc;
	      break;

	    case TFmode:
	      libcall = extendsftf2_libfunc;
	      break;

	    default:
	      break;
	    }
	  break;

	case DFmode:
	  switch (to_mode)
	    {
	    case SFmode:
	      libcall = truncdfsf2_libfunc;
	      break;

	    case XFmode:
	      libcall = extenddfxf2_libfunc;
	      break;

	    case TFmode:
	      libcall = extenddftf2_libfunc;
	      break;

	    default:
	      break;
	    }
	  break;

	case XFmode:
	  switch (to_mode)
	    {
	    case SFmode:
	      libcall = truncxfsf2_libfunc;
	      break;

	    case DFmode:
	      libcall = truncxfdf2_libfunc;
	      break;

	    default:
	      break;
	    }
	  break;

	case TFmode:
	  switch (to_mode)
	    {
	    case SFmode:
	      libcall = trunctfsf2_libfunc;
	      break;

	    case DFmode:
	      libcall = trunctfdf2_libfunc;
	      break;

	    default:
	      break;
	    }
	  break;

	default:
	  break;
	}

      if (libcall == (rtx) 0)
	/* This conversion is not implemented yet.  */
	abort ();

      start_sequence ();
      value = emit_library_call_value (libcall, NULL_RTX, LCT_CONST, to_mode,
				       1, from, from_mode);
      insns = get_insns ();
      end_sequence ();
      emit_libcall_block (insns, to, value, gen_rtx_FLOAT_TRUNCATE (to_mode,
								    from));
      return;
    }

  /* Now both modes are integers.  */

  /* Handle expanding beyond a word.  */
  if (GET_MODE_BITSIZE (from_mode) < GET_MODE_BITSIZE (to_mode)
      && GET_MODE_BITSIZE (to_mode) > BITS_PER_WORD)
    {
      rtx insns;
      rtx lowpart;
      rtx fill_value;
      rtx lowfrom;
      int i;
      enum machine_mode lowpart_mode;
      int nwords = CEIL (GET_MODE_SIZE (to_mode), UNITS_PER_WORD);

      /* Try converting directly if the insn is supported.  */
      if ((code = can_extend_p (to_mode, from_mode, unsignedp))
	  != CODE_FOR_nothing)
	{
	  /* If FROM is a SUBREG, put it into a register.  Do this
	     so that we always generate the same set of insns for
	     better cse'ing; if an intermediate assignment occurred,
	     we won't be doing the operation directly on the SUBREG.  */
	  if (optimize > 0 && GET_CODE (from) == SUBREG)
	    from = force_reg (from_mode, from);
	  emit_unop_insn (code, to, from, equiv_code);
	  return;
	}
      /* Next, try converting via full word.  */
      else if (GET_MODE_BITSIZE (from_mode) < BITS_PER_WORD
	       && ((code = can_extend_p (to_mode, word_mode, unsignedp))
		   != CODE_FOR_nothing))
	{
	  if (GET_CODE (to) == REG)
	    emit_insn (gen_rtx_CLOBBER (VOIDmode, to));
	  convert_move (gen_lowpart (word_mode, to), from, unsignedp);
	  emit_unop_insn (code, to,
			  gen_lowpart (word_mode, to), equiv_code);
	  return;
	}

      /* No special multiword conversion insn; do it by hand.  */
      start_sequence ();

      /* Since we will turn this into a no conflict block, we must ensure
	 that the source does not overlap the target.  */

      if (reg_overlap_mentioned_p (to, from))
	from = force_reg (from_mode, from);

      /* Get a copy of FROM widened to a word, if necessary.  */
      if (GET_MODE_BITSIZE (from_mode) < BITS_PER_WORD)
	lowpart_mode = word_mode;
      else
	lowpart_mode = from_mode;

      lowfrom = convert_to_mode (lowpart_mode, from, unsignedp);

      lowpart = gen_lowpart (lowpart_mode, to);
      emit_move_insn (lowpart, lowfrom);

      /* Compute the value to put in each remaining word.  */
      if (unsignedp)
	fill_value = const0_rtx;
      else
	{
#ifdef HAVE_slt
	  if (HAVE_slt
	      && insn_data[(int) CODE_FOR_slt].operand[0].mode == word_mode
	      && STORE_FLAG_VALUE == -1)
	    {
	      emit_cmp_insn (lowfrom, const0_rtx, NE, NULL_RTX,
			     lowpart_mode, 0);
	      fill_value = gen_reg_rtx (word_mode);
	      emit_insn (gen_slt (fill_value));
	    }
	  else
#endif
	    {
	      fill_value
		= expand_shift (RSHIFT_EXPR, lowpart_mode, lowfrom,
				size_int (GET_MODE_BITSIZE (lowpart_mode) - 1),
				NULL_RTX, 0);
	      fill_value = convert_to_mode (word_mode, fill_value, 1);
	    }
	}

      /* Fill the remaining words.  */
      for (i = GET_MODE_SIZE (lowpart_mode) / UNITS_PER_WORD; i < nwords; i++)
	{
	  int index = (WORDS_BIG_ENDIAN ? nwords - i - 1 : i);
	  rtx subword = operand_subword (to, index, 1, to_mode);

	  if (subword == 0)
	    abort ();

	  if (fill_value != subword)
	    emit_move_insn (subword, fill_value);
	}

      insns = get_insns ();
      end_sequence ();

      emit_no_conflict_block (insns, to, from, NULL_RTX,
			      gen_rtx_fmt_e (equiv_code, to_mode, copy_rtx (from)));
      return;
    }

  /* Truncating multi-word to a word or less.  */
  if (GET_MODE_BITSIZE (from_mode) > BITS_PER_WORD
      && GET_MODE_BITSIZE (to_mode) <= BITS_PER_WORD)
    {
      if (!((GET_CODE (from) == MEM
	     && ! MEM_VOLATILE_P (from)
	     && direct_load[(int) to_mode]
	     && ! mode_dependent_address_p (XEXP (from, 0)))
	    || GET_CODE (from) == REG
	    || GET_CODE (from) == SUBREG))
	from = force_reg (from_mode, from);
      convert_move (to, gen_lowpart (word_mode, from), 0);
      return;
    }

  /* Handle pointer conversion.  */			/* SPEE 900220.  */
  if (to_mode == PQImode)
    {
      if (from_mode != QImode)
	from = convert_to_mode (QImode, from, unsignedp);

#ifdef HAVE_truncqipqi2
      if (HAVE_truncqipqi2)
	{
	  emit_unop_insn (CODE_FOR_truncqipqi2, to, from, UNKNOWN);
	  return;
	}
#endif /* HAVE_truncqipqi2 */
      abort ();
    }

  if (from_mode == PQImode)
    {
      if (to_mode != QImode)
	{
	  from = convert_to_mode (QImode, from, unsignedp);
	  from_mode = QImode;
	}
      else
	{
#ifdef HAVE_extendpqiqi2
	  if (HAVE_extendpqiqi2)
	    {
	      emit_unop_insn (CODE_FOR_extendpqiqi2, to, from, UNKNOWN);
	      return;
	    }
#endif /* HAVE_extendpqiqi2 */
	  abort ();
	}
    }

  if (to_mode == PSImode)
    {
      if (from_mode != SImode)
	from = convert_to_mode (SImode, from, unsignedp);

#ifdef HAVE_truncsipsi2
      if (HAVE_truncsipsi2)
	{
	  emit_unop_insn (CODE_FOR_truncsipsi2, to, from, UNKNOWN);
	  return;
	}
#endif /* HAVE_truncsipsi2 */
      abort ();
    }

  if (from_mode == PSImode)
    {
      if (to_mode != SImode)
	{
	  from = convert_to_mode (SImode, from, unsignedp);
	  from_mode = SImode;
	}
      else
	{
#ifdef HAVE_extendpsisi2
	  if (! unsignedp && HAVE_extendpsisi2)
	    {
	      emit_unop_insn (CODE_FOR_extendpsisi2, to, from, UNKNOWN);
	      return;
	    }
#endif /* HAVE_extendpsisi2 */
#ifdef HAVE_zero_extendpsisi2
	  if (unsignedp && HAVE_zero_extendpsisi2)
	    {
	      emit_unop_insn (CODE_FOR_zero_extendpsisi2, to, from, UNKNOWN);
	      return;
	    }
#endif /* HAVE_zero_extendpsisi2 */
	  abort ();
	}
    }

  if (to_mode == PDImode)
    {
      if (from_mode != DImode)
	from = convert_to_mode (DImode, from, unsignedp);

#ifdef HAVE_truncdipdi2
      if (HAVE_truncdipdi2)
	{
	  emit_unop_insn (CODE_FOR_truncdipdi2, to, from, UNKNOWN);
	  return;
	}
#endif /* HAVE_truncdipdi2 */
      abort ();
    }

  if (from_mode == PDImode)
    {
      if (to_mode != DImode)
	{
	  from = convert_to_mode (DImode, from, unsignedp);
	  from_mode = DImode;
	}
      else
	{
#ifdef HAVE_extendpdidi2
	  if (HAVE_extendpdidi2)
	    {
	      emit_unop_insn (CODE_FOR_extendpdidi2, to, from, UNKNOWN);
	      return;
	    }
#endif /* HAVE_extendpdidi2 */
	  abort ();
	}
    }

  /* Now follow all the conversions between integers
     no more than a word long.  */

  /* For truncation, usually we can just refer to FROM in a narrower mode.  */
  if (GET_MODE_BITSIZE (to_mode) < GET_MODE_BITSIZE (from_mode)
      && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (to_mode),
				GET_MODE_BITSIZE (from_mode)))
    {
      if (!((GET_CODE (from) == MEM
	     && ! MEM_VOLATILE_P (from)
	     && direct_load[(int) to_mode]
	     && ! mode_dependent_address_p (XEXP (from, 0)))
	    || GET_CODE (from) == REG
	    || GET_CODE (from) == SUBREG))
	from = force_reg (from_mode, from);
      if (GET_CODE (from) == REG && REGNO (from) < FIRST_PSEUDO_REGISTER
	  && ! HARD_REGNO_MODE_OK (REGNO (from), to_mode))
	from = copy_to_reg (from);
      emit_move_insn (to, gen_lowpart (to_mode, from));
      return;
    }

  /* Handle extension.  */
  if (GET_MODE_BITSIZE (to_mode) > GET_MODE_BITSIZE (from_mode))
    {
      /* Convert directly if that works.  */
      if ((code = can_extend_p (to_mode, from_mode, unsignedp))
	  != CODE_FOR_nothing)
	{
	  if (flag_force_mem)
	    from = force_not_mem (from);

	  emit_unop_insn (code, to, from, equiv_code);
	  return;
	}
      else
	{
	  enum machine_mode intermediate;
	  rtx tmp;
	  tree shift_amount;

	  /* Search for a mode to convert via.  */
	  for (intermediate = from_mode; intermediate != VOIDmode;
	       intermediate = GET_MODE_WIDER_MODE (intermediate))
	    if (((can_extend_p (to_mode, intermediate, unsignedp)
		  != CODE_FOR_nothing)
		 || (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (intermediate)
		     && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (to_mode),
					       GET_MODE_BITSIZE (intermediate))))
		&& (can_extend_p (intermediate, from_mode, unsignedp)
		    != CODE_FOR_nothing))
	      {
		convert_move (to, convert_to_mode (intermediate, from,
						   unsignedp), unsignedp);
		return;
	      }

	  /* No suitable intermediate mode.
	     Generate what we need with	shifts.  */
	  shift_amount = build_int_2 (GET_MODE_BITSIZE (to_mode)
				      - GET_MODE_BITSIZE (from_mode), 0);
	  from = gen_lowpart (to_mode, force_reg (from_mode, from));
	  tmp = expand_shift (LSHIFT_EXPR, to_mode, from, shift_amount,
			      to, unsignedp);
	  tmp = expand_shift (RSHIFT_EXPR, to_mode, tmp, shift_amount,
			      to, unsignedp);
	  if (tmp != to)
	    emit_move_insn (to, tmp);
	  return;
	}
    }

  /* Support special truncate insns for certain modes.  */

  if (from_mode == DImode && to_mode == SImode)
    {
#ifdef HAVE_truncdisi2
      if (HAVE_truncdisi2)
	{
	  emit_unop_insn (CODE_FOR_truncdisi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == DImode && to_mode == HImode)
    {
#ifdef HAVE_truncdihi2
      if (HAVE_truncdihi2)
	{
	  emit_unop_insn (CODE_FOR_truncdihi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == DImode && to_mode == QImode)
    {
#ifdef HAVE_truncdiqi2
      if (HAVE_truncdiqi2)
	{
	  emit_unop_insn (CODE_FOR_truncdiqi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == SImode && to_mode == HImode)
    {
#ifdef HAVE_truncsihi2
      if (HAVE_truncsihi2)
	{
	  emit_unop_insn (CODE_FOR_truncsihi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == SImode && to_mode == QImode)
    {
#ifdef HAVE_truncsiqi2
      if (HAVE_truncsiqi2)
	{
	  emit_unop_insn (CODE_FOR_truncsiqi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == HImode && to_mode == QImode)
    {
#ifdef HAVE_trunchiqi2
      if (HAVE_trunchiqi2)
	{
	  emit_unop_insn (CODE_FOR_trunchiqi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == TImode && to_mode == DImode)
    {
#ifdef HAVE_trunctidi2
      if (HAVE_trunctidi2)
	{
	  emit_unop_insn (CODE_FOR_trunctidi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == TImode && to_mode == SImode)
    {
#ifdef HAVE_trunctisi2
      if (HAVE_trunctisi2)
	{
	  emit_unop_insn (CODE_FOR_trunctisi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == TImode && to_mode == HImode)
    {
#ifdef HAVE_trunctihi2
      if (HAVE_trunctihi2)
	{
	  emit_unop_insn (CODE_FOR_trunctihi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  if (from_mode == TImode && to_mode == QImode)
    {
#ifdef HAVE_trunctiqi2
      if (HAVE_trunctiqi2)
	{
	  emit_unop_insn (CODE_FOR_trunctiqi2, to, from, UNKNOWN);
	  return;
	}
#endif
      convert_move (to, force_reg (from_mode, from), unsignedp);
      return;
    }

  /* Handle truncation of volatile memrefs, and so on;
     the things that couldn't be truncated directly,
     and for which there was no special instruction.  */
  if (GET_MODE_BITSIZE (to_mode) < GET_MODE_BITSIZE (from_mode))
    {
      rtx temp = force_reg (to_mode, gen_lowpart (to_mode, from));
      emit_move_insn (to, temp);
      return;
    }

  /* Mode combination is not recognized.  */
  abort ();
}
