static void
store_constructor (exp, target, cleared, size)
     tree exp;
     rtx target;
     int cleared;
     HOST_WIDE_INT size;
{
  tree type = TREE_TYPE (exp);
#ifdef WORD_REGISTER_OPERATIONS
  HOST_WIDE_INT exp_size = int_size_in_bytes (type);
#endif

  if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE
      || TREE_CODE (type) == QUAL_UNION_TYPE)
    {
      tree elt;

      /* We either clear the aggregate or indicate the value is dead.  */
      if ((TREE_CODE (type) == UNION_TYPE
	   || TREE_CODE (type) == QUAL_UNION_TYPE)
	  && ! cleared
	  && ! CONSTRUCTOR_ELTS (exp))
	/* If the constructor is empty, clear the union.  */
	{
	  clear_storage (target, expr_size (exp));
	  cleared = 1;
	}

      /* If we are building a static constructor into a register,
	 set the initial value as zero so we can fold the value into
	 a constant.  But if more than one register is involved,
	 this probably loses.  */
      else if (! cleared && GET_CODE (target) == REG && TREE_STATIC (exp)
	       && GET_MODE_SIZE (GET_MODE (target)) <= UNITS_PER_WORD)
	{
	  emit_move_insn (target, CONST0_RTX (GET_MODE (target)));
	  cleared = 1;
	}

      /* If the constructor has fewer fields than the structure
	 or if we are initializing the structure to mostly zeros,
	 clear the whole structure first.  Don't do this if TARGET is a
	 register whose mode size isn't equal to SIZE since clear_storage
	 can't handle this case.  */
      else if (! cleared && size > 0
	       && ((list_length (CONSTRUCTOR_ELTS (exp))
		    != fields_length (type))
		   || mostly_zeros_p (exp))
	       && (GET_CODE (target) != REG
		   || ((HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (target))
		       == size)))
	{
	  clear_storage (target, GEN_INT (size));
	  cleared = 1;
	}

      if (! cleared)
	emit_insn (gen_rtx_CLOBBER (VOIDmode, target));

      /* Store each element of the constructor into
	 the corresponding field of TARGET.  */

      for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))
	{
	  tree field = TREE_PURPOSE (elt);
	  tree value = TREE_VALUE (elt);
	  enum machine_mode mode;
	  HOST_WIDE_INT bitsize;
	  HOST_WIDE_INT bitpos = 0;
	  int unsignedp;
	  tree offset;
	  rtx to_rtx = target;

	  /* Just ignore missing fields.
	     We cleared the whole structure, above,
	     if any fields are missing.  */
	  if (field == 0)
	    continue;

	  if (cleared && is_zeros_p (value))
	    continue;

	  if (host_integerp (DECL_SIZE (field), 1))
	    bitsize = tree_low_cst (DECL_SIZE (field), 1);
	  else
	    bitsize = -1;

	  unsignedp = TREE_UNSIGNED (field);
	  mode = DECL_MODE (field);
	  if (DECL_BIT_FIELD (field))
	    mode = VOIDmode;

	  offset = DECL_FIELD_OFFSET (field);
	  if (host_integerp (offset, 0)
	      && host_integerp (bit_position (field), 0))
	    {
	      bitpos = int_bit_position (field);
	      offset = 0;
	    }
	  else
	    bitpos = tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 0);

	  if (offset)
	    {
	      rtx offset_rtx;

	      if (contains_placeholder_p (offset))
		offset = build (WITH_RECORD_EXPR, sizetype,
				offset, make_tree (TREE_TYPE (exp), target));

	      offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);
	      if (GET_CODE (to_rtx) != MEM)
		abort ();

#ifdef POINTERS_EXTEND_UNSIGNED
	      if (GET_MODE (offset_rtx) != Pmode)
		offset_rtx = convert_memory_address (Pmode, offset_rtx);
#else
	      if (GET_MODE (offset_rtx) != ptr_mode)
		offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);
#endif

	      to_rtx = offset_address (to_rtx, offset_rtx,
				       highest_pow2_factor (offset));
	    }

	  if (TREE_READONLY (field))
	    {
	      if (GET_CODE (to_rtx) == MEM)
		to_rtx = copy_rtx (to_rtx);

	      RTX_UNCHANGING_P (to_rtx) = 1;
	    }

#ifdef WORD_REGISTER_OPERATIONS
	  /* If this initializes a field that is smaller than a word, at the
	     start of a word, try to widen it to a full word.
	     This special case allows us to output C++ member function
	     initializations in a form that the optimizers can understand.  */
	  if (GET_CODE (target) == REG
	      && bitsize < BITS_PER_WORD
	      && bitpos % BITS_PER_WORD == 0
	      && GET_MODE_CLASS (mode) == MODE_INT
	      && TREE_CODE (value) == INTEGER_CST
	      && exp_size >= 0
	      && bitpos + BITS_PER_WORD <= exp_size * BITS_PER_UNIT)
	    {
	      tree type = TREE_TYPE (value);

	      if (TYPE_PRECISION (type) < BITS_PER_WORD)
		{
		  type = type_for_size (BITS_PER_WORD, TREE_UNSIGNED (type));
		  value = convert (type, value);
		}

	      if (BYTES_BIG_ENDIAN)
		value
		  = fold (build (LSHIFT_EXPR, type, value,
				 build_int_2 (BITS_PER_WORD - bitsize, 0)));
	      bitsize = BITS_PER_WORD;
	      mode = word_mode;
	    }
#endif

	  if (GET_CODE (to_rtx) == MEM && !MEM_KEEP_ALIAS_SET_P (to_rtx)
	      && DECL_NONADDRESSABLE_P (field))
	    {
	      to_rtx = copy_rtx (to_rtx);
	      MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;
	    }

	  store_constructor_field (to_rtx, bitsize, bitpos, mode,
				   value, type, cleared,
				   get_alias_set (TREE_TYPE (field)));
	}
    }
  else if (TREE_CODE (type) == ARRAY_TYPE
	   || TREE_CODE (type) == VECTOR_TYPE)
    {
      tree elt;
      int i;
      int need_to_clear;
      tree domain = TYPE_DOMAIN (type);
      tree elttype = TREE_TYPE (type);
      int const_bounds_p;
      HOST_WIDE_INT minelt = 0;
      HOST_WIDE_INT maxelt = 0;

      /* Vectors are like arrays, but the domain is stored via an array
	 type indirectly.  */
      if (TREE_CODE (type) == VECTOR_TYPE)
	{
	  /* Note that although TYPE_DEBUG_REPRESENTATION_TYPE uses
	     the same field as TYPE_DOMAIN, we are not guaranteed that
	     it always will.  */
	  domain = TYPE_DEBUG_REPRESENTATION_TYPE (type);
	  domain = TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (domain)));
	}

      const_bounds_p = (TYPE_MIN_VALUE (domain)
			&& TYPE_MAX_VALUE (domain)
			&& host_integerp (TYPE_MIN_VALUE (domain), 0)
			&& host_integerp (TYPE_MAX_VALUE (domain), 0));

      /* If we have constant bounds for the range of the type, get them.  */
      if (const_bounds_p)
	{
	  minelt = tree_low_cst (TYPE_MIN_VALUE (domain), 0);
	  maxelt = tree_low_cst (TYPE_MAX_VALUE (domain), 0);
	}

      /* If the constructor has fewer elements than the array,
         clear the whole array first.  Similarly if this is
         static constructor of a non-BLKmode object.  */
      if (cleared || (GET_CODE (target) == REG && TREE_STATIC (exp)))
	need_to_clear = 1;
      else
	{
	  HOST_WIDE_INT count = 0, zero_count = 0;
	  need_to_clear = ! const_bounds_p;

	  /* This loop is a more accurate version of the loop in
	     mostly_zeros_p (it handles RANGE_EXPR in an index).
	     It is also needed to check for missing elements.  */
	  for (elt = CONSTRUCTOR_ELTS (exp);
	       elt != NULL_TREE && ! need_to_clear;
	       elt = TREE_CHAIN (elt))
	    {
	      tree index = TREE_PURPOSE (elt);
	      HOST_WIDE_INT this_node_count;

	      if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)
		{
		  tree lo_index = TREE_OPERAND (index, 0);
		  tree hi_index = TREE_OPERAND (index, 1);

		  if (! host_integerp (lo_index, 1)
		      || ! host_integerp (hi_index, 1))
		    {
		      need_to_clear = 1;
		      break;
		    }

		  this_node_count = (tree_low_cst (hi_index, 1)
				     - tree_low_cst (lo_index, 1) + 1);
		}
	      else
		this_node_count = 1;

	      count += this_node_count;
	      if (mostly_zeros_p (TREE_VALUE (elt)))
		zero_count += this_node_count;
	    }

	  /* Clear the entire array first if there are any missing elements,
	     or if the incidence of zero elements is >= 75%.  */
	  if (! need_to_clear
	      && (count < maxelt - minelt + 1 || 4 * zero_count >= 3 * count))
	    need_to_clear = 1;
	}

      if (need_to_clear && size > 0)
	{
	  if (! cleared)
	    {
	      if (REG_P (target))
		emit_move_insn (target,  CONST0_RTX (GET_MODE (target)));
	      else
		clear_storage (target, GEN_INT (size));
	    }
	  cleared = 1;
	}
      else if (REG_P (target))
	/* Inform later passes that the old value is dead.  */
	emit_insn (gen_rtx_CLOBBER (VOIDmode, target));

      /* Store each element of the constructor into
	 the corresponding element of TARGET, determined
	 by counting the elements.  */
      for (elt = CONSTRUCTOR_ELTS (exp), i = 0;
	   elt;
	   elt = TREE_CHAIN (elt), i++)
	{
	  enum machine_mode mode;
	  HOST_WIDE_INT bitsize;
	  HOST_WIDE_INT bitpos;
	  int unsignedp;
	  tree value = TREE_VALUE (elt);
	  tree index = TREE_PURPOSE (elt);
	  rtx xtarget = target;

	  if (cleared && is_zeros_p (value))
	    continue;

	  unsignedp = TREE_UNSIGNED (elttype);
	  mode = TYPE_MODE (elttype);
	  if (mode == BLKmode)
	    bitsize = (host_integerp (TYPE_SIZE (elttype), 1)
		       ? tree_low_cst (TYPE_SIZE (elttype), 1)
		       : -1);
	  else
	    bitsize = GET_MODE_BITSIZE (mode);

	  if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)
	    {
	      tree lo_index = TREE_OPERAND (index, 0);
	      tree hi_index = TREE_OPERAND (index, 1);
	      rtx index_r, pos_rtx, hi_r, loop_top, loop_end;
	      struct nesting *loop;
	      HOST_WIDE_INT lo, hi, count;
	      tree position;

	      /* If the range is constant and "small", unroll the loop.  */
	      if (const_bounds_p
		  && host_integerp (lo_index, 0)
		  && host_integerp (hi_index, 0)
		  && (lo = tree_low_cst (lo_index, 0),
		      hi = tree_low_cst (hi_index, 0),
		      count = hi - lo + 1,
		      (GET_CODE (target) != MEM
		       || count <= 2
		       || (host_integerp (TYPE_SIZE (elttype), 1)
			   && (tree_low_cst (TYPE_SIZE (elttype), 1) * count
			       <= 40 * 8)))))
		{
		  lo -= minelt;  hi -= minelt;
		  for (; lo <= hi; lo++)
		    {
		      bitpos = lo * tree_low_cst (TYPE_SIZE (elttype), 0);

		      if (GET_CODE (target) == MEM
			  && !MEM_KEEP_ALIAS_SET_P (target)
			  && TREE_CODE (type) == ARRAY_TYPE
			  && TYPE_NONALIASED_COMPONENT (type))
			{
			  target = copy_rtx (target);
			  MEM_KEEP_ALIAS_SET_P (target) = 1;
			}

		      store_constructor_field
			(target, bitsize, bitpos, mode, value, type, cleared,
			 get_alias_set (elttype));
		    }
		}
	      else
		{
		  hi_r = expand_expr (hi_index, NULL_RTX, VOIDmode, 0);
		  loop_top = gen_label_rtx ();
		  loop_end = gen_label_rtx ();

		  unsignedp = TREE_UNSIGNED (domain);

		  index = build_decl (VAR_DECL, NULL_TREE, domain);

		  index_r
		    = gen_reg_rtx (promote_mode (domain, DECL_MODE (index),
						 &unsignedp, 0));
		  SET_DECL_RTL (index, index_r);
		  if (TREE_CODE (value) == SAVE_EXPR
		      && SAVE_EXPR_RTL (value) == 0)
		    {
		      /* Make sure value gets expanded once before the
                         loop.  */
		      expand_expr (value, const0_rtx, VOIDmode, 0);
		      emit_queue ();
		    }
		  store_expr (lo_index, index_r, 0);
		  loop = expand_start_loop (0);

		  /* Assign value to element index.  */
		  position
		    = convert (ssizetype,
			       fold (build (MINUS_EXPR, TREE_TYPE (index),
					    index, TYPE_MIN_VALUE (domain))));
		  position = size_binop (MULT_EXPR, position,
					 convert (ssizetype,
						  TYPE_SIZE_UNIT (elttype)));

		  pos_rtx = expand_expr (position, 0, VOIDmode, 0);
		  xtarget = offset_address (target, pos_rtx,
					    highest_pow2_factor (position));
		  xtarget = adjust_address (xtarget, mode, 0);
		  if (TREE_CODE (value) == CONSTRUCTOR)
		    store_constructor (value, xtarget, cleared,
				       bitsize / BITS_PER_UNIT);
		  else
		    store_expr (value, xtarget, 0);

		  expand_exit_loop_if_false (loop,
					     build (LT_EXPR, integer_type_node,
						    index, hi_index));

		  expand_increment (build (PREINCREMENT_EXPR,
					   TREE_TYPE (index),
					   index, integer_one_node), 0, 0);
		  expand_end_loop ();
		  emit_label (loop_end);
		}
	    }
	  else if ((index != 0 && ! host_integerp (index, 0))
		   || ! host_integerp (TYPE_SIZE (elttype), 1))
	    {
	      tree position;

	      if (index == 0)
		index = ssize_int (1);

	      if (minelt)
		index = convert (ssizetype,
				 fold (build (MINUS_EXPR, index,
					      TYPE_MIN_VALUE (domain))));

	      position = size_binop (MULT_EXPR, index,
				     convert (ssizetype,
					      TYPE_SIZE_UNIT (elttype)));
	      xtarget = offset_address (target,
					expand_expr (position, 0, VOIDmode, 0),
					highest_pow2_factor (position));
	      xtarget = adjust_address (xtarget, mode, 0);
	      store_expr (value, xtarget, 0);
	    }
	  else
	    {
	      if (index != 0)
		bitpos = ((tree_low_cst (index, 0) - minelt)
			  * tree_low_cst (TYPE_SIZE (elttype), 1));
	      else
		bitpos = (i * tree_low_cst (TYPE_SIZE (elttype), 1));

	      if (GET_CODE (target) == MEM && !MEM_KEEP_ALIAS_SET_P (target)
		  && TREE_CODE (type) == ARRAY_TYPE
		  && TYPE_NONALIASED_COMPONENT (type))
		{
		  target = copy_rtx (target);
		  MEM_KEEP_ALIAS_SET_P (target) = 1;
		}

	      store_constructor_field (target, bitsize, bitpos, mode, value,
				       type, cleared, get_alias_set (elttype));

	    }
	}
    }

  /* Set constructor assignments.  */
  else if (TREE_CODE (type) == SET_TYPE)
    {
      tree elt = CONSTRUCTOR_ELTS (exp);
      unsigned HOST_WIDE_INT nbytes = int_size_in_bytes (type), nbits;
      tree domain = TYPE_DOMAIN (type);
      tree domain_min, domain_max, bitlength;

      /* The default implementation strategy is to extract the constant
	 parts of the constructor, use that to initialize the target,
	 and then "or" in whatever non-constant ranges we need in addition.

	 If a large set is all zero or all ones, it is
	 probably better to set it using memset (if available) or bzero.
	 Also, if a large set has just a single range, it may also be
	 better to first clear all the first clear the set (using
	 bzero/memset), and set the bits we want.  */

      /* Check for all zeros.  */
      if (elt == NULL_TREE && size > 0)
	{
	  if (!cleared)
	    clear_storage (target, GEN_INT (size));
	  return;
	}

      domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));
      domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));
      bitlength = size_binop (PLUS_EXPR,
			      size_diffop (domain_max, domain_min),
			      ssize_int (1));

      nbits = tree_low_cst (bitlength, 1);

      /* For "small" sets, or "medium-sized" (up to 32 bytes) sets that
	 are "complicated" (more than one range), initialize (the
	 constant parts) by copying from a constant.  */
      if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD
	  || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))
	{
	  unsigned int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));
	  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);
	  char *bit_buffer = (char *) alloca (nbits);
	  HOST_WIDE_INT word = 0;
	  unsigned int bit_pos = 0;
	  unsigned int ibit = 0;
	  unsigned int offset = 0;  /* In bytes from beginning of set.  */

	  elt = get_set_constructor_bits (exp, bit_buffer, nbits);
	  for (;;)
	    {
	      if (bit_buffer[ibit])
		{
		  if (BYTES_BIG_ENDIAN)
		    word |= (1 << (set_word_size - 1 - bit_pos));
		  else
		    word |= 1 << bit_pos;
		}

	      bit_pos++;  ibit++;
	      if (bit_pos >= set_word_size || ibit == nbits)
		{
		  if (word != 0 || ! cleared)
		    {
		      rtx datum = GEN_INT (word);
		      rtx to_rtx;

		      /* The assumption here is that it is safe to use
			 XEXP if the set is multi-word, but not if
			 it's single-word.  */
		      if (GET_CODE (target) == MEM)
			to_rtx = adjust_address (target, mode, offset);
		      else if (offset == 0)
			to_rtx = target;
		      else
			abort ();
		      emit_move_insn (to_rtx, datum);
		    }

		  if (ibit == nbits)
		    break;
		  word = 0;
		  bit_pos = 0;
		  offset += set_word_size / BITS_PER_UNIT;
		}
	    }
	}
      else if (!cleared)
	/* Don't bother clearing storage if the set is all ones.  */
	if (TREE_CHAIN (elt) != NULL_TREE
	    || (TREE_PURPOSE (elt) == NULL_TREE
		? nbits != 1
		: ( ! host_integerp (TREE_VALUE (elt), 0)
		   || ! host_integerp (TREE_PURPOSE (elt), 0)
		   || (tree_low_cst (TREE_VALUE (elt), 0)
		       - tree_low_cst (TREE_PURPOSE (elt), 0) + 1
		       != (HOST_WIDE_INT) nbits))))
	  clear_storage (target, expr_size (exp));

      for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))
	{
	  /* Start of range of element or NULL.  */
	  tree startbit = TREE_PURPOSE (elt);
	  /* End of range of element, or element value.  */
	  tree endbit   = TREE_VALUE (elt);
#ifdef TARGET_MEM_FUNCTIONS
	  HOST_WIDE_INT startb, endb;
#endif
	  rtx bitlength_rtx, startbit_rtx, endbit_rtx, targetx;

	  bitlength_rtx = expand_expr (bitlength,
				       NULL_RTX, MEM, EXPAND_CONST_ADDRESS);

	  /* Handle non-range tuple element like [ expr ].  */
	  if (startbit == NULL_TREE)
	    {
	      startbit = save_expr (endbit);
	      endbit = startbit;
	    }

	  startbit = convert (sizetype, startbit);
	  endbit = convert (sizetype, endbit);
	  if (! integer_zerop (domain_min))
	    {
	      startbit = size_binop (MINUS_EXPR, startbit, domain_min);
	      endbit = size_binop (MINUS_EXPR, endbit, domain_min);
	    }
	  startbit_rtx = expand_expr (startbit, NULL_RTX, MEM,
				      EXPAND_CONST_ADDRESS);
	  endbit_rtx = expand_expr (endbit, NULL_RTX, MEM,
				    EXPAND_CONST_ADDRESS);

	  if (REG_P (target))
	    {
	      targetx
		= assign_temp
		  ((build_qualified_type (type_for_mode (GET_MODE (target), 0),
					  TYPE_QUAL_CONST)),
		   0, 1, 1);
	      emit_move_insn (targetx, target);
	    }

	  else if (GET_CODE (target) == MEM)
	    targetx = target;
	  else
	    abort ();

#ifdef TARGET_MEM_FUNCTIONS
	  /* Optimization:  If startbit and endbit are
	     constants divisible by BITS_PER_UNIT,
	     call memset instead.  */
	  if (TREE_CODE (startbit) == INTEGER_CST
	      && TREE_CODE (endbit) == INTEGER_CST
	      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0
	      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)
	    {
	      emit_library_call (memset_libfunc, LCT_NORMAL,
				 VOIDmode, 3,
				 plus_constant (XEXP (targetx, 0),
						startb / BITS_PER_UNIT),
				 Pmode,
				 constm1_rtx, TYPE_MODE (integer_type_node),
				 GEN_INT ((endb - startb) / BITS_PER_UNIT),
				 TYPE_MODE (sizetype));
	    }
	  else
#endif
	    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__setbits"),
			       LCT_NORMAL, VOIDmode, 4, XEXP (targetx, 0),
			       Pmode, bitlength_rtx, TYPE_MODE (sizetype),
			       startbit_rtx, TYPE_MODE (sizetype),
			       endbit_rtx, TYPE_MODE (sizetype));

	  if (REG_P (target))
	    emit_move_insn (target, targetx);
	}
    }

  else
    abort ();
}
