void
check_max_integer_computation_mode (exp)
     tree exp;
{
  enum tree_code code;
  enum machine_mode mode;

  /* Strip any NOPs that don't change the mode.  */
  STRIP_NOPS (exp);
  code = TREE_CODE (exp);

  /* We must allow conversions of constants to MAX_INTEGER_COMPUTATION_MODE.  */
  if (code == NOP_EXPR
      && TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST)
    return;

  /* First check the type of the overall operation.   We need only look at
     unary, binary and relational operations.  */
  if (TREE_CODE_CLASS (code) == '1'
      || TREE_CODE_CLASS (code) == '2'
      || TREE_CODE_CLASS (code) == '<')
    {
      mode = TYPE_MODE (TREE_TYPE (exp));
      if (GET_MODE_CLASS (mode) == MODE_INT
	  && mode > MAX_INTEGER_COMPUTATION_MODE)
	internal_error ("unsupported wide integer operation");
    }

  /* Check operand of a unary op.  */
  if (TREE_CODE_CLASS (code) == '1')
    {
      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
      if (GET_MODE_CLASS (mode) == MODE_INT
	  && mode > MAX_INTEGER_COMPUTATION_MODE)
	internal_error ("unsupported wide integer operation");
    }

  /* Check operands of a binary/comparison op.  */
  if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')
    {
      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));
      if (GET_MODE_CLASS (mode) == MODE_INT
	  && mode > MAX_INTEGER_COMPUTATION_MODE)
	internal_error ("unsupported wide integer operation");

      mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 1)));
      if (GET_MODE_CLASS (mode) == MODE_INT
	  && mode > MAX_INTEGER_COMPUTATION_MODE)
	internal_error ("unsupported wide integer operation");
    }
}
