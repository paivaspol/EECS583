void
expand_start_catch (type_or_list)
     tree type_or_list;
{
  struct eh_region *t, *c, *l;
  tree type_list;

  if (! doing_eh (0))
    return;

  type_list = type_or_list;

  if (type_or_list)
    {
      /* Ensure to always end up with a type list to normalize further
         processing, then register each type against the runtime types
         map.  */
      tree type_node;

      if (TREE_CODE (type_or_list) != TREE_LIST)
        type_list = tree_cons (NULL_TREE, type_or_list, NULL_TREE);

      type_node = type_list;
      for (; type_node; type_node = TREE_CHAIN (type_node))
        add_type_for_runtime (TREE_VALUE (type_node));
    }

  expand_eh_region_start ();

  t = cfun->eh->try_region;
  c = cfun->eh->cur_region;
  c->type = ERT_CATCH;
  c->u.catch.type_list = type_list;
  c->label = gen_label_rtx ();

  l = t->u.try.last_catch;
  c->u.catch.prev_catch = l;
  if (l)
    l->u.catch.next_catch = c;
  else
    t->u.try.catch = c;
  t->u.try.last_catch = c;

  emit_label (c->label);
}
