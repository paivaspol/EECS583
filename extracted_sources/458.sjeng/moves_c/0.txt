void gen (move_s moves[]) {

  /* generate pseudo-legal moves, and place them in the moves array */

  int from, a, j, i;

  kingcap = FALSE;
  
  numb_moves = 0;
  genfor = &moves[0];

  if (Variant == Suicide)
  {
    captures = FALSE;
    fcaptures = FALSE;
  };
	
restart:

  /* generate white moves, if it is white to move: */
  if (white_to_move) {
    for (a = 1, j = 1;
	 (a <= piece_count) 
	   && (((Variant != Suicide) && !kingcap)
	   || ((Variant == Suicide) && (fcaptures == captures)));
	 j++) {

      i = pieces[j];
      
      if (!i)
	continue;
      else
	a++;

      from = i;
      gfrom = i;
      
       switch (board[from]) {
       case (wpawn):
	 /* pawn moves up one square: */
	 if (board[from+12] == npiece) {
	   /* only promotions when captures == TRUE */
	   if (rank (from) == 7 && ((Variant != Suicide) && (Variant != Losers))) {
	     push_pawn (from+12, FALSE);
	   }
	   else if (!captures) {
	     push_pawn (from+12, FALSE);

	     /* pawn moving up two squares on its first move: */
	     if (rank(from) == 2 && board[from+24] == npiece)
	       push_pawn_simple (from+24);
	   }
	 }
	 /* pawn capturing diagonally: */
	 if ((board[from+13]&1) == 0 && board[from+13] != frame)
	   push_pawn (from+13, FALSE);
	 /* pawn captruing diagonally: */
	 if ((board[from+11]&1) == 0 && board[from+11] != frame)
	   push_pawn (from+11, FALSE);
	 /* ep move: */
	 if (ep_square == from+13)
	   push_pawn (from+13, TRUE);
	 /* ep move: */
	 else if (ep_square == from+11)
	   push_pawn (from+11, TRUE);
	 break;
       case (wknight):
	 /* use the knight offsets: */
	 push_knight (from-25);
	 push_knight (from-23);
	 push_knight (from-14);
	 push_knight (from-10);
	 push_knight (from+10);
	 push_knight (from+14);
	 push_knight (from+23);
	 push_knight (from+25);
	 break;
       case (wbishop):
	 /* use the bishop offsets: */
	 push_slide (from-13);
	 push_slide (from-11);
	 push_slide (from+11);
	 push_slide (from+13);
	 break;
       case (wrook):
	 /* use the rook offsets: */
	 push_slide (from-12);
	 push_slide (from-1);
	 push_slide (from+1);
	 push_slide (from+12);
	 break;
       case (wqueen):
	 /* use the queen offsets: */
	 push_slide (from-13);
	 push_slide (from-12);
	 push_slide (from-11);
	 push_slide (from-1);
	 push_slide (from+1);
	 push_slide (from+11);
	 push_slide (from+12);
	 push_slide (from+13);
	 break;
       case (wking):
	 /* use the king offsets for 'normal' moves: */
	  push_king (from-13);
	  push_king (from-12);
	  push_king (from-11);
	  push_king (from-1);
	  push_king (from+1);
	  push_king (from+11);
	  push_king (from+12);
	  push_king (from+13);
	  /* castling moves: */
	  if (from == 30 && !moved[30] && !captures && (Variant != Suicide || Giveaway == TRUE)) {
	    /* kingside: */
	    if (!moved[33] && board[33] == wrook)
	      if (board[31] == npiece && board[32] == npiece)
		push_king_castle (from+2, wck);
	    /* queenside: */
	    if (!moved[26] && board[26] == wrook)
	      if (board[27] == npiece && board[28] == npiece
		  && board[29] == npiece)
		push_king_castle (from-2, wcq);
	  }
	  break;
        default:
	  break;
      }
    }
  }

  /* generate black moves, if it is black to move: */
  else {
    for (a = 1, j = 1;
	 (a <= piece_count) &&
	  (((Variant != Suicide) && !kingcap)
	  || ((Variant == Suicide) && (fcaptures == captures)))
	  ; j++) {
      i = pieces[j];
      
      if (!i)
	continue;
      else
	a++;

      from = i; 
      gfrom = i;

      switch (board[from]) {
      case (bpawn):
	/* pawn moves up one square: */
	if (board[from-12] == npiece) {
	  /* only promotions when captures == TRUE */
	  if (rank (from) == 2 && ((Variant != Suicide) && (Variant != Losers))) {
	    push_pawn (from-12, FALSE);
	  }
	  else if (!captures) {
	    push_pawn (from-12, FALSE);
	  
	  /* pawn moving up two squares on its first move: */
	  if (rank(from) == 7 && board[from-24] == npiece)
	    push_pawn_simple (from-24);
	  }
	};
	/* pawn capturing diagonally: */
	if ((board[from-13]&1) == 1 && board[from-13] != npiece)
	  push_pawn (from-13, FALSE);
	/* pawn capturing diagonally: */
	if ((board[from-11]&1) == 1 && board[from-11] != npiece)
	  push_pawn (from-11, FALSE);
	/* ep move: */
	if (ep_square == from-13)
	  push_pawn (from-13, TRUE);
	/* ep move: */
	else if (ep_square == from-11)
	  push_pawn (from-11, TRUE);
	  break;
      case (bknight):
	/* use the knight offsets: */
	push_knight (from-25);
	push_knight (from-23);
	push_knight (from-14);
	push_knight (from-10);
	push_knight (from+10);
	push_knight (from+14);
	push_knight (from+23);
	push_knight (from+25);
	  break;
      case (bbishop):
	/* use the bishop offsets: */
	push_slide (from-13);
	push_slide (from-11);
	push_slide (from+11);
	push_slide (from+13);
	break;
      case (brook):
	/* use the rook offsets: */
	push_slide (from-12);
	push_slide (from-1);
	push_slide (from+1);
	push_slide (from+12);
	break;
      case (bqueen):
	/* use the queen offsets: */
	push_slide (from-13);
	push_slide (from-12);
	push_slide (from-11);
	push_slide (from-1);
	push_slide (from+1);
	push_slide (from+11);
	push_slide (from+12);
	push_slide (from+13);
	break;
      case (bking):
	  /* use the king offsets for 'normal' moves: */
	push_king (from-13);
	push_king (from-12);
	push_king (from-11);
	push_king (from-1);
	push_king (from+1);
	push_king (from+11);
	push_king (from+12);
	push_king (from+13);
	/* castling moves: */
	if (from == 114 && !moved[114] && !captures && (Variant != Suicide || Giveaway == TRUE)) {
	  /* kingside: */
	  if (!moved[117] && board[117] == brook)
	    if (board[115] == npiece && board[116] == npiece)
	      push_king_castle (from+2, bck);
	  /* queenside: */
	  if (!moved[110] && board[110] == brook)
	    if (board[111] == npiece && board[112] == npiece
		&& board[113] == npiece)
	      push_king_castle (from-2, bcq);
	}
	break;
      default:
	break;
      }
    }
  }
  if (((Variant == Crazyhouse) || (Variant == Bughouse)) && !captures && !kingcap)
    {
      if (white_to_move && 
	  (holding[WHITE][wpawn] || holding[WHITE][wknight]
	   || holding[WHITE][wbishop] || holding[WHITE][wqueen]
	   || holding[WHITE][wrook]))
	{
	  for (from = 26; from < 118; from++)
	    {
              gfrom = from;
	      
	      switch (board[from])
		{
		case (frame):
		  from += 3;
		  continue;
		case (npiece):
		  if(holding[WHITE][wpawn])
		    {  
		      if ((rank(from) != 8) && (rank(from) != 1))	
			{
			  try_drop(wpawn);
			}
		    }   
		  if(holding[WHITE][wknight])
		    {
		      try_drop(wknight);
		    }
		  if(holding[WHITE][wbishop])
		    {
		      try_drop(wbishop);
		    }
		  if(holding[WHITE][wrook])
		    {
		      try_drop(wrook);
		    }	
		  if(holding[WHITE][wqueen])
		    {
		      try_drop(wqueen);
		    }
		};
	    }
	}      
      else if (!white_to_move && 
	       (holding[BLACK][bpawn] || holding[BLACK][bknight]
		|| holding[BLACK][bbishop] || holding[BLACK][bqueen]
		|| holding[BLACK][brook]))
	{
	  for (from = 26; from < 118; from++)
	    {
	      gfrom = from;
	      
	      switch (board[from])
		{
		case (frame):
		  from += 3;
		  continue;
		case (npiece):
		  if(holding[BLACK][bpawn])
		    {  
		      if ((rank(from) != 8) && (rank(from) != 1))	
			{
			  try_drop(bpawn);
			}
		    }   
		  if(holding[BLACK][bknight])
		    {
		      try_drop(bknight);
		    }
		  if(holding[BLACK][bbishop])
		    {
		      try_drop(bbishop);
		    }
		  if(holding[BLACK][brook])
		    {
		      try_drop(brook);
		    }	
		  if(holding[BLACK][bqueen])
		    {
		      try_drop(bqueen);
		    }
		};
	    };
	}
    }

  if ((Variant == Suicide) && fcaptures == TRUE && captures == FALSE)
    {
      captures = TRUE;
      numb_moves = 0;
      goto restart;
    }

  if (Variant == Suicide) kingcap = FALSE;
  

}
