int eval (int alpha, int beta) {

  /* return a score for the current middlegame position: */

  int i, a, j;
  int score = 0;
  int in_cache;
  int safety, badsquares;
  int norm_white_hand_eval, norm_black_hand_eval;
  int wdev_dscale, bdev_dscale;

  if (Variant == Normal)
    {
      return std_eval(alpha, beta);
    }
  else if (Variant == Suicide)
    {
      return suicide_eval();
    }
  else if (Variant == Losers)
    {
      return losers_eval();
    }

  in_cache = 0;

  checkECache(&score, &in_cache);

  if(in_cache)
    {
      if (white_to_move == 1) return score;
      return -score;
    }

  /* set up development scalefactor depending on material
   * in hand */
  if (cfg_devscale)
    {
      /* computer plays black -> no white downscaling */
      if (white_to_move != comp_color)
	{
	  if (white_hand_eval <= 200 && (Variant != Bughouse))
	    {
	      /* 2 pawns or less */
	      wdev_dscale = 2;
	    }
	  else if (white_hand_eval >= 700)
	    {
	      /* queen + minor, three minors or more */
	      wdev_dscale = 0;
	    }
	  else
	    {
	      wdev_dscale = 1;
	    }
	}
      else
	wdev_dscale = 0;

      if (white_to_move == comp_color)
	{
	  if ((-black_hand_eval) <= 200 && (Variant != Bughouse))
	    {
	      /* 2 pawns or less */
	      bdev_dscale = 2;
	}
	  else if ((-black_hand_eval) >= 700)
	    {
	      /* queen + pawn, two minors + pawn */
	      bdev_dscale = 0;
	    }
	  else
	    {
	      bdev_dscale = 1;
	    }
	}
      else
	bdev_dscale = 0;
    }
  else
    {
      wdev_dscale = bdev_dscale = 0;
    }

  /* loop through the board, adding material value, as well as positional
     bonuses for all pieces encountered: */
  for (a = 1, j = 1;(a <= piece_count); j++) {
    i = pieces[j];

    if (!i)
      continue;
    else
      a++;

    switch (board[i]) {
      case (wpawn):
	score += 100;
	score += white_pawn[i] >> wdev_dscale;
	score += p_tropism[i][bking_loc];
	break;

      case (bpawn):
	score -= 100;
	score -= black_pawn[i] >> bdev_dscale;
	score -= p_tropism[i][wking_loc];
	break;

      case (wrook):
	score += 250;
	score += white_rook[i] >> wdev_dscale;
	score += r_tropism[i][bking_loc];
	break;

      case (brook):
	score -= 250;
	score -= black_rook[i] >> bdev_dscale;
	score -= r_tropism[i][wking_loc];
	break;

      case (wbishop):
	score += 230;
	score += pcsqbishop[i] >> wdev_dscale;
	score += b_tropism[i][bking_loc];
	break;

      case (bbishop):
	score -= 230;
	score -= pcsqbishop[i] >> bdev_dscale;
	score -= b_tropism[i][wking_loc];
	break;

      case (wknight):
	score += 210;
	score += white_knight[i] >> wdev_dscale;
	score += n_tropism[i][bking_loc];
	break;

      case (bknight):
	score -= 210;
	score -= black_knight[i] >> bdev_dscale;
	score -= n_tropism[i][wking_loc];
	break;

      case (wqueen):
	score += 450;
	score += white_queen[i] >> wdev_dscale;
	score += q_tropism[i][bking_loc];
	break;

      case (bqueen):
	score -= 450;
	score -= black_queen[i] >> bdev_dscale;
	score -= q_tropism[i][wking_loc];
	break;

    }
  }

  /* we scale our kings position depending on how
     much material the _other_ side has in hand */

  score += white_king[wking_loc] >> bdev_dscale;
  score -= black_king[bking_loc] >> wdev_dscale;

  /* we do not give a bonus for castling, but it is important
     to keep our options open */

  if (!white_castled && moved[30])
  {
      score -= 30;
  }
  if (!black_castled && moved[114])
  {
      score += 30;
  }

  /* give penalties for blocking the e/d pawns: */
  if (!moved[41] && board[53] != npiece)
    score -= 15;
  if (!moved[42] && board[54] != npiece)
    score -= 15;
  if (!moved[101] && board[89] != npiece)
    score += 15;
  if (!moved[102] && board[90] != npiece)
    score += 15;


  if (cfg_smarteval)
  {
  /* Pawn cover for the King please... */
  /* White */

  if (wking_loc != E1 && wking_loc != D1)
  {
  	if (board[wking_loc+11] != wpawn) score -= 24;
  	if (board[wking_loc+12] != wpawn) score -= 35;
  	if (board[wking_loc+13] != wpawn) score -= 24;

	/* When castled, building a fortress wont hurt */
	if (white_castled)
	  {
	    if (board[bking_loc-25] == bpawn) score += 11;
	    if (board[bking_loc-24] == bpawn) score += 15;
	    if (board[bking_loc-23] == bpawn) score += 11;
	  }
  }
  /* Black */
  if (bking_loc != E8 && bking_loc != D8)
  {
  	if (board[bking_loc-13] != bpawn) score += 24;
  	if (board[bking_loc-12] != bpawn) score += 35;
  	if (board[bking_loc-11] != bpawn) score += 24;

	/* When castled, building a fortress wont hurt */
	if (black_castled)
	  {
	    if (board[bking_loc-25] == bpawn) score -= 11;
	    if (board[bking_loc-24] == bpawn) score -= 15;
	    if (board[bking_loc-23] == bpawn) score -= 11;
	  }
  }
  /* Develop stuff */
  if (moved[E2])
    {
      score += 30;
      if (moved[D2]) score += 25;
      if (moved[G1]) score += 20;
      if (moved[B1]) score += 15;
      if (moved[C1]) score += 10;
    }
  if (moved[E7])
    {
      score -= 30;
      if (moved[D7]) score -= 25;
      if (moved[G8]) score -= 20;
      if (moved[B8]) score -= 15;
      if (moved[C8]) score -= 10;

    }

  /* Bad holes in the kingside (g2/e2) or (g7/e7) allow attacks */

  if ((board[G2] != wpawn) && (board[F3] == bpawn || board[E4] == bpawn))
      score -= 30;
  if ((board[G7] != bpawn) && (board[F6] == wpawn || board[E5] == wpawn))
      score += 30;

#define Fis_attacked(x,y) (board[(x)] == frame ? 0 : is_attacked((x),(y)))
#define Gis_attacked(x,y) (board[(x)] == frame ? 0 : nk_attacked((x),(y)))

  /* An enemy pawn in front of the king can be deadly.*/
  /* especially if it is protected                    */

  if (board[wking_loc + 12] == bpawn || board[wking_loc + 12] == bbishop)
    {
      score -= 35;
      if (Fis_attacked(wking_loc + 12, 0))
	score -= 150 >> bdev_dscale;
    }
  if (board[bking_loc - 12] == wpawn || board[bking_loc - 12] == wbishop)
    {
      score += 35;
      if (Fis_attacked(bking_loc - 12,1))
	score += 150 >> wdev_dscale;
    }

  /* If e6 is attacked but there is no pawn there (just P-f7) */


  if (((board[F2] == wpawn) || (board[E3] == wpawn) || board[E3] == bpawn) && Fis_attacked(E3,0))
    {
      if (board[F2] == wpawn) score += 10;
      if (board[E3] == wpawn) score += 20;
      else if (board[E3] == bpawn) score -= 15;
    }
  if (((board[F7] == bpawn) || (board[E6] == bpawn) || board[E6] == wpawn) && Fis_attacked(E6,1))
    {
      if (board[F7] == bpawn) score -= 10;
      if (board[E6] == bpawn) score -= 20;
      else if (board[E6] == wpawn) score += 15;
    }

  /* Bonus if in check */

  if (Fis_attacked(bking_loc,1))
    score += 50 >> wdev_dscale;
  else if (Fis_attacked(wking_loc,0))
    score -= 50 >> bdev_dscale;

  /* Give big pentalty for knight or pawn at g2/g7 especially if supported */
  /* Also  protect  with  Rook  and  Bishop                                */

  if (board[G2] == bknight)
    {
      score -= 20;
      if (Fis_attacked(G2,0)) score -= 40;
      if (board[G1] == wrook) score += 10;
      if (board[F1] == wbishop) score += 10;
    }
  if (board[G7] == wknight)
    {
      score += 20;
      if (Fis_attacked(G7,1)) score += 40;
      if (board[G8] == brook) score -= 10;
      if (board[F8] == bbishop)score -= 10;
    }

  /* Bishop at h3/h6 often leads to crushing attacks */
  /* Especially when the king is trapped behind a N  */

  if ((board[H3] == bbishop) && (board[G2] != wpawn))
    {
      score -= 20;
      if (board[G2] == bknight)
	{
	  score -= 40;
	  if (board[F1] == wking || board[G1] == wking || board[H1] == wking)
	      score -= 80;
	}
    }
  if ((board[H6] == wbishop) && (board[G7] != bpawn))
    {
      score += 20;
      if (board[G7] == wknight)
	{
	  score += 40;
	  if (board[F8] == bking || board[G8] == bking || board[H8] == bking)
	    score += 80;
	}
    }
  }

  if (cfg_attackeval)
  {
    badsquares = 0;
    safety = 0;

    badsquares += Gis_attacked(wking_loc - 13, 0);
    badsquares += Gis_attacked(wking_loc - 12, 0);
    badsquares += Gis_attacked(wking_loc - 11, 0);
    badsquares += Gis_attacked(wking_loc -  1, 0);
    badsquares += Gis_attacked(wking_loc +  1, 0);
    badsquares += Gis_attacked(wking_loc + 11, 0);
    badsquares += Gis_attacked(wking_loc + 12, 0);
    badsquares += Gis_attacked(wking_loc + 13, 0);

    norm_black_hand_eval = ((-black_hand_eval) / 100);
    if (norm_black_hand_eval > 14) norm_black_hand_eval = 14;
    else if (norm_black_hand_eval < 0) norm_black_hand_eval = 0;

    safety -= ksafety_scaled[norm_black_hand_eval][badsquares];

    badsquares = 0;

    badsquares += Gis_attacked(bking_loc - 13, 1);
    badsquares += Gis_attacked(bking_loc - 12, 1);
    badsquares += Gis_attacked(bking_loc - 11, 1);
    badsquares += Gis_attacked(bking_loc -  1, 1);
    badsquares += Gis_attacked(bking_loc +  1, 1);
    badsquares += Gis_attacked(bking_loc + 11, 1);
    badsquares += Gis_attacked(bking_loc + 12, 1);
    badsquares += Gis_attacked(bking_loc + 13, 1);

    norm_white_hand_eval = (white_hand_eval / 100);
    if (norm_white_hand_eval > 14) norm_white_hand_eval = 14;
    else if (norm_white_hand_eval < 0) norm_white_hand_eval = 0;

    safety += ksafety_scaled[norm_white_hand_eval][badsquares];

    score += safety;
  }

  score += (white_hand_eval + black_hand_eval);

  storeECache(score);

  /* adjust for color: */
  if (white_to_move == 1) {
    return score;
  }
  else {
    return -score;
  }

}
