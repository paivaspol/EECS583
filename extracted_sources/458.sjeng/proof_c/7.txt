void set_proof_and_disproof_numbers (node_t * node)
{
  int proof;
  int disproof;
  int i;
  move_s moves[MOVE_BUFF];
  int l, num_moves;
  int ic;

  if (node->expanded)
    {
      if (ToMove != root_to_move)
	{
	  proof = 0;
	  disproof = PN_INF;

	  for (i = 0; i < node->num_children; i++)
	    {
	      proof += node->children[i]->proof;

	      if (proof > PN_INF)
		proof = PN_INF;

	      if (node->children[i]->disproof < disproof)
		{
		  disproof = node->children[i]->disproof;
		}
	    }
	  
	  if ((proof == 0) || (disproof == PN_INF))
	    {
	      forwards++;
	      StoreTT(INF-500, INF, -INF, -1, 0, 200);
	    }
	  else if ((disproof == 0) || (proof == PN_INF))
	    {
	      forwards++;
	      StoreTT(-INF+500, INF, -INF, -1, 0, 200);
	    }
	}
      else
	{
	  disproof = 0;
	  proof = PN_INF;

	  for (i = 0; i < node->num_children; i++)
	    {

	      disproof += node->children[i]->disproof;

	      if (disproof > PN_INF)
		disproof = PN_INF;

	      if (node->children[i]->proof < proof)
		{
		  proof = node->children[i]->proof;
		}
	    }

	  if ((proof == 0) || (disproof == PN_INF))
	    {
	      forwards++;
	      StoreTT(INF-500, INF, -INF, -1, 0, 200);
	    }
	  else if ((disproof == 0) || (proof == PN_INF))
	    {
	      forwards++;
	      StoreTT(-INF+500, INF, -INF, -1, 0, 200);
	    }
	}
	  
      hash_history[move_number+ply-1] = hash; 
	  
      node->proof = proof;
      node->disproof = disproof;

    }
  else if (node->evaluated)
    {
      if (node->value == UNKNOWN)
	{
	  
	  hash_history[move_number+ply-1] = hash; 

	  if (is_draw() || ply > 200)
	    {
	      node->proof = 50000;
	      node->disproof = 50000;
	      return;
	    }
	  
	  /* ept = ep_square; */
	  
	  if (Variant != Losers)
	    {
	      num_moves = 0;
	      gen (&moves[0]);
	      num_moves = numb_moves;

	      ic = in_check();
	      
	      if (Variant != Suicide)
		{
		  l = 0;
		  
		  for (i = 0; i < num_moves; i++)
		    {
		      make (&moves[0], i);
		      /* check to see if our move is legal: */
		      if (check_legal (&moves[0], i, ic))
			{
			  l++;
			}
		      unmake (&moves[0], i);
		    };
		}
	      else
		{
		  l = numb_moves;
		};
	    }
	  else
	    {
	      /* Losers...this a bit more messy */

	      l = 0;
	      captures = TRUE;
	      num_moves = 0;
	      gen (&moves[0]);
	      num_moves = numb_moves;
	      captures = FALSE;	

	      ic = in_check();
	      
	      if (num_moves)
		{
		  for (i = 0; i < num_moves; i++)
		    {
		      make(&moves[0], i);
		      
		      if (check_legal(&moves[0], i, ic))
			{
			  l++;
			}
		      unmake(&moves[0], i);
		    }
		}
	      
	      /* ep_square = ept; */
	      
	      if (!l) 
		{
		  captures = FALSE;
		  num_moves = 0;
		  gen(&moves[0]);
		  num_moves = numb_moves;

		  for (i = 0; i < num_moves; i++)
		    {
		      make(&moves[0], i);
		      
		      if (check_legal(&moves[0], i, ic))
			{
			  l++;
			}
		      unmake(&moves[0], i);
		    }
		};
	    }
	  
	  if (l == 0)
	    {
	      /* might be stalemate too */
	      node->proof = 1;
	      node->disproof = 1;
	    }
	  else if (ToMove == root_to_move)	/* OR */
	    {
	      if ((Variant != Suicide) && (Variant != Losers))
		{
		  node->proof = 1 + ply / 50;
		  node->disproof = l + ply  / 50;
		}
	      else
		{
		  if (Variant == Losers)
		    {
		      /* this is probably a bogus line,
			 so breathen the tree */
		      if (phase == Endgame)
		      {
			node->proof = 1 + ply / 30;
			node->disproof = l + ply / 30;
		      }
		      else
		      {
			node->proof = 1 + ply / 80;
			node->disproof = l + ply / 80;
		      }
		    }
		  else
		    {
		      node->proof = 1 + ply / 150;
		      node->disproof = l + ply / 150;
		    }
		}
	    }
	  else
	    {
	      if ((Variant != Suicide) && (Variant != Losers))
		{
		  node->proof = l + ply / 50;
		  node->disproof = 1 + ply / 50;
		}
	      else
		{
		  if (Variant == Losers)
		    {
		      if (phase == Endgame)
		      {
			  node->proof = l + ply/30;
			  node->disproof = 1 + ply/30;
			
		      }
		      else
		      {
			  node->proof = l + ply/80;
			  node->disproof = 1 + ply/80;
		      }
		    }
		  else
		    {
		      node->proof = l + ply / 150;
		      node->disproof = 1 + ply / 150;
		    }
		}
	    }
	  
	  /* ep_square = ept; */
	}
      else if (node->value == FALSE)
	{
	  node->proof = PN_INF;
	  node->disproof = 0;
	}
      else if (node->value == TRUE)
	{
	  node->proof = 0;
	  node->disproof = PN_INF;
	}
      else if (node->value == STALEMATE)
	{
	  /* don't look at this node, its a dead-end */
	  node->proof = 50000;
	  node->disproof = 50000;
	};
    }
  else
    {
      node->proof = node->disproof = 1;
    }
}
