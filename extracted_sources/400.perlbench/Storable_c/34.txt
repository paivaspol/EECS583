static int store(pTHX_ stcxt_t *cxt, SV *sv)
{
	SV **svh;
	int ret;
	int type;
	HV *hseen = cxt->hseen;

	TRACEME(("store (0x%"UVxf")", PTR2UV(sv)));

	/*
	 * If object has already been stored, do not duplicate data.
	 * Simply emit the SX_OBJECT marker followed by its tag data.
	 * The tag is always written in network order.
	 *
	 * NOTA BENE, for 64-bit machines: the "*svh" below does not yield a
	 * real pointer, rather a tag number (watch the insertion code below).
	 * That means it probably safe to assume it is well under the 32-bit limit,
	 * and makes the truncation safe.
	 *		-- RAM, 14/09/1999
	 */

	svh = hv_fetch(hseen, (char *) &sv, sizeof(sv), FALSE);
	if (svh) {
		I32 tagval;

		if (sv == &PL_sv_undef) {
			/* We have seen PL_sv_undef before, but fake it as
			   if we have not.

			   Not the simplest solution to making restricted
			   hashes work on 5.8.0, but it does mean that
			   repeated references to the one true undef will
			   take up less space in the output file.
			*/
			/* Need to jump past the next hv_store, because on the
			   second store of undef the old hash value will be
			   SvREFCNT_dec()ed, and as Storable cheats horribly
			   by storing non-SVs in the hash a SEGV will ensure.
			   Need to increase the tag number so that the
			   receiver has no idea what games we're up to.  This
			   special casing doesn't affect hooks that store
			   undef, as the hook routine does its own lookup into
			   hseen.  Also this means that any references back
			   to PL_sv_undef (from the pathological case of hooks
			   storing references to it) will find the seen hash
			   entry for the first time, as if we didn't have this
			   hackery here. (That hseen lookup works even on 5.8.0
			   because it's a key of &PL_sv_undef and a value
			   which is a tag number, not a value which is
			   PL_sv_undef.)  */
			cxt->tagnum++;
			type = svis_SCALAR;
			goto undef_special_case;
		}
		
		tagval = htonl(LOW_32BITS(*svh));

		TRACEME(("object 0x%"UVxf" seen as #%d", PTR2UV(sv), ntohl(tagval)));

		PUTMARK(SX_OBJECT);
		WRITE_I32(tagval);
		return 0;
	}

	/*
	 * Allocate a new tag and associate it with the address of the sv being
	 * stored, before recursing...
	 *
	 * In order to avoid creating new SvIVs to hold the tagnum we just
	 * cast the tagnum to an SV pointer and store that in the hash.  This
	 * means that we must clean up the hash manually afterwards, but gives
	 * us a 15% throughput increase.
	 *
	 */

	cxt->tagnum++;
	if (!hv_store(hseen,
			(char *) &sv, sizeof(sv), INT2PTR(SV*, cxt->tagnum), 0))
		return -1;

	/*
	 * Store `sv' and everything beneath it, using appropriate routine.
	 * Abort immediately if we get a non-zero status back.
	 */

	type = sv_type(aTHX_ sv);

undef_special_case:
	TRACEME(("storing 0x%"UVxf" tag #%d, type %d...",
		 PTR2UV(sv), cxt->tagnum, type));

	if (SvOBJECT(sv)) {
		HV *pkg = SvSTASH(sv);
		ret = store_blessed(aTHX_ cxt, sv, type, pkg);
	} else
		ret = SV_STORE(type)(aTHX_ cxt, sv);

	TRACEME(("%s (stored 0x%"UVxf", refcnt=%d, %s)",
		ret ? "FAILED" : "ok", PTR2UV(sv),
		SvREFCNT(sv), sv_reftype(sv, FALSE)));

	return ret;
}
