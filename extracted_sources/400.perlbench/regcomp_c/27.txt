void
Perl_regprop(pTHX_ SV *sv, regnode *o)
{
#ifdef DEBUGGING
    register int k;

    sv_setpvn(sv, "", 0);
    if (OP(o) >= reg_num)		/* regnode.type is unsigned */
	/* It would be nice to FAIL() here, but this may be called from
	   regexec.c, and it would be hard to supply pRExC_state. */
	Perl_croak(aTHX_ "Corrupted regexp opcode");
    sv_catpv(sv, (char*)reg_name[OP(o)]); /* Take off const! */

    k = PL_regkind[(U8)OP(o)];

    if (k == EXACT) {
        SV *dsv = sv_2mortal(newSVpvn("", 0));
	/* Using is_utf8_string() is a crude hack but it may
	 * be the best for now since we have no flag "this EXACTish
	 * node was UTF-8" --jhi */
	bool do_utf8 = is_utf8_string((U8*)STRING(o), STR_LEN(o));
	char *s    = do_utf8 ?
	  pv_uni_display(dsv, (U8*)STRING(o), STR_LEN(o), 60,
			 UNI_DISPLAY_REGEX) :
	  STRING(o);
	int len = do_utf8 ?
	  strlen(s) :
	  STR_LEN(o);
	Perl_sv_catpvf(aTHX_ sv, " <%s%.*s%s>",
		       PL_colors[0],
		       len, s,
		       PL_colors[1]);
    }
    else if (k == CURLY) {
	if (OP(o) == CURLYM || OP(o) == CURLYN || OP(o) == CURLYX)
	    Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags); /* Parenth number */
	Perl_sv_catpvf(aTHX_ sv, " {%d,%d}", ARG1(o), ARG2(o));
    }
    else if (k == WHILEM && o->flags)			/* Ordinal/of */
	Perl_sv_catpvf(aTHX_ sv, "[%d/%d]", o->flags & 0xf, o->flags>>4);
    else if (k == REF || k == OPEN || k == CLOSE || k == GROUPP )
	Perl_sv_catpvf(aTHX_ sv, "%d", (int)ARG(o));	/* Parenth number */
    else if (k == LOGICAL)
	Perl_sv_catpvf(aTHX_ sv, "[%d]", o->flags);	/* 2: embedded, otherwise 1 */
    else if (k == ANYOF) {
	int i, rangestart = -1;
	U8 flags = ANYOF_FLAGS(o);
	const char * const anyofs[] = {	/* Should be synchronized with
					 * ANYOF_ #xdefines in regcomp.h */
	    "\\w",
	    "\\W",
	    "\\s",
	    "\\S",
	    "\\d",
	    "\\D",
	    "[:alnum:]",
	    "[:^alnum:]",
	    "[:alpha:]",
	    "[:^alpha:]",
	    "[:ascii:]",
	    "[:^ascii:]",
	    "[:ctrl:]",
	    "[:^ctrl:]",
	    "[:graph:]",
	    "[:^graph:]",
	    "[:lower:]",
	    "[:^lower:]",
	    "[:print:]",
	    "[:^print:]",
	    "[:punct:]",
	    "[:^punct:]",
	    "[:upper:]",
	    "[:^upper:]",
	    "[:xdigit:]",
	    "[:^xdigit:]",
	    "[:space:]",
	    "[:^space:]",
	    "[:blank:]",
	    "[:^blank:]"
	};

	if (flags & ANYOF_LOCALE)
	    sv_catpv(sv, "{loc}");
	if (flags & ANYOF_FOLD)
	    sv_catpv(sv, "{i}");
	Perl_sv_catpvf(aTHX_ sv, "[%s", PL_colors[0]);
	if (flags & ANYOF_INVERT)
	    sv_catpv(sv, "^");
	for (i = 0; i <= 256; i++) {
	    if (i < 256 && ANYOF_BITMAP_TEST(o,i)) {
		if (rangestart == -1)
		    rangestart = i;
	    } else if (rangestart != -1) {
		if (i <= rangestart + 3)
		    for (; rangestart < i; rangestart++)
			put_byte(sv, rangestart);
		else {
		    put_byte(sv, rangestart);
		    sv_catpv(sv, "-");
		    put_byte(sv, i - 1);
		}
		rangestart = -1;
	    }
	}

	if (o->flags & ANYOF_CLASS)
	    for (i = 0; i < sizeof(anyofs)/sizeof(char*); i++)
		if (ANYOF_CLASS_TEST(o,i))
		    sv_catpv(sv, anyofs[i]);

	if (flags & ANYOF_UNICODE)
	    sv_catpv(sv, "{unicode}");
	else if (flags & ANYOF_UNICODE_ALL)
	    sv_catpv(sv, "{unicode_all}");

	{
	    SV *lv;
	    SV *sw = regclass_swash(o, FALSE, &lv, 0);
	
	    if (lv) {
		if (sw) {
		    U8 s[UTF8_MAXBYTES_CASE+1];
		
		    for (i = 0; i <= 256; i++) { /* just the first 256 */
			U8 *e = uvchr_to_utf8(s, i);
			
			if (i < 256 && swash_fetch(sw, s, TRUE)) {
			    if (rangestart == -1)
				rangestart = i;
			} else if (rangestart != -1) {
			    U8 *p;
			
			    if (i <= rangestart + 3)
				for (; rangestart < i; rangestart++) {
				    for(e = uvchr_to_utf8(s, rangestart), p = s; p < e; p++)
					put_byte(sv, *p);
				}
			    else {
				for (e = uvchr_to_utf8(s, rangestart), p = s; p < e; p++)
				    put_byte(sv, *p);
				sv_catpv(sv, "-");
				    for (e = uvchr_to_utf8(s, i - 1), p = s; p < e; p++)
					put_byte(sv, *p);
				}
				rangestart = -1;
			    }
			}
			
		    sv_catpv(sv, "..."); /* et cetera */
		}

		{
		    char *s = savesvpv(lv);
		    char *origs = s;
		
		    while(*s && *s != '\n') s++;
		
		    if (*s == '\n') {
			char *t = ++s;
			
			while (*s) {
			    if (*s == '\n')
				*s = ' ';
			    s++;
			}
			if (s[-1] == ' ')
			    s[-1] = 0;
			
			sv_catpv(sv, t);
		    }
		
		    Safefree(origs);
		}
	    }
	}

	Perl_sv_catpvf(aTHX_ sv, "%s]", PL_colors[1]);
    }
    else if (k == BRANCHJ && (OP(o) == UNLESSM || OP(o) == IFMATCH))
	Perl_sv_catpvf(aTHX_ sv, "[-%d]", o->flags);
#endif	/* DEBUGGING */
}
