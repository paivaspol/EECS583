OP *
Perl_ck_sassign(pTHX_ OP *o)
{
    OP *kid = cLISTOPo->op_first;
    /* has a disposable target? */
    if ((PL_opargs[kid->op_type] & OA_TARGLEX)
	&& !(kid->op_flags & OPf_STACKED)
	/* Cannot steal the second time! */
	&& !(kid->op_private & OPpTARGET_MY))
    {
	OP *kkid = kid->op_sibling;

	/* Can just relocate the target. */
	if (kkid && kkid->op_type == OP_PADSV
	    && !(kkid->op_private & OPpLVAL_INTRO))
	{
	    kid->op_targ = kkid->op_targ;
	    kkid->op_targ = 0;
	    /* Now we do not need PADSV and SASSIGN. */
	    kid->op_sibling = o->op_sibling;	/* NULL */
	    cLISTOPo->op_first = NULL;
	    op_free(o);
	    op_free(kkid);
	    kid->op_private |= OPpTARGET_MY;	/* Used for context settings */
	    return kid;
	}
    }
    /* optimise C<my $x = undef> to C<my $x> */
    if (kid->op_type == OP_UNDEF) {
	OP *kkid = kid->op_sibling;
	if (kkid && kkid->op_type == OP_PADSV
		&& (kkid->op_private & OPpLVAL_INTRO))
	{
	    cLISTOPo->op_first = NULL;
	    kid->op_sibling = NULL;
	    op_free(o);
	    op_free(kid);
	    return kkid;
	}
    }
    return o;
}
