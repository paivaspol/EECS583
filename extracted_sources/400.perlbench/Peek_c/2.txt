void
_mstats_to_hv(HV *hv, struct mstats_buffer *b, int level)
{
    dTHX;
    SV **svp;
    int type;

    svp = hv_fetch(hv, "topbucket", 9, 1);
    sv_setiv(*svp, b->buffer.topbucket);

    svp = hv_fetch(hv, "topbucket_ev", 12, 1);
    sv_setiv(*svp, b->buffer.topbucket_ev);

    svp = hv_fetch(hv, "topbucket_odd", 13, 1);
    sv_setiv(*svp, b->buffer.topbucket_odd);

    svp = hv_fetch(hv, "totfree", 7, 1);
    sv_setiv(*svp, b->buffer.totfree);

    svp = hv_fetch(hv, "total", 5, 1);
    sv_setiv(*svp, b->buffer.total);

    svp = hv_fetch(hv, "total_chain", 11, 1);
    sv_setiv(*svp, b->buffer.total_chain);

    svp = hv_fetch(hv, "total_sbrk", 10, 1);
    sv_setiv(*svp, b->buffer.total_sbrk);

    svp = hv_fetch(hv, "sbrks", 5, 1);
    sv_setiv(*svp, b->buffer.sbrks);

    svp = hv_fetch(hv, "sbrk_good", 9, 1);
    sv_setiv(*svp, b->buffer.sbrk_good);

    svp = hv_fetch(hv, "sbrk_slack", 10, 1);
    sv_setiv(*svp, b->buffer.sbrk_slack);

    svp = hv_fetch(hv, "start_slack", 11, 1);
    sv_setiv(*svp, b->buffer.start_slack);

    svp = hv_fetch(hv, "sbrked_remains", 14, 1);
    sv_setiv(*svp, b->buffer.sbrked_remains);
    
    svp = hv_fetch(hv, "minbucket", 9, 1);
    sv_setiv(*svp, b->buffer.minbucket);
    
    svp = hv_fetch(hv, "nbuckets", 8, 1);
    sv_setiv(*svp, b->buffer.nbuckets);

    if (_NBUCKETS < b->buffer.nbuckets) 
	warn("FIXME: internal mstats buffer too short");
    
    for (type = 0; type < (level ? 4 : 2); type++) {
	UV *p = 0, *p1 = 0;
	AV *av;
	int i;
	static const char *types[4] = { 
	    "free", "used", "mem_size", "available_size"    
	};

	svp = hv_fetch(hv, types[type], strlen(types[type]), 1);

	if (SvOK(*svp) && !(SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVAV))
	    croak("Unexpected value for the key '%s' in the mstats hash", types[type]);
	if (!SvOK(*svp)) {
	    av = newAV();
	    (void)SvUPGRADE(*svp, SVt_RV);
	    SvRV(*svp) = (SV*)av;
	    SvROK_on(*svp);
	} else
	    av = (AV*)SvRV(*svp);

	av_extend(av, b->buffer.nbuckets - 1);
	/* XXXX What is the official way to reduce the size of the array? */
	switch (type) {
	case 0:
	    p = b->buffer.nfree;
	    break;
	case 1:
	    p = b->buffer.ntotal;
	    p1 = b->buffer.nfree;
	    break;
	case 2:
	    p = b->buffer.bucket_mem_size;
	    break;
	case 3:
	    p = b->buffer.bucket_available_size;
	    break;
	}
	for (i = 0; i < b->buffer.nbuckets; i++) {
	    svp = av_fetch(av, i, 1);
	    if (type == 1)
		sv_setiv(*svp, p[i]-p1[i]);
	    else
		sv_setuv(*svp, p[i]);
	}
    }
}
