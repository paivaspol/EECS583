PP(pp_ggrent)
{
#ifdef HAS_GROUP
    dSP;
    I32 which = PL_op->op_type;
    register char **elem;
    register SV *sv;
    struct group *grent;
    STRLEN n_a;

    if (which == OP_GGRNAM) {
        char* name = POPpbytex;
	grent = (struct group *)getgrnam(name);
    }
    else if (which == OP_GGRGID) {
        Gid_t gid = POPi;
	grent = (struct group *)getgrgid(gid);
    }
    else
#ifdef HAS_GETGRENT
	grent = (struct group *)getgrent();
#else
        DIE(aTHX_ PL_no_func, "getgrent");
#endif

    EXTEND(SP, 4);
    if (GIMME != G_ARRAY) {
	PUSHs(sv = sv_newmortal());
	if (grent) {
	    if (which == OP_GGRNAM)
		sv_setiv(sv, (IV)grent->gr_gid);
	    else
		sv_setpv(sv, grent->gr_name);
	}
	RETURN;
    }

    if (grent) {
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setpv(sv, grent->gr_name);

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
#ifdef GRPASSWD
	sv_setpv(sv, grent->gr_passwd);
#endif

	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	sv_setiv(sv, (IV)grent->gr_gid);

#if !(defined(_CRAYMPP) && defined(USE_REENTRANT_API))
	PUSHs(sv = sv_mortalcopy(&PL_sv_no));
	/* In UNICOS/mk (_CRAYMPP) the multithreading
	 * versions (getgrnam_r, getgrgid_r)
	 * seem to return an illegal pointer
	 * as the group members list, gr_mem.
	 * getgrent() doesn't even have a _r version
	 * but the gr_mem is poisonous anyway.
	 * So yes, you cannot get the list of group
	 * members if building multithreaded in UNICOS/mk. */
	for (elem = grent->gr_mem; elem && *elem; elem++) {
	    sv_catpv(sv, *elem);
	    if (elem[1])
		sv_catpvn(sv, " ", 1);
	}
#endif
    }

    RETURN;
#else
    DIE(aTHX_ PL_no_func, "getgrent");
#endif
}
