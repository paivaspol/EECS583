PP(pp_entersub)
{
    dSP; dPOPss;
    GV *gv;
    HV *stash;
    register CV *cv;
    register PERL_CONTEXT *cx;
    I32 gimme;
    bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;

    if (!sv)
	DIE(aTHX_ "Not a CODE reference");
    switch (SvTYPE(sv)) {
    default:
	if (!SvROK(sv)) {
	    char *sym;
	    STRLEN n_a;

	    if (sv == &PL_sv_yes) {		/* unfound import, ignore */
		if (hasargs)
		    SP = PL_stack_base + POPMARK;
		RETURN;
	    }
	    if (SvGMAGICAL(sv)) {
		mg_get(sv);
		if (SvROK(sv))
		    goto got_rv;
		sym = SvPOKp(sv) ? SvPVX(sv) : Nullch;
	    }
	    else
		sym = SvPV(sv, n_a);
	    if (!sym)
		DIE(aTHX_ PL_no_usym, "a subroutine");
	    if (PL_op->op_private & HINT_STRICT_REFS)
		DIE(aTHX_ PL_no_symref, sym, "a subroutine");
	    cv = get_cv(sym, TRUE);
	    break;
	}
  got_rv:
	{
	    SV **sp = &sv;		/* Used in tryAMAGICunDEREF macro. */
	    tryAMAGICunDEREF(to_cv);
	}	
	cv = (CV*)SvRV(sv);
	if (SvTYPE(cv) == SVt_PVCV)
	    break;
	/* FALL THROUGH */
    case SVt_PVHV:
    case SVt_PVAV:
	DIE(aTHX_ "Not a CODE reference");
    case SVt_PVCV:
	cv = (CV*)sv;
	break;
    case SVt_PVGV:
	if (!(cv = GvCVu((GV*)sv)))
	    cv = sv_2cv(sv, &stash, &gv, FALSE);
	if (!cv) {
	    ENTER;
	    SAVETMPS;
	    goto try_autoload;
	}
	break;
    }

    ENTER;
    SAVETMPS;

  retry:
    if (!CvROOT(cv) && !CvXSUB(cv)) {
	GV* autogv;
	SV* sub_name;

	/* anonymous or undef'd function leaves us no recourse */
	if (CvANON(cv) || !(gv = CvGV(cv)))
	    DIE(aTHX_ "Undefined subroutine called");

	/* autoloaded stub? */
	if (cv != GvCV(gv)) {
	    cv = GvCV(gv);
	}
	/* should call AUTOLOAD now? */
	else {
try_autoload:
	    if ((autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   FALSE)))
	    {
		cv = GvCV(autogv);
	    }
	    /* sorry */
	    else {
		sub_name = sv_newmortal();
		gv_efullname3(sub_name, gv, Nullch);
		DIE(aTHX_ "Undefined subroutine &%"SVf" called", sub_name);
	    }
	}
	if (!cv)
	    DIE(aTHX_ "Not a CODE reference");
	goto retry;
    }

    gimme = GIMME_V;
    if ((PL_op->op_private & OPpENTERSUB_DB) && GvCV(PL_DBsub) && !CvNODEBUG(cv)) {
	cv = get_db_sub(&sv, cv);
	if (!cv || (!CvXSUB(cv) && !CvSTART(cv)))
	    DIE(aTHX_ "No DB::sub routine defined");
    }

#ifdef USE_5005THREADS
    /*
     * First we need to check if the sub or method requires locking.
     * If so, we gain a lock on the CV, the first argument or the
     * stash (for static methods), as appropriate. This has to be
     * inline because for FAKE_THREADS, COND_WAIT inlines code to
     * reschedule by returning a new op.
     */
    MUTEX_LOCK(CvMUTEXP(cv));
    if (CvFLAGS(cv) & CVf_LOCKED) {
	MAGIC *mg;	
	if (CvFLAGS(cv) & CVf_METHOD) {
	    if (SP > PL_stack_base + TOPMARK)
		sv = *(PL_stack_base + TOPMARK + 1);
	    else {
		AV *av = (AV*)PAD_SVl(0);
		if (hasargs || !av || AvFILLp(av) < 0
		    || !(sv = AvARRAY(av)[0]))
		{
		    MUTEX_UNLOCK(CvMUTEXP(cv));
		    DIE(aTHX_ "no argument for locked method call");
		}
	    }
	    if (SvROK(sv))
		sv = SvRV(sv);
	    else {		
		STRLEN len;
		char *stashname = SvPV(sv, len);
		sv = (SV*)gv_stashpvn(stashname, len, TRUE);
	    }
	}
	else {
	    sv = (SV*)cv;
	}
	MUTEX_UNLOCK(CvMUTEXP(cv));
	mg = condpair_magic(sv);
	MUTEX_LOCK(MgMUTEXP(mg));
	if (MgOWNER(mg) == thr)
	    MUTEX_UNLOCK(MgMUTEXP(mg));
	else {
	    while (MgOWNER(mg))
		COND_WAIT(MgOWNERCONDP(mg), MgMUTEXP(mg));
	    MgOWNER(mg) = thr;
	    DEBUG_S(PerlIO_printf(Perl_debug_log, "%p: pp_entersub lock %p\n",
				  thr, sv));
	    MUTEX_UNLOCK(MgMUTEXP(mg));
	    SAVEDESTRUCTOR_X(Perl_unlock_condpair, sv);
	}
	MUTEX_LOCK(CvMUTEXP(cv));
    }
    /*
     * Now we have permission to enter the sub, we must distinguish
     * four cases. (0) It's an XSUB (in which case we don't care
     * about ownership); (1) it's ours already (and we're recursing);
     * (2) it's free (but we may already be using a cached clone);
     * (3) another thread owns it. Case (1) is easy: we just use it.
     * Case (2) means we look for a clone--if we have one, use it
     * otherwise grab ownership of cv. Case (3) means we look for a
     * clone (for non-XSUBs) and have to create one if we don't
     * already have one.
     * Why look for a clone in case (2) when we could just grab
     * ownership of cv straight away? Well, we could be recursing,
     * i.e. we originally tried to enter cv while another thread
     * owned it (hence we used a clone) but it has been freed up
     * and we're now recursing into it. It may or may not be "better"
     * to use the clone but at least CvDEPTH can be trusted.
     */
    if (CvOWNER(cv) == thr || CvXSUB(cv))
	MUTEX_UNLOCK(CvMUTEXP(cv));
    else {
	/* Case (2) or (3) */
	SV **svp;
	
	/*
	 * XXX Might it be better to release CvMUTEXP(cv) while we
     	 * do the hv_fetch? We might find someone has pinched it
     	 * when we look again, in which case we would be in case
     	 * (3) instead of (2) so we'd have to clone. Would the fact
     	 * that we released the mutex more quickly make up for this?
     	 */
	if ((svp = hv_fetch(thr->cvcache, (char *)cv, sizeof(cv), FALSE)))
	{
	    /* We already have a clone to use */
	    MUTEX_UNLOCK(CvMUTEXP(cv));
	    cv = *(CV**)svp;
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "entersub: %p already has clone %p:%s\n",
				  thr, cv, SvPEEK((SV*)cv)));
	    CvOWNER(cv) = thr;
	    SvREFCNT_inc(cv);
	    if (CvDEPTH(cv) == 0)
		SAVEDESTRUCTOR_X(unset_cvowner, (void*) cv);
	}
	else {
	    /* (2) => grab ownership of cv. (3) => make clone */
	    if (!CvOWNER(cv)) {
		CvOWNER(cv) = thr;
		SvREFCNT_inc(cv);
		MUTEX_UNLOCK(CvMUTEXP(cv));
		DEBUG_S(PerlIO_printf(Perl_debug_log,
			    "entersub: %p grabbing %p:%s in stash %s\n",
			    thr, cv, SvPEEK((SV*)cv), CvSTASH(cv) ?
	    			HvNAME(CvSTASH(cv)) : "(none)"));
	    }
	    else {
		/* Make a new clone. */
		CV *clonecv;
		SvREFCNT_inc(cv); /* don't let it vanish from under us */
		MUTEX_UNLOCK(CvMUTEXP(cv));
		DEBUG_S((PerlIO_printf(Perl_debug_log,
				       "entersub: %p cloning %p:%s\n",
				       thr, cv, SvPEEK((SV*)cv))));
		/*
	    	 * We're creating a new clone so there's no race
		 * between the original MUTEX_UNLOCK and the
		 * SvREFCNT_inc since no one will be trying to undef
		 * it out from underneath us. At least, I don't think
		 * there's a race...
		 */
	     	clonecv = cv_clone(cv);
    		SvREFCNT_dec(cv); /* finished with this */
		hv_store(thr->cvcache, (char*)cv, sizeof(cv), (SV*)clonecv,0);
		CvOWNER(clonecv) = thr;
		cv = clonecv;
		SvREFCNT_inc(cv);
	    }
	    DEBUG_S(if (CvDEPTH(cv) != 0)
			PerlIO_printf(Perl_debug_log, "depth %ld != 0\n",
                                     CvDEPTH(cv)));
	    SAVEDESTRUCTOR_X(unset_cvowner, (void*) cv);
	}
    }
#endif /* USE_5005THREADS */

    if (CvXSUB(cv)) {
#ifdef PERL_XSUB_OLDSTYLE
	if (CvOLDSTYLE(cv)) {
	    I32 (*fp3)(int,int,int);
	    dMARK;
	    register I32 items = SP - MARK;
					/* We dont worry to copy from @_. */
	    while (SP > mark) {
		SP[1] = SP[0];
		SP--;
	    }
	    PL_stack_sp = mark + 1;
	    fp3 = (I32(*)(int,int,int))CvXSUB(cv);
	    items = (*fp3)(CvXSUBANY(cv).any_i32,
			   MARK - PL_stack_base + 1,
			   items);
	    PL_stack_sp = PL_stack_base + items;
	}
	else
#endif /* PERL_XSUB_OLDSTYLE */
	{
	    I32 markix = TOPMARK;

	    PUTBACK;

	    if (!hasargs) {
		/* Need to copy @_ to stack. Alternative may be to
		 * switch stack to @_, and copy return values
		 * back. This would allow popping @_ in XSUB, e.g.. XXXX */
		AV* av;
		I32 items;
#ifdef USE_5005THREADS
		av = (AV*)PAD_SVl(0);
#else
		av = GvAV(PL_defgv);
#endif /* USE_5005THREADS */		
		items = AvFILLp(av) + 1;   /* @_ is not tieable */

		if (items) {
		    /* Mark is at the end of the stack. */
		    EXTEND(SP, items);
		    Copy(AvARRAY(av), SP + 1, items, SV*);
		    SP += items;
		    PUTBACK ;		
		}
	    }
	    /* We assume first XSUB in &DB::sub is the called one. */
	    if (PL_curcopdb) {
		SAVEVPTR(PL_curcop);
		PL_curcop = PL_curcopdb;
		PL_curcopdb = NULL;
	    }
	    /* Do we need to open block here? XXXX */
	    (void)(*CvXSUB(cv))(aTHX_ cv);

	    /* Enforce some sanity in scalar context. */
	    if (gimme == G_SCALAR && ++markix != PL_stack_sp - PL_stack_base ) {
		if (markix > PL_stack_sp - PL_stack_base)
		    *(PL_stack_base + markix) = &PL_sv_undef;
		else
		    *(PL_stack_base + markix) = *PL_stack_sp;
		PL_stack_sp = PL_stack_base + markix;
	    }
	}
	LEAVE;
	return NORMAL;
    }
    else {
	dMARK;
	register I32 items = SP - MARK;
	AV* padlist = CvPADLIST(cv);
	push_return(PL_op->op_next);
	PUSHBLOCK(cx, CXt_SUB, MARK);
	PUSHSUB(cx);
	CvDEPTH(cv)++;
	/* XXX This would be a natural place to set C<PL_compcv = cv> so
	 * that eval'' ops within this sub know the correct lexical space.
	 * Owing the speed considerations, we choose instead to search for
	 * the cv using find_runcv() when calling doeval().
	 */
	if (CvDEPTH(cv) >= 2) {
	    PERL_STACK_OVERFLOW_CHECK();
	    pad_push(padlist, CvDEPTH(cv), 1);
	}
#ifdef USE_5005THREADS
	if (!hasargs) {
	    AV* av = (AV*)PAD_SVl(0);

	    items = AvFILLp(av) + 1;
	    if (items) {
		/* Mark is at the end of the stack. */
		EXTEND(SP, items);
		Copy(AvARRAY(av), SP + 1, items, SV*);
		SP += items;
		PUTBACK ;		
	    }
	}
#endif /* USE_5005THREADS */		
	PAD_SET_CUR(padlist, CvDEPTH(cv));
#ifndef USE_5005THREADS
	if (hasargs)
#endif /* USE_5005THREADS */
	{
	    AV* av;
	    SV** ary;

#if 0
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
	    			  "%p entersub preparing @_\n", thr));
#endif
	    av = (AV*)PAD_SVl(0);
	    if (AvREAL(av)) {
		/* @_ is normally not REAL--this should only ever
		 * happen when DB::sub() calls things that modify @_ */
		av_clear(av);
		AvREAL_off(av);
		AvREIFY_on(av);
	    }
#ifndef USE_5005THREADS
	    cx->blk_sub.savearray = GvAV(PL_defgv);
	    GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_5005THREADS */
	    CX_CURPAD_SAVE(cx->blk_sub);
	    cx->blk_sub.argarray = av;
	    ++MARK;

	    if (items > AvMAX(av) + 1) {
		ary = AvALLOC(av);
		if (AvARRAY(av) != ary) {
		    AvMAX(av) += AvARRAY(av) - AvALLOC(av);
		    SvPVX(av) = (char*)ary;
		}
		if (items > AvMAX(av) + 1) {
		    AvMAX(av) = items - 1;
		    Renew(ary,items,SV*);
		    AvALLOC(av) = ary;
		    SvPVX(av) = (char*)ary;
		}
	    }
	    Copy(MARK,AvARRAY(av),items,SV*);
	    AvFILLp(av) = items - 1;
	
	    while (items--) {
		if (*MARK)
		    SvTEMP_off(*MARK);
		MARK++;
	    }
	}
	/* warning must come *after* we fully set up the context
	 * stuff so that __WARN__ handlers can safely dounwind()
	 * if they want to
	 */
	if (CvDEPTH(cv) == 100 && ckWARN(WARN_RECURSION)
	    && !(PERLDB_SUB && cv == GvCV(PL_DBsub)))
	    sub_crush_depth(cv);
#if 0
	DEBUG_S(PerlIO_printf(Perl_debug_log,
			      "%p entersub returning %p\n", thr, CvSTART(cv)));
#endif
	RETURNOP(CvSTART(cv));
    }
}
