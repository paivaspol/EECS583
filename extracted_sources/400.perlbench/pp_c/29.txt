PP(pp_pow)
{
    dSP; dATARGET;
#ifdef PERL_PRESERVE_IVUV
    bool is_int = 0;
#endif
    tryAMAGICbin(pow,opASSIGN);
#ifdef PERL_PRESERVE_IVUV
    /* For integer to integer power, we do the calculation by hand wherever
       we're sure it is safe; otherwise we call pow() and try to convert to
       integer afterwards. */
    {
        SvIV_please(TOPm1s);
        if (SvIOK(TOPm1s)) {
            bool baseuok = SvUOK(TOPm1s);
            UV baseuv;

            if (baseuok) {
                baseuv = SvUVX(TOPm1s);
            } else {
                IV iv = SvIVX(TOPm1s);
                if (iv >= 0) {
                    baseuv = iv;
                    baseuok = TRUE; /* effectively it's a UV now */
                } else {
                    baseuv = -iv; /* abs, baseuok == false records sign */
                }
            }
            SvIV_please(TOPs);
            if (SvIOK(TOPs)) {
                UV power;

                if (SvUOK(TOPs)) {
                    power = SvUVX(TOPs);
                } else {
                    IV iv = SvIVX(TOPs);
                    if (iv >= 0) {
                        power = iv;
                    } else {
                        goto float_it; /* Can't do negative powers this way.  */
                    }
                }
                /* now we have integer ** positive integer. */
                is_int = 1;

                /* foo & (foo - 1) is zero only for a power of 2.  */
                if (!(baseuv & (baseuv - 1))) {
                    /* We are raising power-of-2 to a positive integer.
                       The logic here will work for any base (even non-integer
                       bases) but it can be less accurate than
                       pow (base,power) or exp (power * log (base)) when the
                       intermediate values start to spill out of the mantissa.
                       With powers of 2 we know this can't happen.
                       And powers of 2 are the favourite thing for perl
                       programmers to notice ** not doing what they mean. */
                    NV result = 1.0;
                    NV base = baseuok ? baseuv : -(NV)baseuv;
                    int n = 0;

                    for (; power; base *= base, n++) {
                        /* Do I look like I trust gcc with long longs here?
                           Do I hell.  */
                        UV bit = (UV)1 << (UV)n;
                        if (power & bit) {
                            result *= base;
                            /* Only bother to clear the bit if it is set.  */
                            power -= bit;
                           /* Avoid squaring base again if we're done. */
                           if (power == 0) break;
                        }
                    }
                    SP--;
                    SETn( result );
                    SvIV_please(TOPs);
                    RETURN;
		} else {
		    register unsigned int highbit = 8 * sizeof(UV);
		    register unsigned int lowbit = 0;
		    register unsigned int diff;
		    bool odd_power = (bool)(power & 1);
		    while ((diff = (highbit - lowbit) >> 1)) {
			if (baseuv & ~((1 << (lowbit + diff)) - 1))
			    lowbit += diff;
			else 
			    highbit -= diff;
		    }
		    /* we now have baseuv < 2 ** highbit */
		    if (power * highbit <= 8 * sizeof(UV)) {
			/* result will definitely fit in UV, so use UV math
			   on same algorithm as above */
			register UV result = 1;
			register UV base = baseuv;
			register int n = 0;
			for (; power; base *= base, n++) {
			    register UV bit = (UV)1 << (UV)n;
			    if (power & bit) {
				result *= base;
				power -= bit;
				if (power == 0) break;
			    }
			}
			SP--;
			if (baseuok || !odd_power)
			    /* answer is positive */
			    SETu( result );
			else if (result <= (UV)IV_MAX)
			    /* answer negative, fits in IV */
			    SETi( -(IV)result );
			else if (result == (UV)IV_MIN) 
			    /* 2's complement assumption: special case IV_MIN */
			    SETi( IV_MIN );
			else
			    /* answer negative, doesn't fit */
			    SETn( -(NV)result );
			RETURN;
		    } 
		}
	    }
	}
    }
  float_it:
#endif    
    {
	dPOPTOPnnrl;
	SETn( Perl_pow( left, right) );
#ifdef PERL_PRESERVE_IVUV
	if (is_int)
	    SvIV_please(TOPs);
#endif
	RETURN;
    }
}
