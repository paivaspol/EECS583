I32
Perl_wait4pid(pTHX_ Pid_t pid, int *statusp, int flags)
{
    I32 result;
    if (!pid)
	return -1;
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
    {
	SV *sv;
	SV** svp;
	char spid[TYPE_CHARS(IV)];

	if (pid > 0) {
	    sprintf(spid, "%"IVdf, (IV)pid);
	    svp = hv_fetch(PL_pidstatus,spid,strlen(spid),FALSE);
	    if (svp && *svp != &PL_sv_undef) {
		*statusp = SvIVX(*svp);
		(void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
		return pid;
	    }
	}
	else {
	    HE *entry;

	    hv_iterinit(PL_pidstatus);
	    if ((entry = hv_iternext(PL_pidstatus))) {
		pid = atoi(hv_iterkey(entry,(I32*)statusp));
		sv = hv_iterval(PL_pidstatus,entry);
		*statusp = SvIVX(sv);
		sprintf(spid, "%"IVdf, (IV)pid);
		(void)hv_delete(PL_pidstatus,spid,strlen(spid),G_DISCARD);
		return pid;
	    }
	}
    }
#endif
#ifdef HAS_WAITPID
#  ifdef HAS_WAITPID_RUNTIME
    if (!HAS_WAITPID_RUNTIME)
	goto hard_way;
#  endif
    result = PerlProc_waitpid(pid,statusp,flags);
    goto finish;
#endif
#if !defined(HAS_WAITPID) && defined(HAS_WAIT4)
    result = wait4((pid==-1)?0:pid,statusp,flags,Null(struct rusage *));
    goto finish;
#endif
#if !defined(HAS_WAITPID) && !defined(HAS_WAIT4) || defined(HAS_WAITPID_RUNTIME)
  hard_way:
    {
	if (flags)
	    Perl_croak(aTHX_ "Can't do waitpid with flags");
	else {
	    while ((result = PerlProc_wait(statusp)) != pid && pid > 0 && result >= 0)
		pidgone(result,*statusp);
	    if (result < 0)
		*statusp = -1;
	}
    }
#endif
  finish:
    if (result < 0 && errno == EINTR) {
	PERL_ASYNC_CHECK();
    }
    return result;
}
