void
Perl_report_evil_fh(pTHX_ GV *gv, IO *io, I32 op)
{
    char *func =
	op == OP_READLINE   ? "readline"  :	/* "<HANDLE>" not nice */
	op == OP_LEAVEWRITE ? "write" :		/* "write exit" not nice */
	PL_op_desc[op];
    char *pars = OP_IS_FILETEST(op) ? "" : "()";
    char *type = OP_IS_SOCKET(op)
	    || (gv && io && IoTYPE(io) == IoTYPE_SOCKET)
		?  "socket" : "filehandle";
    char *name = NULL;

    if (gv && isGV(gv)) {
	name = GvENAME(gv);
    }

    if (op == OP_phoney_OUTPUT_ONLY || op == OP_phoney_INPUT_ONLY) {
	if (ckWARN(WARN_IO)) {
	    const char *direction = (op == OP_phoney_INPUT_ONLY) ? "in" : "out";
	    if (name && *name)
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle %s opened only for %sput",
			    name, direction);
	    else
		Perl_warner(aTHX_ packWARN(WARN_IO),
			    "Filehandle opened only for %sput", direction);
	}
    }
    else {
	char *vile;
	I32   warn_type;

	if (gv && io && IoTYPE(io) == IoTYPE_CLOSED) {
	    vile = "closed";
	    warn_type = WARN_CLOSED;
	}
	else {
	    vile = "unopened";
	    warn_type = WARN_UNOPENED;
	}

	if (ckWARN(warn_type)) {
	    if (name && *name) {
		Perl_warner(aTHX_ packWARN(warn_type),
			    "%s%s on %s %s %s", func, pars, vile, type, name);
		if (io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		    Perl_warner(
			aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle %s?)\n",
			func, pars, name
		    );
	    }
	    else {
		Perl_warner(aTHX_ packWARN(warn_type),
			    "%s%s on %s %s", func, pars, vile, type);
		if (gv && io && IoDIRP(io) && !(IoFLAGS(io) & IOf_FAKE_DIRP))
		    Perl_warner(
			aTHX_ packWARN(warn_type),
			"\t(Are you trying to call %s%s on dirhandle?)\n",
			func, pars
		    );
	    }
	}
    }
}
