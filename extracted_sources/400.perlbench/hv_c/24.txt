void
Perl_hv_clear(pTHX_ HV *hv)
{
    register XPVHV* xhv;
    if (!hv)
	return;

    xhv = (XPVHV*)SvANY(hv);

    if (SvREADONLY(hv) && xhv->xhv_array != NULL) {
	/* restricted hash: convert all keys to placeholders */
	I32 i;
	HE* entry;
	for (i = 0; i <= (I32) xhv->xhv_max; i++) {
	    entry = ((HE**)xhv->xhv_array)[i];
	    for (; entry; entry = HeNEXT(entry)) {
		/* not already placeholder */
		if (HeVAL(entry) != &PL_sv_placeholder) {
		    if (HeVAL(entry) && SvREADONLY(HeVAL(entry))) {
			SV* keysv = hv_iterkeysv(entry);
			Perl_croak(aTHX_
	"Attempt to delete readonly key '%"SVf"' from a restricted hash",
				   keysv);
		    }
		    SvREFCNT_dec(HeVAL(entry));
		    HeVAL(entry) = &PL_sv_placeholder;
		    xhv->xhv_placeholders++; /* HvPLACEHOLDERS(hv)++ */
		}
	    }
	}
	goto reset;
    }

    hfreeentries(hv);
    xhv->xhv_placeholders = 0; /* HvPLACEHOLDERS(hv) = 0 */
    if (xhv->xhv_array /* HvARRAY(hv) */)
	(void)memzero(xhv->xhv_array /* HvARRAY(hv) */,
		      (xhv->xhv_max+1 /* HvMAX(hv)+1 */) * sizeof(HE*));

    if (SvRMAGICAL(hv))
	mg_clear((SV*)hv);

    HvHASKFLAGS_off(hv);
    HvREHASH_off(hv);
    reset:
    HvEITER(hv) = NULL;
}
