void PCG (double *A, double *x, double *b, int neq, int len, int *ia, 
	  int *iz,double *eps, int *niter, int precFlg,
	  double *rho, double *r, double *g, double *C, double *z)
{
  int			i=0, k=0, ncg=0,iam,ier=0;
  double		alpha=0.0, ekm1=0.0, rrho=0.0;
  double		rrho1=0.0, gz=0.0, qk=0.0;
  double          c1=0.005,qam,err,ram=0;
  
  
  /*  initialize result and residual vectors  */
  
  qam=0.;iam=0;
  for (i=0; i<neq; i++)
    {
      x[i] = 0.0;	  
      r[i] = b[i];
      err=fabs(r[i]);
      if(err>1.e-20){qam+=err;iam++;}
    }
  if(iam>0) qam=qam/iam;
  else {*niter=0;return;}

  /*  preconditioning  */
  
  printf("Cholesky preconditioning\n\n");
  
  printf("alpha=%f\n",alpha);
  PreConditioning(A,neq,len,ia,iz,alpha,precFlg,C,&ier);
  while (ier==0)
    {
      if (alpha<=0.0)	alpha=0.005;
      alpha += alpha;
      printf("alpha=%f\n",alpha);
      PreConditioning(A,neq,len,ia,iz,alpha,precFlg,C,&ier);
    }
  
  /* solving the system of equations using the iterative solver */
  
  printf("Solving the system of equations using the iterative solver\n\n");
  
  /*  main iteration loop  */
  
  for (k=1; k<=*niter; k++, ncg++)
    {
      
      /*  solve M rho = r, M=C CT  */
      
      Mrhor(C,neq,ia,iz,r,rho);
      
      /*  inner product (r,rho)  */
      
      InnerProduct(r,rho,neq,&rrho);
      
      /*  If working with Penalty-terms for boundary conditions you can get 
	  numerical troubles because RRHO becomes a very large value. 
	  With at least two iterations the result may be better !!! */
      
      /*  convergency check */
      
      printf("iteration= %d, error= %e, limit=%e\n",ncg,ram,c1*qam);
      if (k!=1 && (ram<=c1*qam))	break;
/*      if (k==6500)	break;*/
      if (k!=1)
	{
	  ekm1 = rrho/rrho1;
	  for (i=0; i<neq; i++)	g[i] = ekm1*g[i]-rho[i];
	}
      else
	{
	  
	  /*  g1 = -rho0  */
	  
	  for (i=0; i<neq; i++)	g[i] = -rho[i];
	}
      
      /*  solve equation system z = A g_k  */
      
      MatVecProduct(A,g,neq,ia,iz,z);
      
      /*  inner product (g,z)  */
      
      InnerProduct(g,z,neq,&gz);
      qk = rrho/gz;
      ram=0.;
      for (i=0; i<neq; i++)
	{
	  x[i] += qk*g[i];
	  r[i] += qk*z[i];
	  err=fabs(r[i]);
	  if(err>ram) ram=err;
	}
      rrho1 = rrho;
    }
  if(k==*niter){
    printf("*ERROR in PCG: no convergence;");
    FORTRAN(stop,());
  } 
  *eps = rrho;
  *niter = ncg;
  
  return;
}
