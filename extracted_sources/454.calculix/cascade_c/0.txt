void cascade(int *ipompc, double **coefmpcp, int **nodempcp, int *nmpc,
   int *mpcfree, int *nodeboun, int *ndirboun, int*nboun, int*ikmpc,
   int *ilmpc, int *ikboun, int *ilboun, int *mpcend, int *mpcmult,
   char *labmpc, int labmpcLen, int *nk, int *memmpc_, int *icascade, int *maxlenmpc,
   int *callfrommain){

 /*   detects cascaded mpc's and decascades them; checks multiple
     occurrence of the same dependent DOF's in different mpc/spc's

     data structure of ipompc,coefmpc,nodempc:
       for each mpc, e.g. i, 
         -the nodes are stored in nodempc(1,ipompc(i)),
          nodempc(1,nodempc(3,ipompc(i))),
          nodempc(1,nodempc(3,nodempc(3,ipompc(i))))... till
          nodempc(3,nodempc(3,nodempc(3,.......))))))=0;
         -the corresponding directions in nodempc(2,ipompc(i)),
          nodempc(2,nodempc(3,ipompc(i))),.....
         -the corresponding coefficient in coefmpc(ipompc(i)),
          coefmpc(nodempc(3,ipompc(i))),.....
       the mpc is written as a(1)u(i1,j1)+a(2)u(i2,j2)+...
       +....a(k)u(ik,jk)=0, the first term is the dependent term,
       the others are independent, at least after execution of the
       present routine. The mpc's must be homogeneous, otherwise a
       error message is generated and the program stops. */

    int i,j,index,id,idof,nterm,irow,icolumn,node,idir,idepend,
        irownl,icolnl,*ipointer=NULL,*icoef=NULL,ifree,*nodempc=NULL,
	*indepdof=NULL,nindep,ispooles,iexpand,ichange,indexold,ip1,
        mpc,indexnew,index1,index2,index1old,index2old,*jmpc=NULL,nl;

    double coef,*xcoef=NULL,*coefmpc=NULL,b;

    nodempc=*nodempcp;
    coefmpc=*coefmpcp;

    jmpc=NNEW(int,*nmpc);
    *icascade=0;
    idepend=0;

/*        check whether a node is used as a dependent node in a MPC
	  and in a SPC */

    for(i=0;i<*nmpc;i++){
	if(*nboun>0){
	    FORTRAN(nident,(ikboun,&ikmpc[i],nboun,&id));}
	else{id=0;}
	if(id>0){
	    if(ikboun[id-1]==ikmpc[i]){
		printf("*ERROR in cascade: the DOF corresponding to \n node %d in direction %d is detected on the \n dependent side of a MPC and a SPC\n",
		       (ikmpc[i]-1)/7+1,ikmpc[i]-3*((ikmpc[i]-1)/7));
		FORTRAN(stop,());
	    }
	}
    }

/*     check whether there are user mpc's other than MEANROT:
       return if called from Calculix.c   */

    for(i=0;i<*nmpc;i++){

        /* linear mpc */

	if((strcmp1(&labmpc[20*i],"                    ")==0) ||
	   (strcmp1(&labmpc[20*i],"CYCLIC")==0) ||
	   (strcmp1(&labmpc[20*i],"SUBCYCLIC")==0)) jmpc[i]=0;

        /* nonlinear mpc */

	else if((strcmp1(&labmpc[20*i],"RIGID")==0) ||
	   (strcmp1(&labmpc[20*i],"PLANE")==0) ||
	   (strcmp1(&labmpc[20*i],"STRAIGHT")==0)) jmpc[i]=1;

        /* user mpc */

	else{
	    jmpc[i]=1;
	    *icascade=1;
	}
    }

/*     decascading */

    ispooles=0;

    /* decascading using simple substitution */

    do{
        ichange=0;
	/*  printf("ichange=%d\n",ichange);*/
        for(i=0;i<*nmpc;i++){
	    if(jmpc[i]==1) nl=1;
	    else nl=0;
	    iexpand=0;
	    index=nodempc[3*ipompc[i]-1];
	    if(index==0) continue;
	    do{
		idof=(nodempc[3*index-3]-1)*7+nodempc[3*index-2];
		FORTRAN(nident,(ikmpc,&idof,nmpc,&id));
		if((id>0)&&(ikmpc[id-1]==idof)){
		    
		    /* a term on the independent side of the MPC is
		       detected as dependent node in another MPC */
		    
		    /* printf("*INFO in cascade: DOF %d of node %d is expanded\n",
			   nodempc[3*index-2],nodempc[3*index-3]);
		    ichange=1;iexpand=1; */
		    indexold=nodempc[3*index-1];
		    coef=coefmpc[index-1];
		    mpc=ilmpc[id-1];

                    /* no expansion of there is a dependence of a
                       nonlinear MPC on another linear or nonlinear MPC
                       and the call is from main */ 

		    if((jmpc[mpc-1]==1)||(nl==1)){
			*icascade=2;
			if(idepend==0){
			    printf("*INFO in cascade: linear MPCs and\n");
			    printf("       nonlinear MPCs depend on each other\n\n");
			    idepend=1;}
			/* FORTRAN(stop,()); */
			if(*callfrommain==1){
			    index=nodempc[3*index-1];
			    if(index!=0) continue;
			    else break;}
			ip1=i+1;
			/*FORTRAN(writempc,(ipompc,nodempc,coefmpc,&ip1));
			  FORTRAN(writempc,(ipompc,nodempc,coefmpc,&mpc));*/
		    }
#ifndef SPEC_CPU
/* reduce i/o */
		    printf("*INFO in cascade: DOF %d of node %d is expanded\n",
			   nodempc[3*index-2],nodempc[3*index-3]);
#endif
		    ichange=1;iexpand=1;
		    if((strcmp1(&labmpc[20*i],"                    ")==0)&&
		       (strcmp1(&labmpc[20*(mpc-1)],"CYCLIC")==0))
			strcpy1(&labmpc[20*i],"SUBCYCLIC",9);
		    indexnew=ipompc[mpc-1];
		    coef=-coef/coefmpc[indexnew-1];
		    indexnew=nodempc[3*indexnew-1];
		    do{
			coefmpc[index-1]=coef*coefmpc[indexnew-1];
			nodempc[3*index-3]=nodempc[3*indexnew-3];
			nodempc[3*index-2]=nodempc[3*indexnew-2];
			indexnew=nodempc[3*indexnew-1];
			if(indexnew!=0){
			    nodempc[3*index-1]=*mpcfree;
			    index=*mpcfree;
			    *mpcfree=nodempc[3**mpcfree-1];
			    if(*mpcfree==0){
				*mpcfree=*memmpc_+1;
				nodempc[3*index-1]=*mpcfree;
				*memmpc_=(int)(1.1**memmpc_);
				printf("*INFO in cascade: reallocating nodempc; new size = %d\n",*memmpc_);
				RENEW(nodempc,int,3**memmpc_);
				RENEW(coefmpc,double,*memmpc_);
				for(j=*mpcfree;j<*memmpc_;j++){
				    nodempc[3*j-1]=j+1;
				}
				nodempc[3**memmpc_-1]=0;
			    }
			    continue;
			}
			else{
			    nodempc[3*index-1]=indexold;
			    break;
			}
		    }while(1);
		    break;
		}
		else{
		    index=nodempc[3*index-1];
		    if(index!=0) continue;
		    else break;
		}
	    }while(1);
	    if(iexpand==0) continue;
	    
	    /* one term of the mpc was expanded 
	       collecting terms corresponding to the same DOF */
	    
	    index1=ipompc[i];
	    do{
		index2old=index1;
		index2=nodempc[3*index1-1];
		if(index2==0) break;
		do{
		    if((nodempc[3*index1-3]==nodempc[3*index2-3])&&
		       (nodempc[3*index1-2]==nodempc[3*index2-2])){
			coefmpc[index1-1]+=coefmpc[index2-1];
			nodempc[3*index2old-1]=nodempc[3*index2-1];
			nodempc[3*index2-1]=*mpcfree;
			*mpcfree=index2;
			index2=nodempc[3*index2old-1];
			if(index2==0) break;
		    }
		    else{
			index2old=index2;
			index2=nodempc[3*index2-1];
			if(index2==0) break;
		    }
		}while(1);
		index1=nodempc[3*index1-1];
		if(index1==0) break;
	    }while(1);
	    
	    /* check for zero coefficients on the dependent and
	       independent side */
	    
	    index1=ipompc[i];
	    index1old=0;
	    do {
		if(fabs(coefmpc[index1-1])<1.e-10){
		    if(index1old==0){
			printf("*ERROR in cascade: zero coefficient on the\n");
			printf("       dependent side of an equation\n");
			FORTRAN(stop,());
		    }
		    else{
			nodempc[3*index1old-1]=nodempc[3*index1-1];
			nodempc[3*index1-1]=*mpcfree;
			*mpcfree=index1;
			index1=nodempc[3*index1old-1];
		    }
		}
		else{
		    index1old=index1;
		    index1=nodempc[3*index1-1];
		}
		if(index1==0) break;
	    }while(1);
        }
        if(ichange==0) break;
    }while(1);
    
/*     determining the effective size of nodempc and coefmpc for
       the reallocation*/

    *mpcend=0;
    *mpcmult=0;
    *maxlenmpc=0;
/*    printf("overview:\n");*/
    for(i=0;i<*nmpc;i++){
	index=ipompc[i];
	*mpcend=max(*mpcend,index);
	nterm=1;
	while(1){
	    /*     printf("%d,%d,%d,%f\n",i+1,nodempc[3*index-3],nodempc[3*index-2],
		   coefmpc[index-1]);*/
	    index=nodempc[3*index-1];
	    if(index==0){
		*mpcmult+=nterm*(nterm-1);
		*maxlenmpc=max(*maxlenmpc,nterm);
		break;
	    }
	    *mpcend=max(*mpcend,index);
	    nterm++;
	}
    }

    free(jmpc);

/*    *mpcfree=0;*/
    *nodempcp=nodempc;
    *coefmpcp=coefmpc;
    
    /*   for(i=0;i<*nmpc;i++){
	ip1=i+1;
	FORTRAN(writempc,(ipompc,nodempc,coefmpc,labmpc,&ip1));
	}*/
    
    return;
}
