void
P7PriorifyEmissionVector(float *vec, struct p7prior_s *pri, 
		       int num, float eq[MAXDCHLET], float e[MAXDCHLET][MAXABET],
		       float *ret_mix)
{
  int   x;                      /* counter over vec                     */
  int   q;                      /* counter over mixtures                */
  float mix[MAXDCHLET];         /* posterior distribution over mixtures */
  float totc;                   /* total counts                         */
  float tota;                   /* total alpha terms                    */
  float xi;                     /* X_i term, Sjolander eq. 41           */

  /* Calculate mix[], which is the posterior probability
   * P(q | n) of mixture component q given the count vector n
   *
   * (side effect note: note that an insert vector in a PAM prior
   * is passed with num = 1, bypassing pam prior code; this means
   * that inserts cannot be mixture Dirichlets...)
   * [SRE, 12/24/00: the above comment is cryptic! what the hell does that
   *  mean, inserts can't be mixtures? doesn't seem to be true. it 
   *  may mean that in a PAM prior, you can't have a mixture for inserts,
   *  but I don't even understand that. The insert vectors aren't passed
   *  with num=1!!]
   */
  mix[0] = 1.0;
  if (pri->strategy == PRI_DCHLET && num > 1) 
    {
      for (q = 0; q < num; q++) 
	{
	  mix[q] =  eq[q] > 0.0 ? log(eq[q]) : -999.;
	  mix[q] += Logp_cvec(vec, Alphabet_size, e[q]);
	}
      LogNorm(mix, num);      /* now mix[q] is P(component_q | n) */
    }
  else if (pri->strategy == PRI_PAM && num > 1) 
    {		/* pam prior uses aa frequencies as `P(q|n)' */
      for (q = 0; q < Alphabet_size; q++) 
	mix[q] = vec[q];
      FNorm(mix, Alphabet_size);
    }

  /* Convert the counts to probabilities, following Sjolander (1996) 
   */
  totc = FSum(vec, Alphabet_size);
  for (x = 0; x < Alphabet_size; x++) {
    xi = 0.0;
    for (q = 0; q < num; q++) {
      tota = FSum(e[q], Alphabet_size);
      xi += mix[q] * (vec[x] + e[q][x]) / (totc + tota);
    }
    vec[x] = xi;
  }
  FNorm(vec, Alphabet_size);

  if (ret_mix != NULL)
    for (q = 0; q < num; q++)
      ret_mix[q] = mix[q];
}
