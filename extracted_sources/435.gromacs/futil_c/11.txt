bool get_libdir(char *libdir)
{
  char bin_name[512];
  char buf[512];
  char full_path[512];
  char test_file[512];
  char system_path[512];
  char *dir,*ptr,*s;
  bool found=FALSE;
  int i;

#ifdef SPEC_CPU
  return FALSE;
#else

  /* First - detect binary name */
  strcpy(bin_name,Program());
  
  /* On windows & cygwin we need to add the .exe extension
   * too, or we wont be able to detect that the file exists
   */
#if (defined WIN32 || defined _WIN32 || defined WIN64 || defined _WIN64 || defined __CYGWIN__ || defined __CYGWIN32__)
  if(strlen(bin_name)<3 || strncasecmp(bin_name+strlen(bin_name)-4,".exe",4))
    strcat(bin_name,".exe");
#endif

  /* Only do the smart search part if we got a real name */
  if (bin_name && strcmp(bin_name,"GROMACS")) {
  
    if (!strchr(bin_name,DIR_SEPARATOR)) {
      /* No slash or backslash in name means it must be in the path - search it! */
      s=getenv("PATH");

      /* Add the local dir since it is not in the path on windows */
      getcwd(system_path,sizeof(system_path)-1);
      strcat(system_path,PATH_SEPARATOR);
      if (s != NULL)
	strcat(system_path,s);
      s=system_path;
      found=FALSE;
      while (!found && (dir=strtok(s,PATH_SEPARATOR))!=NULL) {
	sprintf(full_path,"%s%c%s",dir,DIR_SEPARATOR,bin_name);
	found=fexist(full_path);
	s=NULL; /* pointer should be null for subseq. calls to strtok */
      }
      if (!found)
	return FALSE;
    } else if (!filename_is_absolute(bin_name)) {
      /* name contains directory separators, but 
       * it does not start at the root, i.e.
       * name is relative to the current dir 
       */
      getcwd(buf,sizeof(buf)-1);
      strcpy(full_path,buf);
      strcat(full_path,bin_name+1);
    } else {
      strcpy(full_path,bin_name);
    }
    
    /* Now we should have a full path and name in full_path,
     * but on unix it might be a link, or a link to a link to a link..
     */
#if (!defined WIN32 && !defined _WIN32 && !defined WIN64 && !defined _WIN64)
    while( (i=readlink(full_path,buf,sizeof(buf)-1)) > 0 ) {
      buf[i]='\0';
      /* If it doesn't start with "/" it is relative */
      if (buf[0]!=DIR_SEPARATOR) {
	strcpy(strrchr(full_path,DIR_SEPARATOR)+1,buf);
      } else
	strcpy(full_path,buf);
    }
#endif
    
    /* Remove the executable name - it always contains at least one slash */
    *(strrchr(full_path,DIR_SEPARATOR)+1)='\0';
    /* Now we have the full path to the gromacs executable.
     * Use it to find the library dir. 
     */
    found=FALSE;
    while(!found && ( (ptr=strrchr(full_path,DIR_SEPARATOR)) != NULL ) ) {
      *ptr='\0';
      found=search_subdirs(full_path,libdir);
    }
  }
  /* End of smart searching. If we didn't find it in our parent tree,
   * or if the program name wasn't set, at least try some standard 
   * locations before giving up, in case we are running from e.g. 
   * a users home directory. This only works on unix or cygwin...
   */
#if ((!defined WIN32 && !defined _WIN32 && !defined WIN64 && !defined _WIN64) || defined __CYGWIN__ || defined __CYGWIN32__)
  if(!found) 
    found=search_subdirs("/usr/local",libdir);
  if(!found) 
    found=search_subdirs("/usr",libdir);
  if(!found) 
    found=search_subdirs("/opt",libdir);
#endif
  return found;
#endif
}
