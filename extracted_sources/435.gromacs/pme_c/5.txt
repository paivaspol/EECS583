void gather_f_bsplines(t_fftgrid *grid,matrix recipbox,
		       ivec idx[],rvec f[],real *charge,splinevec theta,
		       splinevec dtheta,int nr,int order,
		       int nnx[],int nny[],int nnz[])
{
  /* sum forces for local particles */  
  int     i,j,k,n,*i0,*j0,*k0,*ii0,*jj0,*kk0,ithx,ithy,ithz;
  int     nx,ny,nz,la2,la12;
  t_fft_r *ptr;
  int     xidx,yidx,zidx;
  real    tx,ty,dx,dy,qn;
  real    fx,fy,fz,gval,tgz,dgz;
  real    gval1,gval2,gval3,gval4;
  real    fxy1,fz1;
  real    *thx,*thy,*thz,*dthx,*dthy,*dthz;
  int     sn,norder,norder1,*idxptr,ind0;
  real    rxx,ryx,ryy,rzx,rzy,rzz;

  unpack_fftgrid(grid,&nx,&ny,&nz,&la2,&la12,TRUE,&ptr);
 
  thx  = theta[XX];
  thy  = theta[YY];
  thz  = theta[ZZ];
  dthx = dtheta[XX];
  dthy = dtheta[YY];
  dthz = dtheta[ZZ];
  ii0  = nnx+nx+1-order;
  jj0  = nny+ny+1-order;
  kk0  = nnz+nz+1-order;
  
  rxx = recipbox[XX][XX];
  ryx = recipbox[YY][XX];
  ryy = recipbox[YY][YY];
  rzx = recipbox[ZZ][XX];
  rzy = recipbox[ZZ][YY];
  rzz = recipbox[ZZ][ZZ];


  for(n=0; (n<nr); n++) {
    qn     = charge[n];
    fx      = 0.0;
    fy      = 0.0;
    fz      = 0.0;

    if (fabs(qn) > GMX_REAL_MIN) {
      idxptr = idx[n];
      xidx = idxptr[XX];
      yidx = idxptr[YY];
      zidx = idxptr[ZZ];
#ifdef DEBUG
      range_check(xidx,nx);
      range_check(yidx,ny);
      range_check(zidx,nz);
#endif
      
      i0      = ii0+xidx;   /* Pointer arithemtic */
      norder  = n*order;
      norder1 = norder+order;
      for(ithx=norder; (ithx<norder1); ithx++,i0++) {
        i     = *i0;
        tx    = thx[ithx];
        dx    = dthx[ithx];
        j0    = jj0+yidx;   /* Pointer arithemtic */

        if (order == 4) {
          for(ithy=norder; (ithy<norder1); ithy++,j0++) {
            j     = *j0;
            ty    = thy[ithy];
            dy    = dthy[ithy];
            k0    = kk0+zidx;     /* Pointer arithemtic */
            ind0  = INDEX(i,j,0);
            gval1 = ptr[ind0+k0[0]];
            gval2 = ptr[ind0+k0[1]];
            gval3 = ptr[ind0+k0[2]];
            gval4 = ptr[ind0+k0[3]];
            
            ithz  = norder;
            
            /* First iteration */
            fxy1  = thz[ithz]*gval1;
            fz1   = dthz[ithz]*gval1;
            ithz++;
            
            /* Second iteration */
            fxy1 += thz[ithz]*gval2;
            fz1  += dthz[ithz]*gval2;
            ithz++;
            
            /* Third iteration */
            fxy1 += thz[ithz]*gval3;
            fz1  += dthz[ithz]*gval3;
            ithz++;
            
            /* Fourth iteration */
            fxy1 += thz[ithz]*gval4;
            fz1  += dthz[ithz]*gval4;
            fx    = fx+dx*ty*fxy1;
            fy    = fy+tx*dy*fxy1;
            fz    = fz+tx*ty*fz1;    
          } 
        }
	   else {
        	  for(ithy=norder; (ithy<norder1); ithy++,j0++) {
            j     = *j0;
            ty    = thy[ithy];
            dy    = dthy[ithy];
            k0    = kk0+zidx; /* Pointer arithemtic */
            ind0  = INDEX(i,j,0);
            fxy1 = fz1 = 0;
            for(ithz=norder; (ithz<norder1); ithz++,k0++) {
              k     = *k0;
#ifdef DEBUG
	      range_check(i,nx);
	      range_check(j,ny);
	      range_check(k,nz);
	      range_check(ind0+k,grid->nptr);
#endif            
              gval  = ptr[ind0+k];
              fxy1 += thz[ithz]*gval;
              fz1  += dthz[ithz]*gval;
            }
            fx += dx*ty*fxy1;
            fy += tx*dy*fxy1;
            fz += tx*ty*fz1; 
          } 
        } 
      }
      f[n][XX] -= qn*( fx*nx*rxx );
      f[n][YY] -= qn*( fx*nx*ryx + fy*ny*ryy );
      f[n][ZZ] -= qn*( fx*nx*rzx + fy*ny*rzy + fz*nz*rzz );
    }
  }
  /* Since the energy and not forces are interpolated
   * the net force might not be exactly zero.
   * This can be solved by also interpolating F, but
   * that comes at a cost.
   * A better hack is to remove the net force every
   * step, but that must be done at a higher level
   * since this routine doesn't see all atoms if running
   * in parallel. Don't know how important it is?  EL 990726
   */
}
