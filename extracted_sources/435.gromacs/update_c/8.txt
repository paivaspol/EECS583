void calc_ke_part_visc(bool bFirstStep,int start,int homenr,
		       matrix box,rvec x[],
		       rvec vold[],rvec v[],rvec vt[],
		       t_grpopts *opts,t_mdatoms *md,t_groups *grps,
		       t_nrnb *nrnb,real lambda,real *dvdlambda)
{
  int          g,d,n,gt;
  rvec         v_corrt;
  real         hm,vvt;
  t_grp_tcstat *tcstat=grps->tcstat;
  t_cos_acc    *cosacc=&(grps->cosacc);
  real         dvdl;
  real         fac,cosz;
  double       mvcos;

  for (g=0; g<opts->ngtc; g++)
    clear_mat(grps->tcstat[g].ekin); 
    
  if (bFirstStep)
    for(n=start; n<start+homenr; n++)
      copy_rvec(v[n],vold[n]);

  fac = 2*M_PI/box[ZZ][ZZ];
  mvcos = 0;
  dvdl = 0;
  for(n=start; n<start+homenr; n++) {  
    gt   = md->cTC[n];
    hm   = 0.5*md->massT[n];
    
    for(d=0; d<DIM; d++) {
      vvt        = 0.5*(v[n][d]+vold[n][d]);
      vt[n][d]   = vvt;
      v_corrt[d] = vvt;
    }
    cosz         = cos(fac*x[n][ZZ]);
    /* Subtract the profile for the kinetic energy */
    v_corrt[XX] -= cosz*cosacc->vcos;
    /* Calculate the amplitude of the new velocity profile */
    mvcos       += 2*cosz*md->massT[n]*v[n][XX];

    for(d=0; d<DIM; d++) {
      tcstat[gt].ekin[XX][d]+=hm*v_corrt[XX]*v_corrt[d];
      tcstat[gt].ekin[YY][d]+=hm*v_corrt[YY]*v_corrt[d];
      tcstat[gt].ekin[ZZ][d]+=hm*v_corrt[ZZ]*v_corrt[d];
    }
    if (dvdlambda!=NULL && md->bPerturbed[n]) {
      dvdl-=0.5*(md->massB[n]-md->massA[n])*iprod(v_corrt,v_corrt);
    }
  }
  if(dvdlambda!=NULL)
    *dvdlambda += dvdl;
  cosacc->mvcos = mvcos;

  inc_nrnb(nrnb,eNR_EKIN,homenr);
}
