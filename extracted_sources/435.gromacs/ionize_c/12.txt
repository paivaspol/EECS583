void ionize(FILE *fp,t_mdatoms *md,char **atomname[],real t,t_inputrec *ir,
	    rvec x[],rvec v[],int start,int end,matrix box,t_commrec *cr)
{
  static FILE  *xvg,*ion;
  static char  *leg[] = { "Probability", "Primary Ionization", "Integral over PI", "KHole-Decay", "Integral over KD" };
  static bool  bFirst = TRUE;
  static real  t0,imax,width,rho,nphot;
  static real  interval;
  static int   dq_tot,nkd_tot,ephot,mode;
  static t_cross_atom *ca;
  static int   Eindex=-1;
    
  real factor,E_lost=0;
  real pt,ptot,pphot,pcoll[ecollNR],tmax;
  real hboxx,hboxy,rho2;
  rvec dv,ddv;
  bool bIonize=FALSE,bKHole,bL,bDOIT;
  int  i,k,kk,m,nK,nL,dq,nkh,nkdecay;
  int  *nionize,*nkhole,*ndecay,nbuf[2];
  
  if (bFirst) {
    /* Get parameters for gaussian photon pulse from inputrec */
    t0       = ir->userreal1;  /* Peak of the gaussian pulse            */
    nphot    = ir->userreal2;  /* Intensity                             */
    width    = ir->userreal3;  /* Width of the peak (in time)           */
    rho      = ir->userreal4;  /* Diameter of the focal spot (nm)       */
    ionize_seed = ir->userint1;   /* Random seed for stochastic ionization */
    ephot    = ir->userint2;   /* Energy of the photons                 */
    mode     = ir->userint3;   /* Mode of ionizing                      */
    interval = 0.001*ir->userint4;   /* Interval between pulses (ps)    */
     
    if ((width <= 0) || (nphot <= 0))
      fatal_error(0,"Your parameters for ionization are not set properly\n"
		  "width (userreal3) = %f,  nphot (userreal2) = %f",
		  width,nphot);
    
    if ((mode < 0) || (mode >= eionNR))
      fatal_error(0,"Ionization mode (userint3)"
		  " should be in the range 0 .. %d",eionNR-1);
    
    switch (mode) {
    case eionCYL:
      imax  = (nphot/(M_PI*sqr(rho/2)))*1e-10*1.0/(width*sqrt(2.0*M_PI));
      break;
    case eionSURF:
      imax  = (nphot/(M_PI*sqr(rho/2)))*1e-10*1.0/(width*sqrt(2.0*M_PI));
      break;
    }
    if (ionize_seed == 0)
      ionize_seed = make_seed();
    if (PAR(cr)) {
      for(i=0; (i<cr->nodeid); i++)
	ionize_seed = INT_MAX*rando(&ionize_seed);
      fprintf(fp,PREFIX"Modifying seed on parallel processor to %d\n",
	      ionize_seed);
    }
          
    for(Eindex=0; (Eindex < NENER) && (Energies[Eindex] != ephot); Eindex++)
      ;
    if (Eindex == NENER)
      fatal_error(0,PREFIX"Energy level of %d keV not supported",ephot);
    
    /* Initiate cross section data etc. */
    ca      = mk_cross_atom(fp,md,atomname,Eindex);
    
    dq_tot  = 0;
    nkd_tot = 0;

    xvg   = xvgropen("ionize.xvg","Ionization Events","Time (ps)","()");
    xvgr_legend(xvg,asize(leg),leg);
    ion   = ffopen("ionize.log","w");

    fprintf(fp,PREFIX"Parameters for ionization events:\n");
    fprintf(fp,PREFIX"Imax = %g, t0 = %g, width = %g, seed = %d\n"
	    PREFIX"# Photons = %g, rho = %g, ephot = %d (keV)\n",
	    imax,t0,width,ionize_seed,nphot,rho,ephot);
    fprintf(fp,PREFIX"Electron_mass: %10.3e(keV) Atomic_mass: %10.3e(keV)\n"
	    PREFIX"Speed_of_light: %10.3e(nm/ps)\n",
	    ELECTRONMASS_keV,ATOMICMASS_keV,SPEED_OF_LIGHT);
    fprintf(fp,PREFIX"Interval between shots: %g ps\n",interval);
    fprintf(fp,PREFIX"Eindex = %d\n",Eindex);
    fprintf(fp,PREFIX"Doing ionizations for atoms %d - %d\n",start,end);
    
    fflush(fp);

    bFirst = FALSE;
  }

  /******************************************************
   *
   *    H E R E    S T A R T S   I O N I Z A T I O N
   *
   ******************************************************/

  /* Calculate probability */
  tmax        = t0;
  if (interval > 0)
    while (t > (tmax+interval*0.5))
      tmax += interval;
  /*  End when t <= t0 + (N+0.5) interval */
  
  pt          = imax*ir->delta_t*exp(-0.5*sqr((t-tmax)/width));
  dq          = 0;
  nkdecay     = 0;

  hboxx       = 0.5*box[XX][XX];
  hboxy       = 0.5*box[YY][YY];
  rho2        = sqr(rho);
  
  /* Arrays for ionization statistics */
  snew(nionize,md->nr);
  snew(nkhole,md->nr);
  snew(ndecay,md->nr);
    
  /* Loop over atoms */
  for(i=start; (i<end); i++) {
    /* Loop over collision types */
    bKHole = FALSE;
    for(k=0; (k<ecollNR); k++) 
      /* Determine cross section for this collision type */
      pcoll[k]= pt*xray_cross_section(k,&(ca[i]));
    
    /* Total probability of ionisation */
    ptot = 1 - (1-pcoll[ecollPHOTO])*(1-pcoll[ecollINELASTIC]);
    if (debug && (i==0)) 
      fprintf(debug,PREFIX"Ptot = %g, t = %g\n",ptot,t);
    
    /* Check whether to ionize this guy */
    bDOIT = FALSE;
    switch (mode) {
    case eionCYL:
      bDOIT = (((rando(&ionize_seed) < ptot) && (ca[i].n < ca[i].z)) && 
	       ((sqr(x[i][XX] - hboxx) + sqr(x[i][YY] - hboxy)) < rho2));
      break;
    case eionSURF:
      bDOIT = FALSE;
      break;
    default:
      fatal_error(0,"Unknown ionization mode %d (%s, line %d)",mode,
		  __FILE__,__LINE__);
    }
      
    if (bDOIT) {
      clear_rvec(dv);
      
      /* The relative probability for a photoellastic event is given by: */
      pphot = pcoll[ecollPHOTO]/(pcoll[ecollPHOTO]+pcoll[ecollINELASTIC]);
      
      if (rando(&ionize_seed) < pphot) 
	k = ecollPHOTO;
      else
	k = ecollINELASTIC;
      
      /* If a random number is smaller than the probability for 
       * an L ionization than do that. Note that the probability
       * may be zero (H, He), but the < instead of <= covers that.
       */
      nK = number_K(&ca[i]);
      nL = number_L(&ca[i]);
      bL = (nK == 0) || ( (nL > 0) && (rando(&ionize_seed) > prob_K(k,&(ca[i]))));

      switch (k) {
      case ecollPHOTO: {
	/* Select which one to take by yet another random numer */
	real theta,phi;
	
	/* Get parameters for photoelestic effect */
	/* Note that in the article this is called 2 theta */
	theta = DEG2RAD*gauss(70.0,26.0,&ionize_seed);
	phi   = 2*M_PI*rando(&ionize_seed);
	
	if (bL)
	  E_lost = ephot-recoil[ca[i].z].E_L*(ca[i].n+1);
	else {
	  E_lost = ephot-recoil[ca[i].z].E_K;
	  if ((ca[i].z > 2) && (nL > 0))
	    bKHole = TRUE;
	}
	if (debug)
	  fprintf(debug,"i = %d, nK = %d, nL = %d, bL = %s, bKHole = %s\n",
		  i,nK,nL,BOOL(bL),BOOL(bKHole));
	if (E_lost < 0) {
	  E_lost  = 0.0;
	  bIonize = FALSE;
	  bKHole  = FALSE;
	}
	else {
	  /* Compute the components of the velocity vector */
	  factor = ((ELECTRONMASS_keV/(ATOMICMASS_keV*md->massT[i]))*
		    (SPEED_OF_LIGHT*sqrt(2*E_lost/ELECTRONMASS_keV)));
	  
	  /* Subtract momentum of recoiling electron */
	  polar2cart(phi,theta,ddv);
	  for(m=0; (m<DIM); m++)
	    dv[m] -= factor*ddv[m];
	
	  if (debug)
	    pr_rvec(debug,0,"ELL",dv,DIM);
	  
	  bIonize = TRUE;
	}
	break;
      }
      case ecollINELASTIC: {
	real theta,Ebind,Eelec;
	
	if (bL)
	  Ebind = (ca[i].n+1)*recoil[ca[i].z].E_L;
	else {
	  Ebind  = recoil[ca[i].z].E_K;
	  if ((ca[i].z > 2) && (nL > 0))
	    bKHole = TRUE;
	}
	theta      = DEG2RAD*rand_theta_incoh(Eindex,&ionize_seed);
	Eelec      = (sqr(ephot)/512)*(1-cos(2*theta));
	bIonize    = (Ebind <= Eelec);
	bKHole     = bKHole && bIonize;
	if (debug)
	  fprintf(debug,PREFIX"Ebind: %g, Eelectron: %g\n",Ebind,Eelec);
	if (!bIonize) {
	  /* Subtract momentum of recoiling photon */
	  /*phi     = 2*M_PI*rando(&ionize_seed);
 	    bKHole  = FALSE;  
	    factor  = ephot*438;  
	    dv[XX] -= factor*cos(phi)*sin(theta);
	    dv[YY] -= factor*sin(phi)*sin(theta);
	    dv[ZZ] -= factor*cos(theta);
	  */
	  if (debug)
	    pr_rvec(debug,0,"INELL",dv,DIM);
	}
	break;
      }
      default:
	fatal_error(0,"Ga direct naar de gevangenis. Ga niet langs start");
      }
      if (bIonize) {
	/* First increase the charge */
	if (ca[i].n < ca[i].z) {
	  md->chargeA[i] += 1.0;
	  md->chargeB[i] += 1.0;
	  ca[i].n++;
	  dq ++;
	}
	if (debug) {
	  fprintf(debug,"Random-dv[%3d] = %10.3e,%10.3e,%10.3e,"
		  " ephot = %d, Elost=%10.3e\n",
		  i,dv[XX],dv[YY],dv[ZZ],ephot,E_lost);
	}
      }
      /* Now actually add the impulse to the velocities */
      for(m=0; (m<DIM); m++)
	v[i][m] += dv[m];
      if (bKHole) {
	ca[i].k ++;
	nkhole[i]++;
      }
      else if (bIonize)
	nionize[i]++;
    }
    
    /* Now check old event: Loop over k holes! */
    nkh = ca[i].k;
    for (kk = 0; (kk < nkh); kk++) 
      if (khole_decay(fp,&(ca[i]),x,v,i,&ionize_seed,ir->delta_t)) {
	nkdecay ++;
	ndecay[i]++;
      }
    
    if (debug && (ca[i].n > 0))
      dump_ca(debug,&(ca[i]),i,__FILE__,__LINE__);
  }

  /* Sum events for statistics if necessary */
  if (PAR(cr)) {
    gmx_sumi(md->nr,nionize,cr);
    gmx_sumi(md->nr,nkhole,cr);
    gmx_sumi(md->nr,ndecay,cr);
    nbuf[0] = dq; nbuf[1] = nkdecay;
    gmx_sumi(2,nbuf,cr);
    dq = nbuf[0]; nkdecay = nbuf[1];
  }
  /* Now sum global events on this timestep to cumulative numbers */
  dq_tot  += dq;
  nkd_tot += nkdecay;
  
  /* Printing time */
  if (MASTER(cr)) {
    /* Print data to the file that holds ionization events per atom */
    fprintf(ion,"%12.8f",t);
    for(i=0; (i<md->nr); i++) {
      if (nionize[i])
	fprintf(ion,"  I:%d",i+1);
      if (nkhole[i])
	fprintf(ion,"  K:%d",i+1);
      if (ndecay[i])
	fprintf(ion,"  D:%d",i+1);
    }
    fprintf(ion,"\n");
    if (debug)
      fflush(ion);
  
    /* Print statictics to file */
    fprintf(xvg,"%10.5f  %10.3e  %6d  %6d  %6d  %6d",
	    t,pt,dq,dq_tot,nkdecay,nkd_tot);
    fprintf(xvg,"\n");
    if (debug)
      fflush(xvg);
  }
  sfree(nionize);
  sfree(nkhole);
  sfree(ndecay);
}
