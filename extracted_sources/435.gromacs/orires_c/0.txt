void init_orires(FILE *log,int nfa,t_iatom forceatoms[],t_iparams ip[],
		 rvec *xref,t_mdatoms *md,t_inputrec *ir,
		 t_commrec *mcr,t_fcdata *fcd)
{
  int  i,j,d,ex,nr,*nr_ex;
  real mtot;
  rvec com;
  t_oriresdata *od;
  
  od = &(fcd->orires);
  od->fc  = ir->orires_fc;
  od->nex = 0;
  od->S   = NULL;

  if (ir->orires_tau > 0)
    od->edt = exp(-ir->delta_t/ir->orires_tau);
  else
    od->edt = 0;
  od->edt1 = 1 - od->edt;
  od->exp_min_t_tau = 1.0;
  od->nr = nfa/3;
  
  if (od->nr == 0)
    return;

  nr_ex = NULL;

  for(i=0; i<nfa; i+=3) {
    ex = ip[forceatoms[i]].orires.ex;
    if (ex >= od->nex) {
      srenew(nr_ex,ex+1);
      for(j=od->nex; j<ex+1; j++)
	nr_ex[j] = 0;
      od->nex = ex+1;
    }
    nr_ex[ex]++;
  }
  snew(od->S,od->nex);
  /* When not doing time averaging, the instaneous and time averaged data
   * are indentical and the pointers can point to the same memory.
   */
  snew(od->Dinsl,od->nr);
  if (mcr)
    snew(od->Dins,od->nr);
  else
    od->Dins = od->Dinsl;
  if (fabs(ir->orires_tau) < GMX_REAL_MIN)
    od->Dtav = od->Dins;
  else
    snew(od->Dtav,od->nr);
  snew(od->oinsl,od->nr);
  if (mcr)
    snew(od->oins,od->nr);
  else
    od->oins = od->oinsl;
  if ( fabs(ir->orires_tau) < GMX_REAL_MIN)
    od->otav = od->oins;
  else
    snew(od->otav,od->nr);
  snew(od->tmp,od->nex);
  snew(od->TMP,od->nex);
  for(ex=0; ex<od->nex; ex++) {
    snew(od->TMP[ex],5);
    for(i=0; i<5; i++)
      snew(od->TMP[ex][i],5);
  }

  od->nref = 0;
  for(i=0; i<md->nr; i++)
    if (md->cORF[i] == 0)
      od->nref++;
  snew(od->mref,od->nref);
  snew(od->xref,od->nref);
  snew(od->xtmp,od->nref);

  /* Determine the reference structure on the master node.
   * Copy it to the other nodes after checking multi compatibility,
   * so we are sure the subsystems match before copying.
   */
  clear_rvec(com);
  mtot = 0.0;
  j = 0;
  for(i=0; i<md->nr; i++) {
    if (md->cORF[i] == 0) {
      od->mref[j] = md->massT[i];
      if (mcr==NULL || MASTER(mcr)) {
	copy_rvec(xref[i],od->xref[j]);
	for(d=0; d<DIM; d++)
	  com[d] += od->mref[j]*xref[i][d];
      }
      mtot += od->mref[j];
      j++;
    }
  }
  od->invmref = 1.0/mtot;
  svmul(od->invmref,com,com);
  if (mcr==NULL || MASTER(mcr))
    for(j=0; j<od->nref; j++)
      rvec_dec(od->xref[j],com);
  
  fprintf(log,"Found %d orientation experiments\n",od->nex);
  for(i=0; i<od->nex; i++)
    fprintf(log,"  experiment %d has %d restraints\n",i+1,nr_ex[i]);

  sfree(nr_ex);

  fprintf(log,"  the fit group consists of %d atoms and has total mass %g\n",
	  od->nref,mtot);
  
  if (mcr) {
    fprintf(log,"  the orientation restraints are ensemble averaged over %d systems\n",mcr->nnodes);

    check_multi_int(log,mcr,fcd->orires.nr,
		    "the number of orientation restraints");
    check_multi_int(log,mcr,fcd->orires.nref,
		    "the number of fit atoms for orientation restraining");
    /* Copy the reference coordinates from the master to the other nodes */
    gmx_sum(DIM*fcd->orires.nref,fcd->orires.xref[0],mcr);
  }
}
