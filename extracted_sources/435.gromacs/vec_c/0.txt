void vecinvsqrt(real in[],real out[],int n)
{
  /* Always use assembly on Alpha CPU. */
#ifdef USE_AXP_ASM
#  ifdef DOUBLE
   sqrtiv_(in,out,&n);
#  else /* SINGLE */
   ssqrtiv_(in,out,&n);
#  endif    
#elif defined HAVE_LIBMASSV_ANY
 /* On IBM we should definitely use vectorized MASS if present. */ 
#  ifdef DOUBLE
   vrsqrt(out,in,&n);
#  else /* SINGLE */
   vsrsqrt(out,in,&n);
#  endif 
#else /* not alpha, and not IBM with MASS */
   /* Software routines and calls to x86 assembly. */
#ifdef SOFTWARE_INVSQRT
  const real  half=0.5;
  const real  three=3.0;
  t_convert   result,bit_pattern;
  unsigned int exp,fract;
  float       lu,x;
#ifdef DOUBLE
  real        y;
#endif
#endif /* VARIABLES FOR SOFTWARE_INVSQRT */
  int i;
 
#if (defined USE_X86_SSE_AND_3DNOW && !defined DOUBLE) 
  static bool bFirst=TRUE;
  static int cpu_capabilities;
  
  if(bFirst) {
    cpu_capabilities=detect_cpu(NULL);
    bFirst=FALSE;
  }

  if((cpu_capabilities & X86_SSE_SUPPORT) && !((unsigned long int)in & 0x1f) && !((unsigned long int)out & 0x1f)) /* SSE data must be cache aligned */
    vecinvsqrt_sse(in,out,n);
  else if(cpu_capabilities & X86_3DNOW_SUPPORT)
    vecinvsqrt_3dnow(in,out,n);
  else
#endif /* no x86 optimizations */
#if (defined USE_X86_SSE2 && defined DOUBLE) 
  static bool bFirst=TRUE;
  static int cpu_capabilities;
  
  if(bFirst) {
    cpu_capabilities=detect_cpu(NULL);
    bFirst=FALSE;
  }

  if((cpu_capabilities & X86_SSE2_SUPPORT) && !((unsigned long int)in & 0x1f) && !((unsigned long int)out & 0x1f)) /* SSE2 data must be cache aligned */
    vecinvsqrt_sse2(in,out,n);
  else
#endif /* no sse2 optimizations */
#ifdef SOFTWARE_INVSQRT
    for(i=0;i<n;i++) {
      x=in[i];
      bit_pattern.fval=x;
      exp   = EXP_ADDR(bit_pattern.bval);
      fract = FRACT_ADDR(bit_pattern.bval);
      result.bval=cinvsqrtexptab[exp] | cinvsqrtfracttab[fract];
      lu    = result.fval;
      
#ifdef DOUBLE
      y=(half*lu*(three-((x*lu)*lu)));
      out[i]=(half*y*(three-((x*y)*y)));
#else
      out[i]=(half*lu*(three-((x*lu)*lu)));
#endif
    }
#else  /* no gmx invsqrt */
    for(i=0;i<n;i++)
      out[i]=1.0f/sqrt(in[i]);
#endif /* SOFTWARE_SQRT */
#endif
}
