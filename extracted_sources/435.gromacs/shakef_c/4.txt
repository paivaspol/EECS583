bool bshakef(FILE *log,int natoms,real invmass[],int nblocks,int sblock[],
	     t_idef *idef,t_inputrec *ir,matrix box,rvec x_s[],rvec xp[],
	     t_nrnb *nrnb,real lambda,real *dvdlambda,bool bDumpOnError)
{
  static  bool bFirst=TRUE;
  static  real *lagr;
  /* Stuff for successive overrelaxation */
  static  real delta=0.1;
  static  real omega=1.0;
  static  int  gamma=1000000;
  
  t_iatom *iatoms;
  real    *lam,dt_2,dvdl;
  int     i,n0,ncons,blen,type;
  int     tnit=0,trij=0;
  
#ifdef DEBUG
  fprintf(log,"nblocks=%d, sblock[0]=%d\n",nblocks,sblock[0]);
#endif
  ncons=idef->il[F_SHAKE].nr/3;
  if (bFirst) {
    if (ir->bShakeSOR) 
      please_cite(log,"Barth95a");
    snew(lagr,ncons);
    bFirst=FALSE;
  }
  for(i=0; i<ncons; i++)
    lagr[i] =0;
  
  iatoms = &(idef->il[F_SHAKE].iatoms[sblock[0]]);
  lam    = lagr;
  for(i=0; (i<nblocks); ) {
    blen  = (sblock[i+1]-sblock[i]);
    blen /= 3;
    n0 = vec_shakef(log,natoms,invmass,blen,idef->iparams,
		    iatoms,ir->shake_tol,x_s,xp,omega,
		    ir->efep!=efepNO,lambda,lam);
#ifdef DEBUGSHAKE
    check_cons(log,blen,x_s,xp,idef->iparams,iatoms,invmass);
#endif
    
    if (n0 == 0) {
      if (bDumpOnError)
	check_cons(log,blen,x_s,xp,idef->iparams,iatoms,invmass);
      return FALSE;
    }
    tnit   += n0*blen;
    trij   += blen;
    iatoms += 3*blen;	/* Increment pointer! */
    lam    += blen;
    i++;
  }
  if (ir->efep != efepNO) {
    dt_2 = 1/sqr(ir->delta_t);
    dvdl = 0;
    for(i=0; i<ncons; i++) {
      type = idef->il[F_SHAKE].iatoms[3*i];
      dvdl += lagr[i]*dt_2*
	(idef->iparams[type].shake.dB-idef->iparams[type].shake.dA);
    }
    *dvdlambda += dvdl;
  }
#ifdef DEBUG
  fprintf(log,"tnit: %5d  omega: %10.5f\n",tnit,omega);
#endif
  if (ir->bShakeSOR) {
    if (tnit > gamma) {
      delta = -0.5*delta;
    }
    omega = omega + delta;
    gamma = tnit;
  }
  inc_nrnb(nrnb,eNR_SHAKE,tnit);
  inc_nrnb(nrnb,eNR_SHAKE_RIJ,trij);
  
  return TRUE;
}
