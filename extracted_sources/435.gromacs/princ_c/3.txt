void principal_comp(int n,atom_id index[],t_atom atom[],rvec x[],
		    matrix trans,rvec d)
{
  int  i,j,ai,m,nrot;
  real mm,rx,ry,rz;
  double **inten,dd[NDIM],tvec[NDIM],**ev;
#ifdef DEBUG
  real e[NDIM];
#endif
  real temp;
  
  snew(inten,NDIM);
  snew(ev,NDIM);
  for(i=0; (i<NDIM); i++) {
    snew(inten[i],NDIM);
    snew(ev[i],NDIM);
    dd[i]=0.0;
#ifdef DEBUG
    e[i]=0.0;
#endif
  }
  
  for(i=0; (i<NDIM); i++)
    for(m=0; (m<NDIM); m++)
      inten[i][m]=0;
  for(i=0; (i<n); i++) {
    ai=index[i];
    mm=atom[ai].m;
    rx=x[ai][XX];
    ry=x[ai][YY];
    rz=x[ai][ZZ];
    inten[0][0]+=mm*(sqr(ry)+sqr(rz));
    inten[1][1]+=mm*(sqr(rx)+sqr(rz));
    inten[2][2]+=mm*(sqr(rx)+sqr(ry));
    inten[1][0]-=mm*(ry*rx);
    inten[2][0]-=mm*(rx*rz);
    inten[2][1]-=mm*(rz*ry);
  }
  inten[0][1]=inten[1][0];
  inten[0][2]=inten[2][0];
  inten[1][2]=inten[2][1];
#ifdef DEBUG
  ptrans("initial",inten,dd,e);
#endif
  
  for(i=0; (i<DIM); i++) {
    for(m=0; (m<DIM); m++)
      trans[i][m]=inten[i][m];
  }

  /* Call numerical recipe routines */
  jacobi(inten,3,dd,ev,&nrot);
#ifdef DEBUG
  ptrans("jacobi",ev,dd,e);
#endif
  
  /* Sort eigenvalues in descending order */
#define SWAPPER(i) 			\
  if (fabs(dd[i+1]) > fabs(dd[i])) {	\
    temp=dd[i];			\
    for(j=0; (j<NDIM); j++) tvec[j]=ev[j][i];\
    dd[i]=dd[i+1];			\
    for(j=0; (j<NDIM); j++) ev[j][i]=ev[j][i+1];		\
    dd[i+1]=temp;			\
    for(j=0; (j<NDIM); j++) ev[j][i+1]=tvec[j];			\
  }
  SWAPPER(0)
  SWAPPER(1)
  SWAPPER(0)
#ifdef DEBUG
  ptrans("swap",ev,dd,e);
  t_trans(trans,dd,ev);
#endif
    
  for(i=0; (i<DIM); i++) {
    d[i]=dd[i];
    for(m=0; (m<DIM); m++)
      trans[i][m]=ev[m][i];
  }
    
  for(i=0; (i<NDIM); i++) {
    sfree(inten[i]);
    sfree(ev[i]);
  }
  sfree(inten);
  sfree(ev);
}
