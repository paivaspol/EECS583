void make_refgrps(t_pull *pull,matrix box,t_mdatoms *md) 
{
  int ngrps,i,ii,j,k,m;
  static bool bFirst = TRUE;
  real dr,mass;
  real truemass;
  rvec test;

  ngrps = pull->pull.n;
  if (bFirst) {
    snew(pull->dyna.ngx,ngrps);
    snew(pull->dyna.idx,ngrps);
    snew(pull->dyna.weights,ngrps);
    for (i=0;i<ngrps;i++) {
      snew(pull->dyna.idx[i],pull->ref.ngx[0]);    /* more than nessary */
      snew(pull->dyna.weights[i],pull->ref.ngx[0]);
    }      
    bFirst = FALSE;
  }

  /* loop over all groups to make a reference group for each*/
  for (i=0;i<ngrps;i++) {
    k=0;
    truemass=0;
    pull->dyna.tmass[i] = 0;
    pull->dyna.ngx[i] = 0;

    /* loop over all atoms in the main ref group */
    for (j=0;j<pull->ref.ngx[0];j++) {
      ii = pull->ref.idx[0][j];

      /* get_distance takes pbc into account */
      dr = get_cylinder_distance(pull->ref.x0[0][j],pull->pull.x_unc[i],box);

      if (dr < pull->rc) {
	/* add to index, to sum of COM, to weight array */
	mass = md->massT[ii];
	truemass += mass;
	pull->dyna.ngx[i]++;
	pull->dyna.weights[i][k] = get_weight(dr,pull->r,pull->rc);
	pull->dyna.idx[i][k] = ii;
	for (m=0;m<DIM;m++) 
	  pull->dyna.x_unc[i][m] += mass*pull->dyna.weights[i][k]*
	    pull->ref.x0[0][j][m];
	pull->dyna.tmass[i] += mass*pull->dyna.weights[i][k];
	k++;
      }
    }

    /* normalize the new 'x_unc' */
    svmul(1/pull->dyna.tmass[i],pull->dyna.x_unc[i],pull->dyna.x_unc[i]);
    if (pull->bVerbose) 
      fprintf(stderr,"Made group %d:%8.3f%8.3f%8.3f wm:%8.3f m:%8.3f\n",
	      i,pull->dyna.x_unc[i][0],pull->dyna.x_unc[i][1],
	      pull->dyna.x_unc[i][2],pull->dyna.tmass[i],truemass);
  }
}
