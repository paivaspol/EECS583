void init_edsam(FILE *log,t_topology *top,
	   t_mdatoms *md,int start,int homenr,
	   rvec x[],matrix box, 
	   t_edsamyn *edyn,t_edpar *edi)
{
  int i,j,ned,*refmasnrs;
  rvec *xdum,*transvec;
  real rmsd;
  matrix rotmat;

  fprintf(log,"Initialising ED sampling\n\n");
  
  /* first read the input. All input is stored in edi */
  read_edi(edyn,edi,top->atoms.nr);

  /* here for initialisation */

  /* evaluate masses */
  ned=edi->ned;
  edi->tmass=0.0;
  if (edi->selmas) {
    edi->nmass=edi->npro;
    snew(edi->mass,edi->nmass);
    snew(edi->masnrs,edi->nmass);
    snew(refmasnrs,edi->nmass);
    for(i=0; (i < edi->nmass); i++) {
      edi->mass[i]=top->atoms.atom[edi->sref.anrs[i]].m;
      edi->masnrs[i]=i;
      refmasnrs[i]=i;
      edi->tmass+=edi->mass[i];
    }
  }
  else {
    edi->nmass=edi->sav.nr;
    snew(edi->mass,edi->nmass);
    snew(edi->masnrs,edi->nmass);
    snew(refmasnrs,edi->nmass);
    for(i=0; (i < edi->nmass); i++) {
      edi->mass[i]=1.0;
      edi->masnrs[i]=edi->sav.anrs[i];
      for(j=0; (j < edi->sref.nr); j++) {
	if (edi->sref.anrs[j] == edi->sav.anrs[i])
	  refmasnrs[i]=j;
      }
      edi->tmass+=edi->mass[i];
    }
  }

  /* mark atoms that are to be used for rotational fit */
  edi->nfit=0;
  for(i=0; (i < ned); i++) {
    if (strcmp(*top->atoms.atomname[i],"CA") == 0) 
      edi->nfit++;
  }
  fprintf(log,"%d CA atoms found\n", edi->nfit);
  if (edi->nfit == 0) {
    edi->nfit = edi->sav.nr;
    snew(edi->fitnrs,edi->nfit);
    for(i=0; (i < edi->nfit); i++) {
      edi->fitnrs[i] = edi->sav.anrs[i];
    }
  }
  else {
    snew(edi->fitnrs,edi->nfit);
    j = 0;
    for(i=0; (i < ned); i++) {
      if (strcmp(*top->atoms.atomname[i],"CA") == 0) {
	edi->fitnrs[j] = i;
	/*fprintf(stderr,"Found CA at position %d\n",i);*/
	j++;
      }
    }
  }

  /* put reference structure in origin */
  put_in_origin(edi->sref.nr,edi->sref.x,edi->nmass,refmasnrs,edi->mass,
		edi->tmass);

  /* reduce the reference structure */
  snew(xdum,edi->nfit);
  j=0;
  for(i=0; (i < edi->sref.nr); i++) {
    if (j < edi->nfit) {
      if (edi->sref.anrs[i] == edi->fitnrs[j]) {
	copy_rvec(edi->sref.x[i],xdum[j]);
	j++;
      }
    }
  }
  if (j != edi->nfit) fatal_error(0,"Counted %d, should be %d in init_edsam",
				  j,edi->nfit);
  edi->sref.nr=edi->nfit;
  sfree(edi->sref.x);
  snew(edi->sref.x,edi->nfit);
  for(i=0; (i < edi->nfit); i++)
    copy_rvec(xdum[i],edi->sref.x[i]);
  sfree(xdum);

  /* remove pbc */
  snew(xdum,top->atoms.nr);
  rm_pbc(&(top->idef),top->atoms.nr,box,x,xdum);

  /* fit starting positions to reference structure */
  snew(transvec,ned);
  rmsd=fitit(ned,xdum,edi,transvec,rotmat);
  fprintf(log,"Initial RMSD from reference structure = %10.5f nm\n\n",rmsd);
  sfree(transvec);

  /* calculate initial projections */
  project(xdum,edi,"x");
  fprintf(log,"Initial projections:\n");
  write_edidx(log,edi);

  /* process target structure, if required */
  if (edi->star.nr > 0) {
    rmsd=fitit(ned,edi->star.x,edi,transvec,rotmat);
    projectx(edi,edi->star.x,&edi->vecs.radcon);
  }

  /* process structure that will serve as origin of expansion circle */
  if (edi->sori.nr > 0) {
    rmsd=fitit(ned,edi->sori.x,edi,transvec,rotmat);
    projectx(edi,edi->sori.x,&edi->vecs.radacc);
    projectx(edi,edi->sori.x,&edi->vecs.radfix);
  }
  else {
    projectx(edi,xdum,&edi->vecs.radacc);
    projectx(edi,xdum,&edi->vecs.radfix);
  }
  
  /* set starting projections for linsam */
  projectx(edi,xdum,&edi->vecs.linacc);
  projectx(edi,xdum,&edi->vecs.linfix);
  sfree(xdum);

  /* calculate initial radii */
  fprintf(log,"Initial fixed increment radius=%f\n",edi->vecs.radfix.radius);
  fprintf(log,"Initial   acceptance    radius=%f\n",edi->vecs.radacc.radius);
  fprintf(log,"Initial   contracting   radius=%f\n",edi->vecs.radcon.radius);
  fflush(log);
  
  /* open output file */
  edi->edo=ffopen(edyn->edonam,"w");
  write_edidx(edi->edo,edi);
}
