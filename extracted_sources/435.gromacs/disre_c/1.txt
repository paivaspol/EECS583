void calc_disres_R_6(t_commrec *mcr,
		     int nfa,t_iatom forceatoms[],t_iparams ip[],
		     rvec x[],t_fcdata *fcd)
{
  atom_id     ai,aj;
  int         fa,res,i,pair,ki,kj,m;
  int         type,label;
  rvec        dx;
  real        rt_1,rt_3,rt2,rav_3,*rt,*rav,*Rtl_6,*Rt_6,*Rav_6;
  ivec        it,jt,dt;
  t_disresdata *dd;
  int         dr_weighting;
  bool        dr_bMixed;
  real        ETerm,ETerm1,cf1,cf2,invn=0;

  dd = &(fcd->disres);
  dr_weighting = dd->dr_weighting;
  dr_bMixed    = dd->dr_bMixed;
  ETerm        = dd->ETerm;
  ETerm1       = dd->ETerm1;
  rt           = dd->rt;
  rav          = dd->rav;
  Rtl_6        = dd->Rtl_6;
  Rt_6         = dd->Rt_6;
  Rav_6        = dd->Rav_6;

  /* scaling factor to smoothly turn on the restraint forces *
   * when using time averaging                               */
  dd->exp_min_t_tau *= ETerm;

  cf1 = dd->exp_min_t_tau;
  cf2 = 1.0/(1.0 - dd->exp_min_t_tau);
  
  if (mcr)
    invn = 1.0/mcr->nnodes;

  /* 'loop' over all atom pairs (pair_nr=fa/3) involved in restraints, *
   * the total number of atoms pairs is nfa/3                          */
  res = 0;
  fa  = 0;
  while (fa < nfa) {
    type  = forceatoms[fa];
    label = ip[type].disres.label;

    Rav_6[res] = 0.0;
    Rt_6[res]  = 0.0;
  
    /* Loop over the atom pairs of 'this' restraint */
    while (fa<nfa && ip[forceatoms[fa]].disres.label==label) {
      pair = fa/3;
      ai   = forceatoms[fa+1];
      aj   = forceatoms[fa+2];
      
      rvec_sub(x[ai],x[aj],dx);
      rt2  = iprod(dx,dx);
      rt_1 = invsqrt(rt2);
      rt_3 = rt_1*rt_1*rt_1;

      rt[pair]  = sqrt(rt2);
      rav_3     = cf2*((ETerm - cf1)*rav[pair] + ETerm1*rt_3);
      rav[pair] = rav_3;
      
      Rt_6[res]  += rt_3*rt_3;
      Rav_6[res] += rav_3*rav_3;

      fa += 3;
    }
    if (mcr) {
      Rtl_6[res]  = Rt_6[res];
      Rt_6[res]  *= invn;
      Rav_6[res] *= invn;
    }
    res++;
  }
  
  if ((mcr) && PAR(mcr))
    gmx_sum(2*dd->nr,Rt_6,mcr);
}
