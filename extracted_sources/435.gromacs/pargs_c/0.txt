void get_pargs(int *argc,char *argv[],int nparg,t_pargs pa[],bool bKeepArgs)
{
  int  i,j,k,match;
  bool *bKeep;
  char buf[32];
  char *ptr;
  
  snew(bKeep,*argc+1);
  bKeep[0]     = TRUE;
  bKeep[*argc] = TRUE;
  
  for(i=1; (i<*argc); i++) {
    bKeep[i] = TRUE;
    for(j=0; (j<nparg); j++) {
      if (pa[j].type == etBOOL) {
	sprintf(buf,"-no%s",pa[j].option+1);
	if (strcmp(pa[j].option,argv[i])== 0) {
	  *pa[j].u.b = TRUE;
	  pa[j].bSet = TRUE;
	  bKeep[i] = FALSE;
	}
	else if (strcmp(buf,argv[i])== 0) {
	  *pa[j].u.b = FALSE;
	  pa[j].bSet = TRUE;
	  bKeep[i] = FALSE;
	}
      } else if (strcmp(pa[j].option,argv[i])== 0) {
	if (pa[j].bSet)
	  fprintf(stderr,"Setting option %s more than once!\n",pa[j].option);
	pa[j].bSet = TRUE;
	bKeep[i] = FALSE;
	switch(pa[j].type) {
	case etINT:
	  *pa[j].u.i = iscan(*argc,argv,&i);
	  break;
	case etTIME:
	case etREAL:
	  *pa[j].u.r = dscan(*argc,argv,&i);
	  break;
	case etSTR:
	  *(pa[j].u.c) = sscan(*argc,argv,&i);
	  break;
	case etENUM:
	  match=NOTSET;
	  ptr = sscan(*argc,argv,&i);
	  for(k=1; (pa[j].u.c[k] != NULL); k++)
	    /* only check ptr against beginning of pa[j].u.c[k] */
	    if (strncasecmp(ptr,pa[j].u.c[k],strlen(ptr)) == 0)
	      if ( ( match == NOTSET ) || 
		   ( strlen(pa[j].u.c[k]) < strlen(pa[j].u.c[match]) ) )
		     match = k;
	  if (match!=NOTSET)
	    pa[j].u.c[0] = pa[j].u.c[match];
	  else 
	    fatal_error(0,"Invalid argument %s for option %s",
			ptr,pa[j].option);
	  break;
	case etRVEC:
	  (*pa[j].u.rv)[0] = dscan(*argc,argv,&i);
	  if ( (i+1 == *argc) || 
	       ( (argv[i+1][0]=='-') && !isdigit(argv[i+1][1]) ) )
	    (*pa[j].u.rv)[1] = (*pa[j].u.rv)[2] = (*pa[j].u.rv)[0];
	  else {
	    bKeep[i] = FALSE;
	    (*pa[j].u.rv)[1] = dscan(*argc,argv,&i);
	    if ( (i+1 == *argc) || 
		 ( (argv[i+1][0]=='-') && !isdigit(argv[i+1][1]) ) )
	      fatal_error(0,"%s: vector must have 1 or 3 real parameters",
			  pa[j].option);
	    bKeep[i] = FALSE;
	    (*pa[j].u.rv)[2] = dscan(*argc,argv,&i);
	  }
	  break;
	default:
	  fatal_error(0,"Invalid type %d in pargs",pa[j].type);
	}
	/* i may be incremented, so set it to not keep */
	bKeep[i] = FALSE;
      }
    }
  }
  if (!bKeepArgs) {
    /* Remove used entries */
    for(i=j=0; (i<=*argc); i++) {
      if (bKeep[i])
	argv[j++]=argv[i];
    }
    (*argc)=j-1;
  }
  sfree(bKeep);
}
