void utt_end (kb_t *kb)
{
    int32 id, ascr, lscr;
    glist_t hyp;
    gnode_t *gn;
    hyp_t *h;
    FILE *fp, *latfp;
    dict_t *dict;
    int32 i;
    char *hyp_strptr;
    
    fp = stdout; //SPEC we use stdout instead of stderr to prefer buffered io
    dict = kbcore_dict (kb->kbcore);
    kb_freehyps(kb);
    
    if ((id = vithist_utt_end (kb->vithist, kb->kbcore)) >= 0) {
      if (cmd_ln_str("-bptbldir")) {
	char file[8192];
	
	sprintf (file, "%s/%s.bpt", cmd_ln_str ("-bptbldir"), kb->uttid);
	if ((latfp = fopen (file, "w")) == NULL) {
	  E_ERROR("fopen(%s,w) failed; using stdout\n", file);
	  latfp = stdout;
	}
	
	vithist_dump (kb->vithist, -1, kb->kbcore, latfp);
	if (latfp != stdout)
	  fclose (latfp);
      }
      
      hyp = vithist_backtrace (kb->vithist, id);
      
      /* Detailed backtrace */
      fprintf (fp, "\nBacktrace(%s)\n", kb->uttid);
      fprintf (fp, "%6s %5s %5s %11s %8s %4s\n",
	       "LatID", "SFrm", "EFrm", "AScr", "LScr", "Type");
      
      ascr = 0;
      lscr = 0;
      
      for (gn = hyp; gn; gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	fprintf (fp, "%6d %5d %5d %11d %8d %4d %s\n",
		 h->vhid, h->sf, h->ef, h->ascr, h->lscr, h->type,
		 dict_wordstr(dict, h->id));
	
	ascr += h->ascr;
	lscr += h->lscr;
	kb->hyp_seglen++;
	if (!dict_filler_word(dict,h->id) && (h->id!=dict_finishwid(dict))) {
	  kb->hyp_strlen +=
	    strlen(dict_wordstr(dict, dict_basewid(dict, h->id))) + 1;
	}
      }
      fprintf (fp, "       %5d %5d %11d %8d (Total)\n",0,kb->nfr,ascr,lscr);

      kb->hyp_segs = ckd_calloc(kb->hyp_seglen, sizeof(hyp_t *));
      kb->hyp_str = ckd_calloc(kb->hyp_strlen+1, sizeof(char));
      hyp_strptr = kb->hyp_str;

      /* Match */
      fprintf (fp, "\nFWDVIT: ");
      i = 0;
      for (gn = hyp; gn; gn = gnode_next(gn)) {
	h = (hyp_t *) gnode_ptr (gn);
	kb->hyp_segs[i++] = h;
	if(!dict_filler_word(dict,h->id) && (h->id!=dict_finishwid(dict))) {
	  strcat(hyp_strptr, dict_wordstr(dict, dict_basewid(dict,h->id)));
	  hyp_strptr += strlen(hyp_strptr);
	  strcat(hyp_strptr, " ");
	  hyp_strptr++;
	}
      }
//SPEC The calloc above has carefully allocated an extra byte, so
//     use *that* for the \0.  The original code was not valid for the
//     case where hyp_strlen=0!  jh 15 apr 2005
//    kb->hyp_str[kb->hyp_strlen - 1] = '\0';
      kb->hyp_str[kb->hyp_strlen] = '\0';
      fprintf (fp, "'%s' (%s)\n\n", kb->hyp_str, kb->uttid);
      
      /* Matchseg */
      if (kb->matchsegfp)
	matchseg_write (kb->matchsegfp, kb, hyp, NULL);
      matchseg_write (fp, kb, hyp, "FWDXCT: ");
      fprintf (fp, "\n");

#ifdef SPEC_CPU
//How many times did we consider an active item in mgau_eval? 
//jh 16 apr 2005
      if (!confp_open) {
        if ((confp = fopen ("considered.out", "w")) == NULL) {
          E_FATAL("fopen considered.out failed\n");
          }
        confp_open=1;
      }
      fprintf (confp, "%22d considered for utterance %s\n", considered, kb->uttid );
      tot_considered += considered;
      considered = 0;
#endif

      if (kb->matchfp)
	match_write (kb->matchfp, kb, hyp, NULL);

      
      if (cmd_ln_str ("-outlatdir")) {
	char str[16384];
	int32 ispipe;
	float64 logbase;
	
	sprintf (str, "%s/%s.%s",
		 cmd_ln_str("-outlatdir"), kb->uttid, cmd_ln_str("-latext"));
	E_INFO("Writing lattice file: %s\n", str);
	
	if ((latfp = fopen_comp (str, "w", &ispipe)) == NULL)
	  E_ERROR("fopen_comp (%s,w) failed\n", str);
	else {
	  /* Write header info */
	  getcwd (str, sizeof(str));
	  fprintf (latfp, "# getcwd: %s\n", str);
	  
	  /* Print logbase first!!  Other programs look for it early in the
	   * DAG */
	  logbase = cmd_ln_float32 ("-logbase");
	  fprintf (latfp, "# -logbase %e\n", logbase);
	  
	  fprintf (latfp, "# -dict %s\n", cmd_ln_str ("-dict"));
	  if (cmd_ln_str ("-fdict"))
	    fprintf (latfp, "# -fdict %s\n", cmd_ln_str ("-fdict"));
	  fprintf (latfp, "# -lm %s\n", cmd_ln_str ("-lm"));
	  fprintf (latfp, "# -mdef %s\n", cmd_ln_str ("-mdef"));
	  fprintf (latfp, "# -mean %s\n", cmd_ln_str ("-mean"));
	  fprintf (latfp, "# -var %s\n", cmd_ln_str ("-var"));
	  fprintf (latfp, "# -mixw %s\n", cmd_ln_str ("-mixw"));
	  fprintf (latfp, "# -tmat %s\n", cmd_ln_str ("-tmat"));
	  fprintf (latfp, "#\n");
	  
	  fprintf (latfp, "Frames %d\n", kb->nfr);
	  fprintf (latfp, "#\n");
	  
	  vithist_dag_write (kb->vithist, hyp, dict,
			     cmd_ln_int32("-outlatoldfmt"), latfp);
	  fclose_comp (latfp, ispipe);
	}
      }
      
      /* free the list containing hyps (we've saved the actual hyps
       * themselves).
       */
      glist_free (hyp);
    } else
      E_ERROR("%s: No recognition\n\n", kb->uttid);
    
#ifdef SPEC_CPU
/* do not attempt to output clock dependent info - SPEC does its own timing
#
* INFO: utt.c(305):  328 frm;  2675 sen, 28593 gau/fr, Sen 7.99 CPU  8.01 Clk [Ovrhd 1.01 CPU 0.99 Clk];   2874 hmm,  10 wd/fr, 1.12 CPU 1.11 Clk (pittsburgh.bigendian)
* INFO: utt.c(305):  328 frm;  2675 sen, 28593 gau/fr, Sen 8.45 CPU 13.13 Clk [Ovrhd 1.03 CPU 1.75 Clk];   2874 hmm,  10 wd/fr, 1.12 CPU 1.84 Clk (pittsburgh.bigendian)
*                     1          2         3                 4        5               6        7            8          9        10        11           12 
*/
    E_INFO("%4d frm;  %4d sen, %5d gau/fr, Sen %4.2f CPU %4.2f Clk [Ovrhd %4.2f CPU %4.2f Clk];  %5d hmm, %3d wd/fr, %4.2f CPU %4.2f Clk (%s)\n",
	   kb->nfr,
	   (kb->utt_sen_eval + (kb->nfr >> 1)) / kb->nfr,
	   (kb->utt_gau_eval + (kb->nfr >> 1)) / kb->nfr,

	   0.0,
           0.0,
	   0.0,

           0.0,
	   (kb->utt_hmm_eval + (kb->nfr >> 1)) / kb->nfr,
	   (vithist_n_entry(kb->vithist) + (kb->nfr >> 1)) / kb->nfr,

 	   0.0,
           0.0,
	   kb->uttid);
#else
    E_INFO("%4d frm;  %4d sen, %5d gau/fr, Sen %4.2f CPU %4.2f Clk [Ovrhd %4.2f CPU %4.2f Clk];  %5d hmm, %3d wd/fr, %4.2f CPU %4.2f Clk (%s)\n",
	   kb->nfr,
	   (kb->utt_sen_eval + (kb->nfr >> 1)) / kb->nfr,
	   (kb->utt_gau_eval + (kb->nfr >> 1)) / kb->nfr,

	   kb->tm_sen.t_cpu * 100.0 / kb->nfr, 
           kb->tm_sen.t_elapsed * 100.0 / kb->nfr,
	   kb->tm_ovrhd.t_cpu * 100.0 / kb->nfr, 

           kb->tm_ovrhd.t_elapsed * 100.0 / kb->nfr,
	   (kb->utt_hmm_eval + (kb->nfr >> 1)) / kb->nfr,
	   (vithist_n_entry(kb->vithist) + (kb->nfr >> 1)) / kb->nfr,

	   kb->tm_srch.t_cpu * 100.0 / kb->nfr, 
           kb->tm_srch.t_elapsed * 100.0 / kb->nfr,
	   kb->uttid);
#endif
    {
      int32 j, k;
      
      for (j = kb->hmm_hist_bins-1; (j >= 0) && (kb->hmm_hist[j] == 0); --j);
      E_INFO("HMMHist[0..%d](%s):", j, kb->uttid);
      for (i = 0, k = 0; i <= j; i++) {
	k += kb->hmm_hist[i];
	fprintf (stdout, " %d(%d)", kb->hmm_hist[i], (k*100)/kb->nfr); //SPEC stdout not stderr: prefer buffered io
      }
      fprintf (stdout, "\n");
      //SPEC fflush (stderr);
    }
    
    kb->tot_sen_eval += kb->utt_sen_eval;
    kb->tot_gau_eval += kb->utt_gau_eval;
    kb->tot_hmm_eval += kb->utt_hmm_eval;
    kb->tot_wd_exit += vithist_n_entry(kb->vithist);
    
    ptmr_reset (&(kb->tm_sen));
    ptmr_reset (&(kb->tm_srch));
    ptmr_reset (&(kb->tm_ovrhd));

#if (!defined(SPEC_CPU))
    if (! system("ps auxgw > /dev/null 2>&1")) {
      system ("ps aguxwww | grep /live | grep -v grep");
      system ("ps aguxwww | grep /dec | grep -v grep");
    }
#endif
    
    for (i = 0; i < kb->n_lextree; i++) {
      lextree_utt_end (kb->ugtree[i], kb->kbcore);
      lextree_utt_end (kb->fillertree[i], kb->kbcore);
    }
    
    vithist_utt_reset (kb->vithist);
    
    lm_cache_stats_dump (kbcore_lm(kb->kbcore));
    lm_cache_reset (kbcore_lm(kb->kbcore));
}
