void lextree_hmm_histbin (lextree_t *lextree, int32 bestscr, int32 *bin, int32 nbin, int32 bw)
{
    lextree_node_t **list, *ln;
    hmm_t *hmm;
    int32 i, k;
    glist_t *binln;
    gnode_t *gn;
    
    binln = (glist_t *) ckd_calloc (nbin, sizeof(glist_t));
    
    list = lextree->active;
    
    for (i = 0; i < lextree->n_active; i++) {
	ln = list[i];
	hmm = &(ln->hmm);
	
	k = (bestscr - hmm->bestscore) / bw;
	if (k >= nbin)
	    k = nbin-1;
	assert (k >= 0);
	
	bin[k]++;
	binln[k] = glist_add_ptr (binln[k], (void *) ln);
    }
    
    /* Reorder the active lexnodes in APPROXIMATELY descending scores */
    k = 0;
    for (i = 0; i < nbin; i++) {
	for (gn = binln[i]; gn; gn = gnode_next(gn)) {
	    ln = (lextree_node_t *) gnode_ptr (gn);
	    list[k++] = ln;
	}
	glist_free (binln[i]);
    }
    assert (k == lextree->n_active);
    
    ckd_free ((void *) binln);
}
