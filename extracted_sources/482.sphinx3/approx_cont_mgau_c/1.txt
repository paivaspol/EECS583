int32 approx_mgau_eval (gs_t* gs,
			subvq_t* svq,
			mgau_model_t* g,
			kb_t *kb,
			int32 s, /*senone index*/
			int32 *senscr,
			float32 *feat,
			int32 best_cid,
			int32 svq_beam
			) 
{
  int32 ng=0;
  int32 *mgau_sl;

  if(gs&&kb->gs4gs){
    ng = gs_mgau_shortlist (gs, s, mgau_n_comp(g,s),feat,best_cid);
    mgau_sl=gs->mgau_sl;
  }else if (svq){
    ng = subvq_mgau_shortlist (svq, s, mgau_n_comp(g,s), svq_beam);
    mgau_sl=svq->mgau_sl;
  }else{
    ng = mgau_n_comp (g, s);
    mgau_sl=NULL;
  }

  /*  
  E_INFO("Full computation: Idx %d using subvq, Senscr %d ng %d\n",s,senscr[s],ng);
  senscr[s] = mgau_eval (g, s, NULL, feat);
  E_INFO("Full computationIdx %d using normal, Senscr %d ng %d\n",s,senscr[s],ng);
  senscr[s] = subvq_mgau_eval(g, svq, s, mgau_n_comp(g,s),mgau_sl);
  E_INFO("Partial Computation: Idx %d using subvq, Senscr %d ng %d\n",s,senscr[s],ng);
  senscr[s] = mgau_eval (g, s, mgau_sl, feat);
  E_INFO("Partial Computation: Idx %d using normal, Senscr %d ng %d\n",s,senscr[s],ng);*/

  /* This safe guard the algorithmic error of other 3rd party converter*/
  if(ng==0){
    /* Not dumping any information because it costs a lot of space*/
    /* E_INFO("short list has 0 element, turn to compute all, please check the Gaussian Selection algorithm\n");*/
    mgau_sl=NULL;
    ng=mgau_n_comp(g,s);
  }

  if(svq&&kb->svq4svq)
    senscr[s] = subvq_mgau_eval(g, svq, s, mgau_n_comp(g,s),mgau_sl);
  else
    senscr[s] = mgau_eval (g, s, mgau_sl, feat);


  /*This routine safe guard the computation such that no abnomality will occur */
  if(senscr[s] < S3_LOGPROB_ZERO+100000){ /* a range of value which recomputation is necessary */
    if(mgau_sl==NULL){
      /*E_INFO("WARNING!! Score is S3_LOGPROB_ZERO even computing full gaussians! %d\n",s);*/
    }
    else{
      mgau_sl=NULL;
      ng+=mgau_n_comp(g,s);
      if(svq&&kb->svq4svq)
	senscr[s] = subvq_mgau_eval(g, svq, s, mgau_n_comp(g,s),NULL);
      else
	senscr[s] = mgau_eval (g, s, NULL, feat);

    }
  }



  return ng;
}
