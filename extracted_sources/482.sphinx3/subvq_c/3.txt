int32 subvq_mgau_shortlist (subvq_t *vq,
				   int32 m,	/* In: Mixture index */
				   int32 n,	/* In: #Components in specified mixture */
				   int32 beam)	/* In: Threshold to select active components */
{
    int32 *gauscore;
    int32 *map;
    int32 i, v, bv, th, nc;
    int32 *sl;
    int32 *vqdist;
    int32 sv_id;
    
    vqdist = vq->vqdist[0];	/* Since map is linearized for efficiency, must also
				   look at vqdist[][] as vqdist[] */
    gauscore = vq->gauscore;
    sl = vq->mgau_sl;
    /* Special case when vq->n_sv == 3; for speed */
    map = vq->map[m][0];
    bv = MAX_NEG_INT32;
    
    switch (vq->n_sv) {
    case 3:
	for (i = 0; i < n; i++) {
	  if (VQ_EVAL == 1) {
	    v = (int32) vqdist[*map];/* If we are not weighting the cep values, we need to adjust the subvqbeam */
	    map += 3;
	  } else {
	    /* RAH, we are ignoring the delta-delta, scoring the delta twice, strangely this works better than weighting the scores  */
	    /* I believe it has to do with the beam widths */
	    if (VQ_EVAL == 2) {
	    v = vqdist[*(map++)];
	      v += 2 * vqdist[*map]; /* RAH Count delta twice, we can keep the same subvqbeam as vq_eval = 3 if we double the delta*/
	      map += 2;
	    } else {
	      v = vqdist[*(map++)];/* Standard way */
	      v += vqdist[*(map++)]; /*  */
	      v += vqdist[*(map++)]; /*  */
	    }
	  }

	  gauscore[i] = v;
	    
	  if (bv < v)
	    bv = v;
	}
	break;
    case 2:
	for (i = 0; i < n; i++) {
	    v = vqdist[*(map++)];
	    v += vqdist[*(map++)];
	    gauscore[i] = v;
	   
	    if (bv < v)
		bv = v;
	}
	break;
    case 1:
      for (i = 0; i < n; i++) {
	v = vqdist[*(map++)];
	gauscore[i] = v;
	
	if (bv < v)
	  bv = v;
      }
      break;
    default:
      for (i = 0; i < n; i++) {
	v=0;
	for(sv_id =0 ; sv_id<vq->n_sv; sv_id++){
	  v+=vqdist[*(map++)];
	}
	gauscore[i] = v;
	
	if (bv < v)
	  bv = v;
      }
    }
    
    th = bv + beam;
    nc = 0;
    for (i = 0; i < n; i++) {
      if (gauscore[i] >= th)
	sl[nc++] = i;
    }
    sl[nc] = -1;
    
    return nc;
}
