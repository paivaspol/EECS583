int32 feat_readfile (feat_t *fcb, char *file, int32 sf, int32 ef, float32 ***feat, int32 maxfr)
{
    FILE *fp;
    int32 i, l, k, nfr;
    int32 byteswap, chksum_present;
    uint32 chksum;
    char **argname, **argval;
    
    E_INFO("Reading feature file: '%s'[%d..%d]\n", file, sf, ef);
    assert (fcb);

    if (ef <= sf) {
	E_ERROR("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
	return -1;
    }
    
    if ((fp = fopen(file, "rb")) == NULL) {
	E_ERROR("fopen(%s,rb) failed\n", file);
	return -1;
    }
    
    /* Read header */
    if (bio_readhdr (fp, &argname, &argval, &byteswap) < 0) {
	E_ERROR("bio_readhdr(%s) failed\n", file);
	fclose (fp);
	return -1;
    }
    
    /* Parse header info (although nothing much is done with it) */
    chksum_present = 0;
    for (i = 0; argname[i]; i++) {
	if (strcmp (argname[i], "version") == 0) {
	    if (strcmp(argval[i], FEAT_VERSION) != 0)
		E_WARN("%s: Version mismatch: %s, expecting %s\n",
		       file, argval[i], FEAT_VERSION);
	} else if (strcmp (argname[i], "chksum0") == 0) {
	    chksum_present = 1;	/* Ignore the associated value */
	}
    }

    bio_hdrarg_free (argname, argval);
    argname = argval = NULL;
    
    chksum = 0;
    
    /* #Frames */
    if (bio_fread (&nfr, sizeof(int32), 1, fp, byteswap, &chksum) != 1) {
	E_ERROR("%s: fread(#frames) failed\n", file);
	fclose (fp);
	return -1;
    }
    
    /* #Feature streams */
    if ((bio_fread (&l, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	(l != feat_n_stream(fcb))) {
	E_ERROR("%s: Missing or bad #feature streams\n", file);
	fclose (fp);
	return -1;
    }
    
    /* Feature stream lengths */
    k = 0;
    for (i = 0; i < feat_n_stream(fcb); i++) {
	if ((bio_fread (&l, sizeof(int32), 1, fp, byteswap, &chksum) != 1) ||
	    (l != feat_stream_len (fcb, i))) {
	    E_ERROR("%s: Missing or bad feature stream size\n", file);
	    fclose (fp);
	    return -1;
	}
	k += l;
    }
    
    /* Check sf/ef specified */
    if (sf > 0) {
	if (sf >= nfr) {
	    E_ERROR("%s: Start frame (%d) beyond file size (%d)\n", file, sf, nfr);
	    fclose (fp);
	    return -1;
	}
	nfr -= sf;
    }
    
    /* Limit nfr as indicated by [sf..ef] */
    if ((ef-sf+1) < nfr)
	nfr = (ef-sf+1);
    if (nfr > maxfr) {
	E_ERROR("%s: Feature buffer size(%d frames) < actual #frames(%d)\n",
		file, maxfr, nfr);
	fclose (fp);
	return -1;
    }
    
    /* Position at desired start frame and read feature data */
    if (sf > 0)
	fseek (fp, sf * k * sizeof(float32), SEEK_CUR);
    if (bio_fread (feat[0][0], sizeof(float32), nfr*k, fp, byteswap, &chksum) != nfr*k) {
	E_ERROR("%s: fread(%dx%d) (feature data) failed\n", file, nfr, k);
	fclose (fp);
	return -1;
    }
    
    fclose (fp);	/* NOTE: checksum NOT verified; we might read only part of file */
    
    return nfr;
}
